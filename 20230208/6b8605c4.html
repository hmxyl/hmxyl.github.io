<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Redis-配置文件 | Alisa&#39;s Home</title>
  <meta name="keywords" content=" Redis ">
  <meta name="description" content="Redis-配置文件 | Alisa&#39;s Home">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Oops～，我崩溃了！找不到你想要的页面 :(">
<meta property="og:type" content="website">
<meta property="og:title" content="404">
<meta property="og:url" content="https://hmxyl.github.io/404/index.html">
<meta property="og:site_name" content="Alisa&#39;s Home">
<meta property="og:description" content="Oops～，我崩溃了！找不到你想要的页面 :(">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-16T09:39:22.000Z">
<meta property="article:modified_time" content="2023-03-17T02:46:08.000Z">
<meta property="article:author" content="Alisa">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Alisa's Home" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Alisa</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(89)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="后端">
            <i class="fold iconfont icon-right"></i>
            后端
            <small>(17)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="后端&lt;---&gt;编程规范">
            
            编程规范
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="后端&lt;---&gt;Java">
            
            Java
            <small>(12)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="后端&lt;---&gt;Python">
            
            Python
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="数据库">
            <i class="fold iconfont icon-right"></i>
            数据库
            <small>(17)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="数据库&lt;---&gt;ElasticSearch">
            
            ElasticSearch
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="数据库&lt;---&gt;MongoDB">
            
            MongoDB
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="数据库&lt;---&gt;MySQL">
            
            MySQL
            <small>(5)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="数据库&lt;---&gt;Redis">
            
            Redis
            <small>(9)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="博客搭建">
            <i class="fold iconfont icon-right"></i>
            博客搭建
            <small>(3)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="博客搭建&lt;---&gt;Hexo">
            
            Hexo
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="博客搭建&lt;---&gt;Markdown语法">
            
            Markdown语法
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="博客搭建&lt;---&gt;UML类图">
            
            UML类图
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="工具|部署">
            <i class="fold iconfont icon-right"></i>
            工具|部署
            <small>(12)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="工具|部署&lt;---&gt;压测">
            
            压测
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="工具|部署&lt;---&gt;Git">
            
            Git
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="工具|部署&lt;---&gt;IDEA">
            
            IDEA
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="工具|部署&lt;---&gt;Ubuntu">
            
            Ubuntu
            <small>(5)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="工具|部署&lt;---&gt;Windows">
            
            Windows
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="框架|中间件">
            <i class="fold iconfont icon-right"></i>
            框架|中间件
            <small>(15)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="框架|中间件&lt;---&gt;Junit">
            
            Junit
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="框架|中间件&lt;---&gt;Log4j">
            
            Log4j
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="框架|中间件&lt;---&gt;Logback">
            
            Logback
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="框架|中间件&lt;---&gt;Lombox">
            
            Lombox
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="框架|中间件&lt;---&gt;Maven">
            
            Maven
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="框架|中间件&lt;---&gt;Nacos">
            
            Nacos
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="框架|中间件&lt;---&gt;Tomcat">
            
            Tomcat
            <small>(6)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="前端">
            <i class="fold iconfont icon-right"></i>
            前端
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="前端&lt;---&gt;Vue3">
            
            Vue3
            <small>(6)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="日常记录">
            <i class="fold iconfont icon-right"></i>
            日常记录
            <small>(2)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="日常记录&lt;---&gt;后端">
            
            后端
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="日常记录&lt;---&gt;前端">
            
            前端
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="网络安全">
            
            网络安全
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="应用推荐">
            
            应用推荐
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Docker">
            
            Docker
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="IDEA">
            <i class="fold iconfont icon-right"></i>
            IDEA
            <small>(1)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="IDEA&lt;---&gt;快捷键">
            
            快捷键
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Linux">
            <i class="fold iconfont icon-right"></i>
            Linux
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;基础命令">
            
            基础命令
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;日常使用">
            
            日常使用
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Linux防火墙">
            
            Linux防火墙
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Spring">
            <i class="fold iconfont icon-right"></i>
            Spring
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Spring&lt;---&gt;Spring Cache">
            
            Spring Cache
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Spring&lt;---&gt;Spring Framework">
            
            Spring Framework
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Spring&lt;---&gt;SpringBoot">
            
            SpringBoot
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Windows系统">
            <i class="fold iconfont icon-right"></i>
            Windows系统
            <small>(1)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Windows系统&lt;---&gt;快捷键">
            
            快捷键
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="89">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>编程规范</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>操作系统</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>测试</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>快捷键</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>日常记录</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>网络安全</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ElasticSearch</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IDEA</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Junit</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Log4j</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Logback</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Lombox</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Maven</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Mongodb</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MongoDB</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Nacos</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Office</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Python</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spring Cache</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spring Framework</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SpringBoot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Tomcat</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Vue3</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 Linux 基础命令 "
           href="/20250616/44c28660.html"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux系统文件操作命令">Linux系统文件操作命令</span>
            <span class="post-date" title="2025-06-16 17:48:34">2025/06/16</span>
        </a>
        
        
        <a  class="全部文章 Linux 基础命令 "
           href="/20250616/b2009fa9.html"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux查看系统信息命令">Linux查看系统信息命令</span>
            <span class="post-date" title="2025-06-16 17:46:02">2025/06/16</span>
        </a>
        
        
        <a  class="全部文章 Linux 日常使用 "
           href="/20250614/fb3eb231.html"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux日常使用">Linux日常使用</span>
            <span class="post-date" title="2025-06-14 16:48:16">2025/06/14</span>
        </a>
        
        
        <a  class="全部文章 Linux 基础命令 "
           href="/20250611/f0a9e559.html"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux系统命令行工具">Linux系统命令行工具</span>
            <span class="post-date" title="2025-06-11 22:48:07">2025/06/11</span>
        </a>
        
        
        <a  class="全部文章 应用推荐 "
           href="/20250610/b78998f1.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cherry书签管理器">Cherry书签管理器</span>
            <span class="post-date" title="2025-06-10 14:17:04">2025/06/10</span>
        </a>
        
        
        <a  class="全部文章 应用推荐 "
           href="/20250605/7f395aef.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LinkAce书签管理器">LinkAce书签管理器</span>
            <span class="post-date" title="2025-06-05 18:32:01">2025/06/05</span>
        </a>
        
        
        <a  class="全部文章 Windows系统 快捷键 "
           href="/20250604/459f9e41.html"
           data-tag="快捷键"
           data-author="" >
            <span class="post-title" title="Windows快捷键">Windows快捷键</span>
            <span class="post-date" title="2025-06-04 16:03:38">2025/06/04</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/20250520/0.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2025-05-20 15:34:49">2025/05/20</span>
        </a>
        
        
        <a  class="全部文章 日常记录 前端 "
           href="/20240929/33f402b5.html"
           data-tag="日常记录"
           data-author="" >
            <span class="post-title" title="前端日常问题记录">前端日常问题记录</span>
            <span class="post-date" title="2024-09-29 19:16:39">2024/09/29</span>
        </a>
        
        
        <a  class="全部文章 前端 Vue3 "
           href="/20231224/7d2d5550.html"
           data-tag="Vue3"
           data-author="" >
            <span class="post-title" title="Vue3基础">Vue3基础</span>
            <span class="post-date" title="2023-12-24 10:49:23">2023/12/24</span>
        </a>
        
        
        <a  class="全部文章 前端 Vue3 "
           href="/20231224/1954b1ff.html"
           data-tag="Vue3"
           data-author="" >
            <span class="post-title" title="侦听器（watch）">侦听器（watch）</span>
            <span class="post-date" title="2023-12-24 10:49:23">2023/12/24</span>
        </a>
        
        
        <a  class="全部文章 前端 Vue3 "
           href="/20231224/4446b2a4.html"
           data-tag="Vue3"
           data-author="" >
            <span class="post-title" title="事件处理">事件处理</span>
            <span class="post-date" title="2023-12-24 10:49:23">2023/12/24</span>
        </a>
        
        
        <a  class="全部文章 前端 Vue3 "
           href="/20231224/9ee367a5.html"
           data-tag="Vue3"
           data-author="" >
            <span class="post-title" title="表单输入绑定（v-model）">表单输入绑定（v-model）</span>
            <span class="post-date" title="2023-12-24 10:49:23">2023/12/24</span>
        </a>
        
        
        <a  class="全部文章 前端 Vue3 "
           href="/20231224/6e23c48.html"
           data-tag="Vue3"
           data-author="" >
            <span class="post-title" title="其他">其他</span>
            <span class="post-date" title="2023-12-24 10:49:23">2023/12/24</span>
        </a>
        
        
        <a  class="全部文章 前端 Vue3 "
           href="/20231224/34778b46.html"
           data-tag="Vue3"
           data-author="" >
            <span class="post-title" title="组件">组件</span>
            <span class="post-date" title="2023-12-24 10:49:23">2023/12/24</span>
        </a>
        
        
        <a  class="全部文章 后端 Python "
           href="/20231108/c8f562d1.html"
           data-tag="Python"
           data-author="" >
            <span class="post-title" title="Python函数">Python函数</span>
            <span class="post-date" title="2023-11-08 10:49:23">2023/11/08</span>
        </a>
        
        
        <a  class="全部文章 后端 Python "
           href="/20231106/d59aed63.html"
           data-tag="Python"
           data-author="" >
            <span class="post-title" title="Python内置函数">Python内置函数</span>
            <span class="post-date" title="2023-11-06 10:49:23">2023/11/06</span>
        </a>
        
        
        <a  class="全部文章 后端 Python "
           href="/20231106/99832f47.html"
           data-tag="Python"
           data-author="" >
            <span class="post-title" title="Python基础">Python基础</span>
            <span class="post-date" title="2023-11-06 10:49:23">2023/11/06</span>
        </a>
        
        
        <a  class="全部文章 数据库 ElasticSearch "
           href="/20230618/872a239c.html"
           data-tag="ElasticSearch"
           data-author="" >
            <span class="post-title" title="ElasticSearch安装">ElasticSearch安装</span>
            <span class="post-date" title="2023-06-18 17:33:20">2023/06/18</span>
        </a>
        
        
        <a  class="全部文章 Linux Linux防火墙 "
           href="/20230511/e26546c7.html"
           data-tag="操作系统"
           data-author="" >
            <span class="post-title" title="Linux防火墙">Linux防火墙</span>
            <span class="post-date" title="2023-05-11 14:32:10">2023/05/11</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Log4j "
           href="/20230511/14631848.html"
           data-tag="Log4j"
           data-author="" >
            <span class="post-title" title="Log4j日常使用记录">Log4j日常使用记录</span>
            <span class="post-date" title="2023-05-11 14:32:10">2023/05/11</span>
        </a>
        
        
        <a  class="全部文章 Spring Spring Framework "
           href="/20230319/28678f43.html"
           data-tag="Spring Framework"
           data-author="" >
            <span class="post-title" title="Spring基础-AOP">Spring基础-AOP</span>
            <span class="post-date" title="2023-03-19 17:44:41">2023/03/19</span>
        </a>
        
        
        <a  class="全部文章 Spring Spring Framework "
           href="/20230319/d607e27b.html"
           data-tag="Spring Framework"
           data-author="" >
            <span class="post-title" title="Spring基础">Spring基础</span>
            <span class="post-date" title="2023-03-19 17:44:41">2023/03/19</span>
        </a>
        
        
        <a  class="全部文章 后端 编程规范 "
           href="/20230317/1761bce2.html"
           data-tag="编程规范"
           data-author="" >
            <span class="post-title" title="Java命名规范">Java命名规范</span>
            <span class="post-date" title="2023-03-17 17:44:04">2023/03/17</span>
        </a>
        
        
        <a  class="全部文章 数据库 Spring Redis SpringBoot "
           href="/20230302/f677ab49.html"
           data-tag="SpringBoot,Mongodb"
           data-author="" >
            <span class="post-title" title="SpringBoot集成Redis">SpringBoot集成Redis</span>
            <span class="post-date" title="2023-03-02 19:10:19">2023/03/02</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Nacos "
           href="/20230301/d8cb1733.html"
           data-tag="Nacos"
           data-author="" >
            <span class="post-title" title="Nacos 使用示例">Nacos 使用示例</span>
            <span class="post-date" title="2023-03-01 10:19:20">2023/03/01</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Nacos "
           href="/20230301/c383a3c4.html"
           data-tag="Nacos"
           data-author="" >
            <span class="post-title" title="Nacos">Nacos</span>
            <span class="post-date" title="2023-03-01 10:19:20">2023/03/01</span>
        </a>
        
        
        <a  class="全部文章 日常记录 后端 "
           href="/20230223/65e80ab3.html"
           data-tag="日常记录"
           data-author="" >
            <span class="post-title" title="2023年问题记录">2023年问题记录</span>
            <span class="post-date" title="2023-02-23 19:52:44">2023/02/23</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 Windows "
           href="/20230216/d9a8c0d4.html"
           data-tag="日常记录,操作系统"
           data-author="" >
            <span class="post-title" title="Windows日常使用问题记录">Windows日常使用问题记录</span>
            <span class="post-date" title="2023-02-16 10:39:23">2023/02/16</span>
        </a>
        
        
        <a  class="全部文章 数据库 Redis "
           href="/20230210/4be8fe93.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-ACL">Redis-ACL</span>
            <span class="post-date" title="2023-02-10 15:14:01">2023/02/10</span>
        </a>
        
        
        <a  class="全部文章 数据库 Redis "
           href="/20230208/6b8605c4.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-配置文件">Redis-配置文件</span>
            <span class="post-date" title="2023-02-08 18:19:01">2023/02/08</span>
        </a>
        
        
        <a  class="全部文章 数据库 Redis "
           href="/20230103/72ab10c8.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-数据类型（基础）">Redis-数据类型（基础）</span>
            <span class="post-date" title="2023-01-03 20:22:19">2023/01/03</span>
        </a>
        
        
        <a  class="全部文章 数据库 Redis "
           href="/20221103/709af9d4.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-命令记录">Redis-命令记录</span>
            <span class="post-date" title="2022-11-03 19:19:19">2022/11/03</span>
        </a>
        
        
        <a  class="全部文章 数据库 Redis "
           href="/20221102/c9f6f059.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis安装">Redis安装</span>
            <span class="post-date" title="2022-11-02 19:10:19">2022/11/02</span>
        </a>
        
        
        <a  class="全部文章 数据库 Redis "
           href="/20221102/4cdb4706.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-发布订阅">Redis-发布订阅</span>
            <span class="post-date" title="2022-11-02 19:10:19">2022/11/02</span>
        </a>
        
        
        <a  class="全部文章 数据库 Redis "
           href="/20221102/574fe2f4.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis-持久化">Redis-持久化</span>
            <span class="post-date" title="2022-11-02 19:10:19">2022/11/02</span>
        </a>
        
        
        <a  class="全部文章 数据库 Spring Redis Spring Cache "
           href="/20221102/3fb18050.html"
           data-tag="Redis,Spring Cache"
           data-author="" >
            <span class="post-title" title="配置 序列化成JSON字符串.md">配置 序列化成JSON字符串.md</span>
            <span class="post-date" title="2022-11-02 19:10:19">2022/11/02</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221101/53471b9a.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="多线程基础">多线程基础</span>
            <span class="post-date" title="2022-11-01 06:52:00">2022/11/01</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221101/3c508c34.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="Java并发包">Java并发包</span>
            <span class="post-date" title="2022-11-01 06:52:00">2022/11/01</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221101/8c062783.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="多线程设计模式">多线程设计模式</span>
            <span class="post-date" title="2022-11-01 06:52:00">2022/11/01</span>
        </a>
        
        
        <a  class="全部文章 数据库 MongoDB "
           href="/20221031/c5d54bc1.html"
           data-tag="MongoDB"
           data-author="" >
            <span class="post-title" title="MongoDB安装">MongoDB安装</span>
            <span class="post-date" title="2022-10-31 16:19:20">2022/10/31</span>
        </a>
        
        
        <a  class="全部文章 数据库 MySQL "
           href="/20221031/4c28b48e.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySQL安装、版本差异、JDBC连接配置">MySQL安装、版本差异、JDBC连接配置</span>
            <span class="post-date" title="2022-10-31 16:19:20">2022/10/31</span>
        </a>
        
        
        <a  class="全部文章 数据库 MySQL "
           href="/20221031/bce68613.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySQL基础">MySQL基础</span>
            <span class="post-date" title="2022-10-31 16:19:20">2022/10/31</span>
        </a>
        
        
        <a  class="全部文章 数据库 MySQL "
           href="/20221031/25158cd7.html"
           data-tag="日常记录,MySQL"
           data-author="" >
            <span class="post-title" title="MySQL日常使用记录">MySQL日常使用记录</span>
            <span class="post-date" title="2022-10-31 16:19:20">2022/10/31</span>
        </a>
        
        
        <a  class="全部文章 数据库 MySQL "
           href="/20221031/ec788ee4.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySQL查询优化策略">MySQL查询优化策略</span>
            <span class="post-date" title="2022-10-31 16:19:20">2022/10/31</span>
        </a>
        
        
        <a  class="全部文章 数据库 MySQL "
           href="/20221031/ad072d5f.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySQL用户管理">MySQL用户管理</span>
            <span class="post-date" title="2022-10-31 16:19:20">2022/10/31</span>
        </a>
        
        
        <a  class="全部文章 数据库 Spring MongoDB SpringBoot "
           href="/20221031/eb573b79.html"
           data-tag="SpringBoot,Mongodb"
           data-author="" >
            <span class="post-title" title="SpringBoot集成MongoDB">SpringBoot集成MongoDB</span>
            <span class="post-date" title="2022-10-31 16:19:20">2022/10/31</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 Ubuntu "
           href="/20221030/d288da69.html"
           data-tag="操作系统,Docker"
           data-author="" >
            <span class="post-title" title="Ubuntu 安装Docker">Ubuntu 安装Docker</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 Docker "
           href="/20221030/8c5d6123.html"
           data-tag="Docker"
           data-author="" >
            <span class="post-title" title="配置Docker环境">配置Docker环境</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 Docker "
           href="/20221030/868b0954.html"
           data-tag="Docker"
           data-author="" >
            <span class="post-title" title="Docker日常使用记录">Docker日常使用记录</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 Ubuntu "
           href="/20221030/6124f545.html"
           data-tag="操作系统"
           data-author="" >
            <span class="post-title" title="Ubuntu虚拟机搭建">Ubuntu虚拟机搭建</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 压测 "
           href="/20221030/e291c7ca.html"
           data-tag="测试"
           data-author="" >
            <span class="post-title" title="压测工具概述">压测工具概述</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 Ubuntu "
           href="/20221030/d81e4de4.html"
           data-tag="操作系统"
           data-author="" >
            <span class="post-title" title="Ubuntu 查看系统信息">Ubuntu 查看系统信息</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 Ubuntu "
           href="/20221030/f075b7f2.html"
           data-tag="操作系统"
           data-author="" >
            <span class="post-title" title="Ubuntu卸载图形界面">Ubuntu卸载图形界面</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 Windows "
           href="/20221030/8bc474d9.html"
           data-tag="Office"
           data-author="" >
            <span class="post-title" title="WORD使用记录">WORD使用记录</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 Ubuntu "
           href="/20221030/b8b8d517.html"
           data-tag="操作系统"
           data-author="" >
            <span class="post-title" title="Ubuntu 防火墙">Ubuntu 防火墙</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Junit "
           href="/20221030/99356519.html"
           data-tag="Junit"
           data-author="" >
            <span class="post-title" title="Junit日常使用记录">Junit日常使用记录</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Tomcat "
           href="/20221030/932ec968.html"
           data-tag="日常记录,Tomcat"
           data-author="" >
            <span class="post-title" title="Tomcat异常排查记录">Tomcat异常排查记录</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Tomcat "
           href="/20221030/d035d83e.html"
           data-tag="日常记录,Tomcat"
           data-author="" >
            <span class="post-title" title="在请求目标中找到无效字符">在请求目标中找到无效字符</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Tomcat "
           href="/20221030/673ec6c6.html"
           data-tag="日常记录,Tomcat"
           data-author="" >
            <span class="post-title" title="给Tomcat配置外部资源路径">给Tomcat配置外部资源路径</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Lombox "
           href="/20221030/f1c78c8.html"
           data-tag="Lombox"
           data-author="" >
            <span class="post-title" title="Lombox日常使用记录">Lombox日常使用记录</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Tomcat "
           href="/20221030/294d5c08.html"
           data-tag="日常记录,Tomcat"
           data-author="" >
            <span class="post-title" title="验证码图片无法显示">验证码图片无法显示</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Logback "
           href="/20221030/4b5ef04d.html"
           data-tag="Logback"
           data-author="" >
            <span class="post-title" title="Logback日常使用记录">Logback日常使用记录</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Maven "
           href="/20221030/4a3536f5.html"
           data-tag="Maven"
           data-author="" >
            <span class="post-title" title="Maven使用场景记录">Maven使用场景记录</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Maven "
           href="/20221030/195cf5d1.html"
           data-tag="Maven"
           data-author="" >
            <span class="post-title" title="Maven基础">Maven基础</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Maven "
           href="/20221030/9926a393.html"
           data-tag="Maven"
           data-author="" >
            <span class="post-title" title="POM.XML文件说明">POM.XML文件说明</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Tomcat "
           href="/20221030/530cfffd.html"
           data-tag="Tomcat"
           data-author="" >
            <span class="post-title" title="Tomcat基础">Tomcat基础</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 框架|中间件 Tomcat "
           href="/20221030/6f43f742.html"
           data-tag="Tomcat"
           data-author="" >
            <span class="post-title" title="安装Tomcat服务">安装Tomcat服务</span>
            <span class="post-date" title="2022-10-30 15:39:23">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221027/6cd20d81.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="JVM基础回顾">JVM基础回顾</span>
            <span class="post-date" title="2022-10-27 19:52:44">2022/10/27</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221027/cc1c3bcb.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="JVM性能调优工具">JVM性能调优工具</span>
            <span class="post-date" title="2022-10-27 19:52:44">2022/10/27</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221027/c3539d05.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="Java中printf的用法总结">Java中printf的用法总结</span>
            <span class="post-date" title="2022-10-27 19:52:44">2022/10/27</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221027/5296b9c2.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="Java枚举类型7种常见的用法">Java枚举类型7种常见的用法</span>
            <span class="post-date" title="2022-10-27 19:52:44">2022/10/27</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221027/7039576b.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="Java注解">Java注解</span>
            <span class="post-date" title="2022-10-27 19:52:44">2022/10/27</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221027/f7c553a3.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="abstract class和interface的区别">abstract class和interface的区别</span>
            <span class="post-date" title="2022-10-27 19:52:44">2022/10/27</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221027/79cf73a2.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="对象之间相同属性的赋值">对象之间相同属性的赋值</span>
            <span class="post-date" title="2022-10-27 19:52:44">2022/10/27</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221027/80d3479f.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="系统方法：System.getProperty">系统方法：System.getProperty</span>
            <span class="post-date" title="2022-10-27 19:52:44">2022/10/27</span>
        </a>
        
        
        <a  class="全部文章 IDEA 快捷键 "
           href="/20221026/610bdf07.html"
           data-tag="快捷键"
           data-author="" >
            <span class="post-title" title="IDEA快捷键">IDEA快捷键</span>
            <span class="post-date" title="2022-10-26 21:32:25">2022/10/26</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 Git "
           href="/20221026/69c3279c.html"
           data-tag="Git"
           data-author="" >
            <span class="post-title" title="Git">Git</span>
            <span class="post-date" title="2022-10-26 21:32:25">2022/10/26</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 IDEA "
           href="/20221026/2241d802.html"
           data-tag="IDEA"
           data-author="" >
            <span class="post-title" title="IDEA 使用技巧">IDEA 使用技巧</span>
            <span class="post-date" title="2022-10-26 21:32:25">2022/10/26</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 IDEA "
           href="/20221026/ee604b16.html"
           data-tag="IDEA"
           data-author="" >
            <span class="post-title" title="IDEA插件">IDEA插件</span>
            <span class="post-date" title="2022-10-26 21:32:25">2022/10/26</span>
        </a>
        
        
        <a  class="全部文章 工具|部署 IDEA "
           href="/20221026/1a8c2722.html"
           data-tag="IDEA"
           data-author="" >
            <span class="post-title" title="IDEA配置">IDEA配置</span>
            <span class="post-date" title="2022-10-26 21:32:25">2022/10/26</span>
        </a>
        
        
        <a  class="全部文章 博客搭建 UML类图 "
           href="/20221025/c9ac90bb.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UML类图与接口图的表示">UML类图与接口图的表示</span>
            <span class="post-date" title="2022-10-25 19:52:44">2022/10/25</span>
        </a>
        
        
        <a  class="全部文章 博客搭建 Markdown语法 "
           href="/20221025/ea43daec.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Markdown使用语法记录">Markdown使用语法记录</span>
            <span class="post-date" title="2022-10-25 19:52:44">2022/10/25</span>
        </a>
        
        
        <a  class="全部文章 博客搭建 Hexo "
           href="/20221025/b6159bfb.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hexo 搭建博客">Hexo 搭建博客</span>
            <span class="post-date" title="2022-10-25 19:52:44">2022/10/25</span>
        </a>
        
        
        <a  class="全部文章 网络安全 "
           href="/20221025/96960bec.html"
           data-tag="网络安全"
           data-author="" >
            <span class="post-title" title="CSRF漏洞处理">CSRF漏洞处理</span>
            <span class="post-date" title="2022-10-25 19:52:44">2022/10/25</span>
        </a>
        
        
        <a  class="全部文章 网络安全 "
           href="/20221025/d188606.html"
           data-tag="网络安全"
           data-author="" >
            <span class="post-title" title="SSL漏洞处理">SSL漏洞处理</span>
            <span class="post-date" title="2022-10-25 19:52:44">2022/10/25</span>
        </a>
        
        
        <a  class="全部文章 网络安全 "
           href="/20221025/409b5317.html"
           data-tag="网络安全"
           data-author="" >
            <span class="post-title" title="XSS漏洞处理">XSS漏洞处理</span>
            <span class="post-date" title="2022-10-25 19:52:44">2022/10/25</span>
        </a>
        
        
        <a  class="全部文章 后端 编程规范 "
           href="/20221025/ba2334ee.html"
           data-tag="编程规范"
           data-author="" >
            <span class="post-title" title="Java开发手册【阿里巴巴】">Java开发手册【阿里巴巴】</span>
            <span class="post-date" title="2022-10-25 19:52:44">2022/10/25</span>
        </a>
        
        
        <a  class="全部文章 后端 Java "
           href="/20221022/725f0c76.html"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="Java 8 in Action【汪文君】">Java 8 in Action【汪文君】</span>
            <span class="post-date" title="2022-10-22 19:52:44">2022/10/22</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-数据库/Redis/02. Redis-配置文件" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Redis-配置文件</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="数据库">数据库</a> > 
            
            <a  data-rel="数据库&lt;---&gt;Redis">Redis</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color1">Redis</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-09-29 19:29:38'>2023-02-08 18:19</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">官方模板文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">具体配置项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#INCLUDES%EF%BC%9A%E5%BC%95%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">INCLUDES：引入自定义配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MODULES"><span class="toc-text">MODULES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NETWORK%EF%BC%9A%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-text">NETWORK：网络配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TLS-SSL"><span class="toc-text">TLS&#x2F;SSL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GENERAL%EF%BC%9A%E9%80%9A%E7%94%A8%E8%AE%BE%E7%BD%AE"><span class="toc-text">GENERAL：通用设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SNAPSHOTTING%EF%BC%9A%E5%BF%AB%E7%85%A7"><span class="toc-text">SNAPSHOTTING：快照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#REPLICATION%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">REPLICATION：主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KEYS-TRACKING"><span class="toc-text">KEYS TRACKING</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SECURITY%EF%BC%9A%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">SECURITY：安全配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CLIENT%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">CLIENT：客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MEMORY-MANAGEMENT%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">MEMORY MANAGEMENT：内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LAZY-FREEING"><span class="toc-text">LAZY FREEING</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#THREADED-I-O"><span class="toc-text">THREADED I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KERNEL-OOM-CONTROL"><span class="toc-text">KERNEL OOM CONTROL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KERNEL-transparent-hugepage-CONTROL"><span class="toc-text">KERNEL transparent hugepage CONTROL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APPEND-ONLY-MODE%EF%BC%9A%E8%BF%BD%E5%8A%A0%E6%A8%A1%E5%BC%8F"><span class="toc-text">APPEND ONLY MODE：追加模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SHUTDOWN"><span class="toc-text">SHUTDOWN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NON-DETERMINISTIC-LONG-BLOCKING-COMMANDS"><span class="toc-text">NON-DETERMINISTIC LONG BLOCKING COMMANDS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#REDIS-CLUSTER%EF%BC%9A%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-text">REDIS CLUSTER：集群配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CLUSTER-DOCKER-NAT-support%EF%BC%9A%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-text">CLUSTER DOCKER&#x2F;NAT support：集群配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SLOW-LOG%EF%BC%9A%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-text">SLOW  LOG：慢查询日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LATENCY-MONITOR%EF%BC%9A%E5%BB%B6%E8%BF%9F%E7%9B%91%E6%8E%A7"><span class="toc-text">LATENCY MONITOR：延迟监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LATENCY-TRACKING%EF%BC%9A%E5%BB%B6%E8%BF%9F%E8%BF%BD%E8%B8%AA"><span class="toc-text">LATENCY TRACKING：延迟追踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EVENT-NOTIFICATION%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5"><span class="toc-text">EVENT NOTIFICATION：事件通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADVANCED-CONFIG"><span class="toc-text">ADVANCED CONFIG</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACTIVE-DEFRAGMENTATION"><span class="toc-text">ACTIVE DEFRAGMENTATION</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>官方模板文件</h1>
<p>参考：<a target="_blank" rel="noopener" href="https://redis.io/docs/management/config-file/">https://redis.io/docs/management/config-file/</a></p>
<p>各版本参数变更：<a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/zh_cn/AmazonElastiCache/latest/red-ug/ParameterGroups.Redis.html">https://docs.aws.amazon.com/zh_cn/AmazonElastiCache/latest/red-ug/ParameterGroups.Redis.html</a></p>
<h1>具体配置项</h1>
<h2 id="INCLUDES：引入自定义配置文件">INCLUDES：引入自定义配置文件</h2>
<p>如果你有一个适用于所有Redis服务器的标准模板，但也需要自定义一些每个服务器的设置，可以使用 <code>include </code> 配置</p>
<p>选项<code>include</code>不会被命令<code>CONFIG REWRITE</code>从管理或Redis哨兵重写。由于Redis总是使用最后处理的行作为配置指令的值，你最好把<code>include</code>放在配置文件的开头，以避免在运行时覆盖配置更改。</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################## INCLUDES ###################################</span></span><br><span class="line"><span class="comment"># include /path/to/local.conf</span></span><br><span class="line"><span class="comment"># include /path/to/other.conf</span></span><br><span class="line"><span class="comment"># include /path/to/fragments/*.conf</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="MODULES">MODULES</h2>
<p>在启动时加载模块。如果服务器不能加载模块，它将中止。可以使用多个<code>loadmodule</code>指令。</p>
<p>通过Redis Module可以扩展Redis本身的能力，能够实现一些Redis本身不支持的命令</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################## MODULES #####################################</span></span><br><span class="line"><span class="comment"># loadmodule /path/to/my_module.so</span></span><br><span class="line"><span class="comment"># loadmodule /path/to/other_module.so</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="NETWORK：网络配置">NETWORK：网络配置</h2>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################## NETWORK #####################################</span></span><br><span class="line"><span class="comment"># 默认情况下，如果没有指定bind配置指令，Redis将监听来自主机上所有可用网络接口的连接。</span></span><br><span class="line"><span class="comment"># 可以使用bind配置指令监听一个或多个选定的接口，后面跟着一个或多个IP地址。</span></span><br><span class="line"><span class="comment"># 不可用仅指不对应于任何网络接口的地址。已经在使用的地址将总是失败，不支持的协议将无法访问。</span></span><br><span class="line"><span class="comment"># Examples:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># bind 192.168.1.100 10.0.0.1     # listens on two specific IPv4 addresses</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1 ::1              # listens on loopback IPv4 and IPv6</span></span><br><span class="line"><span class="comment"># bind * -::*                     # like the default, all available interfaces</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ~~~ WARNING ~~~ </span></span><br><span class="line"><span class="comment"># 如果运行Redis的计算机直接暴露在互联网上，绑定到所有接口是危险的，并将实例暴露给互联网上的每个人。</span></span><br><span class="line"><span class="comment"># 所以默认情况下，我们取消注释下面的bind指令，这将迫使Redis只监听IPv4和IPv6(如果可用)环回接口地址(这意味着Redis将只能接受来自其运行的同一主机的客户端连接)。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果您确定希望您的实例侦听所有接口,注释掉下面一行。</span></span><br><span class="line"><span class="comment"># 您还需要设置密码，除非您显式禁用protected模式。</span></span><br><span class="line"><span class="comment"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1 -::1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，传出连接(从副本到主，从哨兵到实例，集群总线等)不会绑定到特定的本地地址。</span></span><br><span class="line"><span class="comment"># 在大多数情况下，这意味着操作系统将基于路由进行处理和连接通过的接口。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 使用bind-source-addr可以配置要绑定的特定地址,这也可能影响连接的路由方式。举例:</span></span><br><span class="line"><span class="comment"># bind-source-addr 10.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保护模式是一层安全保护层, 默认启用。</span></span><br><span class="line"><span class="comment"># 为了避免打开的Redis实例在互联网上被访问和利用。当开启保护模式且默认用户没有密码时，服务器会自动关闭。</span></span><br><span class="line">protected-mode <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis使用默认的加固安全配置指令来减少攻击无辜用户。因此，几种敏感配置指令是不可变的，一些潜在危险的命令会被阻塞。</span></span><br><span class="line"><span class="comment"># 控制Redis写入文件的配置指令(例如，'dir' 和'dbfilename')，并且通常不会在运行时修改。通过使它们不可变来保护它们。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过设置，这些可以暴露给所有连接，也可以只暴露给本地连接</span></span><br><span class="line"><span class="comment"># 下面列出的每一个配置到这些值中的任意一个:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># no    - 阻塞任何连接(保持不可变)</span></span><br><span class="line"><span class="comment"># yes   - 允许任何连接(无保护)</span></span><br><span class="line"><span class="comment"># local - 只允许本地连接. Ones originating from the IPv4 address (127.0.0.1), IPv6 address (::1) or Unix domain sockets.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># enable-protected-configs no</span></span><br><span class="line"><span class="comment"># enable-debug-command no</span></span><br><span class="line"><span class="comment"># enable-module-command no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受指定端口上的连接，默认为6379 (IANA #815344).</span></span><br><span class="line"><span class="comment"># IANA: https://www.iana.org 互联网地址编码分配机构</span></span><br><span class="line"><span class="comment"># 如果指定了端口0,Redis将不会监听TCP套接字。</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP listen() backlog.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 在每秒请求数高的环境中，您需要大量的积压，以避免客户端连接速度慢的问题。</span></span><br><span class="line"><span class="comment"># 请注意，Linux内核会将其静默地截断为/proc/sys/net/core/somaxconn的值（cat /proc/sys/net/core/somaxconn）</span></span><br><span class="line"><span class="comment"># 因此请确保同时提高somaxconn和tcp_max_syn_backlog（cat /etc/sysctl.conf）的值，以便获得所需的效果。</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"><span class="comment"># Unix socket.</span></span><br><span class="line"><span class="comment"># 指定用于侦听传入连接的Unix套接字的路径。没有默认值，所以如果没有指定，Redis将不会监听unix套接字。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># unixsocket /run/redis.sock</span></span><br><span class="line"><span class="comment"># unixsocketperm 700</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在客户端空闲N秒后关闭连接(0为禁用)</span></span><br><span class="line"><span class="built_in">timeout</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP keepalive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果非零，在没有通信的情况下使用SO_KEEPALIVE向客户端发送TCP ACKs。这很有用，有两个原因:</span></span><br><span class="line"><span class="comment"># 1) 检测失效节点</span></span><br><span class="line"><span class="comment"># 2) 强制中间的网络设备认为连接是活的。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 在Linux操作系统中，该值(单位为秒)为发送ACK的周期。注意，关闭连接需要两倍的时间。在其他内核上，周期取决于内核配置。</span></span><br><span class="line"><span class="comment"># 这个选项的合理值是300秒。从Redis 3.2.1开始，是新的Redis默认值</span></span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用操作系统特有的机制，用指定的ID标记监听套接字，以支持高级路由和过滤功能。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 在Linux上，ID表示一个连接标记</span></span><br><span class="line"><span class="comment"># 在FreeBSD上，ID表示套接字cookie ID。</span></span><br><span class="line"><span class="comment"># 在OpenBSD上，ID表示路由表ID。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值是0，这意味着不需要标记。</span></span><br><span class="line"><span class="comment"># socket-mark-id 0</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="TLS-SSL">TLS/SSL</h2>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################# TLS/SSL #####################################</span></span><br><span class="line"><span class="comment"># 默认情况下，TLS/SSL协议处于禁用状态。要启用它，可以使用“tls-port”配置指令定义tls侦听端口。port指定了0，则不再监听TCP套接字。</span></span><br><span class="line"><span class="comment"># 在默认端口上启用TLS，请使用:</span></span><br><span class="line"><span class="comment"># port 0</span></span><br><span class="line"><span class="comment"># tls-port 6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置X.509证书和私钥，用于对连接的客户端、主节点或集群对等体进行服务器身份验证。这些文件应该是PEM格式的。</span></span><br><span class="line"><span class="comment"># tls-cert-file redis.crt</span></span><br><span class="line"><span class="comment"># tls-key-file redis.key</span></span><br><span class="line"><span class="comment"># 如果KEY文件是使用密码短语加密的，那么它也可以包含在这里。</span></span><br><span class="line"><span class="comment"># tls-key-file-pass secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通常Redis对服务器功能(接受连接)和客户端功能(从主服务器复制，建立集群总线连接等)使用相同的证书。</span></span><br><span class="line"><span class="comment"># 有时颁发证书时带有将其指定为仅客户端证书或仅服务器证书的属性。在这种情况下，可能需要对传入(服务器)和传出(客户端)连接使用不同的证书。要做到这一点，请使用以下指令:</span></span><br><span class="line"><span class="comment"># tls-client-cert-file client.crt</span></span><br><span class="line"><span class="comment"># tls-client-key-file client.key</span></span><br><span class="line"><span class="comment"># 如果KEY文件是使用密码短语加密的，那么它也可以包含在这里。</span></span><br><span class="line"><span class="comment"># tls-client-key-file-pass secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置DH参数文件，开启 DH (Diffie-Hellman) KEY交换功能，这是旧版本OpenSSL(&lt;3.0)的要求。新版本不需要这种配置，建议不要这样做。</span></span><br><span class="line"><span class="comment"># tls-dh-params-file redis.dh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置CA证书包或目录以验证TLS/SSL客户端和对等体。Redis需要至少其中一个的显式配置，并且不会隐式地使用系统范围的配置。</span></span><br><span class="line"><span class="comment"># tls-ca-cert-file ca.crt</span></span><br><span class="line"><span class="comment"># tls-ca-cert-dir /etc/ssl/certs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，TLS端口上的客户端(包括副本服务器)需要使用有效的客户端证书进行身份验证。</span></span><br><span class="line"><span class="comment"># - no：则不需要且不接受客户端证书。</span></span><br><span class="line"><span class="comment"># - optional：则接受客户端证书，并且在提供时必须有效，但不是必需的。</span></span><br><span class="line"><span class="comment"># tls-auth-clients no</span></span><br><span class="line"><span class="comment"># tls-auth-clients optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，Redis副本不会尝试与其主服务器建立TLS连接。使用下面的指令在复制链路上启用TLS。</span></span><br><span class="line"><span class="comment"># tls-replication yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，Redis集群总线使用普通TCP连接. 要为总线协议启用TLS，请使用以下指令:</span></span><br><span class="line"><span class="comment"># tls-cluster yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，只启用TLSv1.2和TLSv1.3，强烈建议禁用旧的正式弃用版本，以减少攻击面。</span></span><br><span class="line"><span class="comment"># 您可以显式地指定要支持的TLS版本。允许的值不区分大小写，包括 “TLSv1”，“TLSv1.1”，“TLSv1.2”，"TLSv1.3" (OpenSSL &gt;= 1.1.1) 或者任意组合.</span></span><br><span class="line"><span class="comment"># 如果只启用TLSv1.2和TLSv1.3，请使用:</span></span><br><span class="line"><span class="comment"># tls-protocols "TLSv1.2 TLSv1.3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置允许的密码。有关此字符串语法的更多信息，请参阅 cipher (1ssl) 手册（ 此配置仅适用于&lt;= TLSv1.2）</span></span><br><span class="line"><span class="comment"># tls-ciphers DEFAULT:!MEDIUM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置允许使用的TLSv1.3密码套件。有关此字符串语法的更多信息，特别是关于TLSv1.3密码套件的信息，请参阅 cipher (1ssl) 手册</span></span><br><span class="line"><span class="comment"># tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在选择密码时，使用服务器的首选项而不是客户端首选项。默认情况下，服务器遵循客户端的首选项。</span></span><br><span class="line"><span class="comment"># tls-prefer-server-ciphers yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，启用TLS会话缓存，以允许支持TLS会话缓存的客户端更快、更便宜地重新连接。使用下面的指令禁用缓存。</span></span><br><span class="line"><span class="comment"># tls-session-caching no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改TLS缓存的默认会话数。零值将缓存设置为无限大小。默认大小为20480。</span></span><br><span class="line"><span class="comment"># tls-session-cache-size 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改TLS缓存会话的默认超时时间。缺省超时时间为300秒。</span></span><br><span class="line"><span class="comment"># tls-session-cache-timeout 60</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="GENERAL：通用设置">GENERAL：通用设置</h2>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################# GENERAL #####################################</span></span><br><span class="line"><span class="comment"># 默认情况下，Redis不作为守护进程运行。如果需要，配置为 “yes”</span></span><br><span class="line"><span class="comment"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span></span><br><span class="line"><span class="comment"># 注意，Redis会在文件 /var/run/redis.pid 中写入守护时的 pid</span></span><br><span class="line"><span class="comment"># 当Redis被upstart或systemd监控时，该参数无影响。</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你从upstart或systemd运行Redis, Redis可以与你的supervision tree交互。这些监督方法只是表明“流程已经准备好了”。他们不允许连续的ping回你的supervisor。</span></span><br><span class="line"><span class="comment"># 选项:</span></span><br><span class="line"><span class="comment">#   - no      - no supervision interaction</span></span><br><span class="line"><span class="comment">#   - upstart - signal upstart by putting Redis into SIGSTOP mode requires "expect stop" in your upstart job config</span></span><br><span class="line"><span class="comment">#   - systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET on startup, and updating Redis status on a regular basis.</span></span><br><span class="line"><span class="comment">#   - auto    - detect upstart or systemd method based on UPSTART_JOB or NOTIFY_SOCKET environment variables</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 默认为 “no”。要在 upstart/systemd下运行，你可以简单地取消下面这行代码的注释:</span></span><br><span class="line"><span class="comment"># supervised auto</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果指定了pid文件，Redis在启动时将其写入指定的位置，并在退出时删除它。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果在配置中没有指定pid文件，那么当服务器运行时，不会创建pid文件。</span></span><br><span class="line"><span class="comment"># 当服务器被守护时，即使没有指定pid文件，也会使用pid文件，默认为 "/var/run/redis.pid"。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 正常创建一个pid文件是最好的结果:如果Redis不能创建它，没有什么不好的事情发生，服务器将正常启动和运行。</span></span><br><span class="line"><span class="comment"># 注意，在现代Linux系统中，"/run/redis.pid" 更符合要求，应该用它来代替。</span></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定服务器日志级别</span></span><br><span class="line"><span class="comment"># - debug：有很多信息，对开发/测试很有用</span></span><br><span class="line"><span class="comment"># - verbose：许多极少用到的信息，但不像调试级别那样混乱</span></span><br><span class="line"><span class="comment"># - notice：合理冗余, 但可能是在生产中需要的</span></span><br><span class="line"><span class="comment"># - warning：只记录非常重要/关键的消息</span></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件名。</span></span><br><span class="line"><span class="comment"># 空字符串也可以用来强制Redis登录到标准输出。</span></span><br><span class="line"><span class="comment"># 注意，如果使用标准输出进行日志记录，但是使用daemonize，那么日志将被发送到/dev/null</span></span><br><span class="line">logfile <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要启用系统日志记录器，只需将'syslog-enabled'设置为yes，并可选地更新其他系统日志参数以满足您的需要</span></span><br><span class="line"><span class="comment"># syslog-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定系统日志标识。</span></span><br><span class="line"><span class="comment"># syslog-ident redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统日志记录的级别，必须为USER或LOCAL0-LOCAL7之间。</span></span><br><span class="line"><span class="comment"># syslog-facility local0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要禁用内建的崩溃日志（它可能会在需要时产生更干净的core dumps），取消注释如下:</span></span><br><span class="line"><span class="comment"># crash-log-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要禁用作为崩溃日志一部分的运行时快速内存检查（这可能会让redis更快地终止），取消以下注释:</span></span><br><span class="line"><span class="comment"># crash-memcheck-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置数据库数量。默认数据库是 DB 0，您可以使用select &lt;dbid&gt;在每个连接的基础上选择一个不同的数据库，其中dbid是从0开始计数</span></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，Redis只在开始记录到标准输出，并且标准输出是TTY, 系统日志记录被禁用，时显示ASCII艺术徽标</span></span><br><span class="line"><span class="comment"># 基本上，这意味着徽标通常只在交互会话中显示。</span></span><br><span class="line"><span class="comment"># 然而，通过将以下选项设置为yes，可以强制4.0之前的行为，并始终在启动日志中显示ASCII艺术徽标。</span></span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，Redis修改进程标题(如'top'和'ps'所示)以提供一些运行时信息。</span></span><br><span class="line"><span class="comment"># 通过将以下设置为no，可以禁用此功能并保留进程名为已执行。</span></span><br><span class="line">set-proc-title <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当更改流程标题时，Redis使用以下模板来构造修改后的标题。模板变量用花括号指定。支持如下变量:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># {title}           父进程时执行的进程名，或子进程的类型</span></span><br><span class="line"><span class="comment"># {listen-addr}     绑定地址或 "*"，后面跟着TCP或TLS端口监听，或Unix套接字(如果有的话)</span></span><br><span class="line"><span class="comment"># {server-mode}     特殊模式, 例如. "[sentinel]" or "[cluster]"</span></span><br><span class="line"><span class="comment"># {port}            TCP监听端口，或0</span></span><br><span class="line"><span class="comment"># {tls-port}        TLS监听端口, or 0.</span></span><br><span class="line"><span class="comment"># {unixsocket}      Unix套接字监听端口, or "".</span></span><br><span class="line"><span class="comment"># {config-file}     使用的配置文件名称.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">proc-title-template <span class="string">"{title} {listen-addr} {server-mode}"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置用于字符串比较操作的本地环境，也会影响Lua脚本的性能。空字符串表示区域设置是由环境变量派生的。</span></span><br><span class="line"><span class="comment"># Set the local environment which is used for string comparison operations, and  also affect the performance of Lua scripts. </span></span><br><span class="line">locale-collate <span class="string">""</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="SNAPSHOTTING：快照">SNAPSHOTTING：快照</h2>
<p><img src="https://hmxyl-image.oss-cn-hangzhou.aliyuncs.com/note/image-20230209170518390.png" alt="image-20230209170518390"></p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将DB数据保存到磁盘</span></span><br><span class="line"><span class="comment"># save &lt;seconds&gt; &lt;changes&gt; [&lt;seconds&gt; &lt;changes&gt; ...]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 经过给定秒数（seconds），且对DB的写操作超过了给定数量（changes），Redis将保存DB。</span></span><br><span class="line"><span class="comment"># 快照可以通过一个空字符串参数完全禁用，如下例所示:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># save ""</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 默认情况下Redis会保存DB</span></span><br><span class="line"><span class="comment">#   - 3600 1： 在3600秒(一小时)之后，至少执行了一次更改</span></span><br><span class="line"><span class="comment">#   - 300 100： 在300秒(五分钟)之后，至少执行了100次更改</span></span><br><span class="line"><span class="comment">#   - 60 10000： 在60秒(一分钟)之后，至少执行了10000次更改</span></span><br><span class="line"><span class="comment"># 您可以通过取消注释下面的行显式地设置这些参数</span></span><br><span class="line"><span class="comment"># save 3600 1 300 100 60 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，如果RDB快照启用(至少一个保存点) 并且最近的后台保存失败，Redis将停止接受写入。</span></span><br><span class="line"><span class="comment"># 这将使用户意识到(以一种艰难的方式)数据没有正确地持久化在磁盘上，否则很可能没有人会注意到，从而发生一些灾难。</span></span><br><span class="line"><span class="comment"># 如果后台保存进程重新开始工作，Redis将自动允许再次写入。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 但是，如果你已经设置了适当的Redis服务器监控和持久化，你可能想要禁用这个功能，这样即使有磁盘、权限等问题，Redis也会继续正常工作。</span></span><br><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认启用：当保存快照文件（RDB数据库）时，使用LZF压缩字符串对象。</span></span><br><span class="line"><span class="comment"># 如果你想在save child中节省一些CPU，将其设置为 "no"，但如果你有可压缩的值或键，数据集可能会更大。</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从RDB版本5开始，CRC64校验和被放在文件的末尾。</span></span><br><span class="line"><span class="comment"># 这使得格式更能抵抗损坏，但在保存和加载RDB文件时，会有性能损失(大约10%)，因此您可以禁用它以获得最大性能。</span></span><br><span class="line"><span class="comment"># 创建的RDB文件时，禁用校验或者校验和为零，将告诉加载代码跳过该检查</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># loading an RDB or RESTORE payload 时，允许或禁止对 ziplist 或者 listpack 等进行 full sanitization checks</span></span><br><span class="line"><span class="comment"># 这降低了稍后在处理命令时发生断言或崩溃的可能性。</span></span><br><span class="line"><span class="comment"># Options:</span></span><br><span class="line"><span class="comment">#   no         - 从不执行 full sanitization</span></span><br><span class="line"><span class="comment">#   yes        - 总是执行 full sanitization</span></span><br><span class="line"><span class="comment">#   clients    - 仅对用户连接执行full sanitization.</span></span><br><span class="line"><span class="comment">#                排除: RDB 文件, 从主连接接收到的RESTORE命令, 和具有skip-cleanup-payload ACL标志的客户端连接.</span></span><br><span class="line"><span class="comment"># 默认值应该是'clients'，但由于它目前会影响通过MIGRATE进行集群重分片，因此默认情况下暂时设置为'no'。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># sanitize-dump-payload no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置快照文件名</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在未启用持久性的情况下，删除实例中复制使用的RDB文件</span></span><br><span class="line"><span class="comment"># 默认情况下，该选项是禁用的，但是在某些环境下，出于法规或其他安全考虑，应该尽快删除由master保存在磁盘上以提供副本，或由副本存储在磁盘上以加载它们以进行初始同步的RDB文件。</span></span><br><span class="line"><span class="comment"># 注意，此选项仅在同时禁用了AOF和RDB持久性的实例中有效，否则将完全忽略。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 获得相同效果的另一种(有时更好)方法是在主实例和副本实例上使用无磁盘复制。但是，在副本实例的环境下，无磁盘并不总是一种选择。</span></span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快照工作目录</span></span><br><span class="line"><span class="comment"># dbfilename配置的快照文件，将被写入这个目录中</span></span><br><span class="line"><span class="comment"># Append Only产生的文件也将在此目录中创建。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 注意，这里必须指定目录，而不是文件名。</span></span><br><span class="line"><span class="built_in">dir</span> ./</span><br></pre></td></tr></tbody></table></figure>
<h2 id="REPLICATION：主从复制">REPLICATION：主从复制</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################# REPLICATION #################################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Master-Replica 复制. 使用replicaof使一个Redis实例成为另一个Redis服务器的副本。 </span></span><br><span class="line"><span class="comment"># 关于Redis复制需要尽快了解的一些事情</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   +------------------+      +---------------+</span></span><br><span class="line"><span class="comment">#   |      Master      | ---&gt; |    Replica    |</span></span><br><span class="line"><span class="comment">#   | (receive writes) |      |  (exact copy) |</span></span><br><span class="line"><span class="comment">#   +------------------+      +---------------+</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Redis复制是异步的，但是你可以配置一个主服务器，如果它没有与至少给定数量的副本连接，它就会停止接受写操作</span></span><br><span class="line"><span class="comment"># 2) 如果复制链路在相对较短的时间内丢失，Redis副本能够与主服务器执行部分再同步。您可能需要配置复制backlog大小(请参阅此文件的下一节)，并根据您的需要设置合理的值。</span></span><br><span class="line"><span class="comment"># 3) 复制是自动的，不需要用户干预，在网络分区之后，副本会自动尝试重新连接到主节点并与它们重新同步。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 如果主机有密码保护 ( “requirepass” 配置指令) 可以在启动同步复制进程之前告诉副本进行身份验证, 否则主服务器将拒绝副本请求。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 然而，如果你正在使用Redis ACL，这是不够的(适用于Redis版本6或更高版本), 默认用户不能执行PSYNC命令和/或复制所需的其他命令。</span></span><br><span class="line"><span class="comment"># 在这种情况下，最好配置一个特殊用户用于复制，并指定主用户配置如下:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># masteruser &lt;username&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 当指定了masteruser时，副本将使用新的AUTH表单对其主服务器进行身份验证: AUTH &lt;username&gt; &lt;password&gt;.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当一个副本失去了与主服务器的连接，或者当复制仍在进行时，副本可以以两种不同的方式工作:</span></span><br><span class="line"><span class="comment"># 1) 如果 replica-serve-stale-data 配置为"yes"(默认) 副本仍然会回复客户端请求, 可能有过时的数据, 如果这是第一次同步，则数据集可能为空.</span></span><br><span class="line"><span class="comment"># 2) 如果 replica-serve-stale-data 配置为"no", 副本会返回给所有请求一下错误信息："MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'", 除了以下命令: INFO, REPLICAOF, AUTH, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST, HOST and LATENCY.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">replica-serve-stale-data</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 您可以配置副本实例是否接受写操作。</span></span><br><span class="line"><span class="comment"># 针对副本实例写入可能有助于存储一些临时数据(因为写入副本的数据在与主服务器重新同步后很容易被删除)，但如果客户端由于错误配置而写入副本，也可能导致问题。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis 2.6 版本之后默认副本是只读的。</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> 只读副本不会被设计成暴露给互联网上不受信任的客户端。它只是防止实例被滥用的保护层。</span></span><br><span class="line"><span class="comment"># 默认情况下，只读副本仍然可输出所有管理类命令，如CONFIG、DEBUG等。在有限的范围内，您可以使用'rename-command'来隐藏所有管理的、危险的命令，从而提高只读副本的安全性。</span></span><br><span class="line"><span class="attr">replica-read-only</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 副本同步策略: 磁盘同步或套接字同步。</span></span><br><span class="line"><span class="comment"># 新的副本和重新连接的副本不能继续复制过程，只是接收差异，需要做所谓的“完全同步”。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># RDB文件从主服务器传输到副本。有两种不同的传输方式:</span></span><br><span class="line"><span class="comment"># 1) Disk-backed: Redis主进程创建一个新进程，将RDB文件写入磁盘。随后，父进程将文件增量地传输到副本</span></span><br><span class="line"><span class="comment">#                 当RDB文件生成时，允许更多的副本排队，只要当前生成RDB文件的子进程完成了它的工作，排队的副本们便可以用生成的RDB文件提供服务</span></span><br><span class="line"><span class="comment"># 2) Diskless: Redis主进程创建一个新进程，直接将RDB文件写入复制套接字，而不需要任何磁盘操作。</span></span><br><span class="line"><span class="comment">#              使用无磁盘复制时，一旦传输开始，新的副本将进入队列，当当前传输终止时，新的传输将开始 </span></span><br><span class="line"><span class="comment">#              当使用无盘复制时，主服务器在开始传输之前等待一段可配置的时间(以秒为单位)，希望有多个副本到达，并行传输数据。</span></span><br><span class="line"><span class="comment">#              对于慢磁盘和快速(大带宽)网络，无磁盘复制工作得更好</span></span><br><span class="line"><span class="attr">repl-diskless-sync</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当启用无磁盘复制时，为了生成 通过套接字将RDB传输到副本 的子节点，可以配置服务器等待时间</span></span><br><span class="line"><span class="comment"># 这很重要，因为一旦传输开始，就不可能为新的副本提供服务，这些副本将排队等待下一个RDB传输，因此服务器等待延迟以让更多副本到达。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 延迟以秒为单位指定，默认为5秒。要完全禁用它，只需将其设置为0秒，传输将尽快开始。</span></span><br><span class="line"><span class="attr">repl-diskless-sync-delay</span> <span class="string">5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当使用延迟启用无磁盘复制时，如果期望的最大副本数量已连接，则可以在达到最大延迟之前让复制启动。</span></span><br><span class="line"><span class="comment"># 默认为0意味着没有定义最大副本数量，Redis将等待全部延迟。</span></span><br><span class="line"><span class="attr">repl-diskless-sync-max-replicas</span> <span class="string">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># WARNING: 由于在这种设置中，副本不会立即在磁盘上存储RDB，因此在故障转移期间可能会导致数据丢失。</span></span><br><span class="line"><span class="comment"># RDB无盘加载+ Redis模块不处理I/O读取可能会导致Redis在与主同步的初始阶段出现I/O错误时中止。</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Replica可以直接从套接字加载它从复制链路读取的RDB，或者将RDB存储到一个文件中，在从master完全接收到RDB后再读取该文件。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 在许多情况下，磁盘比网络慢，存储和加载RDB文件可能会增加复制时间(甚至增加主服务器的Copy on Write内存和副本缓冲区)。</span></span><br><span class="line"><span class="comment"># 然而，当直接从套接字解析RDB文件时，为了避免数据丢失，只有当新数据集在内存中完全加载时才会安全地刷新当前数据集，从而导致更高的内存使用量。</span></span><br><span class="line"><span class="comment"># 因此，我们有以下选择:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># "disabled"    - 不要使用无磁盘加载(先将rdb文件存储到磁盘)</span></span><br><span class="line"><span class="comment"># "swapdb"      - 在直接从套接字解析数据时，将当前db内容保存在RAM中。</span></span><br><span class="line"><span class="comment">#                 在此模式下的副本可以在复制进行时继续服务当前数据集，除非它们无法将主服务器识别为具有来自相同复制历史的数据集</span></span><br><span class="line"><span class="comment">#                 注意，这需要足够的内存，如果没有内存，就有OOM kill的风险</span></span><br><span class="line"><span class="comment"># "on-empty-db" - 仅当当前数据集为空时使用无磁盘加载. </span></span><br><span class="line"><span class="comment">#                 这样更安全，可以避免在复制期间同时加载新旧数据集。</span></span><br><span class="line"><span class="attr">repl-diskless-load</span> <span class="string">disabled</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 主机在预定义的时间间隔内向其副本发送ping。可以使用repl_ping_replica_period选项更改这个间隔。缺省值是10秒。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-ping-replica-period 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 以下选项设置的复制超时时间:</span></span><br><span class="line"><span class="comment"># 1) 从副本的角度来看，同步期间的批量传输I/O</span></span><br><span class="line"><span class="comment"># 2) 从副本(data, ping)的角度看主节点超时</span></span><br><span class="line"><span class="comment"># 3) 从主节点的角度看副本超时(REPLCONF ACK ping)</span></span><br><span class="line"><span class="comment"># 确保这个值大于为repl-ping-replica-period指定的值是很重要的，否则每次在主服务器和副本之间有低流量时都会检测到超时。缺省值是60秒。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-timeout 60</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 在SYNC之后禁用副本套接字上的TCP_NODELAY ?</span></span><br><span class="line"><span class="comment">#  - yes： Redis将使用更少的TCP数据包和更少的带宽将数据发送到副本。但是这可能会增加数据在副本端出现的延迟，对于使用默认配置的Linux内核，延迟最长可达40毫秒。</span></span><br><span class="line"><span class="comment">#  - no： 则数据出现在副本端的延迟将减少，但复制将使用更多带宽。</span></span><br><span class="line"><span class="comment"># 默认情况下，我们优化低延迟，但在非常高的流量条件下，或者当主服务器和副本相隔很多跳时，将此选项变为“yes”可能是一个好主意。</span></span><br><span class="line"><span class="attr">repl-disable-tcp-nodelay</span> <span class="string">no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置复制backlog大小。backlog是一个缓冲区，当副本断开连接一段时间后，它会积累副本数据，因此当副本想再次重新连接时，通常不需要完全重新同步，部分重新同步就足够了，只需传递断开连接时副本错过的部分数据。</span></span><br><span class="line"><span class="comment"># 复制backlog越大，副本能够忍受断开的时间就越长，并且以后能够执行部分重新同步。</span></span><br><span class="line"><span class="comment"># 只有当至少连接了一个副本时，才分配backlog。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-backlog-size 1mb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 主服务器在一段时间内没有连接的副本后，积压将被释放。</span></span><br><span class="line"><span class="comment"># 下面的选项配置需要经过的秒数，从最后一个副本断开连接的时间开始，以释放积压缓冲区。</span></span><br><span class="line"><span class="comment"># 请注意，副本永远不会因为超时而释放积压，因为它们可能稍后会升级为主副本，并且应该能够正确地与其他副本“部分重新同步”:因此它们应该总是积累积压。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 值为0意味着永远不释放待办事项。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-backlog-ttl 3600</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 副本优先级是Redis在INFO输出中发布的整数。它是由Redis哨兵，在主服务器不再正常工作，选择要提升为主服务器的副本时使用</span></span><br><span class="line"><span class="comment"># 优先级低的副本被认为更适合升级，例如，如果有三个优先级为10，100,25的副本，哨兵会选择优先级为10的副本，这是最低的。</span></span><br><span class="line"><span class="comment"># 然而，优先级为0的副本标志着该副本不能执行master角色，因此优先级为0的副本将永远不会被Redis Sentinel选中进行升级。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 缺省情况下，优先级为100。</span></span><br><span class="line"><span class="attr">replica-priority</span> <span class="string">100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 传播错误行为控制了当Redis无法处理来自主机的复制流中正在处理的命令时，它将如何表现。传播过程中发生的错误是意外的，并可能导致数据不一致。然而，在早期版本的Redis中存在一些边缘情况，服务器可能会复制或保留在未来版本中失败的命令。因此，默认行为是忽略此类错误并继续处理命令。</span></span><br><span class="line"><span class="comment"># 如果应用程序希望确保没有数据分歧，则应该将此配置设置为'panic'。该值还可以设置为'panic-on-replicas'，仅当副本在复制流上遇到错误时才恐慌。一旦有足够的安全机制来防止误报崩溃，这两个恐慌值中的一个将成为未来的默认值。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># propagation-error-behavior ignore</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 副本忽略磁盘写错误控制副本在无法将从主服务器接收到的写命令持久化到磁盘时的行为。</span></span><br><span class="line"><span class="comment"># 默认情况下，这个配置被设置为'no'，在这种情况下会使副本崩溃。不建议更改这个默认值，但是为了与旧版本的Redis兼容，这个配置可以切换为“yes”，这将只是记录一个警告，并执行从master得到的写命令。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># replica-ignore-disk-write-errors no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 默认情况下，Redis Sentinel在报告中包含所有副本。一个副本可以排除在Redis哨兵的公告。一个未通知的副本将被'sentinel replicas &lt;master&gt;'命令忽略，并且不会暴露给Redis sentinel的客户端。</span></span><br><span class="line"><span class="comment"># 该选项不会改变复制优先级的行为。即使replica-announce设置为“no”，副本也可以提升为主副本。为了防止这种情况发生，请将replica-priority设置为0。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># replica-announced yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 如果连接的副本少于N个，主服务器有可能停止接受写操作，延迟小于或等于M秒。也就是N个副本需要处于“online”状态。</span></span><br><span class="line"><span class="comment"># 延迟时间(以秒为单位)必须&lt;=指定的值，是从副本接收到的最后一个ping计算出来的，通常每秒钟发送一次。</span></span><br><span class="line"><span class="comment"># 此选项不保证N个副本将接受写入，但将在没有足够的副本可用的情况下将丢失写入的暴露窗口限制为指定的秒数</span></span><br><span class="line"><span class="comment"># 例如，需要至少3个副本，延迟&lt;= 10秒使用:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># min-replicas-to-write 3</span></span><br><span class="line"><span class="comment"># min-replicas-max-lag 10</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 将其中一个或另一个设置为0将禁用该特性。</span></span><br><span class="line"><span class="comment"># 默认情况下，min-replica-to-write设置为0(禁用功能)，min-replica-max-lag设置为10。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis主机能够以不同的方式列出附加副本的地址和端口。</span></span><br><span class="line"><span class="comment"># 例如，“INFO replication”部分提供了这些信息，在其他工具中，Redis Sentinel可以使用这些信息来发现副本实例。另一个可用此信息的地方是主机的“ROLE”命令的输出。</span></span><br><span class="line"><span class="comment"># 副本正常上报的列表IP地址和端口可以通过以下方式获取:</span></span><br><span class="line"><span class="comment">#   IP: 通过检查副本用于连接主服务器的套接字的对端地址，可以自动检测该地址。</span></span><br><span class="line"><span class="comment">#   Port: 该端口在复制握手期间由副本通信，并且通常是副本用来侦听连接的端口。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 然而，当使用端口转发或网络地址转换(NAT)时，副本实际上可能通过不同的IP和端口对可达。副本可以使用以下两个选项向其主服务器报告特定的IP和端口集，这样INFO和ROLE都将报告这些值。</span></span><br><span class="line"><span class="comment"># 如果只需要覆盖端口或IP地址，则不需要同时使用这两个选项。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># replica-announce-ip 5.5.5.5</span></span><br><span class="line"><span class="comment"># replica-announce-port 1234</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="KEYS-TRACKING">KEYS TRACKING</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################### KEYS TRACKING #################################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis实现了客户端值缓存的服务器辅助支持。</span></span><br><span class="line"><span class="comment"># 这是使用一个invalidation table来实现的，它使用一个按键名索引的基数键来记住客户端有哪些键。</span></span><br><span class="line"><span class="comment"># 反过来，这用于向客户端发送invalidation messages。请点击本页了解更多功能:</span></span><br><span class="line"><span class="comment">#   https://redis.io/topics/client-side-caching</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 当对客户端启用跟踪时，所有的只读查询都被假定为缓存:这将迫使Redis在invalidation table中存储信息。当KEY被修改时，此类信息将被清除，invalidation messages将被发送到客户端。</span></span><br><span class="line"><span class="comment"># 然而，如果工作负载被读操作严重占据，Redis可能会使用越来越多的内存来跟踪多个客户端获取的键。</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 因此，可以为无效表配置一个最大填充值。默认情况下，它被设置为1M的键，一旦达到这个限制，Redis将开始从invalidation table中删除键，即使它们没有被修改，只是为了回收内存:这将反过来迫使客户端使缓存的值无效。</span></span><br><span class="line"><span class="comment"># 基本上，表的最大大小是在服务器端用于跟踪谁缓存了什么信息的内存和客户端在内存中保留缓存对象的能力之间进行权衡。</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 如果将该值设置为0，则意味着没有限制，并且Redis将在无效表中保留尽可能多的键。</span></span><br><span class="line"><span class="comment"># 在“stats” INFO部分中，您可以找到关于invalidation table中每个给定时刻的键数的信息。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> 当在广播模式下使用KEY跟踪时，服务器端不使用内存，因此此设置是无用的。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tracking-table-max-keys 1000000</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="SECURITY：安全配置">SECURITY：安全配置</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################## SECURITY ###################################</span></span><br><span class="line"><span class="comment"># 在 Redis6.0中引入了ACL（Access Control List) 的支持，可以给每个用户分配不同的权限来控制权限。</span></span><br><span class="line"><span class="comment"># Redis ACL用户的定义格式如下:</span></span><br><span class="line"><span class="comment">#   user &lt;username&gt; ... acl rules ...</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For example:</span></span><br><span class="line"><span class="comment">#   user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 新连接使用特殊用户名“default”。</span></span><br><span class="line"><span class="comment"># 如果该用户具有“nopass”规则，那么新的连接将立即作为“默认”用户进行身份验证，而不需要通过AUTH命令提供任何密码。</span></span><br><span class="line"><span class="comment"># 否则，如果“默认”用户没有标记为“nopass”，则连接将在未验证的状态下启动，并将需要AUTH(或HELLO命令AUTH选项)才能进行身份验证并开始工作。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 基本上ACL规则是从左到右处理的。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ACL日志</span></span><br><span class="line"><span class="comment"># ACL日志跟踪与ACL相关的失败命令和认证事件。ACL日志用于排除被ACL阻塞的命令失败的故障。ACL日志存储在内存中。可以使用ACL LOG RESET回收内存。</span></span><br><span class="line"><span class="comment"># 定义下面ACL日志的最大条目长度。</span></span><br><span class="line"><span class="attr">acllog-max-len</span> <span class="string">128</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 使用外部ACL文件</span></span><br><span class="line"><span class="comment"># 不需要在此文件中配置用户，可以使用单独列出用户的文件。两种方法不能混合使用:</span></span><br><span class="line"><span class="comment"># 如果在这里配置用户，同时激活外部ACL文件，服务器将拒绝启动。</span></span><br><span class="line"><span class="comment"># 外部ACL用户文件的格式与redis.conf中用于描述用户的格式完全相同。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># aclfile /etc/redis/users.acl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 重要提示: 从Redis 6开始，“requirepass” 只是一个新的ACL系统之上的兼容层。选项效果将只是为默认用户“default”设置密码。</span></span><br><span class="line"><span class="comment"># 客户端仍然会像往常一样使用AUTH &lt;password&gt;进行身份验证，或者更明确地使用AUTH default &lt;password&gt;，如果他们遵循新协议:两者都可以工作。</span></span><br><span class="line"><span class="comment"># requirepass与aclfile选项和ACL LOAD命令不兼容，这将导致requirepass被忽略。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 默认情况下，新用户初始化具有限制性权限，通过等价于ACL规则'off resetkeys -@all'。</span></span><br><span class="line"><span class="comment"># 从Redis 6.2开始，也可以使用ACL规则管理对Pub/Sub通道的访问。默认的Pub/Sub通道权限如果新用户是由acl-pubsub-default配置指令控制的，该指令接受以下值之一:</span></span><br><span class="line"><span class="comment">#  - allchannels: 允许访问所有的Pub/Sub频道</span></span><br><span class="line"><span class="comment">#  - resetchannels: 撤销对所有发布/订阅频道的访问</span></span><br><span class="line"><span class="comment"># 从Redis 7.0开始，acl-pubsub-default默认为'resetchannels'权限。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># acl-pubsub-default resetchannels</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 命令重命名(弃用)。</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># WARNING: 尽可能避免使用此选项。相反，使用acl从默认用户中删除命令，只将它们放在您为管理目的而创建的某个管理用户中。</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 可以在共享环境中更改危险命令的名称。例如，CONFIG命令可能会被重命名为难以猜测的内容，以便它仍然对内部使用的工具可用，但对普通客户端不可用。</span></span><br><span class="line"><span class="comment"># 举例：</span></span><br><span class="line"><span class="comment"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span><br><span class="line"><span class="comment"># 也可以通过将命令重命名为空字符串来完全终止命令:</span></span><br><span class="line"><span class="comment"># rename-command CONFIG ""</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 请注意，更改登录到AOF文件或传输到副本的命令的名称可能会导致问题。</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="CLIENT：客户端">CLIENT：客户端</h2>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################### CLIENTS ####################################</span></span><br><span class="line"><span class="comment"># 设置客户端同时最大连接数。</span></span><br><span class="line"><span class="comment">#  默认情况下，这个限制被设置为10000个客户端，但是如果Redis服务器不能配置进程文件限制，以允许指定的限制，允许的最大客户端数量被设置为当前文件限制-32(因为Redis保留了一些文件描述符供内部使用)</span></span><br><span class="line"><span class="comment"># 一旦达到限制，Redis将关闭所有的新连接，发送一个错误'max number of clients reached'.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 重要说明: 当使用Redis集群时，最大连接数也与集群总线共享:集群中的每个节点将使用两个连接，一个传入连接，另一个传出连接。在非常大的集群的情况下，相应地调整限制是很重要的。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxclients 10000</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="MEMORY-MANAGEMENT：内存管理">MEMORY MANAGEMENT：内存管理</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################## MEMORY MANAGEMENT ################################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 将内存使用限制设置为指定的字节数。当达到内存限制时，Redis将尝试根据所选的清除策略(参见maxmemory-policy)删除键。</span></span><br><span class="line"><span class="comment"># 如果Redis不能根据策略删除键，或者如果策略设置为'noeviction'， Redis将开始回复会使用更多内存的命令，如SET, LPUSH等，并将继续回复只读命令，如GET。</span></span><br><span class="line"><span class="comment"># 当使用Redis作为LRU或LFU缓存，或为实例设置硬内存限制(使用'noeviction'策略)时，此选项通常很有用。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># MAXMEMORY策略:当达到MAXMEMORY时，Redis如何选择要删除的内容。您可以在以下行为中选择:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># volatile-lru -&gt; 使用近似的LRU驱逐，仅具有过期时间的KEY</span></span><br><span class="line"><span class="comment"># allkeys-lru -&gt; 使用近似的LRU驱逐任何键。</span></span><br><span class="line"><span class="comment"># volatile-lfu -&gt; 使用近似LFU驱逐LFU, 仅具有过期时间的KEY</span></span><br><span class="line"><span class="comment"># allkeys-lfu -&gt; 使用近似的LFU驱逐任何键</span></span><br><span class="line"><span class="comment"># volatile-random -&gt; 删除具有过期时间设置的随机KEY</span></span><br><span class="line"><span class="comment"># allkeys-random -&gt; 删除一个随机的任意KEY</span></span><br><span class="line"><span class="comment"># volatile-ttl -&gt; 使用最近的过期时间(小TTL)删除KEY</span></span><br><span class="line"><span class="comment"># noeviction -&gt; 不要清除任何东西，只是在写操作时返回一个错误。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LRU （Least Recently Used）：最近最少使用</span></span><br><span class="line"><span class="comment"># LFU （Least Frequently Used）：最不经常使用的</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LRU、LFU和volatile-ttl均采用近似随机化算法实现。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 注意:使用上述任何一种策略，当没有合适的键用于驱逐时，Redis将在需要更多内存的写操作时返回一个错误。</span></span><br><span class="line"><span class="comment"># 这些命令通常用于创建新KEY、添加数据或修改现有KEY。例如:SET、INCR、HSET、LPUSH、SUNIONSTORE、SORT(由于STORE参数)和EXEC(如果事务包含任何需要内存的命令)。</span></span><br><span class="line"><span class="comment"># 默认配置：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory-policy noeviction</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># LRU、LFU和最小TTL算法都不是精确算法，而是近似算法(为了节省内存)，因此您可以调整它的速度或精度。</span></span><br><span class="line"><span class="comment"># 默认情况下，Redis将检查五个键，并选择一个最近使用最少的键，您可以使用以下配置指令更改样本大小。默认值5可以产生足够好的结果。10非常接近真实的LRU，但消耗更多的CPU。3更快，但不是很准确</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory-samples 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 驱逐处理被设计为在默认设置下正常工作。</span></span><br><span class="line"><span class="comment"># 如果有一个异常大的写流量，这个值可能需要增加。降低这个值可能会降低延迟，但会影响清除处理的有效性</span></span><br><span class="line"><span class="comment">#   0 = minimum latency, 10 = default, 100 = process without regard to latency</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory-eviction-tenacity 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 从Redis 5开始，默认情况下副本将忽略其maxmemory设置(除非在故障转移后或手动将其提升为主内存)。</span></span><br><span class="line"><span class="comment"># 这意味着KEY的删除将仅由主服务器处理，将DEL命令发送到副本，作为主服务器中的KEY删除。</span></span><br><span class="line"><span class="comment"># 这种行为可以确保主副本和副本保持一致，这通常是你想要的，但是如果你的副本是可写的，或者你想让副本有一个不同的内存设置，并且你确定对副本执行的所有写入都是幂等的，那么你可以改变这个默认值(但一定要理解你在做什么)。</span></span><br><span class="line"><span class="comment"># 请注意，由于副本默认情况下不驱逐，因此它最终可能会使用比maxmemory设置的内存更多的内存(副本上的某些缓冲区可能更大，或者数据结构有时可能占用更多内存等等)。因此，请确保监视副本，并确保它们有足够的内存，在主服务器达到配置的maxmemory设置之前不会出现真正的内存不足情况。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># replica-ignore-maxmemory yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis以两种方式回收过期KEY:当这些KEY被发现过期时，在访问时，以及在后台，在所谓的“活动过期KEY”中回收。KEY空间被缓慢地交互式地扫描，寻找要回收的过期KEY，这样就有可能释放过期KEY的内存，并且在短时间内不会再次访问这些KEY。</span></span><br><span class="line"><span class="comment"># 过期周期的默认工作将尽量避免在内存中保留超过10%的过期KEY，并尽量避免消耗总内存的25%以上，并增加系统的延迟。</span></span><br><span class="line"><span class="comment"># 然而，可以将通常设置为“1”的过期“effort”增加到更大的值，直到值“10”。</span></span><br><span class="line"><span class="comment"># 在其最大值时，系统将使用更多的CPU，更长的周期(技术上可能会引入更多的延迟)，并且系统中仍然存在的已经过期的KEY将更少。这是内存、CPU和延迟之间的权衡。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># active-expire-effort 1</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="LAZY-FREEING">LAZY FREEING</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################# LAZY FREEING ####################################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis有两个删除键的原语。一个称为DEL，是对对象的阻塞删除。这意味着服务器停止处理新命令，以便以同步方式回收与对象关联的所有内存。</span></span><br><span class="line"><span class="comment"># 如果删除的键与一个小对象相关联，执行DEL命令所需的时间非常小，与Redis中的大多数其他O(1)或O(log_N)命令相当。</span></span><br><span class="line"><span class="comment"># 但是，如果键与包含数百万个元素的聚合值相关联，则服务器可能阻塞很长时间(甚至几秒钟)以完成操作。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 出于上述原因，Redis还提供了非阻塞删除原语，如UNLINK(非阻塞DEL)和FLUSHALL和FLUSHDB命令的ASYNC选项，以便在后台回收内存。这些命令在常数时间内执行。另一个线程将在后台以最快的速度递增地释放对象。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># FLUSHALL和FLUSHDB的DEL、UNLINK和ASYNC选项由用户控制.</span></span><br><span class="line"><span class="comment"># 什么时候使用一种或另一种是好主意，这取决于应用程序的设计。</span></span><br><span class="line"><span class="comment"># 然而，Redis服务器有时不得不删除键或刷新整个数据库作为其他操作的副作用。</span></span><br><span class="line"><span class="comment"># 具体来说，Redis在以下场景中独立于用户调用删除对象:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) 在清除时，由于maxmemory和maxmemory策略配置，为了为新数据腾出空间，不会超过指定的内存限制.</span></span><br><span class="line"><span class="comment"># 2) 因为过期:当一个键具有相关的生存时间(参见expire命令)时，必须从内存中删除.</span></span><br><span class="line"><span class="comment"># 3) 因为将数据存储在可能已经存在的键上的命令的副作用。</span></span><br><span class="line">     <span class="attr">例如，RENAME命令，当它被另一个KEY替换时，可能会删除旧的KEY内容。类似地，带有STORE选项的SUNIONSTORE或SORT可以删除现有的键。</span></span><br><span class="line">     <span class="attr">SET命令本身删除指定键的任何旧内容，以便用指定的字符串替换它.</span></span><br><span class="line"><span class="comment"># 4) 在复制过程中，当一个副本与它的主数据库执行完全重新同步时，整个数据库的内容将被删除，以便加载刚刚传输的RDB文件</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 在上述所有情况下，默认是以阻塞方式删除对象，就像调用DEL一样。但是，您可以使用以下配置指令专门配置每种情况，以便像调用UNLINK一样以非阻塞的方式释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="attr">lazyfree-lazy-eviction</span> <span class="string">no</span></span><br><span class="line"><span class="attr">lazyfree-lazy-expire</span> <span class="string">no</span></span><br><span class="line"><span class="attr">lazyfree-lazy-server-del</span> <span class="string">no</span></span><br><span class="line"><span class="attr">replica-lazy-flush</span> <span class="string">no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当用户调用DEL代码替换为UNLINK调用是不容易的情况下，修改DEL命令的默认行为，完全像UNLINK，使用以下配置指令:</span></span><br><span class="line"><span class="attr">lazyfree-lazy-user-del</span> <span class="string">no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># FLUSHDB, FLUSHALL, SCRIPT FLUSH and FUNCTION FLUSH 同时支持异步和同步删除, 可以通过将[SYNC|ASYNC]标志传递到命令中来控制。</span></span><br><span class="line"><span class="comment"># 当两个标志都没有传递时，该指令将用于确定是否应该异步删除数据。</span></span><br><span class="line"><span class="attr">lazyfree-lazy-user-flush</span> <span class="string">no</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="THREADED-I-O">THREADED I/O</h2>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ THREADED I/O ：慢I/O访问线程操作 #################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis主要是单线程的，但是也有一些线程操作，如UNLINK，慢I/O访问和其他在边线程上执行的事情。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 现在也可以在不同的I/O线程中处理Redis客户端的套接字读写。</span></span><br><span class="line"><span class="comment"># 由于写的很慢，通常Redis用户使用流水线来加快每个核的性能，并生成多个实例来扩展。使用I/O线程，可以轻松地将Redis加速两倍，而无需诉诸于流水线或实例分片。</span></span><br><span class="line"><span class="comment"># 默认情况下线程是禁用的，我们建议只在至少有4个或更多内核的机器上启用它，至少留下一个备用内核。</span></span><br><span class="line"><span class="comment"># 使用超过8个线程不太可能有太大帮助。我们也建议只有当你真的有性能问题时才使用线程I/O，因为Redis实例能够使用相当大比例的CPU时间，否则使用这个特性没有任何意义。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 例如，如果你有一个四核CPU，尝试使用2或3个I/O线程，如果你有一个8核，尝试使用6个线程。为了启用I/O线程，使用以下配置指令:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># io-threads 4</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 将io-threads设置为1将会像往常一样使用主线程。当I/O线程被启用时，我们只使用线程进行写操作，即执行write(2)系统调用并将客户端缓冲区传输到套接字。</span></span><br><span class="line"><span class="comment"># 然而，也可以使用以下配置指令启用读取线程和协议解析，将其设置为yes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># io-threads-do-reads no</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 通常，线程读取没有太大帮助。</span></span><br><span class="line"><span class="comment"># NOTE 1: 这个配置指令不能在运行时通过CONFIG SET修改。此外，当启用SSL时，此特性目前无法工作。</span></span><br><span class="line"><span class="comment"># NOTE 2:如果你想使用red -benchmark测试Redis的加速，确保你也在线程模式下运行基准测试本身，使用——threads选项来匹配Redis线程的数量，否则你将无法注意到这些改进。</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="KERNEL-OOM-CONTROL">KERNEL OOM CONTROL</h2>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################ KERNEL OOM CONTROL：内核oom控制 ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Linux上，可以提示内核OOM杀手在内存不足时应该首先杀死哪些进程。</span></span><br><span class="line"><span class="comment"># 启用这个特性可以使Redis主动控制所有进程的oom_score_adj值，这取决于它们的角色。</span></span><br><span class="line"><span class="comment"># 默认分数将尝试在所有其他进程之前杀死后台子进程，并在主进程之前杀死副本。</span></span><br><span class="line"><span class="comment"># Redis支持以下选项:</span></span><br><span class="line"><span class="comment"># - no:       不要更改oom-score-adj(默认值)。</span></span><br><span class="line"><span class="comment"># - yes:      “相对”的别名见下文。</span></span><br><span class="line"><span class="comment"># - absolute: om-score-adj- Values中的值被写入内核。</span></span><br><span class="line"><span class="comment">#- relative:  这些值在服务器启动时相对于oom_score_adj的初始值使用，然后被限制在-1000到1000的范围内。因为初始值通常为0，所以它们通常会与绝对值匹配。</span></span><br><span class="line">oom-score-adj no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当使用oom-score-adj时，该指令控制主进程、副本进程和后台子进程的特定值。数值范围为-2000到2000(越高意味着越有可能被杀死)。</span></span><br><span class="line"><span class="comment"># 没有特权的进程(不是根进程，并且没有CAP_SYS_RESOURCE功能)可以自由地增加其值，但不能将其降低到初始设置以下。</span></span><br><span class="line"><span class="comment"># 这意味着将oom-score-adj设置为“相对”，并将oom-score-adj-values设置为正值总是会成功。</span></span><br><span class="line">oom-score-adj-values 0 200 800</span><br></pre></td></tr></tbody></table></figure>
<h2 id="KERNEL-transparent-hugepage-CONTROL">KERNEL transparent hugepage CONTROL</h2>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################### KERNEL transparent hugepage CONTROL ###################### </span></span><br><span class="line"><span class="comment"># 通常内核的透明大页面控件设置为“madvise”或者默认为“never”(/sys/kernel/mm/transparent_hugepage/enabled)，这样，此配置无效。</span></span><br><span class="line"><span class="comment"># 在将其设置为“always”的系统中，Redis将为了Redis进程尝试禁用它，为了避免延迟问题（特别是fork(2)和CoW的延迟问题）。</span></span><br><span class="line"><span class="comment"># 如果出于某种原因，您更喜欢保持启用，您可以将此配置设置为“no”，并将内核全局设置为“always”。</span></span><br><span class="line">disable-thp <span class="built_in">yes</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="APPEND-ONLY-MODE：追加模式">APPEND ONLY MODE：追加模式</h2>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，Redis会异步将数据集转储到磁盘上。这种模式在许多应用程序中已经足够好了，但是Redis进程的问题或停电可能会导致几分钟的写入丢失(取决于配置的保存点)。</span></span><br><span class="line"><span class="comment"># 仅追加文件是另一种持久性模式，它提供了更好的持久性。</span></span><br><span class="line"><span class="comment"># 例如，使用默认的数据fsync策略(参见后面的配置文件)，Redis可以在一个意外事件中丢失一秒钟的写操作内容（比如服务器断电，或者如果Redis进程本身发生了一些错误），但Reids程序仍然正常运行。</span></span><br><span class="line"><span class="comment"># AOF和RDB持久性可以同时启用，没有任何问题.</span></span><br><span class="line"><span class="comment"># 如果启动时启用AOF, Redis将加载AOF，这是具有更好的持久性保证的文件。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please check https://redis.io/topics/persistence for more information.</span></span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅附加文件的基本名称</span></span><br><span class="line"><span class="comment"># Redis 7和更新版本使用一组只能追加的文件来持久化数据集和应用于它的更改。使用的文件有两种基本类型:</span></span><br><span class="line"><span class="comment"># - 基本文件，它是表示创建文件时数据集完整状态的快照。 基本文件的形式可以是RDB (binary serialized：二进制序列化) or AOF (textual commands：文本命令).</span></span><br><span class="line"><span class="comment"># - 增量文件，其中包含在前一个文件之后应用于数据集的其他命令。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 此外，清单文件用于跟踪文件及其创建和应用它们的顺序。</span></span><br><span class="line"><span class="comment"># Append-only文件的文件名是由Redis按照特定的模式创建的。文件名的前缀基于“appendfilename”配置参数，后面跟着关于序列和类型的附加信息。</span></span><br><span class="line"><span class="comment"># 例如，如果appendfilename设置为appendonly.aof，可以导出以下文件名:</span></span><br><span class="line"><span class="comment"># - appendonly.aof.1.base.rdb （基本文件）</span></span><br><span class="line"><span class="comment"># - appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof （增量文件）</span></span><br><span class="line"><span class="comment"># - appendonly.aof.manifest （清单文件）</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了方便起见，Redis将所有持久的仅追加文件存储在专用目录中。目录的名称由appenddirname配置参数决定。</span></span><br><span class="line">appenddirname <span class="string">"appendonlydir"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fsync()调用告诉操作系统实际将数据写入磁盘，而不是在输出缓冲区中等待更多数据。</span></span><br><span class="line"><span class="comment"># 有些操作系统真的会在磁盘上刷新数据，其他操作系统会尽快尝试这样做。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis支持三种不同的模式:</span></span><br><span class="line"><span class="comment"># - no: 不要fsync，让操作系统在需要的时候刷新数据。快。</span></span><br><span class="line"><span class="comment"># - always: 每次写入仅追加日志后进行fsync。慢，但安全。</span></span><br><span class="line"><span class="comment"># - everysec: 每秒只能进行一次fsync。妥协。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 默认是“everysec”，因为这通常是速度和数据安全之间的正确妥协。</span></span><br><span class="line"><span class="comment"># 这取决于您是否可以将其放宽为“no”，从而让操作系统在需要时刷新输出缓冲区，以获得更好的性能(但如果您可以接受一些数据丢失的想法，请考虑默认的持久性模式快照)，或者相反，使用“always”，它非常慢，但比everysec更安全一些。具体内容参考： http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果不确定选择哪种，使用默认的“everysec”。</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当AOF的fsync策略设置为always或everysec时，一个后台保存进程(一个后台保存或AOF日志后台重写)正在对磁盘执行大量的I/O，在一些Linux配置中，Redis可能会在fsync()调用上阻塞太长时间。</span></span><br><span class="line"><span class="comment"># 请注意，目前还没有修复这个问题，因为即使在不同的线程中执行fsync也会阻塞同步写(2)调用。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 为了缓解这个问题，可以使用以下选项来防止在BGSAVE或BGREWRITEAOF正在进行时在主进程中调用fsync()。</span></span><br><span class="line"><span class="comment"># 这意味着当另一个子文件正在保存时，Redis的持久性与“appendfsync no”相同。</span></span><br><span class="line"><span class="comment"># 实际上，这意味着在最坏的情况下(使用默认的Linux设置)，可能会丢失长达30秒的日志。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果你有延迟问题，把这个改为“是”。否则，从耐久性的角度来看，这是最安全的选择。</span></span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动重写append only文件。</span></span><br><span class="line"><span class="comment"># 当AOF日志大小增长到指定的百分比时，Redis能够隐式地自动重写日志文件，调用BGREWRITEAOF。</span></span><br><span class="line"><span class="comment"># 它是这样工作的: Redis记住最近一次重写后AOF文件的大小(如果重启后没有发生重写，则使用启动时AOF的大小)。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 此基本大小与当前大小进行比较. 如果当前大小大于指定的百分比，则会触发重写. 此外，您还需要指定要重写的AOF文件的最小大小, 这对于避免重写AOF文件很有用，即使达到了百分比增长，但它仍然非常小。</span></span><br><span class="line"><span class="comment"># 指定一个百分数为零以禁用自动AOF重写功能。</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Redis启动过程中，当AOF数据被加载回内存时，可能会发现AOF文件在结束时被截断。当Redis运行的系统崩溃时，可能会发生这种情况, 特别是当ext4文件系统在没有data=ordered选项的情况下被挂载时(然而，当Redis本身崩溃或中止，但操作系统仍然正常工作时，这就不会发生)。</span></span><br><span class="line"><span class="comment"># 当这种情况发生时，Redis可以退出错误，或者加载尽可能多的数据(现在的默认值)，并在发现AOF文件在结束时被截断时启动。以下选项控制此行为。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果aof-load-truncated设置为yes，则加载一个截断的AOF文件，并且Redis服务器开始发送日志来通知用户该事件。</span></span><br><span class="line"><span class="comment"># 否则，如果该选项被设置为no，服务器将终止并报错并拒绝启动。当该选项设置为no时，用户需要在重新启动服务器之前使用“redis-check-aof”实用程序修复AOF文件。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 注意，如果AOF文件在中间被发现损坏，服务器仍然会报错退出。这个选项只适用于当Redis试图从AOF文件读取更多的数据，但没有足够的字节将被发现。</span></span><br><span class="line">aof-load-truncated <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis可以创建RDB或AOF格式的只能追加的基本文件. 使用RDB格式总是更快更有效，仅出于向后兼容的目的才支持禁用RDB格式。</span></span><br><span class="line">aof-use-rdb-preamble <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis支持在AOF中记录时间戳注释，以支持从特定时间点恢复数据。但是，使用此功能会以一种可能与现有AOF解析器不兼容的方式更改AOF格式。</span></span><br><span class="line">aof-timestamp-enabled no</span><br></pre></td></tr></tbody></table></figure>
<h2 id="SHUTDOWN">SHUTDOWN</h2>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ SHUTDOWN #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭时等待副本的最大时间，以秒为单位。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 在关闭期间，宽限期允许任何滞后的副本在主复制存在之前赶上最新的复制偏移量。这段时间可以防止数据丢失，特别是对于没有配置磁盘备份的部署。</span></span><br><span class="line"><span class="comment"># “shutdown-timeout”值是宽限期的持续时间，单位为秒。它只适用于实例有副本的情况。如果要禁用该特性，请将该值设置为0。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># shutdown-timeout 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当Redis接收到SIGINT（中断信号：interrupt）或SIGTERM（终止信号：terminal）时，启动关机，默认情况下，如果配置了保存点，则在阻塞操作中将RDB快照写入磁盘。</span></span><br><span class="line"><span class="comment"># 用于信号关闭的选项可以包括以下值:</span></span><br><span class="line"><span class="comment"># default:  仅当配置保存点时保存RDB快照。等待滞后的副本赶上。</span></span><br><span class="line"><span class="comment"># save:     强制数据库保存操作，即使没有配置保存点。</span></span><br><span class="line"><span class="comment"># nosave:   拒绝数据库保存操作，即使配置了一个或多个保存点。</span></span><br><span class="line"><span class="comment"># now:      跳过等待滞后的副本。</span></span><br><span class="line"><span class="comment"># force:    忽略任何通常会阻止服务器退出的错误。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 只要“save”和“nosave”不同时设置，就允许任何值的组合。例如: "nosave force now"</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># shutdown-on-sigint default</span></span><br><span class="line"><span class="comment"># shutdown-on-sigterm default</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="NON-DETERMINISTIC-LONG-BLOCKING-COMMANDS">NON-DETERMINISTIC LONG BLOCKING COMMANDS</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################ NON-DETERMINISTIC LONG BLOCKING COMMANDS： 不确定的长阻塞命令 #####################</span></span><br><span class="line"><span class="comment"># 在Redis开始处理或拒绝其他客户端之前，EVAL脚本、函数和某些情况下模块命令的最大时间(以毫秒为单位)。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果达到最大执行时间，Redis将开始回复大多数命令与BUSY错误。</span></span><br><span class="line"><span class="comment"># 在这种状态下，Redis只允许执行少量命令。例如，SCRIPT KILL, FUNCTION KILL, SHUTDOWN NOSAVE，可能还有一些模块特定的'allow-busy'命令。</span></span><br><span class="line"><span class="comment"># SCRIPT KILL和FUNCTION KILL只能停止尚未调用任何写命令的脚本，因此，当用户不想等待脚本的自然终止时，如果脚本已经发出了写命令，则SHUTDOWN NOSAVE可能是停止服务器的唯一方法</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 缺省值是5秒。可以将其设置为0或负值来禁用此机制(不间断执行)。注意，在过去这个配置有一个不同的名字，现在是一个别名，所以这两个都是一样的:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># lua-time-limit 5000</span></span><br><span class="line"><span class="comment"># busy-reply-threshold 5000</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="REDIS-CLUSTER：集群配置">REDIS CLUSTER：集群配置</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 普通的Redis实例不能成为Redis集群的一部分，只有作为集群节点启动的节点可以。</span></span><br><span class="line"><span class="comment"># 为了启动一个Redis实例作为一个集群节点，启用集群支持取消注释如下:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-enabled yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 每个集群节点都有一个集群配置文件。此文件不建议手动编辑。它由Redis节点创建和更新。</span></span><br><span class="line"><span class="comment"># 每个Redis集群节点都需要不同的集群配置文件。</span></span><br><span class="line"><span class="comment"># 确保在同一系统中运行的实例没有重叠的集群配置文件名。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-config-file nodes-6379.conf</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 集群节点超时时间是指一个节点必须不可达的毫秒数，才会被认为处于故障状态。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-node-timeout 15000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 集群端口是集群总线侦听入站连接的端口。</span></span><br><span class="line"><span class="comment"># 当设置为默认值0时，绑定到命令端口+10000。设置此值要求您在执行cluster meet时指定集群总线端口。</span></span><br><span class="line"><span class="comment"># cluster-port 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 如果发生故障的主服务器的数据看起来太旧，它的副本将避免启动故障转移。</span></span><br><span class="line"><span class="comment"># 对于副本来说，没有简单的方法可以准确测量其“数据年龄”，因此执行以下两个检查:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) 如果有多个副本能够进行故障转移，它们将交换消息，以便尝试为副本提供最佳复制偏移(处理来自主服务器的更多数据)。</span></span><br><span class="line"><span class="comment">#     副本将尝试通过偏移量获得它们的排名，并将与它们的排名成比例的延迟应用于故障转移的开始。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2) 每个副本都计算与主节点最后一次交互的时间. 这可能是接收到的最后一个ping或命令 (如果主服务器仍然处于“已连接”状态), 或者与主服务器断开连接后经过的时间(如果复制链路当前断开)。</span></span><br><span class="line"><span class="comment">#     如果最后一次交互太旧，副本将根本不会尝试故障转移。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 第二点可由用户调整。具体来说，如果自上次与主服务器交互以来，所消耗的时间大于以下情况，副本将不执行故障转移:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   (node-timeout * cluster-replica-validity-factor) + repl-ping-replica-period</span></span><br><span class="line"><span class="comment">#   (节点掉线时间 * 集群副本有效性因子) + 循环PING访问的周期时间</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 因此，例如，如果node-timeout是30秒，cluster-replica-validity-factor是10，并且假设默认的repo -ping-replica-period是10秒，那么如果它不能与主服务器对话超过310秒，它就不会尝试故障转移。</span></span><br><span class="line"><span class="comment"># 一个大的cluster-replica-validity-factor可能会允许带有太旧数据的副本故障转移到主节点，而一个太小的值可能会阻止集群完全能够选择一个副本。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 为了获得最大可用性，可以将cluster-replica-validity-factor设置为0，这意味着副本将始终尝试故障转移到主服务器，而不管它们最后一次与主服务器交互是什么时候。</span></span><br><span class="line"><span class="comment"># (然而，他们总是尝试应用一个与他们的偏移等级成比例的延迟)。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 0是唯一能够保证当所有分区恢复时，集群始终能够继续运行的值。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-replica-validity-factor 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 集群副本能够迁移到孤立的主服务器，即没有工作副本的主服务器。</span></span><br><span class="line"><span class="comment"># 这提高了集群抵抗故障的能力，否则，如果没有工作副本，孤立的主节点就不能在故障发生时被故障转移。但是，只有当它们的旧主人至少还有一定数量的其他工作副本时，副本才会迁移到孤立的主人。这个数字就是“迁移障碍”。迁移障碍为1意味着一个副本只有在它的主副本至少有一个其他工作副本时才会迁移，以此类推。它通常反映集群中每个主节点所需的副本数量。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 默认值是1(只有当它们的主副本保留至少一个副本时，副本才会迁移)。</span></span><br><span class="line"><span class="comment"># 要禁用迁移，只需将其设置为一个非常大的值或将cluster-allow-replica-migration设置为“no”。可以设置0值，但仅在调试时有用，在生产中是危险的。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-migration-barrier 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 关闭此选项允许使用较少的自动集群配置。它既禁止迁移到孤儿的主节点，也禁止从空的主节点迁移。默认是'yes'(允许自动迁移)。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-allow-replica-migration yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 默认情况下，如果Redis集群节点检测到至少有一个哈希槽未被发现(没有可用的节点正在为它服务)，它们将停止接受查询。</span></span><br><span class="line"><span class="comment"># 这样，如果集群部分关闭(例如，一系列哈希槽不再被覆盖)，所有集群最终都将不可用。一旦所有插槽被再次覆盖，它就自动返回可用。</span></span><br><span class="line"><span class="comment"># 然而，有时您希望正在工作的集群子集继续接受对仍然覆盖的键空间部分的查询。为此，只需将cluster-require-full-coverage选项设置为no。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-require-full-coverage yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当此选项设置为yes时，将防止副本在主服务器故障时试图将其主服务器故障转移。但是，如果强制执行，副本仍然可以执行手动故障转移。</span></span><br><span class="line"><span class="comment"># 这在不同的场景中都很有用，特别是在多个数据中心操作的情况下，如果不是在DC完全故障的情况下，我们希望其中一方永远不会被提升。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-replica-no-failover no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当该选项设置为yes时，允许节点在集群处于down状态时服务读流量，只要节点认为它拥有插槽。</span></span><br><span class="line"><span class="comment"># 这在两种情况下是有用的</span></span><br><span class="line"><span class="comment"># 1. 当应用程序在节点故障或网络分区期间不需要数据一致性时。例如缓存数据。只要节点拥有数据，它就应该能够为其提供服务。</span></span><br><span class="line"><span class="comment"># 2. 此用例用于集群不满足推荐的三个分片，但又希望启用集群模式并在以后扩展的配置。</span></span><br><span class="line"><span class="comment">#    如果没有设置这个选项，1或2个分片配置中的主中断将导致整个集群的读/写中断，如果设置了这个选项，则只会导致写中断。如果没有指定的master，插槽的所有权将不会自动改变。</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># cluster-allow-reads-when-down no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当该选项设置为yes时，允许节点在集群处于down状态时服务发布分片流量，只要节点认为它拥有插槽。</span></span><br><span class="line"><span class="comment"># 如果应用程序即使在集群全局稳定状态不正常的情况下也想使用pubsub特性，那么这是很有用的。如果应用程序想要确保只有一个分片服务于给定的通道，这个特性应该保持为yes。</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># cluster-allow-pubsubshard-when-down yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置每个集群总线连接的发送字节缓冲区的内存使用限制，超过限制缓冲区将被清空。</span></span><br><span class="line"><span class="comment"># 这主要是为了防止发送缓冲区在通往慢速连接的链路上无限制地增长(例如PubSub消息被堆积起来)。默认情况下禁用此限制。</span></span><br><span class="line"><span class="comment"># 而当INFO中的'mem_cluster_links' 和/或 'CLUSTER LINKS ' 命令回显中的'send-buffer-allocated'（已分配的发送缓冲区） 项不断增加时，启用该限制。</span></span><br><span class="line"><span class="comment"># 建议设置1gb的最小限制，这样集群链接缓冲区默认情况下至少可以容纳一条PubSub消息。(client-query-buffer-limit默认值为1gb。见 ADVANCED CONFIG)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-link-sendbuf-limit 0</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 集群可以使用此配置配置其宣布的主机名。</span></span><br><span class="line"><span class="comment"># 对于需要使用TLS服务器名称指示(SNI)或处理基于DNS的路由的应用程序，这是一个常见的用例。</span></span><br><span class="line"><span class="comment"># 默认情况下，该值仅在CLUSTER SLOTS命令中显示为额外的元数据，但可以使用'cluster-preferred-endpoint-type' 更改。该值通过集群总线传递给所有节点，将其设置为空字符串将删除主机名并传播删除。</span></span><br><span class="line"><span class="comment"># cluster-announce-hostname ""</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 集群可以通告客户端如何使用它们的IP地址连接到它们，用户定义主机名，或者声明它们没有端点。</span></span><br><span class="line"><span class="comment"># 通过使用 cluster-preferred-end -type 配置值'ip'、'hostname'或'unknown-endpoint'来设置哪个端点显示为首选端点。</span></span><br><span class="line"><span class="comment"># 这个值控制端点如何返回MOVED/ASKING请求以及CLUSTER插槽的第一个字段。</span></span><br><span class="line"><span class="comment"># 如果首选端点类型设置为主机名，但没有设置宣布的主机名，则'?’将被返回。</span></span><br><span class="line"><span class="comment"># 当集群宣称自己具有未知端点时，这表明服务器不知道客户机如何到达集群。这可能发生在某些网络情况下，其中有多个可能的路由到节点，并且服务器不知道客户端选择了哪一个。</span></span><br><span class="line"><span class="comment"># 在这种情况下，服务器期望客户端通过发出最后一个请求时使用的相同端点进行联系，但是使用响应中提供的端口。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-preferred-endpoint-type ip</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># In order to setup your cluster make sure to read the documentation</span></span><br><span class="line"><span class="comment"># available at https://redis.io web site.</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="CLUSTER-DOCKER-NAT-support：集群配置">CLUSTER DOCKER/NAT support：集群配置</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################## CLUSTER DOCKER/NAT support：容器内集群配置  ########################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 在某些部署中，无法检测到Redis集群节点，因为地址是NAT-ted或因为端口被转发(典型的情况是Docker和其他容器)。</span></span><br><span class="line"><span class="comment"># 为了使Redis集群在Docker容器这样的环境中工作，需要一个静态配置，其中每个节点都知道自己的公共地址。</span></span><br><span class="line"><span class="comment"># 以下四个选项用于此范围，分别是:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># * cluster-announce-ip</span></span><br><span class="line"><span class="comment"># * cluster-announce-port</span></span><br><span class="line"><span class="comment"># * cluster-announce-tls-port</span></span><br><span class="line"><span class="comment"># * cluster-announce-bus-port</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 每个配置都指示节点有关其地址、客户端端口(用于不带TLS和带TLS的连接)和集群消息总线端口。</span></span><br><span class="line"><span class="comment"># 然后在总线包的报头中发布该信息，以便其他节点能够正确地映射发布该信息的节点的地址。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 如果“tls-cluster”设置为“yes”，而“cluster-announce-tls-port”被省略或设置为“0”，则“cluster-announce-port”指的是TLS端口。</span></span><br><span class="line"><span class="comment"># 另请注意，如果“tls-cluster”设置为“no“（默认），则”cluster-announce-tls-port”无效。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果不使用上述选项，将使用正常的Redis集群自动检测。</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 注意，在重新映射时，总线端口可能不在客户端端口+10000 的固定偏移量上，因此您可以根据重新映射的方式指定任何端口和总线端口。</span></span><br><span class="line"><span class="comment"># 如果没有设置总线端口，将像往常一样使用固定偏移量10000</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 例如:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-announce-ip 10.1.1.5</span></span><br><span class="line"><span class="comment"># cluster-announce-tls-port 6379</span></span><br><span class="line"><span class="comment"># cluster-announce-port 0</span></span><br><span class="line"><span class="comment"># cluster-announce-bus-port 6380</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="SLOW-LOG：慢查询日志">SLOW  LOG：慢查询日志</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################## SLOW LOG ：满查询日志###################################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis Slow Log 是一个记录超过指定执行时间的查询的系统。执行时间不包括I/O操作，如与客户端交谈、发送应答等，而只包括实际执行命令所需的时间(这是命令执行的唯一阶段，线程被阻塞，不能同时服务其他请求)。</span></span><br><span class="line"><span class="comment"># 您可以使用两个参数配置慢速日志: 一个参数告诉Redis要超过多少微秒的执行时间才能记录命令，另一个参数是慢速日志的长度。</span></span><br><span class="line"><span class="comment"># 当记录一个新命令时，最早的命令将从记录的命令队列中删除。</span></span><br><span class="line"><span class="comment"># 下面的时间以微秒表示，因此1000000相当于一秒。请注意，负数禁用慢日志，而值为零则强制记录每个命令。</span></span><br><span class="line"><span class="attr">slowlog-log-slower-than</span> <span class="string">10000</span></span><br><span class="line"><span class="comment"># 这个长度没有限制。只是要注意它会消耗内存。</span></span><br><span class="line"><span class="comment"># 可以使用SLOWLOG RESET回收慢日志使用的内存。</span></span><br><span class="line"><span class="attr">slowlog-max-len</span> <span class="string">128</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="LATENCY-MONITOR：延迟监控">LATENCY MONITOR：延迟监控</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ LATENCY MONITOR：延迟监控 ##############################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># The Redis latency monitoring subsystem samples different operations at runtime in order to collect data related to possible sources of latency of a Redis instance.</span></span><br><span class="line"><span class="comment"># Redis延迟监控子系统在运行时对不同的操作进行抽样，以收集与Redis实例的可能延迟来源相关的数据。</span></span><br><span class="line"><span class="comment"># 通过LATENCY命令，用户可以打印图表并获得报告。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 系统只记录执行时间等于或大于通过延迟监视器阈值配置指令指定的毫秒数的操作。</span></span><br><span class="line"><span class="comment"># 当其值设置为0时，将关闭延迟监视器。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 默认情况下，延迟监视是禁用的，因为如果您没有延迟问题，则通常不需要它，并且收集数据会对性能产生影响，尽管影响很小，但可以在大负载下测量。</span></span><br><span class="line"><span class="comment"># 如果需要，可以在运行时使用命令"CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;" 轻松启用延迟监控。</span></span><br><span class="line"><span class="attr">latency-monitor-threshold</span> <span class="string">0</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="LATENCY-TRACKING：延迟追踪">LATENCY TRACKING：延迟追踪</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ LATENCY TRACKING ##############################</span></span><br><span class="line"><span class="comment"># Redis扩展延迟监控跟踪每个命令的延迟，并通过“INFO latencystats”命令导出百分比分布，并通过LATENCY命令导出累积延迟分布(直方图)。</span></span><br><span class="line"><span class="comment"># 默认情况下，扩展延迟监视是启用的，因为跟踪命令延迟的开销非常小。</span></span><br><span class="line"><span class="comment"># latency-tracking yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 缺省情况下，通过INFO latencystats命令导出的延迟百分比为p50、p99和p999。</span></span><br><span class="line"><span class="comment"># latency-tracking-info-percentiles 50 99 99.9</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="EVENT-NOTIFICATION：事件通知">EVENT NOTIFICATION：事件通知</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################# EVENT NOTIFICATION ##############################</span></span><br><span class="line"><span class="comment"># Redis可以通知Pub/Sub客户端在key space中发生的事件。该特性在https://redis.io/topics/notifications上有文档说明</span></span><br><span class="line"><span class="comment"># 例如，如果“notify-keyspace-events”通知被启用，并且客户端对存储在数据库0中的KEY“foo”执行DEL操作，则两条消息将通过Pub/Sub发布:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># PUBLISH __keyspace@0__:foo del</span></span><br><span class="line"><span class="comment"># PUBLISH __keyevent@0__:del foo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 可以选择Redis将在一组类中通知的事件。每个类别都由一个单一的字符来标识:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="comment">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="comment">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span></span><br><span class="line"><span class="comment">#  $     String commands</span></span><br><span class="line"><span class="comment">#  l     List commands</span></span><br><span class="line"><span class="comment">#  s     Set commands</span></span><br><span class="line"><span class="comment">#  h     Hash commands</span></span><br><span class="line"><span class="comment">#  z     Sorted set commands</span></span><br><span class="line"><span class="comment">#  x     Expired events (events generated every time a key expires)</span></span><br><span class="line"><span class="comment">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span></span><br><span class="line"><span class="comment">#  n     New key events (<span class="doctag">Note:</span> not included in the 'A' class)</span></span><br><span class="line"><span class="comment">#  t     Stream commands</span></span><br><span class="line"><span class="comment">#  d     Module key type events</span></span><br><span class="line"><span class="comment">#  m     Key-miss events (<span class="doctag">Note:</span> It is not included in the 'A' class)</span></span><br><span class="line"><span class="comment">#  A     Alias for g$lshzxetd, so that the "AKE" string means all the events</span></span><br><span class="line"><span class="comment">#        (Except key-miss events which are excluded from 'A' due to their</span></span><br><span class="line"><span class="comment">#         unique nature).</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#  “notify-keyspace-events” 以一个由零个或多个字符组成的字符串作为参数。空字符串表示禁用通知。</span></span><br><span class="line"><span class="comment">#  示例1:要启用列表和通用事件，从事件名称的角度来看，使用: notify-keyspace-events Elg</span></span><br><span class="line"><span class="comment">#  示例2: 获取订阅通道名的过期KEY的流 __keyevent@0__:expired 使用: notify-keyspace-events Ex</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 默认情况下，所有通知都是禁用的，因为大多数用户不需要这个功能，而且这个功能有一些开销。注意，如果不指定K或E中的至少一个，则不会传递任何事件。</span></span><br><span class="line"><span class="attr">notify-keyspace-events</span> <span class="string">""</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="ADVANCED-CONFIG">ADVANCED CONFIG</h2>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################### ADVANCED CONFIG ###############################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当哈希表有少量条目且最大条目不超过给定阈值时，使用内存效率高的数据结构进行编码。</span></span><br><span class="line"><span class="comment"># 可以使用以下指令配置这些阈值。</span></span><br><span class="line"><span class="attr">hash-max-listpack-entries</span> <span class="string">512</span></span><br><span class="line"><span class="attr">hash-max-listpack-value</span> <span class="string">64</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 列表还以一种特殊的方式进行编码，以节省大量空间。</span></span><br><span class="line"><span class="comment"># 每个内部列表节点允许的条目数可以指定为固定的最大大小或最大元素数。</span></span><br><span class="line"><span class="comment"># 对于固定的最大大小，使用-5到-1，这意味着:</span></span><br><span class="line"><span class="comment"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span></span><br><span class="line"><span class="comment"># -4: max size: 32 Kb  &lt;-- not recommended</span></span><br><span class="line"><span class="comment"># -3: max size: 16 Kb  &lt;-- probably not recommended</span></span><br><span class="line"><span class="comment"># -2: max size: 8 Kb   &lt;-- good</span></span><br><span class="line"><span class="comment"># -1: max size: 4 Kb   &lt;-- good</span></span><br><span class="line"><span class="comment"># 正数意味着每个列表节点存储的元素数量不超过这个数字</span></span><br><span class="line"><span class="comment"># 最高性能选项通常是-2 (8 Kb大小)或-1 (4 Kb大小)，但如果您的用例是唯一的，请根据需要调整设置。</span></span><br><span class="line"><span class="attr">list-max-listpack-size</span> <span class="string">-2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 列表也可以被压缩。</span></span><br><span class="line"><span class="comment"># 压缩深度是从列表的两边排除压缩的quicklist ziplist节点的数量。</span></span><br><span class="line"><span class="comment"># 列表的头部和尾部总是未压缩，以便进行快速的推送/弹出操作。设置:</span></span><br><span class="line"><span class="comment"># 0: 禁用所有列表压缩</span></span><br><span class="line"><span class="comment"># 1: depth 1 means "don't start compressing until after 1 node into the list,</span></span><br><span class="line"><span class="comment">#    going from either the head or tail"</span></span><br><span class="line"><span class="comment">#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span></span><br><span class="line"><span class="comment">#    [head], [tail] will always be uncompressed; inner nodes will compress.</span></span><br><span class="line"><span class="comment"># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span></span><br><span class="line"><span class="comment">#    2 here means: don't compress head or head-&gt;next or tail-&gt;prev or tail,</span></span><br><span class="line"><span class="comment">#    but compress all nodes between them.</span></span><br><span class="line"><span class="comment"># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span></span><br><span class="line"><span class="comment"># etc.</span></span><br><span class="line"><span class="attr">list-compress-depth</span> <span class="string">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当一个集合只是由基数为10的64位有符号整数范围内的整数组成时，集合具有特殊的编码。</span></span><br><span class="line"><span class="comment"># 下面的配置设置设置了集合大小的限制，以便使用这种特殊的内存节省编码。</span></span><br><span class="line"><span class="attr">set-max-intset-entries</span> <span class="string">512</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 包含非整数值的集合，当它们有少量的条目，并且最大的条目不超过给定的阈值时，也使用内存有效的数据结构进行编码。 </span></span><br><span class="line"><span class="comment"># 可以使用以下指令配置这些阈值。</span></span><br><span class="line"><span class="attr">set-max-listpack-entries</span> <span class="string">128</span></span><br><span class="line"><span class="attr">set-max-listpack-value</span> <span class="string">64</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 与哈希和列表类似，排序集也经过特殊编码，以节省大量空间。此编码仅在排序集的长度和元素低于以下限制时使用:</span></span><br><span class="line"><span class="attr">zset-max-listpack-entries</span> <span class="string">128</span></span><br><span class="line"><span class="attr">zset-max-listpack-value</span> <span class="string">64</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># HyperLogLog稀疏表示字节限制。限制包括16字节的报头。当使用稀疏表示的HyperLogLog超过该限制时，将被转换为密集表示。</span></span><br><span class="line"><span class="comment"># 大于16000的值是完全无用的，因为此时密集表示的内存效率更高。</span></span><br><span class="line"><span class="comment"># 建议值为~ 3000，以获得空间高效编码的好处，而不会降低太多PFADD的速度，使用稀疏编码时PFADD为O(N)。</span></span><br><span class="line"><span class="comment"># 当不考虑CPU，但考虑空间，并且数据集由基数在0-15000范围内的许多hyperloglog组成时，该值可以提高到~10000。</span></span><br><span class="line"><span class="attr">hll-sparse-max-bytes</span> <span class="string">3000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Streams macro node max size / items.</span></span><br><span class="line"><span class="comment"># 流数据结构是一个大节点的基树，其中编码多个项。使用此配置，可以配置单个节点的字节大小，以及在添加新流条目时切换到新节点之前可以包含的最大项数。</span></span><br><span class="line"><span class="comment"># 如果下列任何设置被设置为0，则该限制将被忽略，因此，例如，可以通过将max-bytes设置为0并将max-entries设置为所需值来设置max-entries限制。</span></span><br><span class="line"><span class="attr">stream-node-max-bytes</span> <span class="string">4096</span></span><br><span class="line"><span class="attr">stream-node-max-entries</span> <span class="string">100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 主动rehash每100毫秒使用1毫秒的CPU时间来帮助重哈希主Redis哈希表(将顶级键映射到值的哈希表)。</span></span><br><span class="line"><span class="comment"># Redis使用的哈希表实现(参见dicc .c)执行惰性重哈希:你对哈希表执行的操作越多，执行的重哈希“步骤”就越多，所以如果服务器空闲，重哈希永远不会完成，哈希表会占用更多内存。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 默认情况下，每秒钟使用这个毫秒10次，以便主动重新散列主字典，尽可能释放内存。</span></span><br><span class="line"><span class="comment"># 如果不确定:使用“activerehashing no”，如果你有硬延迟要求，在你的环境中，Redis可以不时地以2毫秒的延迟回复查询，这不是一件好事。</span></span><br><span class="line"><span class="comment"># 如果你没有这样的硬性要求，但想尽快释放内存，请使用"activerehashing yes"。</span></span><br><span class="line"><span class="attr">activerehashing</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 客户端输出缓冲区限制可用于强制断开由于某些原因(常见原因是Pub/Sub客户端消费消息的速度不及发布者生成消息的速度)而未能足够快地从服务器读取数据的客户端。</span></span><br><span class="line"><span class="comment"># 可以为三种不同类型的客户端设置不同的限制:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># normal -&gt; normal clients including MONITOR clients</span></span><br><span class="line"><span class="comment"># replica -&gt; replica clients</span></span><br><span class="line"><span class="comment"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The syntax of every client-output-buffer-limit directive is the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A client is immediately disconnected once the hard limit is reached, or if</span></span><br><span class="line"><span class="comment"># the soft limit is reached and remains reached for the specified number of</span></span><br><span class="line"><span class="comment"># seconds (continuously).</span></span><br><span class="line"><span class="comment"># So for instance if the hard limit is 32 megabytes and the soft limit is</span></span><br><span class="line"><span class="comment"># 16 megabytes / 10 seconds, the client will get disconnected immediately</span></span><br><span class="line"><span class="comment"># if the size of the output buffers reach 32 megabytes, but will also get</span></span><br><span class="line"><span class="comment"># disconnected if the client reaches 16 megabytes and continuously overcomes</span></span><br><span class="line"><span class="comment"># the limit for 10 seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default normal clients are not limited because they don't receive data</span></span><br><span class="line"><span class="comment"># without asking (in a push way), but just after a request, so only</span></span><br><span class="line"><span class="comment"># asynchronous clients may create a scenario where data is requested faster</span></span><br><span class="line"><span class="comment"># than it can read.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Instead there is a default limit for pubsub and replica clients, since</span></span><br><span class="line"><span class="comment"># subscribers and replicas receive data in a push fashion.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that it doesn't make sense to set the replica clients output buffer</span></span><br><span class="line"><span class="comment"># limit lower than the repl-backlog-size config (partial sync will succeed</span></span><br><span class="line"><span class="comment"># and then replica will get disconnected).</span></span><br><span class="line"><span class="comment"># Such a configuration is ignored (the size of repl-backlog-size will be used).</span></span><br><span class="line"><span class="comment"># This doesn't have memory consumption implications since the replica client</span></span><br><span class="line"><span class="comment"># will share the backlog buffers memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Both the hard or the soft limit can be disabled by setting them to zero.</span></span><br><span class="line"><span class="attr">client-output-buffer-limit</span> <span class="string">normal 0 0 0</span></span><br><span class="line"><span class="attr">client-output-buffer-limit</span> <span class="string">replica 256mb 64mb 60</span></span><br><span class="line"><span class="attr">client-output-buffer-limit</span> <span class="string">pubsub 32mb 8mb 60</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Client query buffers accumulate new commands. They are limited to a fixed</span></span><br><span class="line"><span class="comment"># amount by default in order to avoid that a protocol desynchronization (for</span></span><br><span class="line"><span class="comment"># instance due to a bug in the client) will lead to unbound memory usage in</span></span><br><span class="line"><span class="comment"># the query buffer. However you can configure it here if you have very special</span></span><br><span class="line"><span class="comment"># needs, such us huge multi/exec requests or alike.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># client-query-buffer-limit 1gb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># In some scenarios client connections can hog up memory leading to OOM</span></span><br><span class="line"><span class="comment"># errors or data eviction. To avoid this we can cap the accumulated memory</span></span><br><span class="line"><span class="comment"># used by all client connections (all pubsub and normal clients). Once we</span></span><br><span class="line"><span class="comment"># reach that limit connections will be dropped by the server freeing up</span></span><br><span class="line"><span class="comment"># memory. The server will attempt to drop the connections using the most </span></span><br><span class="line"><span class="comment"># memory first. We call this mechanism "client eviction".</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Client eviction is configured using the maxmemory-clients setting as follows:</span></span><br><span class="line"><span class="comment"># 0 - client eviction is disabled (default)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A memory value can be used for the client eviction threshold,</span></span><br><span class="line"><span class="comment"># for example:</span></span><br><span class="line"><span class="comment"># maxmemory-clients 1g</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A percentage value (between 1% and 100%) means the client eviction threshold</span></span><br><span class="line"><span class="comment"># is based on a percentage of the maxmemory setting. For example to set client</span></span><br><span class="line"><span class="comment"># eviction at 5% of maxmemory:</span></span><br><span class="line"><span class="comment"># maxmemory-clients 5%</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># In the Redis protocol, bulk requests, that are, elements representing single</span></span><br><span class="line"><span class="comment"># strings, are normally limited to 512 mb. However you can change this limit</span></span><br><span class="line"><span class="comment"># here, but must be 1mb or greater</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># proto-max-bulk-len 512mb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis calls an internal function to perform many background tasks, like</span></span><br><span class="line"><span class="comment"># closing connections of clients in timeout, purging expired keys that are</span></span><br><span class="line"><span class="comment"># never requested, and so forth.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Not all tasks are performed with the same frequency, but Redis checks for</span></span><br><span class="line"><span class="comment"># tasks to perform according to the specified "hz" value.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default "hz" is set to 10. Raising the value will use more CPU when</span></span><br><span class="line"><span class="comment"># Redis is idle, but at the same time will make Redis more responsive when</span></span><br><span class="line"><span class="comment"># there are many keys expiring at the same time, and timeouts may be</span></span><br><span class="line"><span class="comment"># handled with more precision.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The range is between 1 and 500, however a value over 100 is usually not</span></span><br><span class="line"><span class="comment"># a good idea. Most users should use the default of 10 and raise this up to</span></span><br><span class="line"><span class="comment"># 100 only in environments where very low latency is required.</span></span><br><span class="line"><span class="attr">hz</span> <span class="string">10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Normally it is useful to have an HZ value which is proportional to the</span></span><br><span class="line"><span class="comment"># number of clients connected. This is useful in order, for instance, to</span></span><br><span class="line"><span class="comment"># avoid too many clients are processed for each background task invocation</span></span><br><span class="line"><span class="comment"># in order to avoid latency spikes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Since the default HZ value by default is conservatively set to 10, Redis</span></span><br><span class="line"><span class="comment"># offers, and enables by default, the ability to use an adaptive HZ value</span></span><br><span class="line"><span class="comment"># which will temporarily raise when there are many connected clients.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When dynamic HZ is enabled, the actual configured HZ will be used</span></span><br><span class="line"><span class="comment"># as a baseline, but multiples of the configured HZ value will be actually</span></span><br><span class="line"><span class="comment"># used as needed once more clients are connected. In this way an idle</span></span><br><span class="line"><span class="comment"># instance will use very little CPU time while a busy instance will be</span></span><br><span class="line"><span class="comment"># more responsive.</span></span><br><span class="line"><span class="attr">dynamic-hz</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># When a child rewrites the AOF file, if the following option is enabled</span></span><br><span class="line"><span class="comment"># the file will be fsync-ed every 4 MB of data generated. This is useful</span></span><br><span class="line"><span class="comment"># in order to commit the file to the disk more incrementally and avoid</span></span><br><span class="line"><span class="comment"># big latency spikes.</span></span><br><span class="line"><span class="attr">aof-rewrite-incremental-fsync</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># When redis saves RDB file, if the following option is enabled</span></span><br><span class="line"><span class="comment"># the file will be fsync-ed every 4 MB of data generated. This is useful</span></span><br><span class="line"><span class="comment"># in order to commit the file to the disk more incrementally and avoid</span></span><br><span class="line"><span class="comment"># big latency spikes.</span></span><br><span class="line"><span class="attr">rdb-save-incremental-fsync</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span></span><br><span class="line"><span class="comment"># idea to start with the default settings and only change them after investigating</span></span><br><span class="line"><span class="comment"># how to improve the performances and how the keys LFU change over time, which</span></span><br><span class="line"><span class="comment"># is possible to inspect via the OBJECT FREQ command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># There are two tunable parameters in the Redis LFU implementation: the</span></span><br><span class="line"><span class="comment"># counter logarithm factor and the counter decay time. It is important to</span></span><br><span class="line"><span class="comment"># understand what the two parameters mean before changing them.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis</span></span><br><span class="line"><span class="comment"># uses a probabilistic increment with logarithmic behavior. Given the value</span></span><br><span class="line"><span class="comment"># of the old counter, when a key is accessed, the counter is incremented in</span></span><br><span class="line"><span class="comment"># this way:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1. A random number R between 0 and 1 is extracted.</span></span><br><span class="line"><span class="comment"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span></span><br><span class="line"><span class="comment"># 3. The counter is incremented only if R &lt; P.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default lfu-log-factor is 10. This is a table of how the frequency</span></span><br><span class="line"><span class="comment"># counter changes with a different number of accesses with different</span></span><br><span class="line"><span class="comment"># logarithmic factors:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 0      | 104        | 255        | 255        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 1      | 18         | 49         | 255        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 10     | 10         | 18         | 142        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 100    | 8          | 11         | 49         | 143        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> The above table was obtained by running the following commands:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   redis-benchmark -n 1000000 incr foo</span></span><br><span class="line"><span class="comment">#   redis-cli object freq foo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span></span><br><span class="line"><span class="comment"># to accumulate hits.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The counter decay time is the time, in minutes, that must elapse in order</span></span><br><span class="line"><span class="comment"># for the key counter to be decremented.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default value for the lfu-decay-time is 1. A special value of 0 means we</span></span><br><span class="line"><span class="comment"># will never decay the counter.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># lfu-log-factor 10</span></span><br><span class="line"><span class="comment"># lfu-decay-time 1</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="ACTIVE-DEFRAGMENTATION">ACTIVE DEFRAGMENTATION</h2>
<pre><code class="language-properties">########################### ACTIVE DEFRAGMENTATION #######################
#
# What is active defragmentation?
# -------------------------------
#
# Active (online) defragmentation allows a Redis server to compact the
# spaces left between small allocations and deallocations of data in memory,
# thus allowing to reclaim back memory.
#
# Fragmentation is a natural process that happens with every allocator (but
# less so with Jemalloc, fortunately) and certain workloads. Normally a server
# restart is needed in order to lower the fragmentation, or at least to flush
# away all the data and create it again. However thanks to this feature
# implemented by Oran Agra for Redis 4.0 this process can happen at runtime
# in a "hot" way, while the server is running.
#
# Basically when the fragmentation is over a certain level (see the
# configuration options below) Redis will start to create new copies of the
# values in contiguous memory regions by exploiting certain specific Jemalloc
# features (in order to understand if an allocation is causing fragmentation
# and to allocate it in a better place), and at the same time, will release the
# old copies of the data. This process, repeated incrementally for all the keys
# will cause the fragmentation to drop back to normal values.
#
# Important things to understand:
#
# 1. This feature is disabled by default, and only works if you compiled Redis
#    to use the copy of Jemalloc we ship with the source code of Redis.
#    This is the default with Linux builds.
#
# 2. You never need to enable this feature if you don't have fragmentation
#    issues.
#
# 3. Once you experience fragmentation, you can enable this feature when
#    needed with the command "CONFIG SET activedefrag yes".
#
# The configuration parameters are able to fine tune the behavior of the
# defragmentation process. If you are not sure about what they mean it is
# a good idea to leave the defaults untouched.

# Active defragmentation is disabled by default
# activedefrag no

# Minimum amount of fragmentation waste to start active defrag
# active-defrag-ignore-bytes 100mb

# Minimum percentage of fragmentation to start active defrag
# active-defrag-threshold-lower 10

# Maximum percentage of fragmentation at which we use maximum effort
# active-defrag-threshold-upper 100

# Minimal effort for defrag in CPU percentage, to be used when the lower
# threshold is reached
# active-defrag-cycle-min 1

# Maximal effort for defrag in CPU percentage, to be used when the upper
# threshold is reached
# active-defrag-cycle-max 25

# Maximum number of set/hash/zset/list fields that will be processed from
# the main dictionary scan
# active-defrag-max-scan-fields 1000

# Jemalloc background thread for purging will be enabled by default
jemalloc-bg-thread yes

# It is possible to pin different threads and processes of Redis to specific
# CPUs in your system, in order to maximize the performances of the server.
# This is useful both in order to pin different Redis threads in different
# CPUs, but also in order to make sure that multiple Redis instances running
# in the same host will be pinned to different CPUs.
#
# Normally you can do this using the "taskset" command, however it is also
# possible to this via Redis configuration directly, both in Linux and FreeBSD.
#
# You can pin the server/IO threads, bio threads, aof rewrite child process, and
# the bgsave child process. The syntax to specify the cpu list is the same as
# the taskset command:
#
# Set redis server/io threads to cpu affinity 0,2,4,6:
# server_cpulist 0-7:2
#
# Set bio threads to cpu affinity 1,3:
# bio_cpulist 1,3
#
# Set aof rewrite child process to cpu affinity 8,9,10,11:
# aof_rewrite_cpulist 8-11
#
# Set bgsave child process to cpu affinity 1,10,11
# bgsave_cpulist 1,10-11

# In some cases redis will emit warnings and even refuse to start if it detects
# that the system is in bad state, it is possible to suppress these warnings
# by setting the following config which takes a space delimited list of warnings
# to suppress
#
# ignore-warnings ARM64-COW-BUG
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
