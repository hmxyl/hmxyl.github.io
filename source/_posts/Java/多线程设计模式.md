[JAVA并发设计模式_思维导图](D:\0_Notes\Hexo\hmxyl\source\_images\JAVA并发设计模式.xmind)

![JAVA并发设计模式](D:\0_Notes\Hexo\hmxyl\source\_images\并发设计模式-1667230559743-54.png)

# Chapter1：单例设计模式（七种设计方式）

> Java高并发编程详解：第十四章

## 饿汉式

```java
public class SingletonObject1 {

    private static SingletonObject1 instance = new SingletonObject1();

    private SingletonObject1() {

    }

    public SingletonObject1 getInstance() {
        return instance;
    }
}
```

instance作为类变量，在主动使用SingletonObject1的时候，instance会被加载，包括其中的实例变量也会得到初始化。

- 保证单例的唯一性
- instance被ClassLoader加载很长时间后才会被使用 ，所有instance所占用的堆内存会被占用很久（instance实例比较大，就会占用比较大的堆内存）

## 懒汉式（懒加载）

```java
public class SingletonObject2 {

    private static SingletonObject2 instance;

    private SingletonObject2() {
    }

    public SingletonObject2 getInstance() {
        if (instance == null) {
            instance = new SingletonObject2();
        }

        return instance;
    }
}
```

- 多线程下，可能会存在多个实例，不能保证单例的唯一性

  ![image-20220104175246651](D:\0_Notes\Hexo\hmxyl\source\_images\image-20220104175246651-1667230559743-53.png) 

  

## 懒汉式+同步方法

```java
public class SingletonObject3 {

    private static SingletonObject3 instance;

    private SingletonObject3() {
    }

    public synchronized static SingletonObject3 getInstance() {
        if (instance == null)
            instance = new SingletonObject3();

        return instance;
    }
}
```

- 保证单例的唯一性

- 每次读取 都需要抢锁，同一时间只能有一个线程访问，性能低

  

## Double Check

```java
import java.net.Socket;
import java.sql.Connection;

public class SingletonObject4 {
    // 实例变量
    private byte[] data = new byte[1024];
    private Connection connection;
    private Socket socket;

    private static SingletonObject4 instance = null;

    private SingletonObject4() {
        // 初始化connection
        this.connection
        // 初始化socket
        this.socket
    }

    public static SingletonObject4 getInstance() {
        // 当instance为null时，进入同步代码块，可避免每次读取都进入
        if (instance == null) {
            // 只有一个线程能获取到SingletonObject4.classg关联的monitor
            synchronized (SingletonObject4.class) {
                // 判断如果instance为null时重建
                if (instance == null)
                    instance = new SingletonObject4();
            }
        }

        return instance;
    }
}
```

根据JVM运行时指令重排序和Happens-Before规则，instance、connection和 socket 的实例化顺序并无前后关系的约束，那么极有可能是instance最先被实例化，而conn和sock并未完成实例化，并未完成初始化的实例调用其方法会**抛出空指针异常**

![image-20220104182128644](D:\0_Notes\Hexo\hmxyl\source\_images\image-20220104182128644-1667230559743-55.png) 

## Volatile + Double Check

```java
private volatile static SingletonObject4 instance = null;
```

- Double Check 方法调整下，SingletonObject4 实例化的过程中不允许重排序。
- volatile 也不是线程安全的

## Holder方式（推荐1）

```java
public class SingletonObject6 {
    private SingletonObject6() {
    }

    // 在静态内部类中持有SingletonObject6的实例，并且可被直接初始化
    private static class InstanceHolder {
        private final static SingletonObject6 instance = new SingletonObject6();
    }

    // 调用getInstance方法，实际上是获得InstanceHolder的instance静态属性
    public static SingletonObject6 getInstance() {
        return InstanceHolder.instance;
    }
}
```

当InstanceHolder被主动引用的时候，才会创建SingletonObject6的实例（static 主动加载）

## 枚举方式（推荐2）

```java
public class SingletonObject7 {
    private SingletonObject7() {
        System.out.println("3-----------");
    }

    private enum Singleton {
        INSTANCE;

        private final SingletonObject7 instance;

        Singleton() {
            System.out.println("2-----------");
            instance = new SingletonObject7();
        }

        SingletonObject7 getInstance() {
            System.out.println("4-----------");
            return this.instance;
        }
    }

    public static SingletonObject7 getInstance() {
        System.out.println("1-----------");
        return Singleton.INSTANCE.getInstance();
    }

    public static void main(String[] args) {
        System.out.println(SingletonObject7.getInstance().hashCode());
        System.out.println(SingletonObject7.getInstance().hashCode());
    }
}
```

输出

```java
1-----------
2-----------
3-----------
4-----------
1836019240
1-----------
4-----------
1836019240
```



# Chapter2：WaitSet（等待池）

1. 所有的对象都会有一个wait set, 用来存放调用了该对象wait方法之后进入了block状态的线程

2. 线程被notify之后，进入runnable状态，不一定立即得到执行

3. 线程从wait set 中被唤醒的顺序不一定是FIFO

4. 线程从wait set 中被唤醒之后，需要重新抢锁。抢到锁之后，根据wait时记录的执行代码地址，进行==地址恢复==，继续往后执行。

   

#  Chapter3：volatile 关键字

> Java高并发编程详解：第十二章、第十三章



```java
public class VolatileTest {

    private volatile static int INIT_VALUE = 0;
    private final static int MAX_VALUE = 5;

    public static void main(String[] args) {

        new Thread(() -> {
            int localValue = INIT_VALUE;
            while (localValue < MAX_VALUE) {
                if (localValue != INIT_VALUE) {
                    System.out.printf("The value updated from [%d] to [%d]\n", localValue, INIT_VALUE);
                    localValue = INIT_VALUE;
                }
            }
        }, "READER").start();

        new Thread(() -> {
            int localValue = INIT_VALUE;
            while (localValue < MAX_VALUE) {
                INIT_VALUE = ++localValue;
                System.out.printf("Update the value to [%d]\n", INIT_VALUE);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "WRITER").start();
    }
}
```

输出结果

```apl
Update the value to [1]
The value updated from [0] to [1]
Update the value to [2]
The value updated from [1] to [2]
Update the value to [3]
The value updated from [2] to [3]
The value updated from [3] to [4]
Update the value to [4]
The value updated from [4] to [5]
Update the value to [5]
```

## CPU缓存一致性问题

		- 解决方式1：总线加锁方式
		- 解决方式2：CPU高速缓存一致性协议

​		在现代计算机中，CPU 的速度是极高的，如果 CPU 需要存取数据时都直接与内存打交道，在存取过程中，CPU 将一直空闲，这是一种极大的浪费，所以，为了提高处理速度，CPU 不直接和内存进行通信，而是在 CPU 与内存之间加入很多寄存器，多级缓存，它们比内存的存取速度高得多，这样就解决了 CPU 运算速度和内存读取速度不一致问题。

​		由于 CPU 与内存之间加入了缓存，在进行数据操作时，先将数据从内存拷贝到缓存中，CPU 直接操作的是缓存中的数据。但在多处理器下，将可能导致各自的缓存数据不一致（这也是可见性问题的由来），为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，而**嗅探是实现缓存一致性的常见机制**。

![img](D:\0_Notes\Hexo\hmxyl\source\_images\v2-77acfee471d8827a2121157c68f2485d_720w-1667230559743-56.jpg)  

​		在缓存一致性协议中最为出名的时Intel的==MESI==协议。MESI协议保证了每个缓存中使用的共享变量副本是一致的，她的大致思想是：当CPU在操作Cache中的数据时，如果发现该变量是一个共享变量，也就是说在其他的CPU Cache 中也存在一个副本，那么进行如下操作：

​		① 读取操作，不做任何处理，只是将Cache中的数据读取到寄存器

​		② 写入操作，发出信号通知其他CPU将该变量的Cache line置为无效标志，其他CPU在进行该变量读取数据的时候就不得不到主内存中再次获取。



## Java内存模型JMM（Java Memory Model）

​		Java的内存模型决定了一个线程对共享变量的写入如何让其他线程可见，Java内存模型定义了线程和主内存之间的抽象关系

- 共享变量存储于主内存之中，每个线程都可以访问。
- 每个线程都有私有的工作内存（或者叫做本地内存）
- 线程不能直接操作主内存，只是先操作了工作内存之后，才写入主内存
- 工作内存和Java内存模型一样，也是一个抽象的概念，其实并不存在。它涵盖了缓存、寄存器、编译器优化以及硬件等。

![image-20220105142137063](D:\0_Notes\Hexo\hmxyl\source\_images\image-20220105142137063-1667230559746-57.png) 



## JMM与并发编程的三大特性

### 原子性

 一个操作或者多个操作，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行

```
JMM 仅保证了基本数据类型的读写的原子性操作，其他均不保证。
如果想要保证某段代码具有原子性，需要使用synchronized 或者 JUC 中的lock。
如果想要int等类型的自增操作具有原子性，可以使用JUC包下的原子封装类型：`java.util.concurrent.atomic`
```

### 可见性

```
Java提供了以下三种方式保证可见性
①volatile关键字
②synchronized关键字
③JUC提供的显示锁Lock 
```

### 有序性

```
Java提供了以下三种方式保证有序性
①volatile关键字
②synchronized关键字
③JUC提供的显示锁Lock 
```

## Happens-before原则：JMM具备的天生的有序性规则

- 程序次序规则

  ```
  在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后。
  
  这句话的意思看起来是程序按照編写的顺序来执行，但是虚拟机还是可能会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可。
  ```

- 锁定规则

  ```
  一个unlock操作要先行发生于对同一个锁的lock操作
  
  这句话的意思是，无论是在单线程还是在多线程的环境下，如果同一个锁是锁定状态，那么必须先对其执行释放操作之后才能继续进行lock操作。
  ```

- volatile变量规则

  ```
  对一个变量的写操作要早于对这个变量之后的读操作
  
  根据字面的意思来理解是，如果一个变量使用volatlle关键字修饰，一个线程对它进行读操作，一个线程对它进行写操作，那么写入操作肯定要先行发生于读操作，
  ```

- 传递规则

  ```
  如果操作A先于操作B，而操作B又先于操作c，则可以得出操作A肯定要先于操作C，这一点说明了happens-before原则具各传递性
  ```

- 线程启动规则

  ```
  Thread对象的start()方法先行发生于对该线程的任何操作，所以才说：只有start之后线程才能真正运行，否则Thread也只是一个对象而已
  ```

- 线程中断规则

  ```
  对线程执行interrupt()方法肯定要优先于捕获到中断信号
  
  这句话的意思是指如果线程收到了中断信号，那么在此之前势必要有interrupt()
  ```

- 线程的终结规则

  ```
    线程中所有的操作都要先行发生于线程的终止检测
    通俗地讲，线程的任务执行、逻辑单元执行肯定要发生于线程死亡之前。
  ```

- 对象的终结规则

  ```
   一个对象初始化的完成先行发生于finalwe()方法之前，这个更没什么好说的了，先有生后有死
  ```

## volatile 关键字特性总结

1. 保证重排序的时候，不会把后面的指令放到屏障之前，也不会把前面的放到后面
2. 强制对缓存的修改操作立刻写入主存
3. 如果是写操作，会导致其他CPU中的缓存失效。

# Chapter4：观察者模式

>Java高并发编程详解：第十五章

参考：http://c.biancheng.net/view/1390.html

- Demo1

设计模式图

![image-20220109155129782](D:\0_Notes\Hexo\hmxyl\source\_images\image-20220109155129782-1667230559746-58.png)  

代码示例：监控对象

```java
public class Subject {

    private List<Observer> observers = new ArrayList<>();

    private int state;

    public int getState() {
        return this.state;
    }

    public void setState(int state) {
        if (this.state == state) {
            return;
        }
        this.state = state;
        // Subject存在变更，observers同步执行
        notifyAllObserver();
    }

    private void notifyAllObserver() {
        observers.stream().forEach(Observer::update);
    }

    public void attach(Observer observer) {
        this.observers.add(observer);
    }
}
```

```java
public abstract class Observer {
    protected Subject subject;

    public Observer(Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }

    // 执行体由不同的Observer子类完成
    public abstract void update();
}
```

```java
public class BinaryObserver extends Observer {

    public BinaryObserver(Subject subject) {
        super(subject);
    }

    @Override
    public void update() {
        System.out.println("Binary String:" + Integer.toBinaryString(subject.getState()));
    }
}
```

```java
public class OctalObserver extends Observer {
    public OctalObserver(Subject subject) {
        super(subject);
    }

    @Override
    public void update() {
        System.out.println("Octal String:" + Integer.toOctalString(subject.getState()));
    }
}
```

```java
public class ObserverPatternDemo {
    public static void main(String[] args) {
        final Subject subject = new Subject();
        new BinaryObserver(subject);
        new OctalObserver(subject);
        System.out.println("===============1==========");
        subject.setState(10);
        System.out.println("===============2==========");
        subject.setState(10);
        System.out.println("===============3==========");
        subject.setState(20);
    }
}
```

# Chapter5：Single Thread Execution 设计模式

单线程执行设计模式

> Java高并发编程详解：第十六章

线程不安全原因：

1. 共享资源
2. 临界值
3. 多线程竞争（各线程都会有可能变更共享资源的状态）


解决：保证共享资源的写操作同一时间只有一个线程操作

#　Chapter６：读写锁分离设计模式

> Java高并发编程详解：第十七章

共享资源在多个线程在进行读写操作时不会引起冲突

| 线程 |            读            |            写            |
| :--: | :----------------------: | :----------------------: |
|  读  |          不冲突          | 冲突（只允许单线程运行） |
|  写  | 冲突（只允许单线程运行） | 冲突（只允许单线程运行） |

```java
/**
 * 读写分离锁
 */
public class ReadWriteLock {
    private int readingReaders = 0;
    private int waitingReaders = 0;
    private int writingWriters = 0;
    private int waitingWriters = 0;

    // 控制倾向性，有写操作等待时，优先执行
    private final boolean preferWriter;

    public ReadWriteLock() {
        this.preferWriter = true;
    }

    public ReadWriteLock(boolean preferWriter) {
        this.preferWriter = preferWriter;
    }


    public synchronized void readLock() throws InterruptedException {
        try {
            this.waitingReaders++;
            while (writingWriters > 0 || (preferWriter && waitingWriters > 0)) {
                this.wait();
            }
            this.readingReaders++;
        } finally {
            this.waitingReaders--;
        }
    }

    public synchronized void readUnlock() {
        this.readingReaders--;
        this.notifyAll();
    }

    public synchronized void writeLock() throws InterruptedException {
        try {
            this.waitingWriters++;
            while (readingReaders > 0 || writingWriters > 0) {
                this.wait();
            }
            writingWriters++;
        } finally {
            waitingWriters--;
        }
    }

    public synchronized void writeUnlock() {
        writingWriters--;
        notifyAll();
    }
}
```

```java
/**
 * 共享资源读/写执行
 */
public class SharedData {

    // 共享资源
    private final char[] buffer;

    // 读写锁
    private final ReadWriteLock lock = new ReadWriteLock();

    public SharedData(int size) {
        // 初始化共享资源
        buffer = new char[size];
        for (int i = 0; i < size; i++) {
            this.buffer[i] = '*';
        }
    }


    public char[] read() throws InterruptedException {
        try {
            lock.readLock();
            return this.doRead();
        } finally {
            lock.readUnlock();
        }
    }

    public void write(char c) throws InterruptedException {
        try {
            lock.writeLock();
            this.doWrite(c);
        } finally {
            lock.writeUnlock();
        }
    }

    private void doWrite(char c) {
        for (int i = 0; i < buffer.length; i++) {
            buffer[i] = c;
            slowly(10);
        }
    }

    /**
     * @return：共享资源的副本
     */
    private char[] doRead() {
        char[] newBuf = new char[buffer.length];
        for (int i = 0; i < buffer.length; i++) {
            newBuf[i] = buffer[i];
        }

        slowly(50);
        return newBuf;
    }


    private void slowly(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
        }
    }

}
```



```java
/**
 * 线程-读资源
 */
public class ReaderWorker extends Thread {
    private final SharedData data;

    public ReaderWorker(SharedData data) {
        this.data = data;
    }

    @Override
    public void run() {
        try {
            while (true) {
                char[] buf = data.read();
                System.out.println(Thread.currentThread() + " read " + String.valueOf(buf));
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
/**
 * 线程-写资源
 */
public class WriterWorker extends Thread {
    private static final Random random = new Random(System.currentTimeMillis());

    private final SharedData sharedData;

    private int index = 0;
    private final String filler;

    public WriterWorker(SharedData sharedData, String filler) {
        this.sharedData = sharedData;
        this.filler = filler;
    }

    @Override
    public void run() {
        try {
            while (true) {
                char c = nextChar();
                sharedData.write(c);
                System.out.println(Thread.currentThread().getName() + " write " + c);
                Thread.sleep(random.nextInt(1000));
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private char nextChar() {
        char c = filler.charAt(index);
        index++;
        if (index >= filler.length())
            index = 0;
        return c;
    }
}
```

测试类

```java
public class ReadWritLockClient {
    public static void main(String[] args) {
        final SharedData sharedData = new SharedData(10);
        new ReaderWorker(sharedData).start();
        new ReaderWorker(sharedData).start();
        new ReaderWorker(sharedData).start();
        new ReaderWorker(sharedData).start();
        new ReaderWorker(sharedData).start();
        new WriterWorker(sharedData, "qwertyuiopasdfg").start();
        new WriterWorker(sharedData, "QWERTYUIOPASDFG").start();
    }
}
```



# Chapter7：不可变对象设计模式

> Java高并发编程详解：第十八章

不可变对象定义

- 不可变对象是没有机会去修改的
- 每一次修改都会导致一个新的对象的产生。

不可变对象必要条件（String、Integer、Float 等）

- 确保类是final 的，不允许被其他类继承。（final修饰的类，被继承的提示：There is no default constructor available in 'com.hots.part2.chapter7.Person'）

- 确保所有的成员变量是final 的，**引用类型所引用的对象同样不可变**

- 不要提供任何setter 方法。

  **引用集合，GET方法返回unmodifiable的集合**

  ```java
  public List<String> getList() {
      return Collections.unmodifiableList(list);
  }
  ```

- 如果要修改类的状态，必须返回一个新的对象。

```java
/**
 * 不可变对象
 */
final public class Person {
    private final String name;
    private final String address;

    public Person(final String name, final String address) {
        this.name = name;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public String getAddress() {
        return address;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}
```

# Chapter8：Future设计模式

> Java高并发编程详解：第十九章

Future 代表的是未来的一个凭据，保留隔离的逻辑程序执行结果



```java
public interface Future<T> {
    T get();
}
```

```java
public class AsyncFuture<T> implements Future<T> {

    private volatile boolean done = false;

    private T result;

    public void done(T result) {
        synchronized (this) {
            this.result = result;
            this.done = true;
            this.notifyAll();
        }
    }

    @Override
    public T get() throws InterruptedException {
        synchronized (this) {
            while (!done) {
                this.wait();
            }
        }
        return result;
    }
}
```

```java
public interface FutureTask<T> {
    T call();
}
```

```java
public class FutureService {

    public <T> Future<T> submit(final FutureTask<T> futureTask, final Consumer<T> consumer) {
        AsyncFuture<T> asyncFuture = new AsyncFuture<>();
        new Thread(() -> {
            T result = futureTask.call();
            asyncFuture.done(result);
            consumer.accept(result);
        }).start();
        return asyncFuture;
    }
}
```

```java
public class SyncInvoker {
    public static void main(String[] args) throws InterruptedException {
        FutureTask<String> futureTask = () -> {
            try {
                TimeUnit.SECONDS.sleep(15);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "finish jobs";
        };

        FutureService futureService = new FutureService();
        Future<String> result = futureService.submit(futureTask, System.out::println);

        System.out.println("===========");
        System.out.println("do other thing.");
        TimeUnit.SECONDS.sleep(10);
        System.out.println("===========");

        System.out.println("results from job：" + result.get());

    }
}
```





# Chapter9：Guarded Suspension 设计模式（保护性暂挂模式）

>Java高并发编程详解：第二十章

当线程访问某个对象时，发现条件不满足，就暂时挂起等待条件满足时再次访问。

- 处理的消息内容

```java
public class Request {
    final private String value;

    public Request(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }
}
```



```java
public class RequestQueue {

    // 任务队列
    private final LinkedList<Request> queue = new LinkedList<>();

    /**
     * 服务端处理任务
     */
    public Request getRequest() {
        synchronized (queue) {
            while (queue.size() <= 0) {
                try {
                    queue.wait();
                } catch (InterruptedException e) {
                    System.out.println("queue wait interrupted");
                    return null;
                }
            }

            return queue.removeFirst();
        }
    }

    /**
     * 客户端推送任务
     */
    public void putRequest(Request request) {
        synchronized (queue) {
            queue.add(request);
            queue.notifyAll();
        }
    }
}
```

```java
/**
 * 客户端: 发送任务
 */
public class ClientThread extends Thread {
    private final RequestQueue queue;

    private Random random;

    private final String sendValue;


    public ClientThread(RequestQueue queue, String sendValue) {
        this.queue = queue;
        this.sendValue = sendValue;
        this.random = new Random(System.currentTimeMillis());
    }

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("Client -> request " + sendValue);
            queue.putRequest(new Request(sendValue));
            try {
                Thread.sleep(random.nextInt(50));
            } catch (InterruptedException e) {
                System.out.println("Client -> Wake up from sleeping");
                e.printStackTrace();
            }
        }
    }
}
```

```java
/**
 * 服务端：处理任务
 */
public class ServerThread extends Thread {
    private RequestQueue queue;
    private Random random;

    private volatile boolean closed = false;


    public ServerThread(RequestQueue queue) {
        this.queue = queue;
        this.random = new Random(System.currentTimeMillis());
    }


    @Override
    public void run() {
        while (!closed) {
            Request request = queue.getRequest();
            if (null == request) {
                // queue从wait中被打断
                System.out.println("Received the empty request.");
                continue;
            }
            System.out.println("Server ->" + request.getValue());
            try {
                Thread.sleep(random.nextInt(100));
            } catch (InterruptedException e) {
                System.out.println("Server -> Wake up from sleeping");
                return;
            }
        }
    }

    /**
     * 关闭服务端线程
     */
    public void close() {
        this.closed = true;
        this.interrupt();
    }
}
```

```java
/**
 * 测试类
 */
public class SuspensionClient {
    public static void main(String[] args) throws InterruptedException {

        final RequestQueue queue = new RequestQueue();

        ClientThread clientThread = new ClientThread(queue, "test");
        clientThread.start();

        ServerThread serverThread = new ServerThread(queue);
        serverThread.start();

        Thread.sleep(10000);

        System.out.println("Server ready to close.");
        serverThread.close();
    }
}
```

# Chapter10：ThreadLocal：线程局部变量

- This class provides thread-local variables. These variables differ from their  normal counterparts in that each thread that accesses one (via its  `get` or `set` method) has its own, independently  initialized copy of the variable.

- `ThreadLocal` instances are  typically private static fields in classes that wish to associate state with a  thread (e.g., a user ID or Transaction ID). 

- 每个访问`ThreadLocal`变量的线程，都会获取到一个`ThreadLocal`变量的**副本**，线程之间互不影响。
- `始终以当前线程作为KEY值`

```java
public class ThreadLocalSimpleTest {
    private static ThreadLocal<String> threadLocal = new ThreadLocal<String>() {
        @Override
        protected String initialValue() {
            return "设置默认值";
        }
    };

    public static void main(String[] args) throws InterruptedException {
        // 主线程获取ThreadLocal
        System.out.println(Thread.currentThread().getName() + "--" + threadLocal.hashCode() + "---" + threadLocal.get());
        threadLocal.set("TEST");
        Thread.sleep(1_000L);
        System.out.println(Thread.currentThread().getName() + "--" + threadLocal.hashCode() + "---" + threadLocal.get());

        new Thread(() -> {
            threadLocal.set("TEST-1");
            System.out.println(Thread.currentThread().getName() + "--" + threadLocal.hashCode() + "---" + threadLocal.get());
        }).start();

        new Thread(() -> {
            threadLocal.set("TEST-2");
            System.out.println(Thread.currentThread().getName() + "--" + threadLocal.hashCode() + "---" + threadLocal.get());
        }).start();


        Thread.sleep(1_000L);
        // 主线程再次获取ThreadLocal
        System.out.println(Thread.currentThread().getName() + "--" + threadLocal.hashCode() + "---" + threadLocal.get());
    }
}
```

输出

```java
main--1836019240---设置默认值
main--1836019240---TEST
Thread-0--1836019240---TEST-1
Thread-1--1836019240---TEST-2
main--1836019240---TEST
```



# Chapter11：The Thread-Specific Storage：线程保险箱

> Java高并发编程详解：第二十一章 

线程上下文：线程级别的单例，利用ThreadLocal实现。

```java
/**
 * 上下文内容
 */
@Getter
@Setter
public class Context {
    private String name;
    private String cardId;
}
```

```java
/**
 * 线程上下文工具类：线程级别的单例
 */
public class ActionContext {
    private ActionContext() {

    }

    private static final ThreadLocal<Context> threadLocal = new ThreadLocal<Context>() {
        @Override
        protected Context initialValue() {
            return new Context();
        }
    };

    private static class ContextHolder {
        private final static ActionContext actionContext = new ActionContext();
    }

    public static ActionContext getActionContext() {
        return ActionContext.ContextHolder.actionContext;
    }

    public Context getContext() {
        return threadLocal.get();
    }
}
```

```java
/**
 * 线程工作内容
 */
public class ExecutionTask implements Runnable {

    private QueryFromDBAction queryFromDBAction = new QueryFromDBAction();
    private QueryFromHttpAction queryFromHttpAction = new QueryFromHttpAction();

    @Override
    public void run() {
        // 分步骤获取
        queryFromDBAction.execute();
        System.out.println(Thread.currentThread().getName() + " The name query successful");
        queryFromHttpAction.execute();
        System.out.println(Thread.currentThread().getName() + " The card id query successful");
        // 最后，统一获取
        Context context = ActionContext.getActionContext().getContext();
        System.out.println("The Name is " + context.getName() + " and CardId " + context.getCardId());
    }
}
```

```java
/**
 * 线程工作内容：从DB获取
 */
public class QueryFromDBAction {
    public void execute() {
        try {
            Thread.sleep(1000L);
            String name = "Alex " + Thread.currentThread().getName();
            ActionContext.getActionContext().getContext().setName(name);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
/**
 * 线程工作内容：从网络获取
 */
public class QueryFromHttpAction {
    public void execute() {
        Context context = ActionContext.getActionContext().getContext();
        String name = context.getName();
        String cardId = getCardId(name);
        context.setCardId(cardId);
    }

    private String getCardId(String name) {
        try {
            Thread.sleep(1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return "435467523543" + Thread.currentThread().getId();
    }
}
```

```java
/**
 * 测试类
 */
public class ContextTest {
    public static void main(String[] args) {
        IntStream.range(1, 5)
                .forEach(i ->
                        new Thread(new ExecutionTask()).start()
                );
    }
}
```

# Chapter12：Balking设计模式

某个线程发现其他线程正在执行相同的任务而放弃即将开始的任务（修改之前的判断）

> Java高并发编程详解：第二十二章

```java
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;


/**
 * balking 设计模式核心：save 方法
 */
public class BalkingData {
    private String fileName;
    private String content;
    private boolean changed;

    public BalkingData(String fileName, String content) {
        this.fileName = fileName;
        this.content = content;
        this.changed = true;
    }

    public synchronized void change(String newContent) {
        this.content = newContent;
        this.changed = true;
    }

    /**
     * 多个线程同时执行保存任务，其中一个线程完成后changed被调整，另外一个线程不会继续执行
     */
    public synchronized void save() throws IOException {
        if (!changed) {
            return;
        }
        doSave();
        this.changed = false;
    }


    private void doSave() throws IOException {
        System.out.println(Thread.currentThread().getName() + " calls do save. content = " + content);
        try (Writer writer = new FileWriter(fileName, true)) {
            writer.write(content);
            writer.write(System.getProperty("line.separator"));
            writer.flush();
        }
    }
}
```

```java
/**
 * 线程A: 程序触发保存任务
 */
public class CustomerThread extends Thread {
    private final BalkingData balkingData;

    private final Random random = new Random(System.currentTimeMillis());

    public CustomerThread(BalkingData balkingData) {
        super("Customer");
        this.balkingData = balkingData;
    }

    @Override
    public void run() {
        try {
            // 保存数据
            balkingData.save();
            for (int i = 0; i < 20; i++) {
                // 变更数据
                balkingData.change("No." + i);
                Thread.sleep(random.nextInt(1_000));
                // 保存数据
                balkingData.save();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
/**
 * 线程B：后台自动保存
 */
public class WaiterThread extends Thread {
    private final BalkingData balkingData;

    public WaiterThread(BalkingData balkingData) {
        super("Waiter");
        this.balkingData = balkingData;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            try {
                // 后台自动保存
                balkingData.save();
                Thread.sleep(200L);
            } catch (IOException e) {
                e.printStackTrace();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
/**
 * 测试类
 */
public class BalkingTest {
    public static void main(String[] args) {
        String fileName = "D:\\RECEIVED\\test.txt";
        String content = ">>>>>>>> BEGIN <<<<<<<<<<<<";
        BalkingData balkingData = new BalkingData(fileName, content);
        new WaiterThread(balkingData).start();
        new CustomerThread(balkingData).start();
    }
}
```

# Chapter13：生产者/消费者模式

```java
`/**
 * 消费主体
 */
public class Message {
    private String data;

    public Message(String data) {
        this.data = data;
    }

    public String getData() {
        return data;
    }
}
```

```java
/**
 * 消费队列
 */
public class MessageQueue {

    private final static int DEFAULT_MAX_LIMIT = 100;

    private final LinkedList<Message> queue;

    private final int limit;

    public MessageQueue() {
        this(DEFAULT_MAX_LIMIT);
    }

    public MessageQueue(final int limit) {
        this.limit = limit;
        this.queue = new LinkedList<>();
    }


    public void put(Message message) throws InterruptedException {
        synchronized (queue) {
            while (queue.size() > limit) {
                queue.wait();
            }

            queue.addLast(message);
            queue.notifyAll();
        }
    }

    public Message take() throws InterruptedException {
        synchronized (queue) {
            while (queue.size() == 0) {
                queue.wait();
            }

            Message message = queue.removeFirst();
            queue.notifyAll();
            return message;
        }
    }
}
```

```java
import java.util.Random;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 生产者
 */
public class ProducerThread extends Thread {
    private final MessageQueue messageQueue;

    private final static Random random = new Random(System.currentTimeMillis());

    private final static AtomicInteger counter = new AtomicInteger(0);


    public ProducerThread(MessageQueue messageQueue, int seq) {
        super("PRODUCER-" + seq);
        this.messageQueue = messageQueue;
    }

    @Override
    public void run() {
        while (true) {
            try {
                Message message = new Message("Message-" + counter.getAndIncrement());
                messageQueue.put(message);
                System.out.println(Thread.currentThread().getName() + " put message " + message.getData());
                Thread.sleep(random.nextInt(1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
                break;
            }
        }
    }
}
```

```java
/**
 * 消费者
 */
public class ConsumerThread extends Thread {
    private final MessageQueue messageQueue;

    private final static Random random = new Random(System.currentTimeMillis());

    public ConsumerThread(MessageQueue messageQueue, int seq) {
        super("CONSUMER-" + seq);
        this.messageQueue = messageQueue;
    }

    @Override
    public void run() {
        while (true) {
            try {
                Message message = messageQueue.take();
                System.out.println(Thread.currentThread().getName() + " take message " + message.getData());
                Thread.sleep(random.nextInt(1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
                break;
            }
        }
    }
}
```

```java
/**
 * 测试类
 */
public class ProducerAndConsumerClient {
    public static void main(String[] args) {
        final MessageQueue messageQueue = new MessageQueue();
        new ProducerThread(messageQueue, 1).start();
        new ProducerThread(messageQueue, 2).start();
        new ProducerThread(messageQueue, 3).start();
        new ConsumerThread(messageQueue, 1).start();
        new ConsumerThread(messageQueue, 2).start();
    }
}
```

# Chapter14：Latch 设计模式（阀门设计模式）

> Java高并发编程详解：第二十三章

等待所有条件满足时，阀门才会被打开：利用CountDownLatch

```java
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.stream.IntStream;

public class JDKCountDown {
    private static final Random random = new Random(System.currentTimeMillis());

    public static void main(String[] args) throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(5);
        System.out.println("准备多线程处理任务.");
        //The first phase.
        IntStream.rangeClosed(1, 5).forEach(i ->
                new Thread(() -> {
                    System.out.println(Thread.currentThread().getName() + " is working.");
                    try {
                        Thread.sleep(random.nextInt(1000));
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    latch.countDown();
                }, String.valueOf(i)).start()
        );
        // 无限等待
        latch.await();
        //The second phase.
        System.out.println("多线程任务全部结束,准备第二阶段任务");
        System.out.println("............");
        System.out.println("FINISH");
    }
}
```

# Chapter15：Thread-Per-Message 设计模式

> Java高并发编程详解：第二十四章

为每一个消息的处理开辟一个线程，使得消息能够以并发的方式进行处理，从而提高系统整体的吞吐能力。

```java
public class Message {
    private final String value;

    public Message(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }
}
```

```java
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MessageHandler {
    private final static Random random = new Random(System.currentTimeMillis());

    private final static ExecutorService executor = Executors.newFixedThreadPool(5);

    public void request(Message message) {
        executor.execute(() -> {
            String value = message.getValue();
            try {
                Thread.sleep(random.nextInt(1000));
                System.out.println("The message will be handle by " + Thread.currentThread().getName() + " " + value);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }

    public void shutdown() {
        executor.shutdown();
    }
}
```

```java
import java.util.stream.IntStream;

public class PerThreadClient {
    public static void main(String[] args) {
        final MessageHandler handler = new MessageHandler();
        IntStream.rangeClosed(0, 10)
                .forEach(
                        i -> handler.request(new Message(String.valueOf(i)))
                );

        handler.shutdown();
    }
}
```

# Chapter16：Two Phase Termination 设计模式

> Java高并发编程详解：第二十五章



当一个线程正常结束，我们需要考虑如何正常释放线程中资源：文件句柄、Socket套接字句柄、数据库连接等

![image-20220120111130525](D:\0_Notes\Hexo\hmxyl\source\_images\image-20220120111130525-1667230559747-59.png) 



在第二阶段释放资源的时候需要考虑如下几个问题：

- 第二阶段的终止需要保证安全性，比如涉及对共享资源的操作
- 对资源的释放时间需要控制在一个可控的时间范围内
- 要百分百的确保线程的结束：第二阶段出现死循环、线程阻塞等异常无法结束



1. 简单的two phrase termination 设计模式实现：利用finally执行

```java
import java.util.Random;

public class CounterIncrement extends Thread {

    private volatile boolean terminated = false;

    private int counter = 0;

    private Random random = new Random(System.currentTimeMillis());

    @Override
    public void run() {
        try {
            while (!terminated) {
                System.out.println(Thread.currentThread().getName() + " " + counter++);
                Thread.sleep(random.nextInt(1000));
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            this.clean();
        }
    }

    /**
     * 执行程序结束后的任务
     */
    private void clean() {
        System.out.println("do some clean work for the second phase,current counter " + counter);
    }


    /**
     * 结束线程
     */
    public void close() {
        this.terminated = true;
    }
}
```

```java
public class CounterTest {
    public static void main(String[] args) throws InterruptedException {
        CounterIncrement counterIncrement = new CounterIncrement();
        counterIncrement.start();
        Thread.sleep(10_000L);
        counterIncrement.close();
    }
}
```



2. Socket套接字

   - 服务端

     线程池容量为2，等待其他连接关闭，才会处理第三个链接任务

     ```java
     import java.io.IOException;
     import java.net.ServerSocket;
     import java.net.Socket;
     import java.util.LinkedList;
     import java.util.List;
     import java.util.concurrent.ExecutorService;
     import java.util.concurrent.Executors;
     
     public class AppServer extends Thread {
     
     
         private final int port;
     
         private static final int DEFAULT_PORT = 12722;
     
         private volatile boolean start = true;
     
         private final List<ClientHandler> clientHandlers = new LinkedList<>();
     
         private final ExecutorService executor = Executors.newFixedThreadPool(2);
     
         private ServerSocket serverSocket;
     
         public AppServer() {
             this.port = DEFAULT_PORT;
         }
     
         public AppServer(int port) {
             this.port = port;
         }
     
         @Override
         public void run() {
             try {
                 this.serverSocket = new ServerSocket(port);
                 System.out.println("端口：" + port + "，正在等待客户端连接.....");
                 while (start) {
                     // 获取客户端链接
                     Socket client = serverSocket.accept();
                     // 保留客户端链接，用于退出前的清理 
                     ClientHandler clientHandler = new ClientHandler(client);
                     clientHandlers.add(clientHandler);
                     // 提交任务处理
                     executor.submit(clientHandler);
                 }
             } catch (IOException e) {
                 e.printStackTrace();
             } finally {
                 this.dispose();
             }
         }
     
         /**
          * 清理线程程池资源
          */
         private void dispose() {
             System.out.println("清理线程程池资源.....");
             // 关闭客户端链接
             clientHandlers.stream().forEach(e -> e.shutDown());
             executor.shutdown();
         }
     
         /**
          * 关闭服务端
          */
         public void shutDown() {
             System.out.println("关闭服务端.....");
             this.start = false;
             this.interrupt();
             try {
                 serverSocket.close();
                 System.out.println("服务端正常关闭");
             } catch (IOException e) {
                 System.out.println("服务端关闭失败 : " + e.getMessage());
             }
         }
     }
     ```

     

   - 客户端

     ```java
     import java.io.*;
     import java.net.Socket;
     
     /**
      * 处理客户端请求
      */
     public class ClientHandler extends Thread {
         private volatile boolean running = true;
     
         private final Socket socket;
     
         public ClientHandler(Socket socket) {
             this.socket = socket;
         }
     
         @Override
         public void run() {
             try (InputStream inputStream = socket.getInputStream();
                  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
                  OutputStream outputStream = socket.getOutputStream();
                  PrintWriter printWriter = new PrintWriter(outputStream);
             ) {
                 while (running) {
                     // 读取客户端提供数据
                     String message = bufferedReader.readLine();
                     if (message == null) {
                         break;
                     }
                     System.out.println("读取客户端数据 >" + message);
                     // 回写数据给客户端
                     printWriter.write("echo " + message + "\n");
                     printWriter.flush();
                 }
                 System.out.println("客户端正常关闭");
             } catch (IOException e) {
                 e.printStackTrace();
             } finally {
                 this.shutDown();
             }
         }
     
         public void shutDown() {
             if (!running) {
                 // 客户端已经执行完成：balking设计模式
                 return;
             }
             this.running = false;
             try {
                 this.socket.close();
                 System.out.println("客户端正常关闭");
             } catch (IOException e) {
                 System.out.println("客户端关闭失败：" + e.getMessage());
             }
         }
     }
     ```

   - 测试类：启动服务端

     ```java
     public class AppServerClient {
         public static void main(String[] args) throws InterruptedException {
             AppServer appServer = new AppServer(12312);
             appServer.start();
     
             // Thread.sleep(20_000L);
             // appServer.shutDown();
         }
     }
     ```

     

# Chapter17：Worker-Thread 设计模式

 线程池在某种意义上也是一种worker-thread设计模式的实现

> Java高并发编程详解：第二十六章

# Chapter18：Active Objects 设计模式

拥有独立线程的对象（主动对象）接受异步消息，并且能够返回处理结果的设计模式

[active-object设计模式-设计图](‪D:\0_Notes\Hexo\hmxyl\source\_images\active-object设计模式.drawio)

![active-object设计模式](D:\0_Notes\Hexo\hmxyl\source\_images\1fe2af03-d148-4791-adfe-993c1c9ec1db.png)  





功能说明：提交任务、执行任务拆分为两个独立的线程

1. `ActiveObjectFactory `创建` ActiveObjectProxy`，ActiveObjectProxy 包含了 ActiveObject的两种行为方式

2. `ActiveObjectProxy ` 包含一个执行任务线程： `SchedulerThread `，创建即启动，监听任务队列`ActivationQueue`，有任务，就处理。

3. `ActiveObjectProxy ` 接收到的 `makeString `任务和 `displayString `任务都被包装为`MethodRequest`提交到`SchedulerThread`的任务队列`ActivationQueue`。

   每个任务的具体执行包含在`MethodRequest`中（抽象的`execute`方法，由子类实现）。 

4. `MethodRequest`执行`execute`任务之后 ，将执行结果反馈给`FutureResult`

具体代码如下

```java
/**
 * 任务定义接口
 */
public interface ActiveObject {

    Result makeString(int count, char fillChar);

    void displayString(String text);
}
```



```java
class ActiveObjectProxy implements ActiveObject {
    private final SchedulerThread schedulerThread;

    private final Servant servant;

    public ActiveObjectProxy(SchedulerThread schedulerThread, Servant servant) {
        this.schedulerThread = schedulerThread;
        this.servant = servant;
    }


    /**
     * 将提交的request任务（makeString）推送到执行线程
     *
     * @return FutureResult：包装任务完成的执行结果
     */
    @Override
    public Result makeString(int count, char fillChar) {
        FutureResult future = new FutureResult();
        schedulerThread.invoke(new MakeStringRequest(servant, future, count, fillChar));
        return future;
    }

    /**
     * 将提交的request任务（displayString）推送到执行线程
     */
    @Override
    public void displayString(String text) {
        schedulerThread.invoke(new DisplayStringRequest(servant, text));
    }
}
```



```java
/**
 * 任务的具体定义类
 */
class Servant implements ActiveObject {

    @Override
    public Result makeString(int count, char fillChar) {
        char[] buf = new char[count];
        for (int i = 0; i < count; i++) {
            buf[i] = fillChar;
            try {
                Thread.sleep(10);
            } catch (Exception e) {

            }
        }
        return new RealResult(new String(buf));
    }

    @Override
    public void displayString(String text) {
        try {
            System.out.println("Display:" + text);
            Thread.sleep(10);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
/**
 * 由SchedulerThread管理的任务队列
 */
class ActivationQueue {

    private final static int MAX_METHOD_REQUEST_QUEUE_SIZE = 100;

    private LinkedList<MethodRequest> methodQueue;

    public ActivationQueue() {
        methodQueue = new LinkedList<>();
    }

    /**
     * 提交任务到任务队列
     */
    public synchronized void put(MethodRequest request) {
        while (methodQueue.size() >= MAX_METHOD_REQUEST_QUEUE_SIZE) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        methodQueue.addFirst(request);
        this.notifyAll();
    }


    /**
     * 从任务队列提取任务
     */
    public synchronized MethodRequest take() {
        while (methodQueue.isEmpty()) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        MethodRequest methodRequest = methodQueue.removeFirst();
        this.notifyAll();
        return methodRequest;
    }
}
```

```java
import java.util.LinkedList;

public class SchedulerThread extends Thread {

    private final ActivationQueue activationQueue;

    public SchedulerThread(ActivationQueue activationQueue) {
        this.activationQueue = activationQueue;
    }

    /**
     * 提交任务到任务队列
     */
    public void invoke(MethodRequest request) {
        this.activationQueue.put(request);
    }

    /**
     * 执行任务队列中的任务
     */
    @Override
    public void run() {
        while (true) {
            // 执行提交的任务的任务主体
            // execute的内容，存在于提交的request中
            activationQueue.take().execute();
        }
    }
}
```

```java
public interface Result {
    Object getResultValue();
}

/**
 * 仅包可见
 */
class RealResult implements Result {

    private final Object resultValue;


    public RealResult(Object resultValue) {
        this.resultValue = resultValue;
    }

    @Override
    public Object getResultValue() {
        return resultValue;
    }
}

/**
 * 返回的任务结果，仅包可见
 */
class FutureResult implements Result {

    private Result result;
    private boolean ready = false;

    public synchronized void setResult(Result result) {
        this.result = result;
        this.ready = true;
        // 通知等待提取任务结果的线程，任务结束
        this.notifyAll();
    }

    @Override
    public synchronized Object getResultValue() {
        while (!ready) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return this.result.getResultValue();
    }
}
```



```java
abstract class MethodRequest {
    protected final Servant servant;

    protected final FutureResult futureResult;

    public MethodRequest(Servant servant, FutureResult futureResult) {
        this.servant = servant;
        this.futureResult = futureResult;
    }

    /**
     * 提交任务的抽象方法。具体执行内容由子类定义。
     * 执行者交给servant，执行结果包装到futureResult中
     */
    public abstract void execute();
}
```



```java
class MakeStringRequest extends MethodRequest {
    private final int count;
    private final char fillChar;

    public MakeStringRequest(Servant servant, FutureResult futureResult, int count, char fillChar) {
        super(servant, futureResult);
        this.fillChar = fillChar;
        this.count = count;
    }

    /**
     * 任务执行的主体
     */
    @Override
    public void execute() {
        futureResult.setResult(servant.makeString(count, fillChar));
    }
}

class DisplayStringRequest extends MethodRequest {
    private final String text;

    public DisplayStringRequest(Servant servant, final String text) {
        super(servant, null);
        this.text = text;
    }

    /**
     * 任务执行的主体
     */
    @Override
    public void execute() {
        this.servant.displayString(text);
    }
}
```

```java
public final class ActiveObjectFactory {
    public static ActiveObject createActiveObject() {
        Servant servant = new Servant();
        ActivationQueue queue = new ActivationQueue();
        SchedulerThread schedulerThread = new SchedulerThread(queue);
        ActiveObjectProxy proxy = new ActiveObjectProxy(schedulerThread, servant);
        schedulerThread.start();
        return proxy;
    }
}
```



以上对外开放的类仅仅`ActiveObjectFactory`、`ActiveObject`、`Result`

以下为测试代码

```java
import com.hots.part2.chapter18.action.ActiveObject;

public class DisplayClientThread extends Thread {

    private final ActiveObject activeObject;

    public DisplayClientThread(String name, ActiveObject activeObject) {
        super(name);
        this.activeObject = activeObject;
    }

    @Override
    public void run() {
        try {
            for (int i = 0; true; i++) {
                String text = Thread.currentThread().getName() + "=>" + i;
                activeObject.displayString(text);
                Thread.sleep(200);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
import com.hots.part2.chapter18.action.ActiveObject;
import com.hots.part2.chapter18.action.Result;

public class MakerClientThread extends Thread {

    private final ActiveObject activeObject;
    private final char fillChar;

    public MakerClientThread(ActiveObject activeObject, String name) {
        super(name);
        this.activeObject = activeObject;
        this.fillChar = name.charAt(0);
    }

    @Override
    public void run() {
        try {
            for (int i = 0; true; i++) {
                Result result = activeObject.makeString(i + 1, fillChar);
                Thread.sleep(20);
                String value = (String) result.getResultValue();
                System.out.println(Thread.currentThread().getName() + ": value=" + value);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
import com.hots.part2.chapter18.action.ActiveObject;
import com.hots.part2.chapter18.action.ActiveObjectFactory;

public class Test {
    public static void main(String[] args) {
        ActiveObject activeObject = ActiveObjectFactory.createActiveObject();
        // 制造makeString的请求
        new MakerClientThread(activeObject, "Alice").start();
        // 制造displayString的请求
        new MakerClientThread(activeObject, "Bobby").start();

        new DisplayClientThread("Chris", activeObject).start();
    }
}
```

# Chapter19：Event Bus 中介者模式

# Chapter20：Event Driven 事件驱动设计模式
