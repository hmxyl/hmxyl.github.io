##  Chapter1：快速认识线程

### 继承Thread类创建线程类（模板设计模式）

（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。

（2）创建Thread子类的实例，即创建了线程对象。

（3）调用线程对象的start()方法来启动该线程。

```java
import java.util.concurrent.atomic.AtomicInteger;
// 定义Thread类的子类，并重写该类的run方法
public class TicketWindow extends Thread {
    private final int MAX = 50;
    private static AtomicInteger index = new AtomicInteger(0);

    private String name;

    public TicketWindow(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        while (index.get() <= MAX) {
            System.out.println("柜台：" + name + "当前的号码是：" + index.addAndGet(1));
        }
    }
}
```

```java
@Test
public void bankTest1() {
  // step2：创建Thread子类的实例，即创建了线程对象
  TicketWindow ticketWindow1 = new TicketWindow("一号");
  // step3: 调用线程对象的start()方法来启动该线程
  ticketWindow1.start();
  TicketWindow ticketWindow2 = new TicketWindow("二号");
  ticketWindow2.start();
  TicketWindow ticketWindow3 = new TicketWindow("三号");
  ticketWindow3.start();
  TicketWindow ticketWindow4 = new TicketWindow("四号");
  ticketWindow4.start();
}
```

### 通过Runnable接口创建线程类（策略模式的应用）

为了将可执行的控制单元和线程控制分割开来

（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。

（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。

（3）调用线程对象的start()方法来启动该线程。

```java
public class TickWindowRunnable implements Runnable {
    private final int MAX = 50;
    private int index = 1;

    @Override
    public void run() {
        while (index <= MAX) {
            System.out.println(Thread.currentThread().getName() + "的号码是：" + index++);
        }
    }
}
```

```java
@Test
public void bankTest2() {
  TickWindowRunnable ticketWindowRunnable = new TickWindowRunnable();
  Thread ticketWindow1 = new Thread(ticketWindowRunnable, "一号");
  Thread ticketWindow2 = new Thread(ticketWindowRunnable, "二号");
  Thread ticketWindow3 = new Thread(ticketWindowRunnable, "三号");
  Thread ticketWindow4 = new Thread(ticketWindowRunnable, "四号");

  ticketWindow1.start();
  ticketWindow2.start();
  ticketWindow3.start();
  ticketWindow4.start();
}


//java8改造
 @Test
public void bankTest3() {
  final int MAX = 50;
  final AtomicInteger index = new AtomicInteger(0);
  final Runnable runnable = () -> {
    while (index.get() <= MAX) {
      System.out.println(Thread.currentThread().getName() + "的号码是：" + index.addAndGet(1));
    }
  };

  Thread ticketWindow1 = new Thread(runnable, "一号");
  Thread ticketWindow2 = new Thread(runnable, "二号");
  Thread ticketWindow3 = new Thread(runnable, "三号");
  Thread ticketWindow4 = new Thread(runnable, "四号");

  ticketWindow1.start();
  ticketWindow2.start();
  ticketWindow3.start();
  ticketWindow4.start();
}
```

## Chapter2：深入理解Thread的构造函数

| 序号 | 方法                                                         | 说明                                                         |
| :--- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 1    | Thread()                                                     | Allocates a new Thread object.                               |
| 2    | Thread(Runnable target)                                      | Allocates a new Thread object.                               |
| 3    | Thread(Runnable target, String name)                         | Allocates a new Thread object.                               |
| 4    | Thread(String name)                                          | Allocates a new Thread object.                               |
| 5    | Thread(ThreadGroup group, Runnable  target)                  | Allocates a new Thread object.                               |
| 6    | Thread(ThreadGroup group, Runnable  target, String name)     | Allocates a new Thread object so that it has target as its run object,  has the specified name as its name, and belongs to the thread group referred  to by group. |
| 7    | Thread(ThreadGroup group, Runnable  target, String name, long stackSize) | Allocates a new Thread object so that it has target as its run object,  has the specified name as its name, and belongs to the thread group referred  to by group, and has the specified stack size. |
| 8    | Thread(ThreadGroup group, String  name)                      | Allocates a new Thread object.                               |

### Thread命名

1. 默认线程名称，按照编号，从0开始递增。线程一旦启动，线程名不可再进行更改。

   ```java
   public Thread() {
     init(null, null, "Thread-" + nextThreadNum(), 0);
   }
   ```

### Thread和ThreadGroup

1. main线程所在的ThreadGroup称为main
2. 构造一个线程如果没有显示的指定ThreadGroup，他将和父线程在同一个ThreadGroup

### Thread和stackSize

```java
/**
* 测试默认栈深度 
*/
public class TestStack {
    private int counter = 0;

    private void recur() {
        counter++;
        recur();//递归
    }

    public void getStackDepth() {
        try {
            recur();
        } catch (Throwable t) {
            System.out.println("栈最大深度：" + counter);
            t.printStackTrace();
        }
    }

    public static void main(String[] args) {
        TestStack stack = new TestStack();
        stack.getStackDepth();
    }
}


结果：18368  

# 查看配置
jinfo -flag ThreadStackSize  16320
```

###  守护线程

设置守护线程的方法很简单，调用**setDaemon**方法即可，true代表守护线程，false代表正常线程。

线程是否为守护线程和它的父线程有很大的关系，如果父线程是正常线程，则子线程也是正常线程，反之亦然，如果你想要修改它的特性则可以借助方法。
**isDaemon**方法可以判断该线程是不是守护线程。

另外需要注意的就是，**setDaemon方法只在线程启动之前才能生效**，如果一个线程已经死亡，那么再设置setDaemon则会抛出**IllegalThreadStateException**异常。

## Chapter3： Thread API

```java
public final void setName(String name) // 设置线程名称
public final void setPriority(int newPriority) // 设置线程优先级
```

### join()

```java
public final void join()
  
// 主线程等待线程threadTest1、threadTest2执行完成
// threadTest1、threadTest2 交替执行
threadTest1.join();
threadTest2.join();



// 以下写法，main 线程等待main 线程结束，所有程序一直处于等待状态，无法终止。
public static void main(String[] args) throws Exception{
  Thread.currentThread().join();
}
```

###  interrupt()

如下方法的调用会使得当前线程进人阻塞状态，而调用当前线程的interrupt方法，就可以打断阻塞。

```java
join()、sleep()、wait()...
```

上述若干方法都会使得当前线程进人阻塞状态，若另外的一个线程调用被阻塞线程的**interrupt**方法，则会打断这种阻塞，因此这种方法有时会被称为可中断方法。

==打断一个线程并不等于该线程的生命周期结束，仅仅是打断了当前线程的阻塞状态==。

一旦线程在阻塞的情况下被打断，都会抛出一个称为**InterruptedException**的异常，这个异常就像一个signal（信号）一样通知当前线程被打断了。

### 合理关闭一个线程

1. 利用中断信号

   ```java
   public static void main(String[] args) throws InterruptedException {
   	Thread t1 = new Thread() {
   		@Override
   		public void run() {
   			System.out.println("I will start work.");
   			while (!isInterrupted()) {
   				// working
   			}
   			System.out.println("I will be exiting.");
   		}
   	};
   	t1.start();
   	TimeUnit.MINUTES.sleep(1);
   	System.out.println("System will be shutdown");
   	t1.interrupt();
   }
   ```

   

2. 利用Volatile开关变量控制

   ```java
   public class StopThread {
   
       static class MyThread extends Thread {
           private volatile boolean shutdown = false;
   
           @Override
           public void run() {
               System.out.println("I will start work.");
               while (!shutdown) {
                   // working
               }
               System.out.println("I will be exiting.");
           }
   
           public void shutdown() {
               this.shutdown = true;
           }
       }
   
       public static void main(String[] args) throws InterruptedException {
           MyThread t1 = new MyThread();
           t1.start();
           TimeUnit.SECONDS.sleep(10);
           System.out.println("System will be shutdown");
           t1.shutdown();
       }
   }
   ```


3. 耗时时间过长，强制退出线程（将执行程序设置为守护线程）

   - 使用执行线程的守护线程执行程序任务

   ```java
   public class ThreadService {
     private Thread executeThead;
   
     private boolean finished = false;
   
     public void execute(Runnable task) {
       executeThead = new Thread() {
         @Override
         public void run() {
           Thread runner = new Thread(task);
           runner.setDaemon(true);
           runner.start();
           try {
             // 等待runner执行完成
             runner.join();
             finished = true;
           } catch (InterruptedException e) {
             // 执行被打断
             System.out.println("执行任务的守护线程被打断");
             e.printStackTrace();
           }
         }
       };
       executeThead.start();
     }
   
     public void shutdown(long miles) {
       long currentTime = System.currentTimeMillis();
       while (!finished) {
         if (System.currentTimeMillis() - currentTime >= miles) {
           System.out.println("执行任务超时");
           executeThead.interrupt();
           break;
         }
   
         try {
           // 短暂休眠，减少执行次数
           Thread.sleep(1);
         } catch (InterruptedException e) {
           System.out.println("执行线程被打断");
           e.printStackTrace();
         }
       }
     }
   }
   
   ```

   - 调用执行线程

   ```java
   public class ThreadCloseForce {
     public static void main(String[] args) {
       ThreadService threadService = new ThreadService();
       long start = System.currentTimeMillis();
       // 启动执行线程
       threadService.execute(() -> {
         while (true) {
           // 模拟线程阻塞
         }
       });
       // 超时验证
       threadService.shutdown(10_000);
       long end = System.currentTimeMillis();
       System.out.println(end - start);
     }
   }
   ```

   - 执行结果

   ```txt
   执行任务超时
   10117
   执行任务的守护线程被打断
   java.lang.InterruptedException
   	at java.lang.Object.wait(Native Method)
   	at java.lang.Thread.join(Thread.java:1252)
   	at java.lang.Thread.join(Thread.java:1326)
   	at com.hots.part1.chapter3.ThreadService$1.run(ThreadService.java:16)
   
   Process finished with exit code 0
   ```

## Chapter4：线程安全与数据同步

### synchronized关键字

> 使用synchronized需要注意的问题
>
> 1. 与monitor关联的对象不可为空
>
> 2. synchronized的作用域不可太大（降低执行效率）
>
> 3. 不同的monitor企图锁住相同的方法
>
> 4. 多个锁导致死锁

### `this` monitor 和 `class` monitor

1. 使用synchronized同步一个类的不同方法，争抢的是同一个锁（方法所属的对象的锁）：synchronied(this)

   官方说明：

   ```
   When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method's object and releases it when the method returns. 
   
   The lock release occurs even if the return vas caused by an uncaught exception.
   ```

   

2. 使用synchronized同步一个类的不同静态方法，争抢的是同一个锁（类的**class锁**）：synchronied(Test.class)

   官方说明：

   ```
   since a static method is associated with a class, not an object.
   In this case, the thread acquires the intrinsic lock for the Class object associated with the class. 
   Thus access to class'S static fields is controlled by a lock that's distinct from the lock for any instance of the class.
   ```

## Chapter5：线程之间的通信

wait 、notify、notifyAll

### wait 和 sleep和区别

从表面上看，wait和sleep方法都可以使当前线程进人阻塞状态，但是两者之间存在着本质的区别，下面我们将总结两者的区别和相似之处

- wait和sleep方法都可以使线程进人阻塞状态
- wait和sleep方法均是可中断方法，被中断后都会收到中断异常。
- **wait是Object的方法，而sleep是Thread特有的方法**
- wait方法的执行必须在同步方法中进行，而sleep则不需要。
- 线程在同步方法中执行sleep方法时，并不会释放的锁，而wait方法则会释放monitor的锁
- sleep方法短暂休眠之后会主动退出阻塞，而wait方法（没有指定wait时间）则需要被其他线程中断后才能退出阻塞。

###  单线程通信

```java
public class ProducerAndConsumerVersion1 {

    private int i = 0;

    private volatile boolean isProduced = false;

    private final Object LOCK = new Object();

    private void produce() {
        synchronized (LOCK) {
            if (isProduced) {
                try {
                    LOCK.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } else {
                ++i;
                System.out.println(Thread.currentThread().getName() + "：produced->" + i);
                LOCK.notify();
                isProduced = true;
            }
        }
    }

    private void consume() {
        synchronized (LOCK) {
            if (isProduced) {
                System.out.println(Thread.currentThread().getName() + "：consumed->" + i);
                LOCK.notify();
                isProduced = false;
            } else {
                try {
                    LOCK.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        ProducerAndConsumerVersion1 producerAndConsumerVersion1 = new ProducerAndConsumerVersion1();
        new Thread("P1") {
            @Override
            public void run() {
                while (true) {
                    producerAndConsumerVersion1.produce();
                }
            }
        }.start();

        new Thread("C1") {
            @Override
            public void run() {
                while (true) {
                    producerAndConsumerVersion1.consume();
                }
            }
        }.start();
    }
}
```

### 多线程通信

![image-20211227170019463](D:\0_Notes\Hexo\hmxyl\source\_images\image-20211227170019463.png) 

![image-20211227170133400](D:\0_Notes\Hexo\hmxyl\source\_images\image-20211227170133400.png)  



```java
/**
 * Demo
 */
public class ProducerAndConsumerVersion3 {

    private int i = 0;

    private volatile boolean isProduced = false;

    private final Object LOCK = new Object();

    private void produce() {
        synchronized (LOCK) {
            while (isProduced) {
                try {
                    LOCK.wait();
                    System.out.println(Thread.currentThread().getName() + "：wait");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            ++i;
            System.out.println(Thread.currentThread().getName() + "：produced->" + i);
            isProduced = true;
            LOCK.notifyAll();
        }
    }

    private void consume() {
        synchronized (LOCK) {
            while (!isProduced) {
                try {
                    LOCK.wait();
                    System.out.println(Thread.currentThread().getName() + "：wait");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            System.out.println(Thread.currentThread().getName() + "：consumed->" + i);
            isProduced = false;
            LOCK.notifyAll();
        }
    }

    public static void main(String[] args) {
        ProducerAndConsumerVersion3 producerAndConsumerVersion3 = new ProducerAndConsumerVersion3();
        Stream.of("P1", "P2").forEach(name -> {
            new Thread(name) {
                @Override
                public void run() {
                    while (true) {
                        producerAndConsumerVersion3.produce();
                        try {
                            Thread.sleep(10);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            }.start();
        });

        Stream.of("C1", "C2", "C3", "C4").forEach(name -> {
            new Thread(name) {
                @Override
                public void run() {
                    while (true) {
                        producerAndConsumerVersion3.consume();
                        try {
                            Thread.sleep(100);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            }.start();
        });
    }
}
```

### 自定义显示锁

1. Lock接口

```java
import java.util.Collection;

public interface Lock {
    void lock() throws InterruptedException;

    void lock(long mills) throws InterruptedException, TimeoutException;

    void unLock();

    Collection<Thread> getBlockedThread();

    int getBlockedSize();

    class TimeoutException extends Exception {
        public TimeoutException(String message) {
            super(message);
        }
    }
}
```

2. 接口实现

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

public class BooleanLock implements Lock {
    private boolean initValue = false;

    private Thread currentThread;

    private Collection<Thread> blockedThreadCollection = new ArrayList<>();

    @Override
    public synchronized void lock() throws InterruptedException {
        while (initValue) {
            blockedThreadCollection.add(Thread.currentThread());
            this.wait();
        }
        initValue = true;
        currentThread = Thread.currentThread();
        blockedThreadCollection.remove(Thread.currentThread());
    }

    @Override
    public synchronized void lock(long mills) throws InterruptedException, TimeoutException {
        if (mills <= 0) {
            lock();
        }
        long waitMills = mills;
        long endTime = System.currentTimeMillis() + waitMills;
        while (initValue) {
            if (waitMills <= 0) {
                throw new TimeoutException(Thread.currentThread().getName() + " waiting timeout");
            }
            // 重新设置等待时间
            this.wait(waitMills);
            waitMills = endTime - System.currentTimeMillis();
        }

        this.initValue = true;
        this.currentThread = Thread.currentThread();
    }

    @Override
    public synchronized void unLock() {
        if (Thread.currentThread() == currentThread) {
            initValue = false;
            System.out.println(Thread.currentThread().getName() + " release the monitor");
            this.notifyAll();
        }
    }

    @Override
    public Collection<Thread> getBlockedThread() {
        return Collections.unmodifiableCollection(blockedThreadCollection);
    }

    @Override
    public int getBlockedSize() {
        return blockedThreadCollection.size();
    }
}
```

3. 调用

```java
import java.util.Arrays;

public class BooleanLockTest {
    public static void main(String[] args) {
        final BooleanLock booleanLock = new BooleanLock();

        Arrays.asList("W1", "W2", "W3").stream()
                .forEach(name -> {
                    new Thread(() -> {
                        try {
                            booleanLock.lock(5_000);
                            System.out.println(Thread.currentThread().getName() + " got the lock");
                            work();
                        } catch (InterruptedException | Lock.TimeoutException e) {
                            e.printStackTrace();
                        } finally {
                            booleanLock.unLock();
                        }
                    }, name).start();
                });

    }

    public static void work() throws InterruptedException {
        System.out.println(Thread.currentThread().getName() + " is working...");
        Thread.sleep(10_000);
    }
}
```

## Chapter6：Thread Group

### Thread 与 ThreadGroup

![image-20211228162829691](D:\0_Notes\Hexo\hmxyl\source\_images\image-20211228162829691.png)  

### 基本操作

| 方法                    | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| activeCount()           | 用于获取group中活跃的线程，这只是个估计值，并不能百分之百地保证数字一定正确，原因前面已经分析过，该方法会递归获取其他子group中的活跃线程。 |
| activeGroupCount()      | 用于获取group中活跃的子group，这也是一个近似估值，该方法也会递归获取所有的子group。 |
| getMaxPriority()        | 用于获取group的优先级，默认情况下，Group的优先级为10，在该group中，所有线程的优先级都不能大于group的优先级 |
| getName()               | 用于获取group的名字。                                        |
| getParent()             | 用于获取group的父group，如果父group不存在，则会返回null，比如systemgroup的父group就为null。 |
| list()                  | 该方法没有返回值，执行该方法会将group中所有的活跃线程信息全部输出到控制台，也就是System.out0 |
| parentOf(ThreadGroup g) | 会判断当前group是不是给定group的父group，另外如果给定的group就是自己本身，那么该方法也会返回true。 |
| setMaxPriority(int pri) | 会指定group的最大优先级，最大优先级不能超过父group的最大优先级，执行该方法不仅会改变当前group的最大优先级，还会改变所有子group的最大优先级 |

### 守护ThreadGroup

`public final void setDaemon(boolean daemon)`

```
First, the checkAccess method of this thread group is called with no arguments; 
this may result in a security exception.
A daemon thread group is automatically destroyed when its last thread is stopped or its last thread group is destroyed
```

```java
/**
 * Demo
 */
public class ThreadGroupApi {
    public static void main(String[] args) throws InterruptedException {
        ThreadGroup tg1 = new ThreadGroup("group1");
        new Thread(tg1, () -> {
            try {
                Thread.sleep(1_000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "group1-t1").start();

        ThreadGroup tg2 = new ThreadGroup("group2");
        new Thread(tg2, () -> {
            try {
                Thread.sleep(1_000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "group2-t1").start();
        tg2.setDaemon(true);

        Thread.sleep(1_000);

        System.out.println(tg1.getName() + " -- " + tg1.isDestroyed());// false
        System.out.println(tg2.getName() + " -- " + tg2.isDestroyed());// true
      
        tg1.destroy(); // 显示销毁

        System.out.println(tg1.getName() + " -- " + tg1.isDestroyed());// true
        System.out.println(tg2.getName() + " -- " + tg2.isDestroyed());// true
    }
}
```

## Chapter7：Hook线程以及捕获线程执行异常

### 获取线程运行时异常

####  处理Thread运行时异常API，有四个

| 方法                                                         | 说明                                         |
| ------------------------------------------------------------ | -------------------------------------------- |
| public static void  **setDefaultUncaughtExceptionHandler**(Thread.UncaughtExceptionHandler eh) | 设置全局的UncaughtExceptionHandler           |
| public static  Thread.UncaughtExceptionHandler **getDefaultUncaughtExceptionHandler**() | 获取全局的UncaughtExceptionHandler           |
| public void  setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh) | 为某个特定线程指定UncaughtExceptionHandler   |
| public Thread.UncaughtExceptionHandler  getUncaughtExceptionHandler() | 获取某个特定线程指定UncaughtExceptionHandler |

其中UncaughtExceptionHandler 是一个FunctionalInterface接口，仅包含一个抽象方法。

```java
@FunctionalInterface
public interface UncaughtExceptionHandler {
  /**
         * Method invoked when the given thread terminates due to the
         * given uncaught exception.
         * <p>Any exception thrown by this method will be ignored by the
         * Java Virtual Machine.
         * @param t the thread
         * @param e the exception
         */
  void uncaughtException(Thread t, Throwable e);
}
```

该回调接口会被`Thread`和`dispatchUncaughtException`调用。

```java
/**
 * Dispatch an uncaught exception to the handler. This method is
 * intended to be called only by the JVM.
 */
private void dispatchUncaughtException(Throwable e) {
  getUncaughtExceptionHandler().uncaughtException(this, e);
}
```

####  UncaughtExceptionHandler实例

测试类

```java
public class CaptureThreadException {
    public static void main(String[] args) {

        // 1. 设置回调接口
        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {
            System.out.println(t.getName() + " ----- occur exception：" + e.getMessage());
            e.printStackTrace();
        });

        new Thread(() -> {
            try {
                Thread.sleep(1_000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // 2. 抛出运行时异常
            System.out.println(1 / 0);
        }).start();
    }
}
```

输出结果

```bash
Thread-0 ----- occur exception：/ by zero
java.lang.ArithmeticException: / by zero
	at com.hots.chapter7.CaptureThreadException.lambda$main$1(CaptureThreadException.java:20)
	at java.lang.Thread.run(Thread.java:748)

Process finished with exit code 0
```



####  UncaughtExceptionHandler源码分析

1. 获取Thread的UncaughtExceptionHandler

   ```java
   private void dispatchUncaughtException(Throwable e) {
     getUncaughtExceptionHandler().uncaughtException(this, e);
   }
   ```

2. Thread未设置UncaughtExceptionHandler，则找ThreadGroup获取

   ```java
   public UncaughtExceptionHandler getUncaughtExceptionHandler() {
     return uncaughtExceptionHandler != null ?
       uncaughtExceptionHandler : group;
   }
   ```

   > ThreadGroup 是 Thread.UncaughtExceptionHandler 的实现类

3. ThreadGroup的uncaughtException

   ```java
   public void uncaughtException(Thread t, Throwable e) {
   	if (parent != null) {
   		parent.uncaughtException(t, e); // 调用父ThreadGroup的uncaughtException
   	} else {
   		Thread.UncaughtExceptionHandler ueh =
   			Thread.getDefaultUncaughtExceptionHandler(); 
   		if (ueh != null) {
   			ueh.uncaughtException(t, e); // 调用全局默认的UncaughtExceptionHandler
   		} else if (!(e instanceof ThreadDeath)) {
   			System.err.print("Exception in thread \"" + t.getName() + "\" ");
   			e.printStackTrace(System.err);// 将异常的堆栈信息定向到System.err中
   		}
   	}
   }
   ```

```mermaid
   graph LR
   A[线程异常] -->  B(MainGroup) --> C(System Group) --> D[System.err]
```



### 注入Hook线程

#### Hook线程概念

JVM进程的退出是由于JVM进程中没**有活跃的非守护线程**，或者收到了**系统中断信号**。

**向JVM程序注入一个Hook线程，在JVM进程退出的时候，Hook线程会启动执行。**

通过Runtime可以为JVM注人多个Hook线程。

#### Linux 模拟Hook简单调用

==Runtime.getRuntime().addShutdownHook(Thread hook));==

```sh
[root@hots java]# mkdir /root/java
[root@hots java]# vi ExitCapture.java #内容如下
```

```java
public class ExitCapture{
	public static void main(String[] args){
    
		Runtime.getRuntime().addShutdownHook(new Thread(() -> {
			System.out.println(Thread.currentThread().getName() + " exiting......");
      // 进程down之前的安全处理措施
			notifyAndRelease();
		}));
    
		int i = 0;
		while(true){
			++i;
			try{
				Thread.sleep(1_000L);
				System.out.println(Thread.currentThread().getName() + " working....");
			} catch (Throwable e) {
			}
			if (i > 10) {
				throw new RuntimeException(Thread.currentThread().getName() + " error");
			}
		}
	}
	
	private static void notifyAndRelease(){
		System.out.println(Thread.currentThread().getName() + " notify other matchine and release resource");
		try {
			Thread.sleep(1_000L);
		} catch(Exception e) {	
		}
		System.out.println(Thread.currentThread().getName() + "finish exit.");
	}
}  
```

```sh
[root@hots java]# javac ExitCapture.java
[root@hots java]# java ExitCapture
```

> \# 后台运行，日志记录到nohup.out文件
>
> nohup java -cp . ExitCapture & 

10秒后程序退出 / Ctrl+C 退出程序 / kill 进程号

```sh
[root@hots java]# java ExitCapture  
main working....
main working....
main working....
main working....
main working....
main working....
^CThread-0 exiting......
Thread-0 notify other matchine and release resource
main working....
Thread-0finish exit.
[1]+  Exit 1              
```

> kill -9 进程号 会直接退出，钩子程序不会执行。



#### Hook线程实际应用举例

在我们的开发中经常会遇到Hook线程，比如为了防止某个程序被重复启动，在进程启动时会创建一个文件，进程收到中断信号的时候会删除这个lock文件，我们在MySQL服务器、zookeeper、kafka等系统中都能看到lock文件的存在。

```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class PreventDuplicated {
    private static final String LOCK_PATH = "E:\\Downloads";

    private static final String LOCK_FILE = ".lock";

    private static final String PERMISSIONS = "rw-------";

    public static void main(String[] args) {
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            // 程序退出，删除lock文件
            System.out.println("deal program shutdown...");
            getLockFile().toFile().delete();
        }));

        // 判断Lock文件，存在，抛重复执行异常，不存在继续
        checkLockFile();
        //程序执行
        try {
            Thread.sleep(20_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void checkLockFile() {
        Path path = getLockFile();
        if (path.toFile().exists()) {
            throw new RuntimeException("The program already running.");
        }
        try {
            Files.createFile(path);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static Path getLockFile() {
        return Paths.get(LOCK_PATH, LOCK_FILE);
    }
}
```



## Chapter8：线程池原理以及自定义线程池

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

/**
 * 线程池模拟类 
 */
public class SimpleThreadPool extends Thread {
    /* 线程池现有容量：包含FREE, RUNNING, BLOCKED 三种状态的线程 */
    private int poolSize;

    private static volatile int seq = 0;

    private static final String THREAD_PREFIX = "SIMPLE_THREAD_POOL-";

    private final int queueSize;

    /* 默认TASK_QUEUE的阈值 */
    public final static int DEFAULT_TASK_QUEUE_SIZE = 2000;

    private final static LinkedList<Runnable> TASK_QUEUE = new LinkedList<>();

    private final static ThreadGroup GROUP = new ThreadGroup("Pool_Group");

    private final static List<MyThread> THREAD_QUEUE = new ArrayList<>();

    private final DiscardPolicy discardPolicy;

    // 线程池，无能力处理，策略
    public final static DiscardPolicy DEFAULT_DISCARD_POLICY = () -> {
        throw new DiscardException("Discard this task");
    };

    // 线程池，销毁标记
    private volatile boolean destroy = false;

    private final int minPoolSize;

    public static final int DEFAULT_MIN_POOL_SIZE = 4;

    private final int activePoolSize;

    public static final int DEFAULT_ACTIVE_POOL_SIZE = 8;

    private final int maxPoolSize;

    public static final int DEFAULT_MAX_POOL_SIZE = 12;

    public SimpleThreadPool() {
        this(DEFAULT_MIN_POOL_SIZE, DEFAULT_ACTIVE_POOL_SIZE, DEFAULT_MAX_POOL_SIZE, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);
    }

    public SimpleThreadPool(int minPoolSize, int activePoolSize, int maxPoolSize, int queueSize, DiscardPolicy discardPolicy) {
        this.minPoolSize = minPoolSize;
        this.activePoolSize = activePoolSize;
        this.maxPoolSize = maxPoolSize;

        this.queueSize = queueSize;
        this.discardPolicy = discardPolicy;

        // 初始化，最小容量线程池
        for (int i = 0; i < minPoolSize; i++) {
            createMyThread();
        }
        // 自定义线程池，同时也是一个线程，可以根据工作量，自动调整容量
        this.setName(THREAD_PREFIX + "head");
        this.start();
        resetPoolSize();
    }

    private void createMyThread() {
        MyThread myThread = new MyThread(GROUP, THREAD_PREFIX + (seq++));
        THREAD_QUEUE.add(myThread);
        myThread.start();
    }

    /**
     * 获取线程池大小：每次线程池，新增/销毁线程的时候，调用
     */
    private void resetPoolSize() {
        this.poolSize = THREAD_QUEUE.size();
    }

    /**
     * 线程池，根据工作量，自动调整容量
     */
    @Override
    public void run() {
        while (!destroy) {
            // 扩展线程池
            if (TASK_QUEUE.size() > activePoolSize && poolSize < activePoolSize) {
                for (int i = poolSize; i < activePoolSize; i++) {
                    createMyThread();
                }
                System.out.println("The pool increased to activePoolSize.");
                resetPoolSize();
            }
            if (TASK_QUEUE.size() > maxPoolSize && poolSize < maxPoolSize) {
                for (int i = poolSize; i < maxPoolSize; i++) {
                    createMyThread();
                }
                System.out.println("The pool increased to maxPoolSize.");
                resetPoolSize();
            }

            // 缩减线程池
            synchronized (THREAD_QUEUE) {
                if (TASK_QUEUE.isEmpty()
                        && THREAD_QUEUE.stream().filter(e -> e.taskStatus == TaskStatus.RUNNING).count() == 0
                        && poolSize > activePoolSize) {
                    int releaseCount = poolSize - activePoolSize;
                    Iterator<MyThread> it = THREAD_QUEUE.iterator();
                    while (it.hasNext()) {
                        if (releaseCount <= 0) {
                            break;
                        }
                        MyThread myThread = it.next();
                        myThread.close();
                        myThread.interrupt();
                        it.remove();
                        --releaseCount;
                        System.out.println(myThread.getName() + " had been released");
                    }
                    resetPoolSize();
                }
            }
        }
        System.out.println(Thread.currentThread().getName() + "---- is dead");
    }

    public void shutDown() throws InterruptedException {
        // 等待现有线程池中任务执行完成
        while (!TASK_QUEUE.isEmpty() || THREAD_QUEUE.stream().filter(e -> e.taskStatus == TaskStatus.RUNNING).count() > 0) {
            Thread.sleep(50);
        }

        synchronized (THREAD_QUEUE) {
            // 进行关停销毁
            System.out.println("The pool is ready to destroy");
            Iterator<MyThread> it = THREAD_QUEUE.iterator();
            while (it.hasNext()) {
                MyThread myThread = it.next();
                if (myThread.taskStatus == TaskStatus.BLOCKED) {
                    // waiting中的线程
                    myThread.close();
                    myThread.interrupt();
                    it.remove();
                }
            }
            System.out.println("The thread pool disposed");
            resetPoolSize();
            destroy = true;
        }

        System.out.println("All threads had been destroyed");
    }

    public void submit(Runnable runnable) {
        if (destroy)
            throw new IllegalStateException("The thread pool already destroy and not allow submit task.");

        synchronized (TASK_QUEUE) {
            if (TASK_QUEUE.size() > queueSize) {
                // 处理能力之外的任务，处理措施
                discardPolicy.discard();
            }
            TASK_QUEUE.addLast(runnable);
            TASK_QUEUE.notifyAll();
        }

    }

    public interface DiscardPolicy {
        void discard() throws DiscardException;
    }

    public static class DiscardException extends RuntimeException {
        public DiscardException(String message) {
            super(message);
        }
    }

    public enum TaskStatus {
        FREE, RUNNING, BLOCKED, DEAD;
    }

    private class MyThread extends Thread {
        private volatile TaskStatus taskStatus = TaskStatus.FREE;

        public MyThread(ThreadGroup group, String name) {
            super(group, name);
        }

        @Override
        public void run() {
            OUTER:
            while (this.taskStatus != TaskStatus.DEAD) {
                Runnable runnable = null;
                synchronized (TASK_QUEUE) {
                    while (TASK_QUEUE.isEmpty()) {
                        try {
                            // 任务队列为空，线程等待，让出monitor
                            this.taskStatus = TaskStatus.BLOCKED;
                            TASK_QUEUE.wait();
                        } catch (InterruptedException e) {
                            // 任务队列存入数据，被唤醒，重新抢锁处理
                            break OUTER;
                        }
                    }
                    runnable = TASK_QUEUE.removeFirst();
                }

                if (runnable != null) {
                    this.taskStatus = TaskStatus.RUNNING;
                    runnable.run();
                    this.taskStatus = TaskStatus.FREE;
                }
            }
        }

        public void close() {
            this.taskStatus = TaskStatus.DEAD;
        }
    }
}
```

```java
import java.util.stream.IntStream;

/**
 * 线程池测试类
 */
public class SimpleThreadTest {
    public static void main(String[] args) throws InterruptedException {
        SimpleThreadPool threadPool = new SimpleThreadPool();
        IntStream.rangeClosed(0, 40)
                .forEach(index -> {
                    threadPool.submit(() -> {
                                try {
                                    Thread.sleep(1_000L);
                                    System.out.println("Task " + index + " be serviced by " + Thread.currentThread().getName());
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                            }
                    );
                });
        // Thread.sleep(10_000);
        threadPool.shutDown();
    }
}

```



